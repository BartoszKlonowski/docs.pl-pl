---
title: Mapowanie między formatami JSON i XML
ms.date: 03/30/2017
ms.assetid: 22ee1f52-c708-4024-bbf0-572e0dae64af
ms.openlocfilehash: 649d0f50aae806394587c7b79a7970c2de03e087
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 11/26/2020
ms.locfileid: "96234651"
---
# <a name="mapping-between-json-and-xml"></a><span data-ttu-id="4e942-102">Mapowanie między formatami JSON i XML</span><span class="sxs-lookup"><span data-stu-id="4e942-102">Mapping Between JSON and XML</span></span>

<span data-ttu-id="4e942-103">Czytelnicy i autorzy wytwarzający <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory> zawartość pliku XML API over JavaScript Object Notation (JSON).</span><span class="sxs-lookup"><span data-stu-id="4e942-103">The readers and writers produced by the <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory> provide an XML API over JavaScript Object Notation (JSON) content.</span></span> <span data-ttu-id="4e942-104">KOD JSON koduje dane przy użyciu podzestawu literałów obiektów JavaScript.</span><span class="sxs-lookup"><span data-stu-id="4e942-104">JSON encodes data using a subset of the object literals of JavaScript.</span></span> <span data-ttu-id="4e942-105">Czytelnicy i autorzy wytwarzani przez tę fabrykę są również używani, gdy zawartość JSON jest wysyłana lub odbierana przez aplikacje Windows Communication Foundation (WCF) przy użyciu <xref:System.ServiceModel.Channels.WebMessageEncodingBindingElement> lub <xref:System.ServiceModel.WebHttpBinding> .</span><span class="sxs-lookup"><span data-stu-id="4e942-105">The readers and writers produced by this factory are also used when JSON content is being sent or received by Windows Communication Foundation (WCF) applications using the <xref:System.ServiceModel.Channels.WebMessageEncodingBindingElement> or the <xref:System.ServiceModel.WebHttpBinding>.</span></span>

<span data-ttu-id="4e942-106">Po zainicjowaniu z zawartością JSON, czytnik JSON zachowuje się tak samo, jak czytnik tekstowy XML w przypadku wystąpienia XML.</span><span class="sxs-lookup"><span data-stu-id="4e942-106">When initialized with JSON content, the JSON reader behaves in the same way that a textual XML reader does over an instance of XML.</span></span> <span data-ttu-id="4e942-107">Składnik zapisywania JSON, gdy dana sekwencja wywołań, które w czytniku tekstowym XML tworzy pewne wystąpienie XML, zapisuje zawartość JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-107">The JSON writer, when given a sequence of calls that on a textual XML reader produces a certain XML instance, writes out JSON content.</span></span> <span data-ttu-id="4e942-108">Mapowanie między tym wystąpieniem XML a zawartością JSON zostało opisane w tym temacie do użycia w zaawansowanych scenariuszach.</span><span class="sxs-lookup"><span data-stu-id="4e942-108">The mapping between this instance of XML and the JSON content is described in this topic for use in advanced scenarios.</span></span>

<span data-ttu-id="4e942-109">Wewnętrznie, JSON jest reprezentowane jako sprawdzonych XML podczas przetwarzania przez WCF.</span><span class="sxs-lookup"><span data-stu-id="4e942-109">Internally, JSON is represented as an XML infoset when processed by WCF.</span></span> <span data-ttu-id="4e942-110">Zwykle nie trzeba się omawiać w tej wewnętrznej reprezentacji, ponieważ mapowanie jest tylko logicznym: JSON zwykle nie jest fizycznie konwertowane na XML w pamięci lub konwertowane na notację JSON z pliku XML.</span><span class="sxs-lookup"><span data-stu-id="4e942-110">Normally you do not have to be concerned with this internal representation as the mapping is only a logical one: JSON is normally not physically converted to XML in memory or converted to JSON from XML.</span></span> <span data-ttu-id="4e942-111">Mapowanie oznacza, że interfejsy API XML są używane w celu uzyskania dostępu do zawartości JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-111">The mapping means that XML APIs are used to access JSON content.</span></span>

<span data-ttu-id="4e942-112">Gdy WCF korzysta z JSON, typowym scenariuszem jest to, że jest on automatycznie podłączany <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> przez <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> zachowanie lub przez <xref:System.ServiceModel.Description.WebHttpBehavior> zachowanie w razie potrzeby.</span><span class="sxs-lookup"><span data-stu-id="4e942-112">When WCF uses JSON, the usual scenario is that the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> is automatically plugged in by the <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> behavior, or by the <xref:System.ServiceModel.Description.WebHttpBehavior> behavior when appropriate.</span></span> <span data-ttu-id="4e942-113">W <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> programie jest zrozumiałe mapowanie między danymi JSON i XML sprawdzonych oraz działa tak, jakby dane były bezpośrednio zorientowane na dane JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-113">The <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> understands the mapping between JSON and the XML infoset and acts as if it is dealing with JSON directly.</span></span> <span data-ttu-id="4e942-114">(Możliwe jest użycie programu <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> z dowolnym czytnikiem lub składnikiem XML, co oznacza, że kod XML jest zgodny z poniższym mapowaniem).</span><span class="sxs-lookup"><span data-stu-id="4e942-114">(It is possible to use the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> with any XML reader or writer, with the understanding that the XML conforms to the following mapping.)</span></span>

<span data-ttu-id="4e942-115">W zaawansowanych scenariuszach może być konieczne uzyskanie bezpośredniego dostępu do poniższego mapowania.</span><span class="sxs-lookup"><span data-stu-id="4e942-115">In advanced scenarios, it may become necessary to directly access the following mapping.</span></span> <span data-ttu-id="4e942-116">Te scenariusze są wykonywane, gdy chcesz serializować i deserializować kod JSON na niestandardowe sposoby, bez polegania na <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> lub podczas pracy z <xref:System.ServiceModel.Channels.Message> typem bezpośrednio dla komunikatów zawierających kod JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-116">These scenarios occur when you want to serialize and deserialize JSON in custom ways, without relying on the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>, or when dealing with the <xref:System.ServiceModel.Channels.Message> type directly for messages containing JSON.</span></span> <span data-ttu-id="4e942-117">Mapowanie JSON-XML jest również używane do rejestrowania komunikatów.</span><span class="sxs-lookup"><span data-stu-id="4e942-117">The JSON-XML mapping is also used for message logging.</span></span> <span data-ttu-id="4e942-118">W przypadku korzystania z funkcji rejestrowania komunikatów w programie WCF komunikaty JSON są rejestrowane jako XML zgodnie z mapowaniem opisanym w następnej sekcji.</span><span class="sxs-lookup"><span data-stu-id="4e942-118">When using the message logging feature in WCF, JSON messages is logged as XML according to the mapping described in the next section.</span></span>

<span data-ttu-id="4e942-119">Aby wyjaśnić koncepcję mapowania, Poniższy przykład jest dokumentem JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-119">To clarify the concept of a mapping, the following example is of a JSON document.</span></span>

```json
{"product":"pencil","price":12}
```

<span data-ttu-id="4e942-120">Aby odczytać ten dokument JSON przy użyciu jednego z wymienionych wcześniej czytników, należy użyć tej samej sekwencji <xref:System.Xml.XmlDictionaryReader> wywołań, co w przypadku odczytywania poniższego dokumentu XML.</span><span class="sxs-lookup"><span data-stu-id="4e942-120">To read this JSON document using one of the readers previously mentioned, use the same sequence of <xref:System.Xml.XmlDictionaryReader> calls as you would to read the following XML document.</span></span>

```xml
<root type="object">
    <product type="string">pencil</product>
    <price type="number">12</price>
</root>
```

<span data-ttu-id="4e942-121">Ponadto, jeśli komunikat JSON w przykładzie jest odbierany przez WCF i rejestrowany, w poprzednim dzienniku zobaczysz fragment kodu XML.</span><span class="sxs-lookup"><span data-stu-id="4e942-121">Furthermore, if the JSON message in the example is received by WCF and logged, you would see the XML fragment in the preceding log.</span></span>

## <a name="mapping-between-json-and-the-xml-infoset"></a><span data-ttu-id="4e942-122">Mapowanie między elementami JSON i sprawdzonych XML</span><span class="sxs-lookup"><span data-stu-id="4e942-122">Mapping Between JSON and the XML Infoset</span></span>

<span data-ttu-id="4e942-123">Od tego momentu mapowanie ma postać między kodem JSON opisanym w [dokumencie RFC 4627](https://www.ietf.org/rfc/rfc4627.txt) (z wyjątkiem pewnych ograniczeń, które są ograniczone i niektóre inne ograniczenia) oraz XML sprawdzonych (i nie tekst XML) zgodnie z opisem w [zestawie informacji XML](https://www.w3.org/TR/2004/REC-xml-infoset-20040204/).</span><span class="sxs-lookup"><span data-stu-id="4e942-123">Formally, the mapping is between JSON as described in [RFC 4627](https://www.ietf.org/rfc/rfc4627.txt) (except with certain restrictions relaxed and certain other restrictions added) and the XML infoset (and not textual XML) as described in [XML Information Set](https://www.w3.org/TR/2004/REC-xml-infoset-20040204/).</span></span> <span data-ttu-id="4e942-124">Zapoznaj się z tym tematem definicje elementów i pól *informacji* w [nawiasy kwadratowe].</span><span class="sxs-lookup"><span data-stu-id="4e942-124">See this topic for the definitions of *information items* and fields in [square brackets].</span></span>

<span data-ttu-id="4e942-125">Pusty dokument JSON jest mapowany do pustego dokumentu XML, a pusty dokument XML jest mapowany do pustego dokumentu JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-125">A blank JSON document maps to a blank XML document, and a blank XML document maps to a blank JSON document.</span></span> <span data-ttu-id="4e942-126">W przypadku mapowania XML do formatu JSON poprzedzający biały znak i końcowe białe znaki po dokumencie są niedozwolone.</span><span class="sxs-lookup"><span data-stu-id="4e942-126">On the XML to JSON mapping, preceding white space and trailing white space after the document are not allowed.</span></span>

<span data-ttu-id="4e942-127">Mapowanie jest zdefiniowane między elementem informacji o dokumencie (DII) lub elementem informacji o elemencie (EII) i JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-127">The mapping is defined between either a Document Information Item (DII) or an Element Information Item (EII) and JSON.</span></span> <span data-ttu-id="4e942-128">EII lub właściwość DII [Document element] jest określana mianem głównego elementu JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-128">The EII, or the DII’s [document element] property, is referred to as the Root JSON Element.</span></span> <span data-ttu-id="4e942-129">Należy zauważyć, że fragmenty dokumentu (XML z wieloma elementami głównymi) nie są obsługiwane w ramach tego mapowania.</span><span class="sxs-lookup"><span data-stu-id="4e942-129">Note that document fragments (XML with multiple root elements) are not supported in this mapping.</span></span>

<span data-ttu-id="4e942-130">Przykład: następujący dokument:</span><span class="sxs-lookup"><span data-stu-id="4e942-130">Example: The following document:</span></span>

```xml
<?xml version="1.0"?>
<root type="number">42</root>
```

<span data-ttu-id="4e942-131">I następujący element:</span><span class="sxs-lookup"><span data-stu-id="4e942-131">And the following element:</span></span>

```xml
<root type="number">42</root>
```

<span data-ttu-id="4e942-132">Oba mają mapowanie na format JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-132">Both have a mapping to JSON.</span></span> <span data-ttu-id="4e942-133">`root`Element> <jest głównym elementem JSON w obu przypadkach.</span><span class="sxs-lookup"><span data-stu-id="4e942-133">The <`root`> element is the Root JSON Element in both cases.</span></span>

<span data-ttu-id="4e942-134">Ponadto w przypadku DII należy wziąć pod uwagę następujące kwestie:</span><span class="sxs-lookup"><span data-stu-id="4e942-134">Furthermore, in the case of a DII, the following should be considered:</span></span>

- <span data-ttu-id="4e942-135">Niektóre elementy na liście [Children] nie mogą być obecne.</span><span class="sxs-lookup"><span data-stu-id="4e942-135">Some items in the [children] list must not be present.</span></span> <span data-ttu-id="4e942-136">Nie należy polegać na tym fakcie podczas odczytywania kodu XML zamapowanego z formatu JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-136">Do not rely on this fact when reading XML mapped from JSON.</span></span>

- <span data-ttu-id="4e942-137">Lista [Children] nie zawiera żadnych elementów informacji o komentarzach.</span><span class="sxs-lookup"><span data-stu-id="4e942-137">The [children] list holds no comment information items.</span></span>

- <span data-ttu-id="4e942-138">Lista [Children] nie zawiera żadnych elementów informacji DTD.</span><span class="sxs-lookup"><span data-stu-id="4e942-138">The [children] list holds no DTD information items.</span></span>

- <span data-ttu-id="4e942-139">Lista [Children] nie zawiera żadnych elementów informacji osobistych (PI) ( `<?xml…>` Deklaracja nie jest uważana za element informacji o liczbie pi)</span><span class="sxs-lookup"><span data-stu-id="4e942-139">The [children] list holds no personal Information (PI) information items (the `<?xml…>` declaration is not considered a PI information item)</span></span>

- <span data-ttu-id="4e942-140">Zestaw [Notations] jest pusty.</span><span class="sxs-lookup"><span data-stu-id="4e942-140">The [notations] set is empty.</span></span>

- <span data-ttu-id="4e942-141">Zestaw [nieanalizowane jednostki] jest pusty.</span><span class="sxs-lookup"><span data-stu-id="4e942-141">The [unparsed entities] set is empty.</span></span>

<span data-ttu-id="4e942-142">Przykład: następujący dokument nie ma mapowania na kod JSON, ponieważ element [Children] zawiera znak PI i komentarz.</span><span class="sxs-lookup"><span data-stu-id="4e942-142">Example: The following document has no mapping to JSON because [children] holds a PI and a comment.</span></span>

```xml
<?xml version="1.0"?>
<!--comment--><?pi?>
<root type="number">42</root>
```

<span data-ttu-id="4e942-143">EII dla głównego elementu JSON ma następującą charakterystykę:</span><span class="sxs-lookup"><span data-stu-id="4e942-143">The EII for the Root JSON Element has the following characteristics:</span></span>

- <span data-ttu-id="4e942-144">[nazwa lokalna] ma wartość "root".</span><span class="sxs-lookup"><span data-stu-id="4e942-144">[local name] has the value "root".</span></span>

- <span data-ttu-id="4e942-145">[nazwa przestrzeni nazw] nie ma wartości.</span><span class="sxs-lookup"><span data-stu-id="4e942-145">[namespace name] has no value.</span></span>

- <span data-ttu-id="4e942-146">[prefix] nie ma wartości.</span><span class="sxs-lookup"><span data-stu-id="4e942-146">[prefix] has no value.</span></span>

- <span data-ttu-id="4e942-147">[elementy podrzędne] mogą zawierać EIIs (reprezentujący elementy wewnętrzne zgodnie z opisem) lub CIIs (elementy informacji o znakach, jak opisano w dalszej części) lub żadne z nich, ale nie oba.</span><span class="sxs-lookup"><span data-stu-id="4e942-147">[children] may either contain EIIs (which represent Inner Elements as described further) or CIIs (Character Information Items as described further) or none of these, but not both.</span></span>

- <span data-ttu-id="4e942-148">[atrybuty] mogą zawierać następujące opcjonalne elementy informacji o atrybucie (AIIs)</span><span class="sxs-lookup"><span data-stu-id="4e942-148">[attributes] may contain the following optional attribute information items (AIIs)</span></span>

- <span data-ttu-id="4e942-149">Atrybut typu JSON ("Type"), zgodnie z opisem w dalszej postaci.</span><span class="sxs-lookup"><span data-stu-id="4e942-149">The JSON Type Attribute ("type") as described further.</span></span> <span data-ttu-id="4e942-150">Ten atrybut służy do zachowania typu JSON (ciąg, liczba, wartość logiczna, obiekt, tablica lub wartość null) w mapowanym kodzie XML.</span><span class="sxs-lookup"><span data-stu-id="4e942-150">This attribute is used to preserve the JSON type (string, number, boolean, object, array or null) in the mapped XML.</span></span>

- <span data-ttu-id="4e942-151">Atrybut nazwy kontraktu danych (" \_ \_ Type"), zgodnie z opisem w dalszej postaci.</span><span class="sxs-lookup"><span data-stu-id="4e942-151">The Data Contract Name Attribute ("\_\_type") as described further.</span></span> <span data-ttu-id="4e942-152">Ten atrybut jest dostępny tylko wtedy, gdy atrybut typu JSON jest również obecny i jego [znormalizowana wartość] to "Object".</span><span class="sxs-lookup"><span data-stu-id="4e942-152">This attribute is can only be present if the JSON type attribute is also present and its [normalized value] is "object".</span></span> <span data-ttu-id="4e942-153">Ten atrybut jest używany przez program `DataContractJsonSerializer` do zachowywania informacji o typie kontraktu danych — na przykład w przypadkach polimorficznych, w których typ pochodny jest serializowany i gdy oczekiwany jest typ podstawowy.</span><span class="sxs-lookup"><span data-stu-id="4e942-153">This attribute is used by the `DataContractJsonSerializer` to preserve data contract type information - for example, in polymorphic cases where a derived type is serialized and where a base type is expected.</span></span> <span data-ttu-id="4e942-154">Jeśli nie pracujesz z programem `DataContractJsonSerializer` , w większości przypadków ten atrybut jest ignorowany.</span><span class="sxs-lookup"><span data-stu-id="4e942-154">If you are not working with the `DataContractJsonSerializer`, in most cases, this attribute is ignored.</span></span>

- <span data-ttu-id="4e942-155">[przestrzenie nazw w zakresie] zawierają powiązanie "XML" z `http://www.w3.org/XML/1998/namespace` przywidzianą specyfikacją sprawdzonych.</span><span class="sxs-lookup"><span data-stu-id="4e942-155">[in-scope namespaces] contains the binding of "xml" to `http://www.w3.org/XML/1998/namespace` as mandated by the infoset specification.</span></span>

- <span data-ttu-id="4e942-156">[elementy podrzędne], [atrybuty] i [przestrzenie nazw w zakresie] nie mogą zawierać elementów innych niż określone wcześniej, a [atrybuty przestrzeni nazw] nie mogą mieć żadnych elementów członkowskich, ale nie należy polegać na tych faktach podczas odczytywania danych XML mapowanych z formatu JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-156">[children], [attributes] and [in-scope namespaces] must not have any items other than as specified previously and [namespace attributes] must have no members, but do not rely on these facts when reading XML mapped from JSON.</span></span>

<span data-ttu-id="4e942-157">Przykład: następujący dokument nie ma mapowania na kod JSON, ponieważ atrybuty [Namespace] nie są puste.</span><span class="sxs-lookup"><span data-stu-id="4e942-157">Example: The following document has no mapping to JSON because [namespace attributes] is not empty.</span></span>

```xml
<?xml version="1.0"?>
<root xmlns:a="myattributevalue">42</root>
```

<span data-ttu-id="4e942-158">WSZYSTKO dla atrybutu typu JSON ma następującą charakterystykę:</span><span class="sxs-lookup"><span data-stu-id="4e942-158">The AII for the JSON Type Attribute has the following characteristics:</span></span>

- <span data-ttu-id="4e942-159">[nazwa przestrzeni nazw] nie ma wartości.</span><span class="sxs-lookup"><span data-stu-id="4e942-159">[namespace name] has no value.</span></span>
- <span data-ttu-id="4e942-160">[prefix] nie ma wartości.</span><span class="sxs-lookup"><span data-stu-id="4e942-160">[prefix] has no value.</span></span>
- <span data-ttu-id="4e942-161">[nazwa lokalna] to "typ".</span><span class="sxs-lookup"><span data-stu-id="4e942-161">[local name] is "type".</span></span>
- <span data-ttu-id="4e942-162">[znormalizowana wartość] to jedno z możliwych wartości typu opisanych w poniższej sekcji.</span><span class="sxs-lookup"><span data-stu-id="4e942-162">[normalized value] is one of the possible type values described in the following section.</span></span>
- <span data-ttu-id="4e942-163">[określony] ma `true` .</span><span class="sxs-lookup"><span data-stu-id="4e942-163">[specified] is `true`.</span></span>
- <span data-ttu-id="4e942-164">[typ atrybutu] nie ma wartości.</span><span class="sxs-lookup"><span data-stu-id="4e942-164">[attribute type] has no value.</span></span>
- <span data-ttu-id="4e942-165">[References] nie ma wartości.</span><span class="sxs-lookup"><span data-stu-id="4e942-165">[references] has no value.</span></span>

<span data-ttu-id="4e942-166">WSZYSTKO dla atrybutu nazwy kontraktu danych ma następującą charakterystykę:</span><span class="sxs-lookup"><span data-stu-id="4e942-166">The AII for the Data Contract Name Attribute has the following characteristics:</span></span>

- <span data-ttu-id="4e942-167">[nazwa przestrzeni nazw] nie ma wartości.</span><span class="sxs-lookup"><span data-stu-id="4e942-167">[namespace name] has no value.</span></span>
- <span data-ttu-id="4e942-168">[prefix] nie ma wartości.</span><span class="sxs-lookup"><span data-stu-id="4e942-168">[prefix] has no value.</span></span>
- <span data-ttu-id="4e942-169">[nazwa lokalna] to " \_ \_ Typ" (dwie podkreślenia, a następnie "typ").</span><span class="sxs-lookup"><span data-stu-id="4e942-169">[local name] is "\_\_type" (two underscores and then "type").</span></span>
- <span data-ttu-id="4e942-170">[znormalizowana wartość] jest dowolnym prawidłowym ciągiem Unicode — mapowanie tego ciągu na format JSON jest opisane w poniższej sekcji.</span><span class="sxs-lookup"><span data-stu-id="4e942-170">[normalized value] is any valid Unicode string – the mapping of this string to JSON is described in the following section.</span></span>
- <span data-ttu-id="4e942-171">[określony] ma `true` .</span><span class="sxs-lookup"><span data-stu-id="4e942-171">[specified] is `true`.</span></span>
- <span data-ttu-id="4e942-172">[typ atrybutu] nie ma wartości.</span><span class="sxs-lookup"><span data-stu-id="4e942-172">[attribute type] has no value.</span></span>
- <span data-ttu-id="4e942-173">[References] nie ma wartości.</span><span class="sxs-lookup"><span data-stu-id="4e942-173">[references] has no value.</span></span>

<span data-ttu-id="4e942-174">Elementy wewnętrzne zawarte w głównym elemencie JSON lub inne elementy wewnętrzne mają następującą charakterystykę:</span><span class="sxs-lookup"><span data-stu-id="4e942-174">Inner elements contained within the Root JSON Element or other inner elements have the following characteristics:</span></span>

- <span data-ttu-id="4e942-175">[nazwa lokalna] może mieć dowolną wartość, zgodnie z opisem.</span><span class="sxs-lookup"><span data-stu-id="4e942-175">[local name] may have any value as described further.</span></span>
- <span data-ttu-id="4e942-176">[nazwa przestrzeni nazw], [prefiks], [elementy podrzędne], [atrybuty], [atrybuty przestrzeni nazw] i [przestrzenie nazw w zakresie] są objęte tymi samymi regułami, co główny element JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-176">[namespace name], [prefix], [children], [attributes], [namespace attributes], and [in-scope namespaces] are subject to the same rules as the Root JSON Element.</span></span>

<span data-ttu-id="4e942-177">Zarówno w głównym elemencie JSON, jak i elementach wewnętrznych, atrybut typu JSON definiuje mapowanie do formatu JSON oraz możliwe [elementy podrzędne] i ich interpretację.</span><span class="sxs-lookup"><span data-stu-id="4e942-177">In both the Root JSON Element and the inner elements, the JSON Type Attribute defines the mapping to JSON and the possible [children] and their interpretation.</span></span> <span data-ttu-id="4e942-178">Atrybut [znormalizowana wartość] ma wielkość liter i musi być pisany małymi literami i nie może zawierać białych znaków.</span><span class="sxs-lookup"><span data-stu-id="4e942-178">The attribute’s [normalized value] is case-sensitive and must be lowercase, and cannot contain white space.</span></span>

|<span data-ttu-id="4e942-179">[znormalizowana wartość] wszystko atrybutu typu JSON</span><span class="sxs-lookup"><span data-stu-id="4e942-179">[normalized value] of JSON Type Attribute’s AII</span></span>|<span data-ttu-id="4e942-180">Dozwolone elementy [Children] odpowiadającego EII</span><span class="sxs-lookup"><span data-stu-id="4e942-180">Allowed [children] of the corresponding EII</span></span>|<span data-ttu-id="4e942-181">Mapowanie do formatu JSON</span><span class="sxs-lookup"><span data-stu-id="4e942-181">Mapping to JSON</span></span>|
|---------------------------------------------------------|---------------------------------------------------|---------------------|
|<span data-ttu-id="4e942-182">`string` (lub brak typu JSON wszystko)</span><span class="sxs-lookup"><span data-stu-id="4e942-182">`string` (or absence of the JSON type AII)</span></span><br /><br /> <span data-ttu-id="4e942-183">`string`A i brak typu JSON wszystko są takie same `string` .</span><span class="sxs-lookup"><span data-stu-id="4e942-183">A `string` and the absence of the JSON type AII are the same makes `string` the default.</span></span><br /><br /> <span data-ttu-id="4e942-184">Dlatego `<root> string1</root>` mapuje do formatu JSON `string` "ciąg1".</span><span class="sxs-lookup"><span data-stu-id="4e942-184">So, `<root> string1</root>` maps to the JSON `string` "string1".</span></span>|<span data-ttu-id="4e942-185">0 lub więcej CIIs</span><span class="sxs-lookup"><span data-stu-id="4e942-185">0 or more CIIs</span></span>|<span data-ttu-id="4e942-186">Plik JSON `string` (JSON RFC, sekcja 2,5).</span><span class="sxs-lookup"><span data-stu-id="4e942-186">A JSON `string` (JSON RFC, section 2.5).</span></span> <span data-ttu-id="4e942-187">Każdy `char` jest znakiem, który odnosi się do [kod znaku] z CII.</span><span class="sxs-lookup"><span data-stu-id="4e942-187">Each `char` is a character that corresponds to the [character code] from the CII.</span></span> <span data-ttu-id="4e942-188">Jeśli nie ma żadnych CIIs, mapuje do pustego pliku JSON `string` .</span><span class="sxs-lookup"><span data-stu-id="4e942-188">If there are no CIIs, it maps to an empty JSON `string`.</span></span><br /><br /> <span data-ttu-id="4e942-189">Przykład: następujący element mapuje do fragmentu JSON:</span><span class="sxs-lookup"><span data-stu-id="4e942-189">Example: The following element maps to a JSON fragment:</span></span><br /><br /> `<root type="string">42</root>`<br /><br /> <span data-ttu-id="4e942-190">Fragment JSON to "42".</span><span class="sxs-lookup"><span data-stu-id="4e942-190">The JSON fragment is "42".</span></span><br /><br /> <span data-ttu-id="4e942-191">W przypadku mapowania XML do formatu JSON znaki, które muszą mieć sekwencję ucieczki do znaków ucieczki, wszystkie inne są mapowane na znaki, które nie są wyprowadzane.</span><span class="sxs-lookup"><span data-stu-id="4e942-191">On XML to JSON mapping, characters that must be escaped map to escaped characters, all others map to characters that are not escaped.</span></span> <span data-ttu-id="4e942-192">Znak "/" jest specjalny — oznacza, że jest on zmieniony, chociaż nie musi być (napisano jako " \\ /").</span><span class="sxs-lookup"><span data-stu-id="4e942-192">The "/" character is special – it is escaped even though it does not have to be (written out as "\\/").</span></span><br /><br /> <span data-ttu-id="4e942-193">Przykład: Poniższy element mapuje do fragmentu JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-193">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="string">the "da/ta"</root>`<br /><br /> <span data-ttu-id="4e942-194">Fragment JSON to "" \\ da \\ /Ta "" \\ .</span><span class="sxs-lookup"><span data-stu-id="4e942-194">The JSON fragment is "the \\"da\\/ta\\"".</span></span><br /><br /> <span data-ttu-id="4e942-195">W mapowaniu JSON na XML, wszelkie znaki ucieczki i znaki, które nie są poprawnie mapowane na mapę, do odpowiadającego [znakowego kodu].</span><span class="sxs-lookup"><span data-stu-id="4e942-195">On JSON to XML mapping, any escaped characters and characters that are not escaped map correctly to the corresponding [character code].</span></span><br /><br /> <span data-ttu-id="4e942-196">Przykład: fragment JSON "\u0041BC" mapuje do następującego elementu XML.</span><span class="sxs-lookup"><span data-stu-id="4e942-196">Example: The JSON fragment "\u0041BC", maps to the following XML element.</span></span><br /><br /> `<root type="string">ABC</root>`<br /><br /> <span data-ttu-id="4e942-197">Ciąg może być otoczony białym znakiem ("ws" w sekcji 2 dokumentu JSON RFC), który nie jest mapowany do formatu XML.</span><span class="sxs-lookup"><span data-stu-id="4e942-197">The string can be surrounded by white space ('ws' in section 2 of the JSON RFC) that does not get mapped to XML.</span></span><br /><br /> <span data-ttu-id="4e942-198">Przykład: fragment JSON "ABC" (zawiera spacje przed pierwszym cudzysłowem), mapuje do następującego elementu XML.</span><span class="sxs-lookup"><span data-stu-id="4e942-198">Example: The JSON fragment           "ABC", (there are spaces before the first double quote), maps to the following XML element.</span></span><br /><br /> `<root type="string">ABC</root>`<br /><br /> <span data-ttu-id="4e942-199">Dowolny biały znak w programie XML mapuje do białego miejsca w formacie JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-199">Any white space in XML maps to white space in JSON.</span></span><br /><br /> <span data-ttu-id="4e942-200">Przykład: Poniższy element XML mapuje do fragmentu JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-200">Example: The following XML element maps to a JSON fragment.</span></span><br /><br /> `<root type="string">  A BC      </root>`<br /><br /> <span data-ttu-id="4e942-201">Fragment JSON to "A BC".</span><span class="sxs-lookup"><span data-stu-id="4e942-201">The JSON fragment is " A BC ".</span></span>|
|`number`|<span data-ttu-id="4e942-202">1 lub więcej CIIs</span><span class="sxs-lookup"><span data-stu-id="4e942-202">1 or more CIIs</span></span>|<span data-ttu-id="4e942-203">KOD JSON `number` (kod RFC JSON, sekcja 2,4), prawdopodobnie otoczony białym znakiem.</span><span class="sxs-lookup"><span data-stu-id="4e942-203">A JSON `number` (JSON RFC, section 2.4), possibly surrounded by white space.</span></span> <span data-ttu-id="4e942-204">Każdy znak w kombinacji liczby/odstępu jest znakiem, który odnosi się do [kod znaku] z CII.</span><span class="sxs-lookup"><span data-stu-id="4e942-204">Each character in the number/white space combination is a character that corresponds to the [character code] from the CII.</span></span><br /><br /> <span data-ttu-id="4e942-205">Przykład: Poniższy element mapuje do fragmentu JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-205">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="number">    42</root>`<br /><br /> <span data-ttu-id="4e942-206">Fragment JSON to 42</span><span class="sxs-lookup"><span data-stu-id="4e942-206">The JSON fragment is    42</span></span><br /><br /> <span data-ttu-id="4e942-207">(Biały znak jest zachowywany).</span><span class="sxs-lookup"><span data-stu-id="4e942-207">(White space is preserved).</span></span>|
|`boolean`|<span data-ttu-id="4e942-208">4 lub 5 CIIs (które odnoszą się do `true` lub `false` ), prawdopodobnie otoczone dodatkowymi białymi miejscami CIIs.</span><span class="sxs-lookup"><span data-stu-id="4e942-208">4 or 5 CIIs (which corresponds to `true` or `false`), possibly surrounded by additional white-space CIIs.</span></span>|<span data-ttu-id="4e942-209">Sekwencja CIIa odpowiadająca ciągowi "true" jest mapowana na literał `true` , a sekwencja CII, która odpowiada ciągowi "false", jest mapowana na literał `false` .</span><span class="sxs-lookup"><span data-stu-id="4e942-209">A CII sequence that corresponds to the string "true" is mapped to the literal `true`, and a CII sequence that corresponds to the string "false" is mapped to the literal `false`.</span></span> <span data-ttu-id="4e942-210">Zachowywany jest biały znak.</span><span class="sxs-lookup"><span data-stu-id="4e942-210">Surrounding white space is preserved.</span></span><br /><br /> <span data-ttu-id="4e942-211">Przykład: Poniższy element mapuje do fragmentu JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-211">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="boolean"> false</root>`<br /><br /> <span data-ttu-id="4e942-212">Fragment JSON to `false` .</span><span class="sxs-lookup"><span data-stu-id="4e942-212">The JSON fragment is `false`.</span></span>|
|`null`|<span data-ttu-id="4e942-213">Brak dozwolonych.</span><span class="sxs-lookup"><span data-stu-id="4e942-213">None allowed.</span></span>|<span data-ttu-id="4e942-214">Litera `null` .</span><span class="sxs-lookup"><span data-stu-id="4e942-214">The literal `null`.</span></span> <span data-ttu-id="4e942-215">W mapowaniu JSON na XML, `null` może być otoczona białym znakiem ("ws" w sekcji 2), która nie jest zmapowana do formatu XML.</span><span class="sxs-lookup"><span data-stu-id="4e942-215">On JSON to XML mapping, the `null` may be surrounded by white space (‘ws’ in section 2) that does not get mapped to XML.</span></span><br /><br /> <span data-ttu-id="4e942-216">Przykład: Poniższy element mapuje do fragmentu JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-216">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="null"/>`<br /><br /> <span data-ttu-id="4e942-217">lub</span><span class="sxs-lookup"><span data-stu-id="4e942-217">or</span></span><br /><br /> `<root type="null"></root>`<br /><br /> <span data-ttu-id="4e942-218">:</span><span class="sxs-lookup"><span data-stu-id="4e942-218">:</span></span><br /><br /> <span data-ttu-id="4e942-219">Fragment kodu JSON w obu przypadkach ma wartość `Null` .</span><span class="sxs-lookup"><span data-stu-id="4e942-219">The JSON fragment in both cases is `Null`.</span></span>|
|`object`|<span data-ttu-id="4e942-220">0 lub więcej EIIs.</span><span class="sxs-lookup"><span data-stu-id="4e942-220">0 or more EIIs.</span></span>|<span data-ttu-id="4e942-221">A `begin-object` (lewy nawias klamrowy) jak w sekcji 2,2 specyfikacji RFC JSON, a następnie rekord elementu członkowskiego dla każdego EIIu, zgodnie z opisem w dalszej części.</span><span class="sxs-lookup"><span data-stu-id="4e942-221">A `begin-object` (left curly brace) as in section 2.2 of the JSON RFC, followed by a member record for each EII as described further.</span></span> <span data-ttu-id="4e942-222">Jeśli istnieje więcej niż jeden EII, istnieją separatory wartości (przecinki) między rekordami elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="4e942-222">If there is more than one EII, there are value-separators (commas) between the member records.</span></span> <span data-ttu-id="4e942-223">Po nim następuje obiekt końcowy (prawy nawias klamrowy).</span><span class="sxs-lookup"><span data-stu-id="4e942-223">All this is followed by an end-object (right curly brace).</span></span><br /><br /> <span data-ttu-id="4e942-224">Przykład: Poniższy element jest mapowany do fragmentu JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-224">Example: The following element maps to the JSON fragment.</span></span><br /><br /> `<root type="object">`<br /><br /> `<type1 type="string">aaa\</type1>`<br /><br /> `<type2 type="string">bbb\</type2>`<br /><br /> `</root >`<br /><br /> <span data-ttu-id="4e942-225">Fragment JSON to `{"type1":"aaa","type2":"bbb"}` .</span><span class="sxs-lookup"><span data-stu-id="4e942-225">The JSON fragment is `{"type1":"aaa","type2":"bbb"}`.</span></span><br /><br /> <span data-ttu-id="4e942-226">Jeśli atrybut typu kontraktu danych jest obecny w mapowaniu XML do formatu JSON, na początku zostanie wstawiony dodatkowy rekord elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="4e942-226">If the Data Contract Type Attribute is present on XML to JSON mapping, then an additional Member Record is inserted at the beginning.</span></span> <span data-ttu-id="4e942-227">Jego nazwą jest [local name] atrybutu typu kontraktu danych (" \_ \_ Type"), a jego wartością jest [znormalizowana wartość].</span><span class="sxs-lookup"><span data-stu-id="4e942-227">Its name is the [local name] of the Data Contract Type Attribute ("\_\_type"), and its value is the attribute's [normalized value].</span></span> <span data-ttu-id="4e942-228">W przypadku mapowania JSON na XML, jeśli nazwa pierwszego elementu członkowskiego rekordu to [lokalna nazwa] atrybutu typu kontraktu danych (czyli " \_ \_ Typ"), odpowiedni atrybut typu kontraktu danych jest obecny w MAPOWANYM kodzie XML, ale nie ma odpowiedniego EII.</span><span class="sxs-lookup"><span data-stu-id="4e942-228">Conversely, on JSON to XML mapping, if the first member-record’s name is the [local name] of the Data Contract Type Attribute (that is, "\_\_type"), a corresponding Data Contract Type Attribute is present in the mapped XML, but a corresponding EII is not present.</span></span> <span data-ttu-id="4e942-229">Należy zauważyć, że ten rekord elementu członkowskiego musi wystąpić najpierw w obiekcie JSON dla tego mapowania specjalnego do zastosowania.</span><span class="sxs-lookup"><span data-stu-id="4e942-229">Note that this member record must occur first in the JSON object for this special mapping to apply.</span></span> <span data-ttu-id="4e942-230">Reprezentuje to wyjście z normalnego przetwarzania JSON, w którym kolejność rekordów elementów członkowskich nie jest istotna.</span><span class="sxs-lookup"><span data-stu-id="4e942-230">This represents a departure from usual JSON processing, where the order of member records is not significant.</span></span><br /><br /> <span data-ttu-id="4e942-231">Przykład:</span><span class="sxs-lookup"><span data-stu-id="4e942-231">Example:</span></span><br /><br /> <span data-ttu-id="4e942-232">Poniższy fragment kodu JSON jest mapowany na format XML.</span><span class="sxs-lookup"><span data-stu-id="4e942-232">The following JSON fragment maps to XML.</span></span><br /><br /> `{"__type":"Person","name":"John"}`<br /><br /> <span data-ttu-id="4e942-233">Kod XML jest poniższym kodem.</span><span class="sxs-lookup"><span data-stu-id="4e942-233">The XML is the following code.</span></span><br /><br /> `<root type="object" __type="Person">   <name type="string">John</name> </root>`<br /><br /> <span data-ttu-id="4e942-234">Zauważ, że \_ \_ Typ wszystko jest obecny, ale nie ma \_ \_ typu EII.</span><span class="sxs-lookup"><span data-stu-id="4e942-234">Notice that the \_\_type AII is present, but there is no \_\_type EII.</span></span><br /><br /> <span data-ttu-id="4e942-235">Jeśli jednak porządek w kodzie JSON zostanie odwrócony, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="4e942-235">However, if the order in the JSON is reversed as shown in the following example.</span></span><br /><br /> `{"name":"John","\_\_type":"Person"}`<br /><br /> <span data-ttu-id="4e942-236">Wyświetlany jest odpowiedni kod XML.</span><span class="sxs-lookup"><span data-stu-id="4e942-236">The corresponding XML is shown.</span></span><br /><br /> `<root type="object">   <name type="string">John</name>   <__type type="string">Person</__type> </root>`<br /><br /> <span data-ttu-id="4e942-237">Oznacza to, że \_ _Type przestaje mieć specjalne znaczenie i jest mapowany na EII w zwykły sposób, a nie wszystko.</span><span class="sxs-lookup"><span data-stu-id="4e942-237">That is, \__type ceases to have special meaning and maps to an EII as usual, not AII.</span></span><br /><br /> <span data-ttu-id="4e942-238">Reguły ucieczki/anulowania ucieczki dla [znormalizowanej wartości] wszystko są takie same jak w przypadku ciągów JSON określonych w wierszu "String" tej tabeli.</span><span class="sxs-lookup"><span data-stu-id="4e942-238">Escaping/unescaping rules for the AII’s [normalized value] when mapped to a JSON value are the same as for JSON strings, specified in the "string" row of this table.</span></span><br /><br /> <span data-ttu-id="4e942-239">Przykład:</span><span class="sxs-lookup"><span data-stu-id="4e942-239">Example:</span></span><br /><br /> `<root type="object" __type="\abc" />`<br /><br /> <span data-ttu-id="4e942-240">do poprzedniego przykładu można zamapować do poniższego kodu JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-240">to the previous example can be mapped to the following JSON.</span></span><br /><br /> `{"__type":"\\abc"}`<br /><br /> <span data-ttu-id="4e942-241">W mapowaniu XML do formatu JSON pierwszy EII [nazwa lokalna] nie może być \_ \_ typu "Type".</span><span class="sxs-lookup"><span data-stu-id="4e942-241">On an XML to JSON mapping, the first EII’s [local name] must not be "\_\_type".</span></span><br /><br /> <span data-ttu-id="4e942-242">Biały znak ( `ws` ) nie jest nigdy generowany w MAPOWANIU XML na notację JSON dla obiektów i jest ignorowany w MAPOWANIU JSON to XML.</span><span class="sxs-lookup"><span data-stu-id="4e942-242">White space (`ws`) is never generated on XML to JSON mapping for objects and is ignored on JSON to XML mapping.</span></span><br /><br /> <span data-ttu-id="4e942-243">Przykład: Poniższy fragment kodu JSON jest mapowany na element XML.</span><span class="sxs-lookup"><span data-stu-id="4e942-243">Example: The following JSON fragment maps to an XML element.</span></span><br /><br /> `{ "ccc" : "aaa", "ddd" :"bbb"}`<br /><br /> <span data-ttu-id="4e942-244">Element XML jest pokazany w poniższym kodzie.</span><span class="sxs-lookup"><span data-stu-id="4e942-244">The XML element is shown in the following code.</span></span><br /><br /> `<root type="object">    <ccc type="string">aaa</ccc>    <ddd type="string">bbb</bar> </root >`|
|<span data-ttu-id="4e942-245">array</span><span class="sxs-lookup"><span data-stu-id="4e942-245">array</span></span>|<span data-ttu-id="4e942-246">0 lub więcej EIIs</span><span class="sxs-lookup"><span data-stu-id="4e942-246">0 or more EIIs</span></span>|<span data-ttu-id="4e942-247">Tablica BEGIN-Array (lewy nawias kwadratowy), jak w sekcji 2,3 w formacie JSON, a następnie rekord tablicy dla każdego EIIu, zgodnie z opisem w dalszej części.</span><span class="sxs-lookup"><span data-stu-id="4e942-247">A begin-array (left square bracket) as in section 2.3 of the JSON RFC, followed by an array record for each EII as described further.</span></span> <span data-ttu-id="4e942-248">Jeśli istnieje więcej niż jeden EII, istnieją separatory wartości (przecinki) między rekordami tablicy.</span><span class="sxs-lookup"><span data-stu-id="4e942-248">If there is more than one EII, there are value-separators (commas) between the array records.</span></span> <span data-ttu-id="4e942-249">Jest to po nim tablica końcowa.</span><span class="sxs-lookup"><span data-stu-id="4e942-249">All this is followed by an end-array.</span></span><br /><br /> <span data-ttu-id="4e942-250">Przykład: Poniższy element XML mapuje do fragmentu JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-250">Example: The following XML element maps to a JSON fragment.</span></span><br /><br /> `<root type="array"/>    <item type="string">aaa</item>    <item type="string">bbb</item> </root >`<br /><br /> <span data-ttu-id="4e942-251">Fragment JSON jest `["aaa","bbb"]`</span><span class="sxs-lookup"><span data-stu-id="4e942-251">The JSON fragment is `["aaa","bbb"]`</span></span><br /><br /> <span data-ttu-id="4e942-252">Biały znak ( `ws` ) nie jest nigdy generowany w MAPOWANIU XML na kod JSON dla tablic i jest ignorowany w MAPOWANIU JSON to XML.</span><span class="sxs-lookup"><span data-stu-id="4e942-252">White space (`ws`) is never generated on XML to JSON mapping for arrays and is ignored on JSON to XML mapping.</span></span><br /><br /> <span data-ttu-id="4e942-253">Przykład: fragment JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-253">Example: A JSON fragment.</span></span><br /><br />`["aaa", "bbb"]`<br /><br /> <span data-ttu-id="4e942-254">Element XML, który jest mapowany na.</span><span class="sxs-lookup"><span data-stu-id="4e942-254">The XML element that it maps to.</span></span><br /><br /> `<root type="array"/>    <item type="string">aaa</item>    <item type="string">bbb</item> </root >`|

<span data-ttu-id="4e942-255">Rekordy elementów członkowskich działają w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="4e942-255">Member Records work as follows:</span></span>

- <span data-ttu-id="4e942-256">Element wewnętrzny [nazwa lokalna] mapuje do `string` części `member` zgodnie z definicją w sekcji 2,2 specyfikacji RFC JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-256">Inner element’s [local name] maps to the `string` part of the `member` as defined in section 2.2 of the JSON RFC.</span></span>

<span data-ttu-id="4e942-257">Przykład: Poniższy element mapuje do fragmentu JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-257">Example: The following element maps to a JSON fragment.</span></span>

```xml
<root type="object">
    <myLocalName type="string">aaa</myLocalName>
</root>
```

<span data-ttu-id="4e942-258">Zostanie wyświetlony następujący fragment kodu JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-258">The following JSON fragment is displayed.</span></span>

```json
{"myLocalName":"aaa"}
```

- <span data-ttu-id="4e942-259">W przypadku mapowania XML do formatu JSON znaki, które muszą zostać zmienione w formacie JSON, są wyprowadzane, a inne nie są wyprowadzane.</span><span class="sxs-lookup"><span data-stu-id="4e942-259">On the XML to JSON mapping, the characters that must be escaped in JSON are escaped, and the others are not escaped.</span></span> <span data-ttu-id="4e942-260">Znak "/", mimo że nie jest znakiem, który musi zostać zmieniony, jest Niemniej niezbędny (w przypadku mapowania JSON to XML).</span><span class="sxs-lookup"><span data-stu-id="4e942-260">The "/" character, even though it is not a character that must be escaped, is escaped nevertheless (it does not have to be escaped on JSON to XML mapping).</span></span> <span data-ttu-id="4e942-261">Jest to wymagane do obsługi formatu ASP.NET AJAX dla `DateTime` danych w formacie JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-261">This is required to support the ASP.NET AJAX format for `DateTime` data in JSON.</span></span>

- <span data-ttu-id="4e942-262">W przypadku mapowania JSON na XML wszystkie znaki (w tym znaki nieucieczki, w razie potrzeby) są tworzone w celu utworzenia wartości `string` [local name].</span><span class="sxs-lookup"><span data-stu-id="4e942-262">On the JSON to XML mapping, all characters (including the not escaped characters, if necessary) are taken to form a `string` that produces a [local name].</span></span>

- <span data-ttu-id="4e942-263">Elementy wewnętrzne [Children] mapują do wartości w sekcji 2,2, zgodnie z, podobnie `JSON Type Attribute` jak w przypadku `Root JSON Element` .</span><span class="sxs-lookup"><span data-stu-id="4e942-263">Inner elements [children] map to the value in section 2.2, according to the `JSON Type Attribute` just like for the `Root JSON Element`.</span></span> <span data-ttu-id="4e942-264">Dozwolone jest użycie wielu poziomów zagnieżdżenia EIIs (w tym zagnieżdżania w tablicach).</span><span class="sxs-lookup"><span data-stu-id="4e942-264">Multiple levels of nesting of EIIs (including nesting within arrays) are allowed.</span></span>

<span data-ttu-id="4e942-265">Przykład: Poniższy element mapuje do fragmentu JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-265">Example: The following element maps to a JSON fragment.</span></span>

```xml
<root type="object">
    <myLocalName1 type="string">myValue1</myLocalName1>
    <myLocalName2 type="number">2</myLocalName2>
    <myLocalName3 type="object">
        <myNestedName1 type="boolean">true</myNestedName1>
        <myNestedName2 type="null"/>
    </myLocalName3>
</root >
```

<span data-ttu-id="4e942-266">Poniższy fragment kodu JSON jest mapowany do programu.</span><span class="sxs-lookup"><span data-stu-id="4e942-266">The following JSON fragment is what it maps to.</span></span>

```json
{"myLocalName1":"myValue1","myLocalName2":2,"myLocalName3":{"myNestedName1":true,"myNestedName2":null}}
```

> [!NOTE]
> <span data-ttu-id="4e942-267">W poprzednim mapowaniu nie ma kroku kodowania XML.</span><span class="sxs-lookup"><span data-stu-id="4e942-267">There is no XML encoding step in the preceding mapping.</span></span> <span data-ttu-id="4e942-268">W związku z tym WCF obsługuje tylko dokumenty JSON, w których wszystkie znaki w nazwach kluczy są prawidłowymi znakami w nazwach elementów XML.</span><span class="sxs-lookup"><span data-stu-id="4e942-268">Therefore, WCF only supports JSON documents where all characters in key names are valid characters in XML element names.</span></span> <span data-ttu-id="4e942-269">Na przykład dokument JSON {"<": "a"} nie jest obsługiwany, ponieważ < nie jest prawidłową nazwą elementu XML.</span><span class="sxs-lookup"><span data-stu-id="4e942-269">For example, the JSON document {"<":"a"} is not supported because < is not a valid name for an XML element.</span></span>

<span data-ttu-id="4e942-270">Odwrócona sytuacja (znaki prawidłowe w kodzie XML, ale nie w formacie JSON) nie powoduje żadnych problemów, ponieważ poprzednie mapowanie obejmuje ucieczki kodu JSON/etapy anulowania ucieczki.</span><span class="sxs-lookup"><span data-stu-id="4e942-270">The reverse situation (characters valid in XML but not in JSON) does not cause any problems because the preceding mapping includes JSON escaping/unescaping steps.</span></span>

<span data-ttu-id="4e942-271">Rekordy tablic działają w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="4e942-271">Array Records work as follows:</span></span>

- <span data-ttu-id="4e942-272">Element wewnętrzny [local name] to "Item".</span><span class="sxs-lookup"><span data-stu-id="4e942-272">Inner element’s [local name] is "item".</span></span>

- <span data-ttu-id="4e942-273">Element wewnętrzny [Children] mapuje do wartości w sekcji 2,3, zgodnie z atrybutem typu JSON dla elementu głównego JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-273">Inner element’s [children] map to the value in section 2.3, according to the JSON Type Attribute as is does for the Root JSON Element.</span></span> <span data-ttu-id="4e942-274">Dozwolone są wiele poziomów zagnieżdżenia elementu EIIs (w tym zagnieżdżanie w obrębie obiektów).</span><span class="sxs-lookup"><span data-stu-id="4e942-274">Multiple levels of nesting of EIIs (including nesting within objects) are allowed.</span></span>

<span data-ttu-id="4e942-275">Przykład: Poniższy element mapuje do fragmentu JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-275">Example: The following element maps to a JSON fragment.</span></span>

```xml
<root type="array">
    <item type="string">myValue1</item>
    <item type="number">2</item>
    <item type="array">
    <item type="boolean">true</item>
    <item type="null"/></item>
</root>
```

<span data-ttu-id="4e942-276">Poniżej znajduje się fragment kodu JSON.</span><span class="sxs-lookup"><span data-stu-id="4e942-276">The following is the JSON fragment.</span></span>

```json
["myValue1",2,[true,null]]
```

## <a name="see-also"></a><span data-ttu-id="4e942-277">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="4e942-277">See also</span></span>

- <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory>
- <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>
- [<span data-ttu-id="4e942-278">Autonomiczna serializacja kodu JSON</span><span class="sxs-lookup"><span data-stu-id="4e942-278">Stand-Alone JSON Serialization</span></span>](stand-alone-json-serialization.md)
