---
title: Mapowanie między formatami JSON i XML
ms.date: 03/30/2017
ms.assetid: 22ee1f52-c708-4024-bbf0-572e0dae64af
ms.openlocfilehash: 079ca9cebefcc96bffdb0ec4601a675ed83adefe
ms.sourcegitcommit: efff8f331fd9467f093f8ab8d23a203d6ecb5b60
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 09/01/2018
ms.locfileid: "43421726"
---
# <a name="mapping-between-json-and-xml"></a><span data-ttu-id="e9eff-102">Mapowanie między formatami JSON i XML</span><span class="sxs-lookup"><span data-stu-id="e9eff-102">Mapping Between JSON and XML</span></span>
<span data-ttu-id="e9eff-103">Czytniki i moduły zapisujące są produkowane przez <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory> dostarczać interfejs API XML nad zawartością JavaScript Object Notation (JSON).</span><span class="sxs-lookup"><span data-stu-id="e9eff-103">The readers and writers produced by the <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory> provide an XML API over JavaScript Object Notation (JSON) content.</span></span> <span data-ttu-id="e9eff-104">JSON koduje dane za pomocą podzestawu literałów obiektu języka JavaScript.</span><span class="sxs-lookup"><span data-stu-id="e9eff-104">JSON encodes data using a subset of the object literals of JavaScript.</span></span> <span data-ttu-id="e9eff-105">Czytniki i moduły zapisujące, generowane przez tę fabrykę są również używane podczas zawartość JSON jest wysyłane lub odbierane przez Windows Communication Foundation (WCF) aplikacji przy użyciu <xref:System.ServiceModel.Channels.WebMessageEncodingBindingElement> lub <xref:System.ServiceModel.WebHttpBinding>.</span><span class="sxs-lookup"><span data-stu-id="e9eff-105">The readers and writers produced by this factory are also used when JSON content is being sent or received by Windows Communication Foundation (WCF) applications using the <xref:System.ServiceModel.Channels.WebMessageEncodingBindingElement> or the <xref:System.ServiceModel.WebHttpBinding>.</span></span>  
  
 <span data-ttu-id="e9eff-106">Po zainicjowaniu z zawartością JSON, Czytelnik JSON zachowuje się w taki sam sposób, jak tekstową odczytującego XML obsługuje za pośrednictwem wystąpienia XML.</span><span class="sxs-lookup"><span data-stu-id="e9eff-106">When initialized with JSON content, the JSON reader behaves in the same way that a textual XML reader does over an instance of XML.</span></span> <span data-ttu-id="e9eff-107">Moduł zapisujący JSON, gdy podano sekwencję wywołań tworzącego na tekstowy odczytującego XML określone wystąpienie kodu XML, zapisuje zawartość JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-107">The JSON writer, when given a sequence of calls that on a textual XML reader produces a certain XML instance, writes out JSON content.</span></span> <span data-ttu-id="e9eff-108">Mapowanie między to wystąpienie XML i zawartość JSON jest opisane w tym temacie do użycia w zaawansowanych scenariuszach.</span><span class="sxs-lookup"><span data-stu-id="e9eff-108">The mapping between this instance of XML and the JSON content is described in this topic for use in advanced scenarios.</span></span>  
  
 <span data-ttu-id="e9eff-109">Wewnętrznie JSON jest reprezentowany jako zestaw informacji XML podczas przetwarzania przez architekturę WCF.</span><span class="sxs-lookup"><span data-stu-id="e9eff-109">Internally, JSON is represented as an XML infoset when processed by WCF.</span></span> <span data-ttu-id="e9eff-110">Zwykle nie trzeba dotyczą tego wewnętrznej reprezentacji mapowanie jest tylko jeden logiczne: JSON jest zwykle nie fizycznie przekonwertować na format XML w pamięci lub konwersji do formatu JSON z pliku XML.</span><span class="sxs-lookup"><span data-stu-id="e9eff-110">Normally you do not have to be concerned with this internal representation as the mapping is only a logical one: JSON is normally not physically converted to XML in memory or converted to JSON from XML.</span></span> <span data-ttu-id="e9eff-111">Mapowanie oznacza, że interfejsów API XML są używane do uzyskiwania dostępu do zawartości w formacie JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-111">The mapping means that XML APIs are used to access JSON content.</span></span>  
  
 <span data-ttu-id="e9eff-112">Gdy WCF używa formatu JSON, zwykle scenariusza jest to, że <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> jest automatycznie zasilane z sieci przez <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> zachowanie, lub <xref:System.ServiceModel.Description.WebHttpBehavior> zachowanie, gdy jest to konieczne.</span><span class="sxs-lookup"><span data-stu-id="e9eff-112">When WCF uses JSON, the usual scenario is that the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> is automatically plugged in by the <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> behavior, or by the <xref:System.ServiceModel.Description.WebHttpBehavior> behavior when appropriate.</span></span> <span data-ttu-id="e9eff-113"><xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> Rozumie mapowanie między formatami JSON i zestaw informacji XML i działa tak, jakby on bezpośrednio zajmuje się JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-113">The <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> understands the mapping between JSON and the XML infoset and acts as if it is dealing with JSON directly.</span></span> <span data-ttu-id="e9eff-114">(Można użyć <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> z dowolnym odczytującego XML lub moduł zapisujący przy założeniu, że kod XML jest zgodny ze następującego mapowania.)</span><span class="sxs-lookup"><span data-stu-id="e9eff-114">(It is possible to use the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> with any XML reader or writer, with the understanding that the XML conforms to the following mapping.)</span></span>  
  
 <span data-ttu-id="e9eff-115">W zaawansowanych scenariuszach może być konieczne uzyskiwania bezpośredniego dostępu do następującego mapowania.</span><span class="sxs-lookup"><span data-stu-id="e9eff-115">In advanced scenarios, it may become necessary to directly access the following mapping.</span></span> <span data-ttu-id="e9eff-116">Tych scenariuszy wystąpić, gdy użytkownik chce serializacji i deserializacji JSON w niestandardowy sposób, bez konieczności polegania na <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>, lub podczas pracy z <xref:System.ServiceModel.Channels.Message> typu bezpośrednio dla wiadomości zawierające JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-116">These scenarios occur when you want to serialize and deserialize JSON in custom ways, without relying on the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>, or when dealing with the <xref:System.ServiceModel.Channels.Message> type directly for messages containing JSON.</span></span> <span data-ttu-id="e9eff-117">Mapowanie JSON XML służy do rejestrowania komunikatów.</span><span class="sxs-lookup"><span data-stu-id="e9eff-117">The JSON-XML mapping is also used for message logging.</span></span> <span data-ttu-id="e9eff-118">Korzystając z funkcji rejestrowania wiadomości w usłudze WCF, komunikatów JSON jest rejestrowane jako XML zgodnie z mapowania opisane w następnej sekcji.</span><span class="sxs-lookup"><span data-stu-id="e9eff-118">When using the message logging feature in WCF, JSON messages is logged as XML according to the mapping described in the next section.</span></span>  
  
 <span data-ttu-id="e9eff-119">Wyjaśnienie pojęcia mapowania, poniższy przykład jest dokumentu JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-119">To clarify the concept of a mapping, the following example is of a JSON document.</span></span>  
  
```json  
{"product":"pencil","price":12}  
```  
  
 <span data-ttu-id="e9eff-120">Aby odczytać dokument JSON przy użyciu jednej z czytników wcześniej wspomniano, należy użyć taką samą sekwencję <xref:System.Xml.XmlDictionaryReader> wywołuje się, jak w przypadku przeczytaj następujący dokument XML.</span><span class="sxs-lookup"><span data-stu-id="e9eff-120">To read this JSON document using one of the readers previously mentioned, use the same sequence of <xref:System.Xml.XmlDictionaryReader> calls as you would to read the following XML document.</span></span>  
  
```xml  
<root type="object">  
    <product type="string">pencil</product>  
    <price type="number">12</price>  
</root>  
```  
  
 <span data-ttu-id="e9eff-121">Ponadto jeśli komunikat JSON w przykładzie jest odbierany przez architekturę WCF i rejestrowany, zobacz fragment XML w poprzednim dziennika.</span><span class="sxs-lookup"><span data-stu-id="e9eff-121">Furthermore, if the JSON message in the example is received by WCF and logged, you would see the XML fragment in the preceding log.</span></span>  
  
## <a name="mapping-between-json-and-the-xml-infoset"></a><span data-ttu-id="e9eff-122">Mapowanie między formatami JSON i zestaw informacji XML</span><span class="sxs-lookup"><span data-stu-id="e9eff-122">Mapping Between JSON and the XML Infoset</span></span>  
 <span data-ttu-id="e9eff-123">Formalnie, mapowanie jest między JSON, zgodnie z opisem w [RFC 4627](https://go.microsoft.com/fwlink/?LinkId=98808) (z wyjątkiem z pewnymi ograniczeniami swobodna i niektóre inne ograniczenia, które dodano) oraz XML zestaw informacji (i nie tekstowych XML) jako opisanych w [informacji XML Ustaw](https://go.microsoft.com/fwlink/?LinkId=98809) .</span><span class="sxs-lookup"><span data-stu-id="e9eff-123">Formally, the mapping is between JSON as described in [RFC 4627](https://go.microsoft.com/fwlink/?LinkId=98808) (except with certain restrictions relaxed and certain other restrictions added) and the XML infoset (and not textual XML) as described in [XML Information Set](https://go.microsoft.com/fwlink/?LinkId=98809) .</span></span> <span data-ttu-id="e9eff-124">Zobacz ten temat, aby uzyskać definicje *elementy informacji* i pól w [kwadratowych].</span><span class="sxs-lookup"><span data-stu-id="e9eff-124">See this topic for the definitions of *information items* and fields in [square brackets].</span></span>  
  
 <span data-ttu-id="e9eff-125">Pusty dokument JSON mapowany na pusty dokument XML, a pusty dokument XML jest mapowany na pusty dokument JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-125">A blank JSON document maps to a blank XML document, and a blank XML document maps to a blank JSON document.</span></span> <span data-ttu-id="e9eff-126">W pliku XML do mapowania JSON poprzedzających biały znak i końcowe biały znak po dokumentu nie są dozwolone.</span><span class="sxs-lookup"><span data-stu-id="e9eff-126">On the XML to JSON mapping, preceding white space and trailing white space after the document are not allowed.</span></span>  
  
 <span data-ttu-id="e9eff-127">Mapowanie jest zdefiniowane między albo element informacji dokumentu (DII) lub Element informacji elementu (EII) i JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-127">The mapping is defined between either a Document Information Item (DII) or an Element Information Item (EII) and JSON.</span></span> <span data-ttu-id="e9eff-128">EII lub właściwości [element dokumentu] DII, nazywa się głównym elementem JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-128">The EII, or the DII’s [document element] property, is referred to as the Root JSON Element.</span></span> <span data-ttu-id="e9eff-129">Należy pamiętać, że fragmenty dokumentu (XML z wieloma elementami katalogu głównego) nie są obsługiwane w to mapowanie.</span><span class="sxs-lookup"><span data-stu-id="e9eff-129">Note that document fragments (XML with multiple root elements) are not supported in this mapping.</span></span>  
  
 <span data-ttu-id="e9eff-130">Przykład: Następujący dokument:</span><span class="sxs-lookup"><span data-stu-id="e9eff-130">Example: The following document:</span></span>  
  
 `<?xml version="1.0"?>`  
  
 `<root type="number">42</root>`  
  
 <span data-ttu-id="e9eff-131">I następującego elementu:</span><span class="sxs-lookup"><span data-stu-id="e9eff-131">And the following element:</span></span>  
  
 `<root type="number">42</root>`  
  
 <span data-ttu-id="e9eff-132">Zarówno ma mapowania do formatu JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-132">Both have a mapping to JSON.</span></span> <span data-ttu-id="e9eff-133"><`root`> Element jest elementem głównym JSON w obu przypadkach.</span><span class="sxs-lookup"><span data-stu-id="e9eff-133">The <`root`> element is the Root JSON Element in both cases.</span></span>  
  
 <span data-ttu-id="e9eff-134">Ponadto w przypadku DII, należy rozważyć:</span><span class="sxs-lookup"><span data-stu-id="e9eff-134">Furthermore, in the case of a DII, the following should be considered:</span></span>  
  
-   <span data-ttu-id="e9eff-135">Niektóre elementy na liście [dzieci] nie może być obecny.</span><span class="sxs-lookup"><span data-stu-id="e9eff-135">Some items in the [children] list must not be present.</span></span> <span data-ttu-id="e9eff-136">Nie należy polegać na ten fakt, odczytując XML mapowania z formatu JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-136">Do not rely on this fact when reading XML mapped from JSON.</span></span>  
  
-   <span data-ttu-id="e9eff-137">Listy [dzieci] zawiera Brak komentarza elementy informacji.</span><span class="sxs-lookup"><span data-stu-id="e9eff-137">The [children] list holds no comment information items.</span></span>  
  
-   <span data-ttu-id="e9eff-138">Listy [dzieci] przechowuje informacje elementów DTD.</span><span class="sxs-lookup"><span data-stu-id="e9eff-138">The [children] list holds no DTD information items.</span></span>  
  
-   <span data-ttu-id="e9eff-139">Listy [dzieci] nie zawiera żadnych elementów informacji osobistych (PI) ( \<? xml... > Deklaracja nie jest uważany za element informacji PI)</span><span class="sxs-lookup"><span data-stu-id="e9eff-139">The [children] list holds no personal Information (PI) information items (the \<?xml…> declaration is not considered a PI information item)</span></span>  
  
-   <span data-ttu-id="e9eff-140">Zestaw [notacji] jest pusty.</span><span class="sxs-lookup"><span data-stu-id="e9eff-140">The [notations] set is empty.</span></span>  
  
-   <span data-ttu-id="e9eff-141">Zestaw [nieanalizowanych jednostek] jest pusty.</span><span class="sxs-lookup"><span data-stu-id="e9eff-141">The [unparsed entities] set is empty.</span></span>  
  
 <span data-ttu-id="e9eff-142">Przykład: Ten dokument ma nie mapowania na format JSON ponieważ przechowuje [dzieci] PI i komentarz.</span><span class="sxs-lookup"><span data-stu-id="e9eff-142">Example: The following document has no mapping to JSON because [children] holds a PI and a comment.</span></span>  
  
 `<?xml version="1.0"?>`  
  
 `<!--comment--><?pi?>`  
  
 `<root type="number">42</root>`  
  
 <span data-ttu-id="e9eff-143">EII dla elementu JSON głównego ma następującą charakterystykę:</span><span class="sxs-lookup"><span data-stu-id="e9eff-143">The EII for the Root JSON Element has the following characteristics:</span></span>  
  
-   <span data-ttu-id="e9eff-144">[Nazwa lokalnego] ma wartość "root".</span><span class="sxs-lookup"><span data-stu-id="e9eff-144">[local name] has the value "root".</span></span>  
  
-   <span data-ttu-id="e9eff-145">[nazwa przestrzeni nazw] nie ma wartości.</span><span class="sxs-lookup"><span data-stu-id="e9eff-145">[namespace name] has no value.</span></span>  
  
-   <span data-ttu-id="e9eff-146">[prefix] nie ma wartości.</span><span class="sxs-lookup"><span data-stu-id="e9eff-146">[prefix] has no value.</span></span>  
  
-   <span data-ttu-id="e9eff-147">[dzieci] może zawierać EIIs, (które reprezentują elementy wewnętrzne, zgodnie z opisem w dalszej) lub CIIs (znak informacji elementów zgodnie z opisem w dalszej) lub żadna z tych, ale nie oba.</span><span class="sxs-lookup"><span data-stu-id="e9eff-147">[children] may either contain EIIs (which represent Inner Elements as described further) or CIIs (Character Information Items as described further) or none of these, but not both.</span></span>  
  
-   <span data-ttu-id="e9eff-148">[atrybuty] może zawierać następujące elementy informacji opcjonalnego atrybutu (AIIs)</span><span class="sxs-lookup"><span data-stu-id="e9eff-148">[attributes] may contain the following optional attribute information items (AIIs)</span></span>  
  
-   <span data-ttu-id="e9eff-149">Atrybut typu JSON ("type") zgodnie z opisem w dalszej.</span><span class="sxs-lookup"><span data-stu-id="e9eff-149">The JSON Type Attribute ("type") as described further.</span></span> <span data-ttu-id="e9eff-150">Ten atrybut służy do zachowania typu JSON (ciąg, liczba, wartość logiczna, obiektu, tablicy lub wartość null) zamapowanego pliku XML.</span><span class="sxs-lookup"><span data-stu-id="e9eff-150">This attribute is used to preserve the JSON type (string, number, boolean, object, array or null) in the mapped XML.</span></span>  
  
-   <span data-ttu-id="e9eff-151">Kontrakt nazwa atrybutu danych ("__type") zgodnie z opisem w dalszej.</span><span class="sxs-lookup"><span data-stu-id="e9eff-151">The Data Contract Name Attribute ("__type") as described further.</span></span> <span data-ttu-id="e9eff-152">Ten atrybut jest tylko mogą być obecne [znormalizowaną wartość] to "obiekt", jeśli jest również obecny atrybut typu JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-152">This attribute is can only be present if the JSON type attribute is also present and its [normalized value] is "object".</span></span> <span data-ttu-id="e9eff-153">Ten atrybut jest używany przez `DataContractJsonSerializer` zachować kontraktu danych informacji o typie — na przykład w przypadku polimorficznych gdzie typem pochodnym jest serializowana, a oczekiwano typu podstawowego.</span><span class="sxs-lookup"><span data-stu-id="e9eff-153">This attribute is used by the `DataContractJsonSerializer` to preserve data contract type information - for example, in polymorphic cases where a derived type is serialized and where a base type is expected.</span></span> <span data-ttu-id="e9eff-154">Jeśli nie pracujesz z `DataContractJsonSerializer`, w większości przypadków, ten atrybut jest ignorowany.</span><span class="sxs-lookup"><span data-stu-id="e9eff-154">If you are not working with the `DataContractJsonSerializer`, in most cases, this attribute is ignored.</span></span>  
  
-   <span data-ttu-id="e9eff-155">[w zakresie namespaces] zawiera powiązania "xml" do "http://www.w3.org/XML/1998/namespace" nieużywanie przez specyfikację zestaw informacji.</span><span class="sxs-lookup"><span data-stu-id="e9eff-155">[in-scope namespaces] contains the binding of "xml" to "http://www.w3.org/XML/1998/namespace" as mandated by the infoset specification.</span></span>  
  
-   <span data-ttu-id="e9eff-156">[dzieci], [atrybuty] i [w zakresie namespaces] nie może mieć żadnych elementów innych niż określony wcześniej i [atrybuty z przestrzeni nazw] musi mieć żadnych elementów członkowskich, ale nie należy polegać na następujące fakty, podczas odczytywania pliku XML mapowane z formatu JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-156">[children], [attributes] and [in-scope namespaces] must not have any items other than as specified previously and [namespace attributes] must have no members, but do not rely on these facts when reading XML mapped from JSON.</span></span>  
  
 <span data-ttu-id="e9eff-157">Przykład: Ten dokument ma nie mapowania na format JSON ponieważ [atrybuty z przestrzeni nazw] nie jest pusty.</span><span class="sxs-lookup"><span data-stu-id="e9eff-157">Example: The following document has no mapping to JSON because [namespace attributes] is not empty.</span></span>  
  
 `<?xml version="1.0"?>`  
  
 `<root  xmlns:a="myattributevalue">42</root>`  
  
 <span data-ttu-id="e9eff-158">Wszystko dla atrybutu typu JSON ma następującą charakterystykę:</span><span class="sxs-lookup"><span data-stu-id="e9eff-158">The AII for the JSON Type Attribute has the following characteristics:</span></span>  
  
-   <span data-ttu-id="e9eff-159">[nazwa przestrzeni nazw] nie ma wartości.</span><span class="sxs-lookup"><span data-stu-id="e9eff-159">[namespace name] has no value.</span></span>  
  
-   <span data-ttu-id="e9eff-160">[prefix] nie ma wartości.</span><span class="sxs-lookup"><span data-stu-id="e9eff-160">[prefix] has no value.</span></span>  
  
-   <span data-ttu-id="e9eff-161">[Nazwa lokalnego] jest "type".</span><span class="sxs-lookup"><span data-stu-id="e9eff-161">[local name] is "type".</span></span>  
  
-   <span data-ttu-id="e9eff-162">[wartość znormalizowana] to jedna z wartości możliwych typów, opisanych w poniższej sekcji.</span><span class="sxs-lookup"><span data-stu-id="e9eff-162">[normalized value] is one of the possible type values described in the following section.</span></span>  
  
-   <span data-ttu-id="e9eff-163">[] jest `true`.</span><span class="sxs-lookup"><span data-stu-id="e9eff-163">[specified] is `true`.</span></span>  
  
-   <span data-ttu-id="e9eff-164">[atrybutu type] nie ma wartości.</span><span class="sxs-lookup"><span data-stu-id="e9eff-164">[attribute type] has no value.</span></span>  
  
-   <span data-ttu-id="e9eff-165">[odwołania] nie ma wartości.</span><span class="sxs-lookup"><span data-stu-id="e9eff-165">[references] has no value.</span></span>  
  
 <span data-ttu-id="e9eff-166">Wszystko dla atrybutu Name kontraktu danych ma następującą charakterystykę:</span><span class="sxs-lookup"><span data-stu-id="e9eff-166">The AII for the Data Contract Name Attribute has the following characteristics:</span></span>  
  
-   <span data-ttu-id="e9eff-167">[nazwa przestrzeni nazw] nie ma wartości.</span><span class="sxs-lookup"><span data-stu-id="e9eff-167">[namespace name] has no value.</span></span>  
  
-   <span data-ttu-id="e9eff-168">[prefix] nie ma wartości.</span><span class="sxs-lookup"><span data-stu-id="e9eff-168">[prefix] has no value.</span></span>  
  
-   <span data-ttu-id="e9eff-169">[Nazwa lokalnego] jest "__type" (dwóch znaków podkreślenia i następnie "type").</span><span class="sxs-lookup"><span data-stu-id="e9eff-169">[local name] is "__type" (two underscores and then "type").</span></span>  
  
-   <span data-ttu-id="e9eff-170">[wartość znormalizowana] to dowolny prawidłowy ciąg Unicode — mapowanie tego ciągu do ciągu JSON jest opisane w poniższej sekcji.</span><span class="sxs-lookup"><span data-stu-id="e9eff-170">[normalized value] is any valid Unicode string – the mapping of this string to JSON is described in the following section.</span></span>  
  
-   <span data-ttu-id="e9eff-171">[] jest `true`.</span><span class="sxs-lookup"><span data-stu-id="e9eff-171">[specified] is `true`.</span></span>  
  
-   <span data-ttu-id="e9eff-172">[atrybutu type] nie ma wartości.</span><span class="sxs-lookup"><span data-stu-id="e9eff-172">[attribute type] has no value.</span></span>  
  
-   <span data-ttu-id="e9eff-173">[odwołania] nie ma wartości.</span><span class="sxs-lookup"><span data-stu-id="e9eff-173">[references] has no value.</span></span>  
  
 <span data-ttu-id="e9eff-174">Wewnętrzny zawartym w elemencie głównym elementem JSON lub inne elementy wewnętrzny mają następującą charakterystykę:</span><span class="sxs-lookup"><span data-stu-id="e9eff-174">Inner elements contained within the Root JSON Element or other inner elements have the following characteristics:</span></span>  
  
-   <span data-ttu-id="e9eff-175">[Nazwa lokalnego] może mieć dowolną wartość zgodnie z opisem w dalszej</span><span class="sxs-lookup"><span data-stu-id="e9eff-175">[local name] may have any value as described further</span></span>  
  
-   <span data-ttu-id="e9eff-176">[nazwa przestrzeni nazw], [prefix], [dzieci], [atrybuty], [przestrzeń nazw atrybutów], i podlegają one te same reguły jako elementu JSON głównego [w zakresie namespaces].</span><span class="sxs-lookup"><span data-stu-id="e9eff-176">[namespace name], [prefix], [children], [attributes], [namespace attributes], and [in-scope namespaces] are subject to the same rules as the Root JSON Element.</span></span>  
  
 <span data-ttu-id="e9eff-177">W głównym elementem JSON i elementy wewnętrzne atrybut typu JSON definiuje mapowanie na format JSON i możliwe [dzieci] i ich interpretację.</span><span class="sxs-lookup"><span data-stu-id="e9eff-177">In both the Root JSON Element and the inner elements, the JSON Type Attribute defines the mapping to JSON and the possible [children] and their interpretation.</span></span> <span data-ttu-id="e9eff-178">[Wartość znormalizowana] atrybutu jest uwzględniana wielkość liter i musi zawierać tylko litery i nie może zawierać białego.</span><span class="sxs-lookup"><span data-stu-id="e9eff-178">The attribute’s [normalized value] is case-sensitive and must be lowercase, and cannot contain white space.</span></span>  
  
|<span data-ttu-id="e9eff-179">[znormalizowane wartości] z `JSON Type Attribute`firmy wszystko</span><span class="sxs-lookup"><span data-stu-id="e9eff-179">[normalized value] of `JSON Type Attribute`’s AII</span></span>|<span data-ttu-id="e9eff-180">Dozwolone [] elementów podrzędnych odpowiedniego EII</span><span class="sxs-lookup"><span data-stu-id="e9eff-180">Allowed [children] of the corresponding EII</span></span>|<span data-ttu-id="e9eff-181">Mapowanie do formatu JSON</span><span class="sxs-lookup"><span data-stu-id="e9eff-181">Mapping to JSON</span></span>|  
|---------------------------------------------------------|---------------------------------------------------|---------------------|  
|<span data-ttu-id="e9eff-182">`string` (lub Brak typu JSON wszystko)</span><span class="sxs-lookup"><span data-stu-id="e9eff-182">`string` (or absence of the JSON type AII)</span></span><br /><br /> <span data-ttu-id="e9eff-183">A `string` i braku typu JSON wszystko to sprawia, że ten sam `string` domyślnie.</span><span class="sxs-lookup"><span data-stu-id="e9eff-183">A `string` and the absence of the JSON type AII are the same makes `string` the default.</span></span><br /><br /> <span data-ttu-id="e9eff-184">Dlatego `<root> string1</root>` mapuje dane JSON `string` "ciąg1".</span><span class="sxs-lookup"><span data-stu-id="e9eff-184">So, `<root> string1</root>` maps to the JSON `string` "string1".</span></span>|<span data-ttu-id="e9eff-185">0 lub więcej CIIs</span><span class="sxs-lookup"><span data-stu-id="e9eff-185">0 or more CIIs</span></span>|<span data-ttu-id="e9eff-186">JSON `string` (RFC JSON sekcję 2.5).</span><span class="sxs-lookup"><span data-stu-id="e9eff-186">A JSON `string` (JSON RFC, section 2.5).</span></span> <span data-ttu-id="e9eff-187">Każdy `char` jest znak, który odnosi się do [kod znaku] z CII.</span><span class="sxs-lookup"><span data-stu-id="e9eff-187">Each `char` is a character that corresponds to the [character code] from the CII.</span></span> <span data-ttu-id="e9eff-188">W przypadku CIIs nie jest on mapowany pusty kod JSON `string`.</span><span class="sxs-lookup"><span data-stu-id="e9eff-188">If there are no CIIs, it maps to an empty JSON `string`.</span></span><br /><br /> <span data-ttu-id="e9eff-189">Przykład: Następujący element mapuje fragment kodu JSON:</span><span class="sxs-lookup"><span data-stu-id="e9eff-189">Example: The following element maps to a JSON fragment:</span></span><br /><br /> `<root type="string">42</root>`<br /><br /> <span data-ttu-id="e9eff-190">Fragment kodu JSON to "42".</span><span class="sxs-lookup"><span data-stu-id="e9eff-190">The JSON fragment is "42".</span></span><br /><br /> <span data-ttu-id="e9eff-191">W pliku XML do JSON mapowania znaków, które muszą być poprzedzone znakiem zmiany znaczenia mapy na znaki ucieczki przestają być, mapowania wszystkie inne znaki, które nie miały zmienione znaczenie.</span><span class="sxs-lookup"><span data-stu-id="e9eff-191">On XML to JSON mapping, characters that must be escaped map to escaped characters, all others map to characters that are not escaped.</span></span> <span data-ttu-id="e9eff-192">Znak "/" jest szczególna — została zmieniona, mimo że nie musi on być (pisemne się jako "\\/").</span><span class="sxs-lookup"><span data-stu-id="e9eff-192">The "/" character is special – it is escaped even though it does not have to be (written out as "\\/").</span></span><br /><br /> <span data-ttu-id="e9eff-193">Przykład: Następujący element mapuje fragment kodu JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-193">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="string">the "da/ta"</root>`<br /><br /> <span data-ttu-id="e9eff-194">Fragment kodu JSON to " \\" da\\/ta\\"".</span><span class="sxs-lookup"><span data-stu-id="e9eff-194">The JSON fragment is "the \\"da\\/ta\\"".</span></span><br /><br /> <span data-ttu-id="e9eff-195">W formacie JSON do pliku XML wszelkie znaki ucieczki przestają być i znaków, które nie są poprzedzone znakiem zmiany znaczenia mapy poprawnie do odpowiedniego [kod znaku].</span><span class="sxs-lookup"><span data-stu-id="e9eff-195">On JSON to XML mapping, any escaped characters and characters that are not escaped map correctly to the corresponding [character code].</span></span><br /><br /> <span data-ttu-id="e9eff-196">Przykład: Fragment kodu JSON "\u0041BC" mapuje do następujących elementów XML.</span><span class="sxs-lookup"><span data-stu-id="e9eff-196">Example: The JSON fragment "\u0041BC", maps to the following XML element.</span></span><br /><br /> `<root type="string">ABC</root>`<br /><br /> <span data-ttu-id="e9eff-197">Ciąg może być otoczona biały ("ws" w sekcji 2 JSON RFC), które nie są mapowane do pliku XML.</span><span class="sxs-lookup"><span data-stu-id="e9eff-197">The string can be surrounded by white space ('ws' in section 2 of the JSON RFC) that does not get mapped to XML.</span></span><br /><br /> <span data-ttu-id="e9eff-198">Przykład: Za pomocą pliku JSON fragmentu "ABC", (ma spacji przed pierwszym podwójnego cudzysłowu), mapuje do następujących elementów XML.</span><span class="sxs-lookup"><span data-stu-id="e9eff-198">Example: The JSON fragment           "ABC", (there are spaces before the first double quote), maps to the following XML element.</span></span><br /><br /> `<root type="string">ABC</root>`<br /><br /> <span data-ttu-id="e9eff-199">Dowolny biały obszar w pliku XML jest mapowany na biały znak w formacie JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-199">Any white space in XML maps to white space in JSON.</span></span><br /><br /> <span data-ttu-id="e9eff-200">Przykład: Następujący element XML mapuje fragment kodu JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-200">Example: The following XML element maps to a JSON fragment.</span></span><br /><br /> `<root type="string">  A BC      </root>`<br /><br /> <span data-ttu-id="e9eff-201">Fragment kodu JSON to "BC".</span><span class="sxs-lookup"><span data-stu-id="e9eff-201">The JSON fragment is " A BC ".</span></span>|  
|`number`|<span data-ttu-id="e9eff-202">co najmniej 1 CIIs</span><span class="sxs-lookup"><span data-stu-id="e9eff-202">1 or more CIIs</span></span>|<span data-ttu-id="e9eff-203">JSON `number` (RFC JSON, sekcji 2.4), prawdopodobnie otoczony biały znak.</span><span class="sxs-lookup"><span data-stu-id="e9eff-203">A JSON `number` (JSON RFC, section 2.4), possibly surrounded by white space.</span></span> <span data-ttu-id="e9eff-204">Każdy znak w połączeniu numer/biały znak jest znakiem, który odnosi się do [kod znaku] z CII.</span><span class="sxs-lookup"><span data-stu-id="e9eff-204">Each character in the number/white space combination is a character that corresponds to the [character code] from the CII.</span></span><br /><br /> <span data-ttu-id="e9eff-205">Przykład: Następujący element mapuje fragment kodu JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-205">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="number">    42</root>`<br /><br /> <span data-ttu-id="e9eff-206">Fragment kodu JSON jest 42</span><span class="sxs-lookup"><span data-stu-id="e9eff-206">The JSON fragment is    42</span></span><br /><br /> <span data-ttu-id="e9eff-207">(Biały znak jest zachowane).</span><span class="sxs-lookup"><span data-stu-id="e9eff-207">(White space is preserved).</span></span>|  
|`boolean`|<span data-ttu-id="e9eff-208">CIIs 4 lub 5 (co odpowiada `true` lub `false`), prawdopodobnie otoczone dodatkowe CIIs odstępu.</span><span class="sxs-lookup"><span data-stu-id="e9eff-208">4 or 5 CIIs (which corresponds to `true` or `false`), possibly surrounded by additional white-space CIIs.</span></span>|<span data-ttu-id="e9eff-209">Sekwencję CII, która odnosi się do ciągu "true" jest mapowana na literału `true`, i sekwencji CII, który odpowiada ciągowi "false" jest mapowany do literału `false`.</span><span class="sxs-lookup"><span data-stu-id="e9eff-209">A CII sequence that corresponds to the string "true" is mapped to the literal `true`, and a CII sequence that corresponds to the string "false" is mapped to the literal `false`.</span></span> <span data-ttu-id="e9eff-210">Otaczającego biały znak są zachowywane.</span><span class="sxs-lookup"><span data-stu-id="e9eff-210">Surrounding white space is preserved.</span></span><br /><br /> <span data-ttu-id="e9eff-211">Przykład: Następujący element mapuje fragment kodu JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-211">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="boolean"> false</root>`<br /><br /> <span data-ttu-id="e9eff-212">Fragment kodu JSON jest `false`.</span><span class="sxs-lookup"><span data-stu-id="e9eff-212">The JSON fragment is `false`.</span></span>|  
|`null`|<span data-ttu-id="e9eff-213">Zezwalaj na Brak.</span><span class="sxs-lookup"><span data-stu-id="e9eff-213">None allowed.</span></span>|<span data-ttu-id="e9eff-214">Literał `null`.</span><span class="sxs-lookup"><span data-stu-id="e9eff-214">The literal `null`.</span></span> <span data-ttu-id="e9eff-215">Na ciąg JSON do mapowania XML `null` otoczony biały ("ws" w sekcji 2), które nie są mapowane do pliku XML.</span><span class="sxs-lookup"><span data-stu-id="e9eff-215">On JSON to XML mapping, the `null` may be surrounded by white space (‘ws’ in section 2) that does not get mapped to XML.</span></span><br /><br /> <span data-ttu-id="e9eff-216">Przykład: Następujący element mapuje fragment kodu JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-216">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="null"/>`<br /><br /> <span data-ttu-id="e9eff-217">lub</span><span class="sxs-lookup"><span data-stu-id="e9eff-217">or</span></span><br /><br /> `<root type="null"></root>`<br /><br /> <span data-ttu-id="e9eff-218">:</span><span class="sxs-lookup"><span data-stu-id="e9eff-218">:</span></span><br /><br /> <span data-ttu-id="e9eff-219">Fragment kodu JSON w obu przypadkach jest `Null`.</span><span class="sxs-lookup"><span data-stu-id="e9eff-219">The JSON fragment in both cases is `Null`.</span></span>|  
|`object`|<span data-ttu-id="e9eff-220">0 lub więcej EIIs.</span><span class="sxs-lookup"><span data-stu-id="e9eff-220">0 or more EIIs.</span></span>|<span data-ttu-id="e9eff-221">Element `begin-object` (od lewej nawias klamrowy) tak jak w sekcji 2.2 JSON RFC, a następnie rekord elementu członkowskiego dla każdego EII zgodnie z opisem w dalszej.</span><span class="sxs-lookup"><span data-stu-id="e9eff-221">A `begin-object` (left curly brace) as in section 2.2 of the JSON RFC, followed by a member record for each EII as described further.</span></span> <span data-ttu-id="e9eff-222">W przypadku więcej niż jeden EII między rekordów elementów członkowskich są wartości separatorów (przecinkami).</span><span class="sxs-lookup"><span data-stu-id="e9eff-222">If there is more than one EII, there are value-separators (commas) between the member records.</span></span> <span data-ttu-id="e9eff-223">To wszystko następuje koniec — obiekt (prawy nawias klamrowy).</span><span class="sxs-lookup"><span data-stu-id="e9eff-223">All this is followed by an end-object (right curly brace).</span></span><br /><br /> <span data-ttu-id="e9eff-224">Przykład: Następujący element mapuje fragment kodu JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-224">Example: The following element maps to the JSON fragment.</span></span><br /><br /> <span data-ttu-id="e9eff-225">\<główny typ = "obiekt" ></span><span class="sxs-lookup"><span data-stu-id="e9eff-225">\<root type="object"></span></span><br /><br /> <span data-ttu-id="e9eff-226">\<Typ type1 = "string" > aaa\</type1 ></span><span class="sxs-lookup"><span data-stu-id="e9eff-226">\<type1 type="string">aaa\</type1></span></span><br /><br /> <span data-ttu-id="e9eff-227">\<Typ type2 = "string" > bbb\</type2 ></span><span class="sxs-lookup"><span data-stu-id="e9eff-227">\<type2 type="string">bbb\</type2></span></span><br /><br /> <span data-ttu-id="e9eff-228">\</ root ></span><span class="sxs-lookup"><span data-stu-id="e9eff-228">\</root ></span></span><br /><br /> <span data-ttu-id="e9eff-229">Fragment kodu JSON jest {"type1": "aaa", "type2": "bbb"}.</span><span class="sxs-lookup"><span data-stu-id="e9eff-229">The JSON fragment is {"type1":"aaa","type2":"bbb"}.</span></span><br /><br /> <span data-ttu-id="e9eff-230">Jeśli atrybut typu kontraktu danych ma na języku XML do mapowania JSON, dodatkowy rekord elementu członkowskiego jest wstawiany na początku.</span><span class="sxs-lookup"><span data-stu-id="e9eff-230">If the Data Contract Type Attribute is present on XML to JSON mapping, then an additional Member Record is inserted at the beginning.</span></span> <span data-ttu-id="e9eff-231">Jego nazwa jest [Nazwa lokalnego] atrybutu typu kontraktu danych ("__type"), a jego wartość to [wartość znormalizowana] atrybutu.</span><span class="sxs-lookup"><span data-stu-id="e9eff-231">Its name is the [local name] of the Data Contract Type Attribute ("__type"), and its value is the attribute's [normalized value].</span></span> <span data-ttu-id="e9eff-232">Z drugiej strony, w formacie JSON do pliku XML, jeśli nazwa pierwszego elementu członkowskiego rekordu jest [Nazwa lokalnego] atrybutu typu kontraktu danych (czyli "\__typ"), odpowiedni atrybut typu kontraktu danych znajduje się w mapowanych XML, ale nie jest odpowiedni EII obecne.</span><span class="sxs-lookup"><span data-stu-id="e9eff-232">Conversely, on JSON to XML mapping, if the first member-record’s name is the [local name] of the Data Contract Type Attribute (that is, "\__type"), a corresponding Data Contract Type Attribute is present in the mapped XML, but a corresponding EII is not present.</span></span> <span data-ttu-id="e9eff-233">Należy pamiętać, że ten rekord elementu członkowskiego musi wystąpić najpierw w obiekcie JSON dla tego mapowania specjalne do zastosowania.</span><span class="sxs-lookup"><span data-stu-id="e9eff-233">Note that this member record must occur first in the JSON object for this special mapping to apply.</span></span> <span data-ttu-id="e9eff-234">To oznacza odejście od zwykle przetwarzania JSON, w którym kolejność rekordów elementów członkowskich nie jest znaczący.</span><span class="sxs-lookup"><span data-stu-id="e9eff-234">This represents a departure from usual JSON processing, where the order of member records is not significant.</span></span><br /><br /> <span data-ttu-id="e9eff-235">Przykład:</span><span class="sxs-lookup"><span data-stu-id="e9eff-235">Example:</span></span><br /><br /> <span data-ttu-id="e9eff-236">Poniższy fragment kodu JSON mapowany do pliku XML.</span><span class="sxs-lookup"><span data-stu-id="e9eff-236">The following JSON fragment maps to XML.</span></span><br /><br /> `{"__type":"Person","name":"John"}`<br /><br /> <span data-ttu-id="e9eff-237">Kod XML ma następujący kod.</span><span class="sxs-lookup"><span data-stu-id="e9eff-237">The XML is the following code.</span></span><br /><br /> `<root type="object" __type="Person">   <name type="string">John</name> </root>`<br /><br /> <span data-ttu-id="e9eff-238">Należy zauważyć, że \__typ wszystko jest obecny, ale ma nie \__typ EII.</span><span class="sxs-lookup"><span data-stu-id="e9eff-238">Notice that the \__type AII is present, but there is no \__type EII.</span></span><br /><br /> <span data-ttu-id="e9eff-239">Jednak jeśli kolejność, w formacie JSON zostanie odwrócony jako pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="e9eff-239">However, if the order in the JSON is reversed as shown in the following example.</span></span><br /><br /> <span data-ttu-id="e9eff-240">{"name": "John","\__typ": "Person"}</span><span class="sxs-lookup"><span data-stu-id="e9eff-240">{"name":"John","\__type":"Person"}</span></span><br /><br /> <span data-ttu-id="e9eff-241">Odpowiedni kod XML jest wyświetlany.</span><span class="sxs-lookup"><span data-stu-id="e9eff-241">The corresponding XML is shown.</span></span><br /><br /> `<root type="object">   <name type="string">John</name>   <__type type="string">Person</__type> </root>`<br /><br /> <span data-ttu-id="e9eff-242">Oznacza to, że \__typ przestaje w zwykły sposób, mają specjalne znaczenie i mapuje do EII nie wszystko.</span><span class="sxs-lookup"><span data-stu-id="e9eff-242">That is, \__type ceases to have special meaning and maps to an EII as usual, not AII.</span></span><br /><br /> <span data-ttu-id="e9eff-243">Anulowanie unescaping zasady wszystko [Znormalizowana wartość] mapowane na wartości JSON są takie same jak dla ciągów JSON, określone w wierszu "string" w tej tabeli.</span><span class="sxs-lookup"><span data-stu-id="e9eff-243">Escaping/unescaping rules for the AII’s [normalized value] when mapped to a JSON value are the same as for JSON strings, specified in the "string" row of this table.</span></span><br /><br /> <span data-ttu-id="e9eff-244">Przykład:</span><span class="sxs-lookup"><span data-stu-id="e9eff-244">Example:</span></span><br /><br /> `<root type="object" __type="\abc" />`<br /><br /> <span data-ttu-id="e9eff-245">do poprzedniego przykładu można zamapować następujące dane JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-245">to the previous example can be mapped to the following JSON.</span></span><br /><br /> `{"__type":"\\abc"}`<br /><br /> <span data-ttu-id="e9eff-246">W pliku XML do mapowania JSON, nie może być pierwszym EII firmy [Nazwa lokalnego] "\__typ".</span><span class="sxs-lookup"><span data-stu-id="e9eff-246">On an XML to JSON mapping, the first EII’s [local name] must not be "\__type".</span></span><br /><br /> <span data-ttu-id="e9eff-247">Biały znak (`ws`) nigdy nie jest generowany na języku XML do mapowania JSON dla obiektów i jest ignorowany w formacie JSON do pliku XML.</span><span class="sxs-lookup"><span data-stu-id="e9eff-247">White space (`ws`) is never generated on XML to JSON mapping for objects and is ignored on JSON to XML mapping.</span></span><br /><br /> <span data-ttu-id="e9eff-248">Przykład: Poniższy fragment kodu JSON mapowany na XML element.</span><span class="sxs-lookup"><span data-stu-id="e9eff-248">Example: The following JSON fragment maps to an XML element.</span></span><br /><br /> <span data-ttu-id="e9eff-249">{"DW": "aaa", "ddd": "bbb"}</span><span class="sxs-lookup"><span data-stu-id="e9eff-249">{   "ccc"   :  "aaa",   "ddd"    :"bbb"}</span></span><br /><br /> <span data-ttu-id="e9eff-250">XML element przedstawiono w poniższym kodzie.</span><span class="sxs-lookup"><span data-stu-id="e9eff-250">The XML element is shown in the following code.</span></span><br /><br /> `<root type="object">    <ccc type="string">aaa</ccc>    <ddd type="string">bbb</bar> </root >`|  
<span data-ttu-id="e9eff-251">Ray "</span><span class="sxs-lookup"><span data-stu-id="e9eff-251">ray\`</span></span>|<span data-ttu-id="e9eff-252">0 lub więcej EIIs</span><span class="sxs-lookup"><span data-stu-id="e9eff-252">0 or more EIIs</span></span>|<span data-ttu-id="e9eff-253">Begin — tablica (lewy nawias kwadratowy) tak jak w sekcji 2.3 JSON RFC, następuje rekord tablicy do każdego EII zgodnie z opisem w dalszej.</span><span class="sxs-lookup"><span data-stu-id="e9eff-253">A begin-array (left square bracket) as in section 2.3 of the JSON RFC, followed by an array record for each EII as described further.</span></span> <span data-ttu-id="e9eff-254">Jeśli istnieje więcej niż jeden EII, istnieją wartości separatorów (przecinkami) między rekordami tablicy.</span><span class="sxs-lookup"><span data-stu-id="e9eff-254">If there is more than one EII, there are value-separators (commas) between the array records.</span></span> <span data-ttu-id="e9eff-255">Następuje to tablica zakończenia.</span><span class="sxs-lookup"><span data-stu-id="e9eff-255">All this is followed by an end-array.</span></span><br /><br /> <span data-ttu-id="e9eff-256">Przykład: Następujący element XML mapuje fragment kodu JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-256">Example: The following XML element maps to a JSON fragment.</span></span><br /><br /> `<root type="array"/>    <item type="string">aaa</item>    <item type="string">bbb</item> </root >`<br /><br /> <span data-ttu-id="e9eff-257">Fragment kodu JSON to ["aaa", "bbb"]</span><span class="sxs-lookup"><span data-stu-id="e9eff-257">The JSON fragment is ["aaa","bbb"]</span></span><br /><br /> <span data-ttu-id="e9eff-258">Biały znak (`ws`) nigdy nie jest generowany na języku XML do mapowania JSON dla tablic i jest ignorowany w formacie JSON do pliku XML.</span><span class="sxs-lookup"><span data-stu-id="e9eff-258">White space (`ws`) is never generated on XML to JSON mapping for arrays and is ignored on JSON to XML mapping.</span></span><br /><br /> <span data-ttu-id="e9eff-259">Przykład: AJSON fragmentu.</span><span class="sxs-lookup"><span data-stu-id="e9eff-259">Example: AJSON fragment.</span></span><br /><br /> <span data-ttu-id="e9eff-260">["aaa", "bbb"]</span><span class="sxs-lookup"><span data-stu-id="e9eff-260">[     "aaa",     "bbb"]</span></span><br /><br /> <span data-ttu-id="e9eff-261">Element XML, który jest on mapowany.</span><span class="sxs-lookup"><span data-stu-id="e9eff-261">The XML element that it maps to.</span></span><br /><br /> `<root type="array"/>    <item type="string">aaa</item>    <item type="string">bbb</item> </root >`|  
  
 <span data-ttu-id="e9eff-262">Rekordy elementów roboczych w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="e9eff-262">Member Records work as follows:</span></span>  
  
-   <span data-ttu-id="e9eff-263">Mapuje element wewnętrzny firmy [Nazwa lokalnego] `string` wchodzi w skład `member` zgodnie z definicją w sekcji 2.2 JSON RFC.</span><span class="sxs-lookup"><span data-stu-id="e9eff-263">Inner element’s [local name] maps to the `string` part of the `member` as defined in section 2.2 of the JSON RFC.</span></span>  
  
 <span data-ttu-id="e9eff-264">Przykład: Następujący element mapuje fragment kodu JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-264">Example: The following element maps to a JSON fragment.</span></span>  
  
 `<root type="object"/>`  
  
 `<myLocalName type="string">aaa</myLocalName>`  
  
 `</root >`  
  
 <span data-ttu-id="e9eff-265">Poniższy fragment kodu JSON jest wyświetlana.</span><span class="sxs-lookup"><span data-stu-id="e9eff-265">The following JSON fragment is displayed.</span></span>  
  
 `{"myLocalName":"aaa"}`  
  
-   <span data-ttu-id="e9eff-266">Na XML do mapowania JSON będą miały zmienione znaczenie znaków, które muszą być wyjściowym w formacie JSON, a pozostałe są nie zawiera wyjścia.</span><span class="sxs-lookup"><span data-stu-id="e9eff-266">On the XML to JSON mapping, the characters that must be escaped in JSON are escaped, and the others are not escaped.</span></span> <span data-ttu-id="e9eff-267">Znak "/", mimo że nie jest znakiem, który musi być poprzedzone znakiem zmiany znaczenia, jest poprzedzone znakiem zmiany znaczenia mimo wszystko (nie musi być poprzedzone znakiem zmiany znaczenia w formacie JSON do pliku XML).</span><span class="sxs-lookup"><span data-stu-id="e9eff-267">The "/" character, even though it is not a character that must be escaped, is escaped nevertheless (it does not have to be escaped on JSON to XML mapping).</span></span> <span data-ttu-id="e9eff-268">Jest to wymagane do obsługi formatu ASP.NET AJAX `DateTime` dane w formacie JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-268">This is required to support the ASP.NET AJAX format for `DateTime` data in JSON.</span></span>  
  
-   <span data-ttu-id="e9eff-269">W formacie JSON do pliku XML, wszystkie znaki (w tym znaki ucieczki nie, jeśli to konieczne) są pobierane do formularza `string` daje [Nazwa lokalnej].</span><span class="sxs-lookup"><span data-stu-id="e9eff-269">On the JSON to XML mapping, all characters (including the not escaped characters, if necessary) are taken to form a `string` that produces a [local name].</span></span>  
  
-   <span data-ttu-id="e9eff-270">Elementy wewnętrzne [dzieci] mapy do wartości w sekcji 2.2, zgodnie z opisem w `JSON Type Attribute` podobnie jak w przypadku dla `Root JSON Element`.</span><span class="sxs-lookup"><span data-stu-id="e9eff-270">Inner elements [children] map to the value in section 2.2, according to the `JSON Type Attribute` just like for the `Root JSON Element`.</span></span> <span data-ttu-id="e9eff-271">Wiele poziomów zagnieżdżenia EIIs (w tym zagnieżdżenia w macierzy) są dozwolone.</span><span class="sxs-lookup"><span data-stu-id="e9eff-271">Multiple levels of nesting of EIIs (including nesting within arrays) are allowed.</span></span>  
  
 <span data-ttu-id="e9eff-272">Przykład: Następujący element mapuje fragment kodu JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-272">Example: The following element maps to a JSON fragment.</span></span>  
  
 `<root type="object">`  
  
 `<myLocalName1 type="string">myValue1</myLocalName1>`  
  
 `<myLocalName2 type="number">2</myLocalName2>`  
  
 `<myLocalName3 type="object">`  
  
 `<myNestedName1 type="boolean">true</myNestedName1>`  
  
 `<myNestedName2 type="null"/>`  
  
 `</myLocalName3>`  
  
 `</root >`  
  
 <span data-ttu-id="e9eff-273">Poniższy fragment kodu JSON to, co to jest on mapowany.</span><span class="sxs-lookup"><span data-stu-id="e9eff-273">The following JSON fragment is what it maps to.</span></span>  
  
 `{"myLocalName1":"myValue1","myLocalName2":2,"myLocalName3":{"myNestedName1":true,"myNestedName2":null}}`  
  
> [!NOTE]
>  <span data-ttu-id="e9eff-274">W poprzednim mapowanie jest bez kroku kodowania XML.</span><span class="sxs-lookup"><span data-stu-id="e9eff-274">There is no XML encoding step in the preceding mapping.</span></span> <span data-ttu-id="e9eff-275">W związku z tym usługi WCF obsługuje tylko dokumenty JSON, w którym wszystkie znaki nazwy kluczy są prawidłowych znaków w nazwach elementów XML.</span><span class="sxs-lookup"><span data-stu-id="e9eff-275">Therefore, WCF only supports JSON documents where all characters in key names are valid characters in XML element names.</span></span> <span data-ttu-id="e9eff-276">Na przykład dokument JSON {"<": ""} nie jest obsługiwana, ponieważ < nie jest prawidłową nazwą elementu XML.</span><span class="sxs-lookup"><span data-stu-id="e9eff-276">For example, the JSON document {"<":"a"} is not supported because < is not a valid name for an XML element.</span></span>  
  
 <span data-ttu-id="e9eff-277">Sytuacja odwrotna (znaki dozwolone w XML, ale nie w formacie JSON) nie powoduje żadnych problemów, ponieważ mapowanie poprzedniego zawiera kroki anulowania zapewnianego element unescaping JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-277">The reverse situation (characters valid in XML but not in JSON) does not cause any problems because the preceding mapping includes JSON escaping/unescaping steps.</span></span>  
  
 <span data-ttu-id="e9eff-278">Rekordy tablicy pracować w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="e9eff-278">Array Records work as follows:</span></span>  
  
-   <span data-ttu-id="e9eff-279">Wewnętrzny elementu [Nazwa lokalnego] jest "elementu".</span><span class="sxs-lookup"><span data-stu-id="e9eff-279">Inner element’s [local name] is "item".</span></span>  
  
-   <span data-ttu-id="e9eff-280">Wewnętrzny elementu [dzieci] mapy do wartości w sekcji 2.3, zgodnie z atrybutu typu JSON to dla elementu głównego w formacie JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-280">Inner element’s [children] map to the value in section 2.3, according to the JSON Type Attribute as is does for the Root JSON Element.</span></span> <span data-ttu-id="e9eff-281">Wiele poziomów zagnieżdżenia EIIs (w tym zagnieżdżenia w obiektach) są dozwolone.</span><span class="sxs-lookup"><span data-stu-id="e9eff-281">Multiple levels of nesting of EIIs (including nesting within objects) are allowed.</span></span>  
  
 <span data-ttu-id="e9eff-282">Przykład: Następujący element mapuje fragment kodu JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-282">Example: The following element maps to a JSON fragment.</span></span>  
  
 `<root type="array"/>`  
  
 `<item type="string">myValue1</item>`  
  
 `<item type="number">2</item>`  
  
 `<item type="array">`  
  
 `<item type="boolean">true</item>`  
  
 `<item type="null"/>`  
  
 `</item>`  
  
 `</root >`  
  
 <span data-ttu-id="e9eff-283">Poniżej znajduje się fragment kodu JSON.</span><span class="sxs-lookup"><span data-stu-id="e9eff-283">The following is the JSON fragment.</span></span>  
  
 `["myValue1",2,[true,null]]`  
  
## <a name="see-also"></a><span data-ttu-id="e9eff-284">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="e9eff-284">See Also</span></span>  
 <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory>  
 <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>  
 [<span data-ttu-id="e9eff-285">Autonomiczna serializacja kodu JSON</span><span class="sxs-lookup"><span data-stu-id="e9eff-285">Stand-Alone JSON Serialization</span></span>](../../../../docs/framework/wcf/feature-details/stand-alone-json-serialization.md)
