---
title: Typy kolekcji w kontraktach danych
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- collection types [WCF], data contracts
- data contracts [WCF], collection types
- collection types [WCF]
ms.assetid: 9b45b28e-0a82-4ea3-8c33-ec0094aff9d5
ms.openlocfilehash: a10b7c5295407cfbb36446581a4b75670e37bc6a
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 06/09/2020
ms.locfileid: "84579752"
---
# <a name="collection-types-in-data-contracts"></a><span data-ttu-id="89a16-102">Typy kolekcji w kontraktach danych</span><span class="sxs-lookup"><span data-stu-id="89a16-102">Collection Types in Data Contracts</span></span>

<span data-ttu-id="89a16-103">*Kolekcja* jest listą elementów określonego typu.</span><span class="sxs-lookup"><span data-stu-id="89a16-103">A *collection* is a list of items of a certain type.</span></span> <span data-ttu-id="89a16-104">W .NET Framework takie listy mogą być reprezentowane przy użyciu tablic lub różnych typów (lista ogólna, ogólna <xref:System.ComponentModel.BindingList%601> , <xref:System.Collections.Specialized.StringCollection> lub <xref:System.Collections.ArrayList> ).</span><span class="sxs-lookup"><span data-stu-id="89a16-104">In the .NET Framework, such lists can be represented using arrays or a variety of other types (Generic List, Generic <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>, or <xref:System.Collections.ArrayList>).</span></span> <span data-ttu-id="89a16-105">Na przykład kolekcja może zawierać listę adresów dla danego klienta.</span><span class="sxs-lookup"><span data-stu-id="89a16-105">For example, a collection may hold a list of Addresses for a given Customer.</span></span> <span data-ttu-id="89a16-106">Kolekcje te są nazywane *kolekcjami list*, niezależnie od ich rzeczywistego typu.</span><span class="sxs-lookup"><span data-stu-id="89a16-106">These collections are called *list collections*, regardless of their actual type.</span></span>

<span data-ttu-id="89a16-107">Istnieje specjalna forma kolekcji, która reprezentuje skojarzenie między jednym elementem ("kluczem") a drugim ("value").</span><span class="sxs-lookup"><span data-stu-id="89a16-107">A special form of collection exists that represents an association between one item (the "key") and another (the "value").</span></span> <span data-ttu-id="89a16-108">W .NET Framework są one reprezentowane przez typy takie jak <xref:System.Collections.Hashtable> i słownik ogólny.</span><span class="sxs-lookup"><span data-stu-id="89a16-108">In the .NET Framework, these are represented by types such as <xref:System.Collections.Hashtable> and the generic dictionary.</span></span> <span data-ttu-id="89a16-109">Na przykład kolekcja skojarzeń może mapować miasto ("klucz") na jego populację ("wartość").</span><span class="sxs-lookup"><span data-stu-id="89a16-109">For example, an association collection may map a city ("key") to its population ("value").</span></span> <span data-ttu-id="89a16-110">Kolekcje te są nazywane *kolekcjami słownikowymi*, niezależnie od ich rzeczywistego typu.</span><span class="sxs-lookup"><span data-stu-id="89a16-110">These collections are called *dictionary collections*, regardless of their actual type.</span></span>

<span data-ttu-id="89a16-111">Kolekcje otrzymują specjalne traktowanie w modelu kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="89a16-111">Collections receive special treatment in the data contract model.</span></span>

<span data-ttu-id="89a16-112">Typy implementujące <xref:System.Collections.IEnumerable> interfejs, łącznie z tablicami i kolekcjami ogólnymi, są rozpoznawane jako kolekcje.</span><span class="sxs-lookup"><span data-stu-id="89a16-112">Types that implement the <xref:System.Collections.IEnumerable> interface, including arrays and generic collections, are recognized as collections.</span></span> <span data-ttu-id="89a16-113">Z tych typów, które implementują <xref:System.Collections.IDictionary> interfejsy lub, <xref:System.Collections.Generic.IDictionary%602> są kolekcjami słownikowymi; wszystkie inne są kolekcjami list.</span><span class="sxs-lookup"><span data-stu-id="89a16-113">Of those, types that implement the <xref:System.Collections.IDictionary> or Generic <xref:System.Collections.Generic.IDictionary%602> interfaces are dictionary collections; all others are list collections.</span></span>

<span data-ttu-id="89a16-114">Dodatkowe wymagania dotyczące typów kolekcji, takich jak posiadanie metody `Add` i Konstruktor bez parametrów, zostały szczegółowo omówione w poniższych sekcjach.</span><span class="sxs-lookup"><span data-stu-id="89a16-114">Additional requirements on collection types, such as having a method called `Add` and a parameterless constructor, are discussed in detail in the following sections.</span></span> <span data-ttu-id="89a16-115">Gwarantuje to, że typy kolekcji mogą być serializowane i deserializowane.</span><span class="sxs-lookup"><span data-stu-id="89a16-115">This ensures that collection types can be both serialized and deserialized.</span></span> <span data-ttu-id="89a16-116">Oznacza to, że niektóre kolekcje nie są bezpośrednio obsługiwane, takie jak generyczne <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (ponieważ nie ma konstruktora bez parametrów).</span><span class="sxs-lookup"><span data-stu-id="89a16-116">This means that some collections are not directly supported, such as the Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (because it has no parameterless constructor).</span></span> <span data-ttu-id="89a16-117">Jednak aby uzyskać informacje o obchodzeniu tych ograniczeń, zobacz sekcję "używanie typów interfejsów kolekcji i kolekcji tylko do odczytu" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="89a16-117">However, for information about circumventing these restrictions, see the section "Using Collection Interface Types and Read-Only Collections" later in this topic.</span></span>

<span data-ttu-id="89a16-118">Typy zawarte w kolekcjach muszą być typami kontraktu danych lub mogą być serializowane w inny sposób.</span><span class="sxs-lookup"><span data-stu-id="89a16-118">The types contained in collections must be data contract types, or be otherwise serializable.</span></span> <span data-ttu-id="89a16-119">Aby uzyskać więcej informacji, zobacz [Typy obsługiwane przez serializator kontraktu danych](types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="89a16-119">For more information, see [Types Supported by the Data Contract Serializer](types-supported-by-the-data-contract-serializer.md).</span></span>

<span data-ttu-id="89a16-120">Aby uzyskać więcej informacji o tym, co to jest i co nie jest traktowane jako prawidłowa kolekcja, a także o sposobie serializacji kolekcji, zobacz informacje na temat serializacji kolekcji w sekcji "Zaawansowane reguły kolekcji" w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="89a16-120">For more information about what is and what is not considered a valid collection, as well as about how collections are serialized, see the information about serializing collections in the "Advanced Collection Rules" section of this topic.</span></span>

## <a name="interchangeable-collections"></a><span data-ttu-id="89a16-121">Kolekcje wymienne</span><span class="sxs-lookup"><span data-stu-id="89a16-121">Interchangeable Collections</span></span>

<span data-ttu-id="89a16-122">Wszystkie kolekcje list tego samego typu są uznawane za mające ten sam kontrakt danych (chyba że są dostosowane przy użyciu <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu, jak opisano w dalszej części tego tematu).</span><span class="sxs-lookup"><span data-stu-id="89a16-122">All list collections of the same type are considered to have the same data contract (unless they are customized using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, as discussed later in this topic).</span></span> <span data-ttu-id="89a16-123">W tym przypadku następujące kontrakty danych są równoważne.</span><span class="sxs-lookup"><span data-stu-id="89a16-123">Thus, for example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#0](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#0)]
[!code-vb[c_collection_types_in_data_contracts#0](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#0)]

<span data-ttu-id="89a16-124">Oba Kontrakty danych powodują, że kod XML jest podobny do następującego kodu.</span><span class="sxs-lookup"><span data-stu-id="89a16-124">Both data contracts result in XML similar to the following code.</span></span>

```xml
<PurchaseOrder>
    <customerName>...</customerName>
    <items>
        <Item>...</Item>
        <Item>...</Item>
        <Item>...</Item>
        ...
    </items>
    <comments>
        <string>...</string>
        <string>...</string>
        <string>...</string>
        ...
    </comments>
</PurchaseOrder>
```

<span data-ttu-id="89a16-125">Możliwość zmiany kolekcji pozwala na przykład użyć typu kolekcji zoptymalizowanego pod kątem wydajności na serwerze i typu kolekcji zaprojektowanego do powiązania ze składnikami interfejsu użytkownika na komputerze klienckim.</span><span class="sxs-lookup"><span data-stu-id="89a16-125">Collection interchangeability allows you to use, for example, a collection type optimized for performance on the server and a collection type designed to be bound to user interface components on the client.</span></span>

<span data-ttu-id="89a16-126">Podobnie jak w przypadku kolekcji list, wszystkie kolekcje słowników, które mają ten sam typ klucza i wartości, są uznawane za mające ten sam kontrakt danych (chyba że atrybut jest dostosowywany <xref:System.Runtime.Serialization.CollectionDataContractAttribute> ).</span><span class="sxs-lookup"><span data-stu-id="89a16-126">Similar to list collections, all dictionary collections that have the same key and value types are considered to have the same data contract (unless customized by the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute).</span></span>

<span data-ttu-id="89a16-127">Tylko typ kontraktu danych ma znaczenie, jeśli chodzi o równoważność kolekcji, a nie typy .NET.</span><span class="sxs-lookup"><span data-stu-id="89a16-127">Only the data contract type matters as far as collection equivalence is concerned, not .NET types.</span></span> <span data-ttu-id="89a16-128">Oznacza to, że kolekcja Type1 jest traktowana jako odpowiednik kolekcji Type2, jeśli Type1 i Type2 mają równoważne Kontrakty danych.</span><span class="sxs-lookup"><span data-stu-id="89a16-128">That is, a collection of Type1 is considered equivalent to a collection of Type2 if Type1 and Type2 have equivalent data contracts.</span></span>

<span data-ttu-id="89a16-129">Kolekcje inne niż ogólne są uznawane za mające ten sam kontrakt danych jako kolekcje ogólne typu `Object` .</span><span class="sxs-lookup"><span data-stu-id="89a16-129">Non-generic collections are considered to have the same data contract as generic collections of type `Object`.</span></span> <span data-ttu-id="89a16-130">(Na przykład Kontrakty danych dla <xref:System.Collections.ArrayList> i rodzajowe <xref:System.Collections.Generic.List%601> `Object` są takie same).</span><span class="sxs-lookup"><span data-stu-id="89a16-130">(For example, the data contracts for <xref:System.Collections.ArrayList> and Generic <xref:System.Collections.Generic.List%601> of `Object` are the same.)</span></span>

## <a name="using-collection-interface-types-and-read-only-collections"></a><span data-ttu-id="89a16-131">Używanie typów interfejsów kolekcji i kolekcji tylko do odczytu</span><span class="sxs-lookup"><span data-stu-id="89a16-131">Using Collection Interface Types and Read-Only Collections</span></span>

<span data-ttu-id="89a16-132">Typy interfejsów kolekcji ( <xref:System.Collections.IEnumerable> , <xref:System.Collections.IDictionary> , ogólne <xref:System.Collections.Generic.IDictionary%602> lub interfejsy pochodzące z tych interfejsów) są również uznawane za mające Kontrakty danych kolekcji, równoważne z kontraktami danych kolekcji dla rzeczywistych typów kolekcji.</span><span class="sxs-lookup"><span data-stu-id="89a16-132">Collection interface types (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, generic <xref:System.Collections.Generic.IDictionary%602>, or interfaces derived from these interfaces) are also considered as having collection data contracts, equivalent to collection data contracts for actual collection types.</span></span> <span data-ttu-id="89a16-133">W ten sposób można zadeklarować typ, który jest serializowany jako typ interfejsu kolekcji, a wyniki są takie same, jak w przypadku użycia rzeczywistego typu kolekcji.</span><span class="sxs-lookup"><span data-stu-id="89a16-133">Thus, it is possible to declare the type being serialized as a collection interface type and the results are the same as if an actual collection type had been used.</span></span> <span data-ttu-id="89a16-134">Na przykład następujące kontrakty danych są równoważne.</span><span class="sxs-lookup"><span data-stu-id="89a16-134">For example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#1)]
[!code-vb[c_collection_types_in_data_contracts#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#1)]

<span data-ttu-id="89a16-135">Podczas serializacji, gdy zadeklarowany typ jest interfejsem, rzeczywisty typ wystąpienia może być dowolnym typem, który implementuje ten interfejs.</span><span class="sxs-lookup"><span data-stu-id="89a16-135">During serialization, when the declared type is an interface, the actual instance type used can be any type that implements that interface.</span></span> <span data-ttu-id="89a16-136">Opisane wcześniej ograniczenia (posiadające Konstruktor bez parametrów i `Add` Metoda) nie mają zastosowania.</span><span class="sxs-lookup"><span data-stu-id="89a16-136">Restrictions discussed previously (having a parameterless constructor and an `Add` method) do not apply.</span></span> <span data-ttu-id="89a16-137">Na przykład można ustawić adresy w Customer2 do wystąpienia ogólnego <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> adresu, nawet jeśli nie można bezpośrednio zadeklarować elementu członkowskiego danych typu ogólnego <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> .</span><span class="sxs-lookup"><span data-stu-id="89a16-137">For example, you can set addresses in Customer2 to an instance of Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> of Address, even though you cannot directly declare a data member of type Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span></span>

<span data-ttu-id="89a16-138">Podczas deserializacji, gdy zadeklarowany typ jest interfejsem, aparat serializacji wybiera typ implementujący zadeklarowany interfejs, a typ jest skonkretyzowany.</span><span class="sxs-lookup"><span data-stu-id="89a16-138">During deserialization, when the declared type is an interface, the serialization engine chooses a type that implements the declared interface, and the type is instantiated.</span></span> <span data-ttu-id="89a16-139">Mechanizm znanych typów (opisany w [znanych typach kontraktu danych](data-contract-known-types.md)) nie ma wpływu na to miejsce; wybór typu jest wbudowany w funkcję WCF.</span><span class="sxs-lookup"><span data-stu-id="89a16-139">The known types mechanism (described in [Data Contract Known Types](data-contract-known-types.md)) has no effect here; the choice of type is built into WCF.</span></span>

## <a name="customizing-collection-types"></a><span data-ttu-id="89a16-140">Dostosowywanie typów kolekcji</span><span class="sxs-lookup"><span data-stu-id="89a16-140">Customizing Collection Types</span></span>

<span data-ttu-id="89a16-141">Można dostosować typy kolekcji przy użyciu <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu, który ma kilka zastosowania.</span><span class="sxs-lookup"><span data-stu-id="89a16-141">You can customize collection types by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, which has several uses.</span></span>

<span data-ttu-id="89a16-142">Należy zauważyć, że dostosowanie typów kolekcji powoduje naruszenie możliwości zmiany kolekcji, dlatego ogólnie zaleca się uniknięcie stosowania tego atrybutu, jeśli to możliwe.</span><span class="sxs-lookup"><span data-stu-id="89a16-142">Note that customizing collection types compromises collection interchangeability, so it is generally recommended to avoid applying this attribute whenever possible.</span></span> <span data-ttu-id="89a16-143">Więcej informacji o tym problemie znajduje się w sekcji "Zaawansowane reguły kolekcji" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="89a16-143">For more information about this issue, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="collection-data-contract-naming"></a><span data-ttu-id="89a16-144">Nazewnictwo kontraktu danych kolekcji</span><span class="sxs-lookup"><span data-stu-id="89a16-144">Collection Data Contract Naming</span></span>

<span data-ttu-id="89a16-145">Reguły nazewnictwa typów kolekcji są podobne do tych w przypadku nazewnictwa zwykłych typów kontraktów danych, zgodnie z opisem w [nazwach kontraktów danych](data-contract-names.md), chociaż istnieją pewne istotne różnice:</span><span class="sxs-lookup"><span data-stu-id="89a16-145">The rules for naming collection types are similar to those for naming regular data contract types, as described in [Data Contract Names](data-contract-names.md), although some important differences exist:</span></span>

- <span data-ttu-id="89a16-146">Ten <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybut służy do dostosowywania nazwy, a nie <xref:System.Runtime.Serialization.DataContractAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="89a16-146">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is used to customize the name, instead of the <xref:System.Runtime.Serialization.DataContractAttribute> attribute.</span></span> <span data-ttu-id="89a16-147">Ten <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybut ma również `Name` `Namespace` właściwości i.</span><span class="sxs-lookup"><span data-stu-id="89a16-147">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute also has `Name` and `Namespace` properties.</span></span>

- <span data-ttu-id="89a16-148">Gdy <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybut nie jest stosowany, domyślna nazwa i przestrzeń nazw dla typów kolekcji zależą od nazw i przestrzeni nazw typów zawartych w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="89a16-148">When the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is not applied, the default name and namespace for collection types depend on the names and namespaces of types contained within the collection.</span></span> <span data-ttu-id="89a16-149">Nie dotyczy to nazwy i przestrzeni nazw samego typu kolekcji.</span><span class="sxs-lookup"><span data-stu-id="89a16-149">They are not affected by the name and namespace of the collection type itself.</span></span> <span data-ttu-id="89a16-150">Aby zapoznać się z przykładem, zobacz następujące typy.</span><span class="sxs-lookup"><span data-stu-id="89a16-150">For an example, see the following types.</span></span>

  ```csharp
  public CustomerList1 : Collection<string> {}
  public StringList1 : Collection<string> {}
  ```

<span data-ttu-id="89a16-151">Oba typy "Nazwa kontraktu danych to" ArrayOfstring ", a nie" CustomerList1 "lub" StringList1 ".</span><span class="sxs-lookup"><span data-stu-id="89a16-151">Both types’ data contract name is "ArrayOfstring" and not "CustomerList1" or "StringList1".</span></span> <span data-ttu-id="89a16-152">Oznacza to, że Serializacja dowolnego z tych typów na poziomie głównym daje XML podobne do poniższego kodu.</span><span class="sxs-lookup"><span data-stu-id="89a16-152">This means that serializing any one of these types at the root level yields XML similar to the following code.</span></span>

```xml
<ArrayOfstring>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</ArrayOfstring>
```

<span data-ttu-id="89a16-153">Ta reguła nazewnictwa została wybrana, aby upewnić się, że dowolny niedostosowany typ reprezentujący listę ciągów ma ten sam kontrakt danych i reprezentację XML.</span><span class="sxs-lookup"><span data-stu-id="89a16-153">This naming rule was chosen to ensure that any non-customized type that represents a list of strings has the same data contract and XML representation.</span></span> <span data-ttu-id="89a16-154">Dzięki temu możliwe jest przeprowadzenie wymienności kolekcji.</span><span class="sxs-lookup"><span data-stu-id="89a16-154">This makes collection interchangeability possible.</span></span> <span data-ttu-id="89a16-155">W tym przykładzie CustomerList1 i StringList1 są całkowicie zamienne.</span><span class="sxs-lookup"><span data-stu-id="89a16-155">In this example, CustomerList1 and StringList1 are completely interchangeable.</span></span>

<span data-ttu-id="89a16-156">Jednak gdy <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybut zostanie zastosowany, kolekcja zostanie przypisana do niestandardowego kontraktu danych kolekcji, nawet jeśli w atrybucie nie są ustawione żadne właściwości.</span><span class="sxs-lookup"><span data-stu-id="89a16-156">However, when the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is applied, the collection becomes a customized collection data contract, even if no properties are set on the attribute.</span></span> <span data-ttu-id="89a16-157">Nazwa i przestrzeń nazw kontraktu danych kolekcji są zależne od samego typu kolekcji.</span><span class="sxs-lookup"><span data-stu-id="89a16-157">The name and namespace of the collection data contract then depend on the collection type itself.</span></span> <span data-ttu-id="89a16-158">Aby zapoznać się z przykładem, zobacz następujący typ.</span><span class="sxs-lookup"><span data-stu-id="89a16-158">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#2)]
[!code-vb[c_collection_types_in_data_contracts#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#2)]

<span data-ttu-id="89a16-159">Podczas serializacji, otrzymany kod XML jest podobny do poniższego.</span><span class="sxs-lookup"><span data-stu-id="89a16-159">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CustomerList2>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</CustomerList2>
```

<span data-ttu-id="89a16-160">Należy zauważyć, że nie jest to już odpowiednik reprezentacji XML dostosowanych typów.</span><span class="sxs-lookup"><span data-stu-id="89a16-160">Notice that this is no longer equivalent to the XML representation of the non-customized types.</span></span>

- <span data-ttu-id="89a16-161">Możesz użyć `Name` właściwości i, `Namespace` Aby bardziej dostosować nazwy.</span><span class="sxs-lookup"><span data-stu-id="89a16-161">You can use the `Name` and `Namespace` properties to further customize the naming.</span></span> <span data-ttu-id="89a16-162">Zapoznaj się z następującą klasą.</span><span class="sxs-lookup"><span data-stu-id="89a16-162">See the following class.</span></span>

  [!code-csharp[c_collection_types_in_data_contracts#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#3)]
  [!code-vb[c_collection_types_in_data_contracts#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#3)]

<span data-ttu-id="89a16-163">Otrzymany kod XML jest podobny do poniższego.</span><span class="sxs-lookup"><span data-stu-id="89a16-163">The resulting XML is similar to the following.</span></span>

```xml
<cust_list>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</cust_list>
```

<span data-ttu-id="89a16-164">Aby uzyskać więcej informacji, zobacz sekcję "Zaawansowane reguły kolekcji" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="89a16-164">For more information, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="customizing-the-repeating-element-name-in-list-collections"></a><span data-ttu-id="89a16-165">Dostosowywanie powtarzającej się nazwy elementu w kolekcjach list</span><span class="sxs-lookup"><span data-stu-id="89a16-165">Customizing the Repeating Element Name in List Collections</span></span>

<span data-ttu-id="89a16-166">Kolekcje list zawierają powtarzające się wpisy.</span><span class="sxs-lookup"><span data-stu-id="89a16-166">List collections contain repeating entries.</span></span> <span data-ttu-id="89a16-167">Zwykle każdy powtarzający wpis jest reprezentowany jako element o nazwie zgodnie z nazwą kontraktu danych typu zawartego w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="89a16-167">Normally, each repeating entry is represented as an element named according to the data contract name of the type contained in the collection.</span></span>

<span data-ttu-id="89a16-168">W `CustomerList` przykładach kolekcje zawierały ciągi.</span><span class="sxs-lookup"><span data-stu-id="89a16-168">In the `CustomerList` examples, the collections contained strings.</span></span> <span data-ttu-id="89a16-169">Nazwa kontraktu danych dla typu pierwotnego ciągu to "String", więc powtarzalny element to " \<string> ".</span><span class="sxs-lookup"><span data-stu-id="89a16-169">The data contract name for the string primitive type is "string", so the repeating element was "\<string>".</span></span>

<span data-ttu-id="89a16-170">Jednak przy użyciu <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> właściwości <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu, ta powtarzająca się nazwa elementu można dostosować.</span><span class="sxs-lookup"><span data-stu-id="89a16-170">However, using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property on the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, this repeating element name can be customized.</span></span> <span data-ttu-id="89a16-171">Aby zapoznać się z przykładem, zobacz następujący typ.</span><span class="sxs-lookup"><span data-stu-id="89a16-171">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#4)]
[!code-vb[c_collection_types_in_data_contracts#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#4)]

<span data-ttu-id="89a16-172">Otrzymany kod XML jest podobny do poniższego.</span><span class="sxs-lookup"><span data-stu-id="89a16-172">The resulting XML is similar to the following.</span></span>

```xml
<CustomerList4>
    <customer>...</customer>
    <customer>...</customer>
    <customer>...</customer>
    ...
</CustomerList4>
```

<span data-ttu-id="89a16-173">Przestrzeń nazw powtarzającego się elementu jest zawsze taka sama jak przestrzeń nazw kontraktu danych kolekcji, którą można dostosować przy użyciu `Namespace` właściwości, jak opisano wcześniej.</span><span class="sxs-lookup"><span data-stu-id="89a16-173">The namespace of the repeating element is always the same as the namespace of the collection data contract, which can be customized using the `Namespace` property, as described previously.</span></span>

### <a name="customizing-dictionary-collections"></a><span data-ttu-id="89a16-174">Dostosowywanie kolekcji słowników</span><span class="sxs-lookup"><span data-stu-id="89a16-174">Customizing Dictionary Collections</span></span>

<span data-ttu-id="89a16-175">Kolekcje słownika są zasadniczo listami wpisów, w których każdy wpis ma klucz, po którym następuje wartość.</span><span class="sxs-lookup"><span data-stu-id="89a16-175">Dictionary collections are essentially lists of entries, where each entry has a key followed by a value.</span></span> <span data-ttu-id="89a16-176">Podobnie jak w przypadku zwykłych list, można zmienić nazwę elementu, który odnosi się do powtarzalnego elementu przy użyciu <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="89a16-176">Just as with regular lists, you can change the element name that corresponds to the repeating element by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property.</span></span>

<span data-ttu-id="89a16-177">Ponadto można zmienić nazwy elementów reprezentujące klucz i wartość przy użyciu <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> właściwości i.</span><span class="sxs-lookup"><span data-stu-id="89a16-177">Additionally, you can change the element names that represent the key and the value by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> and <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> properties.</span></span> <span data-ttu-id="89a16-178">Przestrzenie nazw dla tych elementów są takie same jak przestrzeń nazw kontraktu danych kolekcji.</span><span class="sxs-lookup"><span data-stu-id="89a16-178">The namespaces for these elements are the same as the namespace of the collection data contract.</span></span>

<span data-ttu-id="89a16-179">Aby zapoznać się z przykładem, zobacz następujący typ.</span><span class="sxs-lookup"><span data-stu-id="89a16-179">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#5)]
[!code-vb[c_collection_types_in_data_contracts#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#5)]

<span data-ttu-id="89a16-180">Podczas serializacji, otrzymany kod XML jest podobny do poniższego.</span><span class="sxs-lookup"><span data-stu-id="89a16-180">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CountriesOrRegionsWithCapitals>
    <entry>
        <countryorregion>USA</countryorregion>
        <capital>Washington</capital>
    </entry>
    <entry>
        <countryorregion>France</countryorregion>
        <capital>Paris</capital>
    </entry>
    ...
</CountriesOrRegionsWithCapitals>
```

<span data-ttu-id="89a16-181">Aby uzyskać więcej informacji na temat kolekcji słowników, zobacz sekcję "Zaawansowane reguły kolekcji" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="89a16-181">For more information about dictionary collections, see the "Advanced Collection Rules" section later in this topic.</span></span>

## <a name="collections-and-known-types"></a><span data-ttu-id="89a16-182">Kolekcje i znane typy</span><span class="sxs-lookup"><span data-stu-id="89a16-182">Collections and Known Types</span></span>

<span data-ttu-id="89a16-183">Nie trzeba dodawać typów kolekcji do znanych typów, jeśli są używane w sposób polimorficzny zamiast innych kolekcji lub interfejsów kolekcji.</span><span class="sxs-lookup"><span data-stu-id="89a16-183">You do not need to add collection types to known types when used polymorphically in place of other collections or collection interfaces.</span></span> <span data-ttu-id="89a16-184">Na przykład, Jeśli deklarujesz element członkowski danych typu <xref:System.Collections.IEnumerable> i użyjesz go do wysłania wystąpienia <xref:System.Collections.ArrayList> , nie musisz dodawać <xref:System.Collections.ArrayList> do znanych typów.</span><span class="sxs-lookup"><span data-stu-id="89a16-184">For example, if you declare a data member of type <xref:System.Collections.IEnumerable> and use it to send an instance of <xref:System.Collections.ArrayList>, you do not need to add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="89a16-185">Jeśli kolekcje są używane w sposób polimorficzny zamiast typów niebędących kolekcjami, muszą być dodawane do znanych typów.</span><span class="sxs-lookup"><span data-stu-id="89a16-185">When you use collections polymorphically in place of non-collection types, they must be added to known types.</span></span> <span data-ttu-id="89a16-186">Na przykład, Jeśli deklarujesz element członkowski danych typu `Object` i użyjesz go do wysłania wystąpienia <xref:System.Collections.ArrayList> , Dodaj <xref:System.Collections.ArrayList> do znanych typów.</span><span class="sxs-lookup"><span data-stu-id="89a16-186">For example, if you declare a data member of type `Object` and use it to send an instance of <xref:System.Collections.ArrayList>, add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="89a16-187">Nie pozwala to na bardziej Serializowanie jakiejkolwiek równoważnej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="89a16-187">This does not allow you to serialize any equivalent collection polymorphically.</span></span> <span data-ttu-id="89a16-188">Na przykład po dodaniu <xref:System.Collections.ArrayList> do listy znanych typów w poprzednim przykładzie nie pozwala to przypisać `Array of Object` klasy, nawet jeśli ma ona odpowiedni kontrakt danych.</span><span class="sxs-lookup"><span data-stu-id="89a16-188">For example, when you add <xref:System.Collections.ArrayList> to the list of known types in the preceding example, this does not let you assign the `Array of Object` class, even though it has an equivalent data contract.</span></span> <span data-ttu-id="89a16-189">Nie różni się to od regularnego znanego typu zachowania podczas serializacji dla typów niebędących kolekcjami, ale jest szczególnie ważne, aby zrozumieć w przypadku kolekcji, ponieważ bardzo często kolekcje są równoważne.</span><span class="sxs-lookup"><span data-stu-id="89a16-189">This is no different from regular known types behavior on serialization for non-collection types, but it is especially important to understand in the case of collections because it is very common for collections to be equivalent.</span></span>

<span data-ttu-id="89a16-190">Podczas serializacji tylko jeden typ może być znany w danym zakresie dla danego kontraktu danych, a równoważne kolekcje mają te same umowy dotyczące danych.</span><span class="sxs-lookup"><span data-stu-id="89a16-190">During serialization, only one type can be known in any given scope for a given data contract, and equivalent collections all have the same data contracts.</span></span> <span data-ttu-id="89a16-191">Oznacza to, że w poprzednim przykładzie nie można dodać jednocześnie <xref:System.Collections.ArrayList> i `Array of Object` do znanych typów w tym samym zakresie.</span><span class="sxs-lookup"><span data-stu-id="89a16-191">This means that, in the previous example, you cannot add both <xref:System.Collections.ArrayList> and `Array of Object` to known types at the same scope.</span></span> <span data-ttu-id="89a16-192">Jest to równoznaczne z zachowaniem znanych typów dla typów niebędących kolekcjami, ale jest to szczególnie ważne, aby zrozumieć kolekcje.</span><span class="sxs-lookup"><span data-stu-id="89a16-192">Again, this is equivalent to known types behavior for non-collection types, but it is especially important to understand for collections.</span></span>

<span data-ttu-id="89a16-193">Znane typy mogą być również wymagane w przypadku zawartości kolekcji.</span><span class="sxs-lookup"><span data-stu-id="89a16-193">Known types may also be required for contents of collections.</span></span> <span data-ttu-id="89a16-194">Na przykład, jeśli w <xref:System.Collections.ArrayList> rzeczywistości zawiera wystąpienia `Type1` i `Type2` , oba typy powinny zostać dodane do znanych typów.</span><span class="sxs-lookup"><span data-stu-id="89a16-194">For example, if an <xref:System.Collections.ArrayList> actually contains instances of `Type1` and `Type2`, both of these types should be added to known types.</span></span>

<span data-ttu-id="89a16-195">Poniższy przykład pokazuje prawidłowo skonstruowany wykres obiektów przy użyciu kolekcji i znanych typów.</span><span class="sxs-lookup"><span data-stu-id="89a16-195">The following example shows a properly constructed object graph using collections and known types.</span></span> <span data-ttu-id="89a16-196">Przykładem jest nieco contrived, ponieważ w rzeczywistej aplikacji zazwyczaj nie można definiować następujących składowych danych jako `Object` , i w związku z tym nie ma znanych problemów z typem/polimorfizmem.</span><span class="sxs-lookup"><span data-stu-id="89a16-196">The example is somewhat contrived, because in an actual application you would normally not define the following data members as `Object`, and thus do not have any known type/polymorphism issues.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#6)]
[!code-vb[c_collection_types_in_data_contracts#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#6)]

<span data-ttu-id="89a16-197">W przypadku deserializacji, jeśli zadeklarowany typ jest typem kolekcji, zadeklarowany typ jest tworzona niezależnie od typu, który faktycznie został wysłany.</span><span class="sxs-lookup"><span data-stu-id="89a16-197">On deserialization, if the declared type is a collection type, the declared type is instantiated regardless of the type that was actually sent.</span></span> <span data-ttu-id="89a16-198">Jeśli zadeklarowany typ jest interfejsem kolekcji, Deserializator wybiera typ, który ma być skonkretyzowany, bez uwzględniania znanych typów.</span><span class="sxs-lookup"><span data-stu-id="89a16-198">If the declared type is a collection interface, the deserializer picks a type to be instantiated with no regard to known types.</span></span>

<span data-ttu-id="89a16-199">Również podczas deserializacji, jeśli zadeklarowany typ nie jest typem kolekcji, ale jest wysyłany typ kolekcji, zgodny typ kolekcji jest wybierany z listy znanych typów.</span><span class="sxs-lookup"><span data-stu-id="89a16-199">Also on deserialization, if the declared type is not a collection type but a collection type is being sent, a matching collection type is picked out of the known types list.</span></span> <span data-ttu-id="89a16-200">Można dodać typy interfejsów kolekcji do listy znanych typów podczas deserializacji.</span><span class="sxs-lookup"><span data-stu-id="89a16-200">It is possible to add collection interface types to the list of known types on deserialization.</span></span> <span data-ttu-id="89a16-201">W takim przypadku aparat deserializacji ponownie wybiera typ do wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="89a16-201">In this case, the deserialization engine again picks a type to be instantiated.</span></span>

## <a name="collections-and-the-netdatacontractserializer-class"></a><span data-ttu-id="89a16-202">Kolekcje i Klasa NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="89a16-202">Collections and the NetDataContractSerializer Class</span></span>

<span data-ttu-id="89a16-203">Gdy <xref:System.Runtime.Serialization.NetDataContractSerializer> Klasa jest używana, niedostosowane typy kolekcji (bez <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu), które nie są tablicami, tracą specjalne znaczenie.</span><span class="sxs-lookup"><span data-stu-id="89a16-203">When the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use, non-customized collection types (without the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute) that are not arrays lose their special meaning.</span></span>

<span data-ttu-id="89a16-204">Niedostosowane typy kolekcji oznaczone <xref:System.SerializableAttribute> atrybutem mogą nadal być serializowane przez <xref:System.Runtime.Serialization.NetDataContractSerializer> klasę zgodnie z <xref:System.SerializableAttribute> atrybutem lub <xref:System.Runtime.Serialization.ISerializable> regułami interfejsu.</span><span class="sxs-lookup"><span data-stu-id="89a16-204">Non-customized collection types marked with the <xref:System.SerializableAttribute> attribute can still be serialized by the <xref:System.Runtime.Serialization.NetDataContractSerializer> class according to the <xref:System.SerializableAttribute> attribute or the <xref:System.Runtime.Serialization.ISerializable> interface rules.</span></span>

<span data-ttu-id="89a16-205">Niestandardowe typy kolekcji, interfejsy kolekcji i tablice są nadal traktowane jako kolekcje, nawet gdy <xref:System.Runtime.Serialization.NetDataContractSerializer> Klasa jest używana.</span><span class="sxs-lookup"><span data-stu-id="89a16-205">Customized collection types, collection interfaces, and arrays are still treated as collections, even when the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use.</span></span>

## <a name="collections-and-schema"></a><span data-ttu-id="89a16-206">Kolekcje i schemat</span><span class="sxs-lookup"><span data-stu-id="89a16-206">Collections and Schema</span></span>

<span data-ttu-id="89a16-207">Wszystkie równoważne kolekcje mają tę samą reprezentację w schemacie języka definicji schematu XML (XSD).</span><span class="sxs-lookup"><span data-stu-id="89a16-207">All equivalent collections have the same representation in XML Schema definition language (XSD) schema.</span></span> <span data-ttu-id="89a16-208">W związku z tym zwykle nie uzyskujesz tego samego typu kolekcji w wygenerowanym kodzie klienta jako ten, który znajduje się na serwerze.</span><span class="sxs-lookup"><span data-stu-id="89a16-208">Because of this, you normally do not get the same collection type in the generated client code as the one on the server.</span></span> <span data-ttu-id="89a16-209">Na przykład serwer może używać kontraktu danych z ogólnym <xref:System.Collections.Generic.List%601> elementem członkowskim danych Integer, ale w kodzie wygenerowanego klienta ten sam element członkowski danych może stać się tablicą liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="89a16-209">For example, the server may use a data contract with a Generic <xref:System.Collections.Generic.List%601> of Integer data member, but in the generated client code the same data member may become an array of integers.</span></span>

<span data-ttu-id="89a16-210">Kolekcje słownika są oznaczone adnotacją schematu specyficzną dla programu WCF, która wskazuje, że są to słowniki; w przeciwnym razie są one nieodróżniane od prostych list zawierających wpisy z kluczem i wartością.</span><span class="sxs-lookup"><span data-stu-id="89a16-210">Dictionary collections are marked with a WCF-specific schema annotation that indicate that they are dictionaries; otherwise, they are indistinguishable from simple lists that contain entries with a key and a value.</span></span> <span data-ttu-id="89a16-211">Dokładny opis sposobu reprezentowania kolekcji w schemacie kontraktu danych znajduje się w temacie [Informacje o schemacie kontraktu danych](data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="89a16-211">For an exact description of how collections are represented in data contract schema, see [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span>

<span data-ttu-id="89a16-212">Domyślnie typy nie są generowane dla niedostosowywanych kolekcji w zaimportowanym kodzie.</span><span class="sxs-lookup"><span data-stu-id="89a16-212">By default, types are not generated for non-customized collections in imported code.</span></span> <span data-ttu-id="89a16-213">Elementy członkowskie danych typów kolekcji list są importowane jako tablice, a elementy członkowskie danych typów kolekcji słownika są importowane jako słownik ogólny.</span><span class="sxs-lookup"><span data-stu-id="89a16-213">Data members of list collection types are imported as arrays, and data members of dictionary collection types are imported as Generic Dictionary.</span></span>

<span data-ttu-id="89a16-214">Jednak w przypadku dostosowanych kolekcji są generowane oddzielne typy, które są oznaczone <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutem.</span><span class="sxs-lookup"><span data-stu-id="89a16-214">However, for customized collections, separate types are generated, marked with the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute.</span></span> <span data-ttu-id="89a16-215">(Dostosowany typ kolekcji w schemacie to taki, który nie używa domyślnej przestrzeni nazw, nazwy, powtarzającej się nazwy elementu ani nazw elementów klucza/wartości). Te typy są pustymi typami pochodnymi od generycznego <xref:System.Collections.Generic.List%601> dla typów list i słownika ogólnego dla typów słowników.</span><span class="sxs-lookup"><span data-stu-id="89a16-215">(A customized collection type in the schema is one that does not use the default namespace, name, repeating element name, or key/value element names.) These types are empty types that derive from Generic <xref:System.Collections.Generic.List%601> for list types and Generic Dictionary for dictionary types.</span></span>

<span data-ttu-id="89a16-216">Na przykład na serwerze mogą znajdować się następujące typy.</span><span class="sxs-lookup"><span data-stu-id="89a16-216">For example, you may have the following types on the server.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#7)]
[!code-vb[c_collection_types_in_data_contracts#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#7)]

<span data-ttu-id="89a16-217">Gdy schemat zostanie wyeksportowany i ponownie zaimportowany, wygenerowany kod klienta jest podobny do poniższego (pola są wyświetlane, a nie właściwości do ułatwienia czytania).</span><span class="sxs-lookup"><span data-stu-id="89a16-217">When the schema is exported and imported back again, the generated client code is similar to the following (fields are shown instead of properties for ease of reading).</span></span>

[!code-csharp[c_collection_types_in_data_contracts#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#8)]
[!code-vb[c_collection_types_in_data_contracts#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#8)]

<span data-ttu-id="89a16-218">Możesz chcieć użyć różnych typów w wygenerowanym kodzie niż domyślne.</span><span class="sxs-lookup"><span data-stu-id="89a16-218">You may want to use different types in generated code than the default ones.</span></span> <span data-ttu-id="89a16-219">Na przykład możesz chcieć użyć generycznych <xref:System.ComponentModel.BindingList%601> zamiast zwykłych tablic dla członków danych, aby ułatwić powiązanie ich ze składnikami interfejsu użytkownika.</span><span class="sxs-lookup"><span data-stu-id="89a16-219">For example, you may want to use Generic <xref:System.ComponentModel.BindingList%601> instead of regular arrays for your data members to make it easier to bind them to user interface components.</span></span>

<span data-ttu-id="89a16-220">Aby wybrać typy kolekcji do wygenerowania, należy przekazać listę typów kolekcji, które mają być używane we <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> właściwości <xref:System.Runtime.Serialization.ImportOptions> obiektu podczas importowania schematu.</span><span class="sxs-lookup"><span data-stu-id="89a16-220">To choose collection types to generate, pass a list of collection types you want to use into the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> property of the <xref:System.Runtime.Serialization.ImportOptions> object when importing schema.</span></span> <span data-ttu-id="89a16-221">Te typy są nazywane *typem kolekcji, do których się odwołuje*.</span><span class="sxs-lookup"><span data-stu-id="89a16-221">These types are called *referenced collection types*.</span></span>

<span data-ttu-id="89a16-222">Gdy istnieją odwołania do typów ogólnych, muszą one być w pełni otwarte ogólne lub w pełni zamknięte typy ogólne.</span><span class="sxs-lookup"><span data-stu-id="89a16-222">When generic types are being referenced, they must either be fully-open generics or fully-closed generics.</span></span>

> [!NOTE]
> <span data-ttu-id="89a16-223">W przypadku korzystania z narzędzia Svcutil. exe to odwołanie można wykonać za pomocą przełącznika wiersza polecenia **/CollectionType** (krótka wersja: **/CT**).</span><span class="sxs-lookup"><span data-stu-id="89a16-223">When using the Svcutil.exe tool, this reference can be accomplished by using the **/collectionType** command-line switch (short form: **/ct**).</span></span> <span data-ttu-id="89a16-224">Należy pamiętać, że należy również określić zestaw dla typów kolekcji, do których istnieją odwołania, przy użyciu przełącznika **/Reference** (krótka wersja: **/r**).</span><span class="sxs-lookup"><span data-stu-id="89a16-224">Keep in mind that you must also specify the assembly for the referenced collection types using the **/reference** switch (short form: **/r**).</span></span> <span data-ttu-id="89a16-225">Jeśli typ jest rodzajowy, musi następować cudzysłów tylny oraz liczbę parametrów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="89a16-225">If the type is generic, it must be followed by a back quote and the number of generic parameters.</span></span> <span data-ttu-id="89a16-226">Cudzysłowu wstecznego ( \` ) nie należy mylić z pojedynczym znakiem cudzysłowu (').</span><span class="sxs-lookup"><span data-stu-id="89a16-226">The back quote (\`) is not to be confused with the single quote (‘) character.</span></span> <span data-ttu-id="89a16-227">Można określić wiele typów kolekcji, do których istnieją odwołania, za pomocą przełącznika **/CollectionType** więcej niż jeden raz.</span><span class="sxs-lookup"><span data-stu-id="89a16-227">You can specify multiple referenced collection types by using the **/collectionType** switch more than once.</span></span>

<span data-ttu-id="89a16-228">Na przykład, aby spowodować, że wszystkie listy zostaną zaimportowane jako ogólne <xref:System.Collections.Generic.List%601> .</span><span class="sxs-lookup"><span data-stu-id="89a16-228">For example, to cause all lists to be imported as Generic <xref:System.Collections.Generic.List%601>.</span></span>

```console
svcutil.exe MyService.wsdl MyServiceSchema.xsd /r:C:\full_path_to_system_dll\System.dll /ct:System.Collections.Generic.List`1
```

<span data-ttu-id="89a16-229">Podczas importowania kolekcji, ta lista typów kolekcji, do których się odwołuje, jest skanowana i jest używana Najlepsza, pasująca kolekcja, gdy zostanie znaleziona, jako typ elementu członkowskiego danych (dla niedostosowanych kolekcji) lub jako typ podstawowy, który ma być pochodny (dla dostosowanych kolekcji).</span><span class="sxs-lookup"><span data-stu-id="89a16-229">When importing any collection, this list of referenced collection types is scanned, and the best-matching collection is used if one is found, either as a data member type (for non-customized collections) or as a base type to derive from (for customized collections).</span></span> <span data-ttu-id="89a16-230">Słowniki są dopasowywane tylko do słowników, a listy są dopasowywane do list.</span><span class="sxs-lookup"><span data-stu-id="89a16-230">Dictionaries are only matched against dictionaries, while lists are matched against lists.</span></span>

<span data-ttu-id="89a16-231">Na przykład jeśli dodasz ogólny <xref:System.ComponentModel.BindingList%601> i <xref:System.Collections.Hashtable> do listy typów, których dotyczy odwołanie, wygenerowany kod klienta dla poprzedniego przykładu będzie podobny do poniższego.</span><span class="sxs-lookup"><span data-stu-id="89a16-231">For example, if you add the Generic <xref:System.ComponentModel.BindingList%601> and <xref:System.Collections.Hashtable> to the list of referenced types, the generated client code for the preceding example is similar to the following.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#9)]
[!code-vb[c_collection_types_in_data_contracts#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#9)]

<span data-ttu-id="89a16-232">Można określić typy interfejsów kolekcji jako część typów kolekcji, do których istnieją odwołania, ale nie można określić nieprawidłowych typów kolekcji (takich jak te bez `Add` metody lub konstruktora publicznego).</span><span class="sxs-lookup"><span data-stu-id="89a16-232">You can specify collection interface types as part of your referenced collection types, but you cannot specify invalid collection types (such as ones with no `Add` method or public constructor).</span></span>

<span data-ttu-id="89a16-233">Zamknięte ogólne jest uznawane za najlepsze dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="89a16-233">A closed generic is considered to be the best match.</span></span> <span data-ttu-id="89a16-234">(Typy inne niż ogólne są uważane za równoważne zamkniętym rodzajom `Object` ).</span><span class="sxs-lookup"><span data-stu-id="89a16-234">(Non-generic types are considered equivalent to closed generics of `Object`).</span></span> <span data-ttu-id="89a16-235">Na przykład, jeśli typy ogólne <xref:System.Collections.Generic.List%601> of <xref:System.DateTime> , Generic <xref:System.ComponentModel.BindingList%601> (Open Generic) i <xref:System.Collections.ArrayList> są typami kolekcji, do których istnieją odwołania, generowane są następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="89a16-235">For example, if the types Generic <xref:System.Collections.Generic.List%601> of <xref:System.DateTime>, Generic <xref:System.ComponentModel.BindingList%601> (open generic), and <xref:System.Collections.ArrayList> are the referenced collection types, the following is generated.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#10)]
[!code-vb[c_collection_types_in_data_contracts#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#10)]

<span data-ttu-id="89a16-236">W przypadku kolekcji list są obsługiwane tylko przypadki z poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="89a16-236">For list collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="89a16-237">Typ przywoływany</span><span class="sxs-lookup"><span data-stu-id="89a16-237">Referenced type</span></span>|<span data-ttu-id="89a16-238">Interfejs zaimplementowany przez przywoływany typ</span><span class="sxs-lookup"><span data-stu-id="89a16-238">Interface implemented by referenced type</span></span>|<span data-ttu-id="89a16-239">Przykład</span><span class="sxs-lookup"><span data-stu-id="89a16-239">Example</span></span>|<span data-ttu-id="89a16-240">Typ traktowany jako:</span><span class="sxs-lookup"><span data-stu-id="89a16-240">Type treated as:</span></span>|
|---------------------|----------------------------------------------|-------------|----------------------|
|<span data-ttu-id="89a16-241">Nieogólne lub zamknięte ogólne (dowolna liczba parametrów)</span><span class="sxs-lookup"><span data-stu-id="89a16-241">Non-generic or closed generic (any number of parameters)</span></span>|<span data-ttu-id="89a16-242">Nieogólny</span><span class="sxs-lookup"><span data-stu-id="89a16-242">Non-generic</span></span>|`MyType : IList`<br /><br /> <span data-ttu-id="89a16-243">lub</span><span class="sxs-lookup"><span data-stu-id="89a16-243">or</span></span><br /><br /> `MyType<T> : IList`<br /><br /> <span data-ttu-id="89a16-244">gdzie T =`int`</span><span class="sxs-lookup"><span data-stu-id="89a16-244">where T= `int`</span></span>|<span data-ttu-id="89a16-245">Zamknięte ogólne z `Object` (na przykład `IList<object>` )</span><span class="sxs-lookup"><span data-stu-id="89a16-245">Closed generic of `Object` (for example, `IList<object>`)</span></span>|
|<span data-ttu-id="89a16-246">Nieogólne lub zamknięte ogólne (dowolna liczba parametrów, które nie muszą być zgodne z typem kolekcji)</span><span class="sxs-lookup"><span data-stu-id="89a16-246">Non-generic or closed generic (any number of parameters that do not necessarily match the collection type)</span></span>|<span data-ttu-id="89a16-247">Zamknięte ogólne</span><span class="sxs-lookup"><span data-stu-id="89a16-247">Closed generic</span></span>|`MyType : IList<string>`<br /><br /> <span data-ttu-id="89a16-248">lub</span><span class="sxs-lookup"><span data-stu-id="89a16-248">or</span></span><br /><br /> <span data-ttu-id="89a16-249">`MyType<T> : IList<string>`gdzie T =`int`</span><span class="sxs-lookup"><span data-stu-id="89a16-249">`MyType<T> : IList<string>` where T=`int`</span></span>|<span data-ttu-id="89a16-250">Zamknięte ogólne (na przykład `IList<string>` )</span><span class="sxs-lookup"><span data-stu-id="89a16-250">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="89a16-251">Zamknięto ogólne z dowolną liczbą parametrów</span><span class="sxs-lookup"><span data-stu-id="89a16-251">Closed generic with any number of parameters</span></span>|<span data-ttu-id="89a16-252">Otwórz ogólny przy użyciu dowolnego z parametrów typu</span><span class="sxs-lookup"><span data-stu-id="89a16-252">Open generic using any one of the type’s parameters</span></span>|`MyType<T,U,V> : IList<U>`<br /><br /> <span data-ttu-id="89a16-253">gdzie T = `int` , U = `string` , V =`bool`</span><span class="sxs-lookup"><span data-stu-id="89a16-253">where T=`int`, U=`string`, V=`bool`</span></span>|<span data-ttu-id="89a16-254">Zamknięte ogólne (na przykład `IList<string>` )</span><span class="sxs-lookup"><span data-stu-id="89a16-254">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="89a16-255">Otwórz ogólny z jednym parametrem</span><span class="sxs-lookup"><span data-stu-id="89a16-255">Open generic with one parameter</span></span>|<span data-ttu-id="89a16-256">Otwórz ogólne przy użyciu parametru typu</span><span class="sxs-lookup"><span data-stu-id="89a16-256">Open generic using the type’s parameter</span></span>|<span data-ttu-id="89a16-257">`MyType<T> : IList<T>`, T jest otwarty</span><span class="sxs-lookup"><span data-stu-id="89a16-257">`MyType<T> : IList<T>`, T is open</span></span>|<span data-ttu-id="89a16-258">Otwórz ogólne (na przykład `IList<T>` )</span><span class="sxs-lookup"><span data-stu-id="89a16-258">Open generic (for example, `IList<T>`)</span></span>|

<span data-ttu-id="89a16-259">Jeśli typ implementuje więcej niż jeden interfejs kolekcji list, mają zastosowanie następujące ograniczenia:</span><span class="sxs-lookup"><span data-stu-id="89a16-259">If a type implements more than one list collection interface, the following restrictions apply:</span></span>

- <span data-ttu-id="89a16-260">Jeśli typ implementuje ogólne <xref:System.Collections.Generic.IEnumerable%601> (lub jego interfejsy pochodne) wiele razy dla różnych typów, typ nie jest uważany za prawidłowy typ kolekcji, do której się odwołuje, i jest ignorowany.</span><span class="sxs-lookup"><span data-stu-id="89a16-260">If the type implements Generic <xref:System.Collections.Generic.IEnumerable%601> (or its derived interfaces) multiple times for different types, the type is not considered a valid referenced collection type and is ignored.</span></span> <span data-ttu-id="89a16-261">Jest to prawdziwe, nawet jeśli niektóre implementacje są nieprawidłowe lub używają otwartych typów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="89a16-261">This is true even if some implementations are invalid or use open generics.</span></span> <span data-ttu-id="89a16-262">Na przykład typ, który implementuje ogólny parametr <xref:System.Collections.Generic.IEnumerable%601> `int` i generyczne <xref:System.Collections.Generic.IEnumerable%601> T nigdy nie będzie używany jako kolekcja, do której się odwołuje `int` , lub inny typ, bez względu na to, czy typ ma `Add` metodę akceptującą, czy `int` `Add` Metoda akceptująca parametr typu T, czy też.</span><span class="sxs-lookup"><span data-stu-id="89a16-262">For example, a type that implements Generic <xref:System.Collections.Generic.IEnumerable%601> of `int` and Generic <xref:System.Collections.Generic.IEnumerable%601> of T would never be used as a referenced collection of `int` or any other type, regardless of whether the type has an `Add` method accepting `int` or an `Add` method accepting a parameter of type T, or both.</span></span>

- <span data-ttu-id="89a16-263">Jeśli typ implementuje interfejs kolekcji ogólnej, a także <xref:System.Collections.IList> , typ nie jest nigdy używany jako przywoływany typ kolekcji, chyba że ogólny interfejs kolekcji jest zamkniętym rodzajem typu <xref:System.Object> .</span><span class="sxs-lookup"><span data-stu-id="89a16-263">If the type implements a generic collection interface as well as <xref:System.Collections.IList>, the type is never used as a referenced collection type unless the generic collection interface is a closed generic of type <xref:System.Object>.</span></span>

<span data-ttu-id="89a16-264">W przypadku kolekcji słownika są obsługiwane tylko przypadki z poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="89a16-264">For dictionary collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="89a16-265">Typ przywoływany</span><span class="sxs-lookup"><span data-stu-id="89a16-265">Referenced type</span></span>|<span data-ttu-id="89a16-266">Interfejs zaimplementowany przez przywoływany typ</span><span class="sxs-lookup"><span data-stu-id="89a16-266">Interface implemented by referenced type</span></span>|<span data-ttu-id="89a16-267">Przykład</span><span class="sxs-lookup"><span data-stu-id="89a16-267">Example</span></span>|<span data-ttu-id="89a16-268">Typ traktowany jako</span><span class="sxs-lookup"><span data-stu-id="89a16-268">Type treated as</span></span>|
|---------------------|----------------------------------------------|-------------|---------------------|
|<span data-ttu-id="89a16-269">Nieogólne lub zamknięte ogólne (dowolna liczba parametrów)</span><span class="sxs-lookup"><span data-stu-id="89a16-269">Non-generic or closed generic (any number of parameters)</span></span>|<xref:System.Collections.IDictionary>|`MyType : IDictionary`<br /><br /> <span data-ttu-id="89a16-270">lub</span><span class="sxs-lookup"><span data-stu-id="89a16-270">or</span></span><br /><br /> <span data-ttu-id="89a16-271">`MyType<T> : IDictionary`gdzie T =`int`</span><span class="sxs-lookup"><span data-stu-id="89a16-271">`MyType<T> : IDictionary` where T=`int`</span></span>|<span data-ttu-id="89a16-272">Zamknięte ogólne`IDictionary<object,object>`</span><span class="sxs-lookup"><span data-stu-id="89a16-272">Closed generic `IDictionary<object,object>`</span></span>|
|<span data-ttu-id="89a16-273">Zamknięte ogólne (dowolna liczba parametrów)</span><span class="sxs-lookup"><span data-stu-id="89a16-273">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="89a16-274"><xref:System.Collections.Generic.IDictionary%602>, zamknięte</span><span class="sxs-lookup"><span data-stu-id="89a16-274"><xref:System.Collections.Generic.IDictionary%602>, closed</span></span>|<span data-ttu-id="89a16-275">`MyType<T> : IDictionary<string, bool>`gdzie T =`int`</span><span class="sxs-lookup"><span data-stu-id="89a16-275">`MyType<T> : IDictionary<string, bool>` where T=`int`</span></span>|<span data-ttu-id="89a16-276">Zamknięte ogólne (na przykład `IDIctionary<string,bool>` )</span><span class="sxs-lookup"><span data-stu-id="89a16-276">Closed generic (for example, `IDIctionary<string,bool>`)</span></span>|
|<span data-ttu-id="89a16-277">Zamknięte ogólne (dowolna liczba parametrów)</span><span class="sxs-lookup"><span data-stu-id="89a16-277">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="89a16-278">Ogólny <xref:System.Collections.Generic.IDictionary%602> , jeden z kluczy lub wartości jest zamknięty, drugi jest otwarty i używa jednego z parametrów typu</span><span class="sxs-lookup"><span data-stu-id="89a16-278">Generic <xref:System.Collections.Generic.IDictionary%602>, one of either key or value is closed, the other is open and uses one of type’s parameters</span></span>|<span data-ttu-id="89a16-279">`MyType<T,U,V> : IDictionary<string,V>`gdzie T = `int` , U = `float` , V =`bool`</span><span class="sxs-lookup"><span data-stu-id="89a16-279">`MyType<T,U,V> : IDictionary<string,V>` where T=`int`, U=`float`,V=`bool`</span></span><br /><br /> <span data-ttu-id="89a16-280">lub</span><span class="sxs-lookup"><span data-stu-id="89a16-280">or</span></span><br /><br /> <span data-ttu-id="89a16-281">`MyType<Z> : IDictionary<Z,bool>`gdzie Z =`string`</span><span class="sxs-lookup"><span data-stu-id="89a16-281">`MyType<Z> : IDictionary<Z,bool>` where Z=`string`</span></span>|<span data-ttu-id="89a16-282">Zamknięte ogólne (na przykład `IDictionary<string,bool>` )</span><span class="sxs-lookup"><span data-stu-id="89a16-282">Closed generic (For example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="89a16-283">Zamknięte ogólne (dowolna liczba parametrów)</span><span class="sxs-lookup"><span data-stu-id="89a16-283">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="89a16-284">Ogólny <xref:System.Collections.Generic.IDictionary%602> , zarówno klucz, jak i wartość są otwarte, a każdy z nich używa jednego z parametrów typu</span><span class="sxs-lookup"><span data-stu-id="89a16-284">Generic <xref:System.Collections.Generic.IDictionary%602>, both key and value are open and each uses one of the type’s parameters</span></span>|<span data-ttu-id="89a16-285">`MyType<T,U,V> : IDictionary<V,U>`gdzie T = `int` , U = `bool` , V =`string`</span><span class="sxs-lookup"><span data-stu-id="89a16-285">`MyType<T,U,V> : IDictionary<V,U>` where T=`int`, U=`bool`, V=`string`</span></span>|<span data-ttu-id="89a16-286">Zamknięte ogólne (na przykład `IDictionary<string,bool>` )</span><span class="sxs-lookup"><span data-stu-id="89a16-286">Closed generic (for example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="89a16-287">Otwórz ogólne (dwa parametry)</span><span class="sxs-lookup"><span data-stu-id="89a16-287">Open generic (two parameters)</span></span>|<span data-ttu-id="89a16-288">Ogólne <xref:System.Collections.Generic.IDictionary%602> , otwarte, używa obu parametrów ogólnych typu w kolejności, w jakiej występują</span><span class="sxs-lookup"><span data-stu-id="89a16-288">Generic <xref:System.Collections.Generic.IDictionary%602>, open, uses both of the type’s generic parameters in the order they appear</span></span>|<span data-ttu-id="89a16-289">`MyType<K,V> : IDictionary<K,V>`, K i V — otwarte</span><span class="sxs-lookup"><span data-stu-id="89a16-289">`MyType<K,V> : IDictionary<K,V>`, K and V both open</span></span>|<span data-ttu-id="89a16-290">Otwórz ogólne (na przykład `IDictionary<K,V>` )</span><span class="sxs-lookup"><span data-stu-id="89a16-290">Open generic (for example, `IDictionary<K,V>`)</span></span>|

<span data-ttu-id="89a16-291">Jeśli typ implementuje zarówno <xref:System.Collections.IDictionary> , jak i rodzajowy <xref:System.Collections.Generic.IDictionary%602> , tylko ogólny <xref:System.Collections.Generic.IDictionary%602> jest brany pod uwagę.</span><span class="sxs-lookup"><span data-stu-id="89a16-291">If the type implements both <xref:System.Collections.IDictionary> and Generic <xref:System.Collections.Generic.IDictionary%602>, only Generic <xref:System.Collections.Generic.IDictionary%602> is considered.</span></span>

<span data-ttu-id="89a16-292">Odwołania do częściowych typów ogólnych nie są obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="89a16-292">Referencing partial generic types is not supported.</span></span>

<span data-ttu-id="89a16-293">Duplikaty są niedozwolone, na przykład nie można dodać obu rodzajowych <xref:System.Collections.Generic.List%601> `Integer` i ogólnych kolekcji `Integer` do <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> , ponieważ uniemożliwia to ustalenie, który z nich ma być używany, gdy w schemacie znajduje się lista liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="89a16-293">Duplicates are not allowed, for example, you cannot add both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` to <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, because this makes it impossible to determine which one to use when a list of integers is found in the schema.</span></span> <span data-ttu-id="89a16-294">Duplikaty są wykrywane tylko wtedy, gdy w schemacie znajduje się typ, który ujawnia problem z duplikatami.</span><span class="sxs-lookup"><span data-stu-id="89a16-294">Duplicates are detected only if there is a type in the schema that exposes the duplicates problem.</span></span> <span data-ttu-id="89a16-295">Na przykład, Jeśli importowany schemat nie zawiera listy liczb całkowitych, może istnieć zarówno ogólny element, <xref:System.Collections.Generic.List%601> `Integer` jak i Ogólna kolekcja `Integer` w <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> , ale nie ma żadnego efektu.</span><span class="sxs-lookup"><span data-stu-id="89a16-295">For example, if the schema being imported does not contain lists of integers, it is allowed to have both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` in the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, but neither has any effect.</span></span>

## <a name="advanced-collection-rules"></a><span data-ttu-id="89a16-296">Zaawansowane reguły zbierania</span><span class="sxs-lookup"><span data-stu-id="89a16-296">Advanced Collection Rules</span></span>

### <a name="serializing-collections"></a><span data-ttu-id="89a16-297">Serializacja kolekcji</span><span class="sxs-lookup"><span data-stu-id="89a16-297">Serializing Collections</span></span>

<span data-ttu-id="89a16-298">Poniżej znajduje się lista reguł kolekcji dla serializacji:</span><span class="sxs-lookup"><span data-stu-id="89a16-298">The following is a list of collection rules for serialization:</span></span>

- <span data-ttu-id="89a16-299">Łączenie typów kolekcji (z kolekcjami kolekcji) jest dozwolone.</span><span class="sxs-lookup"><span data-stu-id="89a16-299">Combining collection types (having collections of collections) is allowed.</span></span> <span data-ttu-id="89a16-300">Tablice nieregularne są traktowane jako kolekcje kolekcji.</span><span class="sxs-lookup"><span data-stu-id="89a16-300">Jagged arrays are treated as collections of collections.</span></span> <span data-ttu-id="89a16-301">Tablice wielowymiarowe nie są obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="89a16-301">Multidimensional arrays are not supported.</span></span>

- <span data-ttu-id="89a16-302">Tablice bajtów i tablic <xref:System.Xml.XmlNode> są specjalnymi typami tablic, które są traktowane jako elementy pierwotne, a nie kolekcje.</span><span class="sxs-lookup"><span data-stu-id="89a16-302">Arrays of byte and arrays of <xref:System.Xml.XmlNode> are special array types that are treated as primitives, not collections.</span></span> <span data-ttu-id="89a16-303">Serializacja tablicy bajtów skutkuje pojedynczym elementem XML zawierającym fragment danych zakodowanych algorytmem Base64 zamiast oddzielnego elementu dla każdego bajtu.</span><span class="sxs-lookup"><span data-stu-id="89a16-303">Serializing an array of byte results in a single XML element that contains a chunk of Base64-encoded data, instead of a separate element for each byte.</span></span> <span data-ttu-id="89a16-304">Aby uzyskać więcej informacji o sposobie <xref:System.Xml.XmlNode> traktowania tablicy, zobacz [Typy XML i ADO.NET w umowach dotyczących danych](xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="89a16-304">For more information about how an array of <xref:System.Xml.XmlNode> is treated, see [XML and ADO.NET Types in Data Contracts](xml-and-ado-net-types-in-data-contracts.md).</span></span> <span data-ttu-id="89a16-305">Oczywiście te typy specjalne mogą się znajdować w kolekcjach: tablica tablicy Byte powoduje wiele elementów XML, z których każdy zawiera fragment danych zakodowanych algorytmem Base64.</span><span class="sxs-lookup"><span data-stu-id="89a16-305">Of course, these special types can themselves participate in collections: an array of array of byte results in multiple XML elements, with each containing a chunk of Base64-encoded data.</span></span>

- <span data-ttu-id="89a16-306">Jeśli <xref:System.Runtime.Serialization.DataContractAttribute> atrybut jest stosowany do typu kolekcji, typ jest traktowany jako zwykły typ kontraktu danych, a nie jako kolekcja.</span><span class="sxs-lookup"><span data-stu-id="89a16-306">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a collection type, the type is treated as a regular data contract type, not as a collection.</span></span>

- <span data-ttu-id="89a16-307">Jeśli typ kolekcji implementuje <xref:System.Xml.Serialization.IXmlSerializable> interfejs, mają zastosowanie następujące reguły `myType:IList<string>, IXmlSerializable` :</span><span class="sxs-lookup"><span data-stu-id="89a16-307">If a collection type implements the <xref:System.Xml.Serialization.IXmlSerializable> interface, the following rules apply, given a type `myType:IList<string>, IXmlSerializable`:</span></span>

  - <span data-ttu-id="89a16-308">Jeśli zadeklarowany typ to `IList<string>` , typ jest serializowany jako listę.</span><span class="sxs-lookup"><span data-stu-id="89a16-308">If the declared type is `IList<string>`, the type is serialized as a list.</span></span>

  - <span data-ttu-id="89a16-309">Jeśli zadeklarowany typ to `myType` , jest serializowany jako `IXmlSerializable` .</span><span class="sxs-lookup"><span data-stu-id="89a16-309">If the declared type is `myType`, it is serialized as `IXmlSerializable`.</span></span>

  - <span data-ttu-id="89a16-310">Jeśli zadeklarowany typ to `IXmlSerializable` , jest serializowany jako `IXmlSerializable` , ale tylko wtedy, gdy dodasz `myType` do listy znanych typów.</span><span class="sxs-lookup"><span data-stu-id="89a16-310">If the declared type is `IXmlSerializable`, it is serialized as `IXmlSerializable`, but only if you add `myType` to the list of known types.</span></span>

- <span data-ttu-id="89a16-311">Kolekcje są serializowane i deserializowane przy użyciu metod przedstawionych w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="89a16-311">Collections are serialized and deserialized using the methods shown in the following table.</span></span>

|<span data-ttu-id="89a16-312">Implementacja typu kolekcji</span><span class="sxs-lookup"><span data-stu-id="89a16-312">Collection type implements</span></span>|<span data-ttu-id="89a16-313">Metody wywoływane podczas serializacji</span><span class="sxs-lookup"><span data-stu-id="89a16-313">Method(s) called on serialization</span></span>|<span data-ttu-id="89a16-314">Metody wywoływane podczas deserializacji</span><span class="sxs-lookup"><span data-stu-id="89a16-314">Method(s) called on deserialization</span></span>|
|--------------------------------|-----------------------------------------|-------------------------------------------|
|<span data-ttu-id="89a16-315">Ogólnego<xref:System.Collections.Generic.IDictionary%602></span><span class="sxs-lookup"><span data-stu-id="89a16-315">Generic <xref:System.Collections.Generic.IDictionary%602></span></span>|<span data-ttu-id="89a16-316">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="89a16-316">`get_Keys`, `get_Values`</span></span>|<span data-ttu-id="89a16-317">Dodawanie ogólne</span><span class="sxs-lookup"><span data-stu-id="89a16-317">Generic Add</span></span>|
|<xref:System.Collections.IDictionary>|<span data-ttu-id="89a16-318">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="89a16-318">`get_Keys`, `get_Values`</span></span>|`Add`|
|<span data-ttu-id="89a16-319">Ogólnego<xref:System.Collections.Generic.IList%601></span><span class="sxs-lookup"><span data-stu-id="89a16-319">Generic <xref:System.Collections.Generic.IList%601></span></span>|<span data-ttu-id="89a16-320"><xref:System.Collections.Generic.IList%601>Indeksator ogólny</span><span class="sxs-lookup"><span data-stu-id="89a16-320">Generic <xref:System.Collections.Generic.IList%601> indexer</span></span>|<span data-ttu-id="89a16-321">Dodawanie ogólne</span><span class="sxs-lookup"><span data-stu-id="89a16-321">Generic Add</span></span>|
|<span data-ttu-id="89a16-322">Ogólnego<xref:System.Collections.Generic.ICollection%601></span><span class="sxs-lookup"><span data-stu-id="89a16-322">Generic <xref:System.Collections.Generic.ICollection%601></span></span>|<span data-ttu-id="89a16-323">Liczeni</span><span class="sxs-lookup"><span data-stu-id="89a16-323">Enumerator</span></span>|<span data-ttu-id="89a16-324">Dodawanie ogólne</span><span class="sxs-lookup"><span data-stu-id="89a16-324">Generic Add</span></span>|
|<xref:System.Collections.IList>|<span data-ttu-id="89a16-325"><xref:System.Collections.IList>Indeksatora</span><span class="sxs-lookup"><span data-stu-id="89a16-325"><xref:System.Collections.IList> Indexer</span></span>|`Add`|
|<span data-ttu-id="89a16-326">Ogólnego<xref:System.Collections.Generic.IEnumerable%601></span><span class="sxs-lookup"><span data-stu-id="89a16-326">Generic <xref:System.Collections.Generic.IEnumerable%601></span></span>|`GetEnumerator`|<span data-ttu-id="89a16-327">Metoda niestatyczna wywołana `Add` , która przyjmuje jeden parametr odpowiedniego typu (typ parametru generycznego lub jeden z jego typów podstawowych).</span><span class="sxs-lookup"><span data-stu-id="89a16-327">A non-static method called `Add` that takes one parameter of the appropriate type (the type of the generic parameter or one of its base types).</span></span> <span data-ttu-id="89a16-328">Taka metoda musi istnieć, aby serializator traktował typ kolekcji jako kolekcję podczas serializacji i deserializacji.</span><span class="sxs-lookup"><span data-stu-id="89a16-328">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|
|<span data-ttu-id="89a16-329"><xref:System.Collections.IEnumerable>(i w ten sposób <xref:System.Collections.ICollection> , który od niego pochodzi)</span><span class="sxs-lookup"><span data-stu-id="89a16-329"><xref:System.Collections.IEnumerable> (and thus <xref:System.Collections.ICollection>, which derives from it)</span></span>|`GetEnumerator`|<span data-ttu-id="89a16-330">Metoda niestatyczna o nazwie `Add` , która przyjmuje jeden parametr typu `Object` .</span><span class="sxs-lookup"><span data-stu-id="89a16-330">A non-static method called `Add` that takes one parameter of type `Object`.</span></span> <span data-ttu-id="89a16-331">Taka metoda musi istnieć, aby serializator traktował typ kolekcji jako kolekcję podczas serializacji i deserializacji.</span><span class="sxs-lookup"><span data-stu-id="89a16-331">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|

<span data-ttu-id="89a16-332">Powyższa tabela zawiera listę interfejsów kolekcji w kolejności malejącej.</span><span class="sxs-lookup"><span data-stu-id="89a16-332">The preceding table lists collection interfaces in descending order of precedence.</span></span> <span data-ttu-id="89a16-333">Oznacza to, na przykład, że jeśli typ implementuje obie <xref:System.Collections.IList> i ogólne <xref:System.Collections.Generic.IEnumerable%601> , kolekcja jest serializowana i deserializowana zgodnie z <xref:System.Collections.IList> regułami:</span><span class="sxs-lookup"><span data-stu-id="89a16-333">This means, for example, that if a type implements both <xref:System.Collections.IList> and Generic <xref:System.Collections.Generic.IEnumerable%601>, the collection is serialized and deserialized according to the <xref:System.Collections.IList> rules:</span></span>

- <span data-ttu-id="89a16-334">Podczas deserializacji wszystkie kolekcje są deserializowane przez utworzenie wystąpienia typu przez wywołanie konstruktora bez parametrów, który musi być obecny, aby serializator traktował typ kolekcji jako kolekcję podczas serializacji i deserializacji.</span><span class="sxs-lookup"><span data-stu-id="89a16-334">At deserialization, all collections are deserialized by first creating an instance of the type by calling the parameterless constructor, which must be present for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>

- <span data-ttu-id="89a16-335">Jeśli ten sam interfejs kolekcji ogólnej jest zaimplementowany więcej niż raz (na przykład jeśli typ implementuje zarówno rodzajowy <xref:System.Collections.Generic.ICollection%601> `Integer` , jak i ogólny <xref:System.Collections.Generic.ICollection%601> <xref:System.String> ) i nie zostanie znaleziony żaden interfejs o wyższym priorytecie, kolekcja nie będzie traktowana jako prawidłowa kolekcja.</span><span class="sxs-lookup"><span data-stu-id="89a16-335">If the same generic collection interface is implemented more than once (for example, if a type implements both Generic <xref:System.Collections.Generic.ICollection%601> of `Integer` and Generic <xref:System.Collections.Generic.ICollection%601> of <xref:System.String>) and no higher-precedence interface is found, the collection is not treated as a valid collection.</span></span>

- <span data-ttu-id="89a16-336">Do typów kolekcji można <xref:System.SerializableAttribute> zastosować atrybut i można zaimplementować <xref:System.Runtime.Serialization.ISerializable> interfejs.</span><span class="sxs-lookup"><span data-stu-id="89a16-336">Collection types can have the <xref:System.SerializableAttribute> attribute applied to them and can implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span> <span data-ttu-id="89a16-337">Oba te elementy są ignorowane.</span><span class="sxs-lookup"><span data-stu-id="89a16-337">Both of these are ignored.</span></span> <span data-ttu-id="89a16-338">Jeśli jednak typ nie spełnia wymagań dotyczących typu kolekcji (na przykład w przypadku `Add` braku metody), typ nie jest uważany za typ kolekcji i w ten sposób <xref:System.SerializableAttribute> atrybut i <xref:System.Runtime.Serialization.ISerializable> interfejs są używane do określenia, czy typ może być serializowany.</span><span class="sxs-lookup"><span data-stu-id="89a16-338">However, if the type does not fully meet collection type requirements (for example, the `Add` method is missing), the type is not considered a collection type, and thus the <xref:System.SerializableAttribute> attribute and the <xref:System.Runtime.Serialization.ISerializable> interface are used to determine whether the type can be serialized.</span></span>

- <span data-ttu-id="89a16-339">Zastosowanie <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu do kolekcji w celu jego dostosowania spowoduje usunięcie <xref:System.SerializableAttribute> poprzedniego mechanizmu powrotu.</span><span class="sxs-lookup"><span data-stu-id="89a16-339">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a collection to customize it removes the <xref:System.SerializableAttribute> preceding fallback mechanism.</span></span> <span data-ttu-id="89a16-340">Zamiast tego, jeśli dostosowana kolekcja nie spełnia wymagań dotyczących typu kolekcji, <xref:System.Runtime.Serialization.InvalidDataContractException> zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="89a16-340">Instead, if a customized collection does not meet collection type requirements, an <xref:System.Runtime.Serialization.InvalidDataContractException> exception is thrown.</span></span> <span data-ttu-id="89a16-341">Ciąg wyjątku często zawiera informacje wyjaśniające, dlaczego dany typ nie jest traktowany jako prawidłowa kolekcja (bez `Add` metody, bez parametrów, i tak dalej), więc często warto zastosować <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybut do celów debugowania.</span><span class="sxs-lookup"><span data-stu-id="89a16-341">The exception string often contains information that explains why a given type is not considered a valid collection (no `Add` method, no parameterless constructor, and so on), so it is often useful to apply the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute for debugging purposes.</span></span>

### <a name="collection-naming"></a><span data-ttu-id="89a16-342">Nazewnictwo kolekcji</span><span class="sxs-lookup"><span data-stu-id="89a16-342">Collection Naming</span></span>

<span data-ttu-id="89a16-343">Poniżej znajduje się lista reguł nazewnictwa kolekcji:</span><span class="sxs-lookup"><span data-stu-id="89a16-343">The following is a list of collection naming rules:</span></span>

- <span data-ttu-id="89a16-344">Domyślna przestrzeń nazw dla wszystkich kontraktów danych kolekcji słowników, a także dla kontraktów danych kolekcji list zawierających typy pierwotne, jest `http://schemas.microsoft.com/2003/10/Serialization/Arrays` chyba że zostanie zastąpiona przy użyciu przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="89a16-344">The default namespace for all dictionary collection data contracts, as well as for list collection data contracts that contain primitive types, is `http://schemas.microsoft.com/2003/10/Serialization/Arrays` unless overridden using Namespace.</span></span> <span data-ttu-id="89a16-345">Typy mapowane na wbudowane typy XSD, `char` a także, `Timespan` i, `Guid` są uznawane za elementy pierwotne w tym celu.</span><span class="sxs-lookup"><span data-stu-id="89a16-345">Types that map to built-in XSD types, as well as `char`, `Timespan`, and `Guid` types, are considered primitives for this purpose.</span></span>

- <span data-ttu-id="89a16-346">Domyślna przestrzeń nazw dla typów kolekcji, które zawierają typy niepierwotne, chyba że zostanie zastąpiona przy użyciu przestrzeni nazw, jest taka sama jak przestrzeń nazw kontraktu danych typu zawartego w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="89a16-346">The default namespace for collection types that contain non-primitive types, unless it is overridden using Namespace, is the same as the data contract namespace of the type contained in the collection.</span></span>

- <span data-ttu-id="89a16-347">Nazwa domyślna dla kontraktów danych kolekcji list, chyba że zostanie zastąpiona przy użyciu nazwy, jest ciągiem "ArrayOf", połączonym z nazwą kontraktu danych typu zawartego w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="89a16-347">The default name for list collection data contracts, unless overridden using Name, is the string "ArrayOf" combined with the data contract name of the type contained in the collection.</span></span> <span data-ttu-id="89a16-348">Na przykład nazwa kontraktu danych dla ogólnej listy liczb całkowitych to "ArrayOfint".</span><span class="sxs-lookup"><span data-stu-id="89a16-348">For example, the data contract name for a Generic List of Integers is "ArrayOfint".</span></span> <span data-ttu-id="89a16-349">Pamiętaj, że nazwa kontraktu danych `Object` to "anyType", więc nazwa kontraktu danych nieogólnych list, takich jak <xref:System.Collections.ArrayList> "ArrayOfanyType".</span><span class="sxs-lookup"><span data-stu-id="89a16-349">Keep in mind that the data contract name of `Object` is "anyType", so the data contract name of non-generic lists like <xref:System.Collections.ArrayList> is "ArrayOfanyType".</span></span>

<span data-ttu-id="89a16-350">Nazwa domyślna dla kontraktów danych kolekcji słowników, chyba że jest zastępowana przy użyciu `Name` , jest ciągiem "ArrayOfKeyValueOf", połączonym z nazwą kontraktu danych typu klucza, po którym następuje nazwa kontraktu danych typu wartości.</span><span class="sxs-lookup"><span data-stu-id="89a16-350">The default name for dictionary collection data contracts, unless overridden using `Name`, is the string "ArrayOfKeyValueOf" combined with the data contract name of the key type followed by the data contract name of the value type.</span></span> <span data-ttu-id="89a16-351">Na przykład nazwa kontraktu danych dla słownika generycznego String i Integer to "ArrayOfKeyValueOfstringint".</span><span class="sxs-lookup"><span data-stu-id="89a16-351">For example, the data contract name for a Generic Dictionary of String and Integer is "ArrayOfKeyValueOfstringint".</span></span> <span data-ttu-id="89a16-352">Ponadto jeśli klucz lub typy wartości nie są typami pierwotnymi, skrót przestrzeni nazw obszaru nazw kontraktu danych klucza i wartości jest dołączany do nazwy.</span><span class="sxs-lookup"><span data-stu-id="89a16-352">Additionally, if either the key or the value types are not primitive types, a namespace hash of the data contract namespaces of the key and value types is appended to the name.</span></span> <span data-ttu-id="89a16-353">Aby uzyskać więcej informacji na temat skrótów przestrzeni nazw, zobacz [nazwy kontraktów danych](data-contract-names.md).</span><span class="sxs-lookup"><span data-stu-id="89a16-353">For more information about namespace hashes, see [Data Contract Names](data-contract-names.md).</span></span>

<span data-ttu-id="89a16-354">Każdy kontrakt danych kolekcji słowników ma kontrakt danych pomocnika, który reprezentuje jeden wpis w słowniku.</span><span class="sxs-lookup"><span data-stu-id="89a16-354">Each dictionary collection data contract has a companion data contract that represents one entry in the dictionary.</span></span> <span data-ttu-id="89a16-355">Jego nazwa jest taka sama jak dla kontraktu danych słownika, z wyjątkiem prefiksu "ArrayOf", a jego przestrzeń nazw jest taka sama jak dla kontraktu danych słownika.</span><span class="sxs-lookup"><span data-stu-id="89a16-355">Its name is the same as for the dictionary data contract, except for the "ArrayOf" prefix, and its namespace is the same as for the dictionary data contract.</span></span> <span data-ttu-id="89a16-356">Na przykład dla kontraktu danych słownika "ArrayOfKeyValueOfstringint" kontrakt danych "KeyValueofstringint" reprezentuje jeden wpis w słowniku.</span><span class="sxs-lookup"><span data-stu-id="89a16-356">For example, for the "ArrayOfKeyValueOfstringint" dictionary data contract, the "KeyValueofstringint" data contract represents one entry in the dictionary.</span></span> <span data-ttu-id="89a16-357">Nazwę tego kontraktu danych można dostosować przy użyciu `ItemName` właściwości, zgodnie z opisem w następnej sekcji.</span><span class="sxs-lookup"><span data-stu-id="89a16-357">You can customize the name of this data contract by using the `ItemName` property, as described in the next section.</span></span>

<span data-ttu-id="89a16-358">Reguły nazewnictwa typów ogólnych, zgodnie z opisem w [nazwach kontraktów danych](data-contract-names.md), w pełni stosowane do typów kolekcji; oznacza to, że można użyć nawiasów klamrowych w nazwie do wskazania parametrów typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="89a16-358">Generic type naming rules, as described in [Data Contract Names](data-contract-names.md), fully apply to collection types; that is, you can use curly braces within Name to indicate generic type parameters.</span></span> <span data-ttu-id="89a16-359">Jednakże liczby w nawiasach klamrowych odnoszą się do parametrów ogólnych, a nie typów zawartych w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="89a16-359">However, numbers within the braces refer to generic parameters and not types contained within the collection.</span></span>

## <a name="collection-customization"></a><span data-ttu-id="89a16-360">Dostosowanie kolekcji</span><span class="sxs-lookup"><span data-stu-id="89a16-360">Collection Customization</span></span>

<span data-ttu-id="89a16-361">Następujące zastosowania <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu są zabronione i powodują <xref:System.Runtime.Serialization.InvalidDataContractException> wyjątek:</span><span class="sxs-lookup"><span data-stu-id="89a16-361">The following uses of the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute are forbidden and result in an <xref:System.Runtime.Serialization.InvalidDataContractException> exception:</span></span>

- <span data-ttu-id="89a16-362">Zastosowanie <xref:System.Runtime.Serialization.DataContractAttribute> atrybutu do typu, do którego <xref:System.Runtime.Serialization.CollectionDataContractAttribute> zastosowano atrybut, lub do jednego z jego typów pochodnych.</span><span class="sxs-lookup"><span data-stu-id="89a16-362">Applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to a type to which the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute has been applied, or to one of its derived types.</span></span>

- <span data-ttu-id="89a16-363">Stosowanie <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu do typu, który implementuje <xref:System.Xml.Serialization.IXmlSerializable> interfejs.</span><span class="sxs-lookup"><span data-stu-id="89a16-363">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a type that implements the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>

- <span data-ttu-id="89a16-364">Stosowanie <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu do typu niebędącego kolekcją.</span><span class="sxs-lookup"><span data-stu-id="89a16-364">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a non-collection type.</span></span>

- <span data-ttu-id="89a16-365">Podjęto próbę ustawienia <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> lub <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> <xref:System.Runtime.Serialization.CollectionDataContractAttribute> zastosowania atrybutu do typu innego niż słownik.</span><span class="sxs-lookup"><span data-stu-id="89a16-365">Attempting to set <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> or <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> on a <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute applied to a non-dictionary type.</span></span>

### <a name="polymorphism-rules"></a><span data-ttu-id="89a16-366">Reguły polimorfizmu</span><span class="sxs-lookup"><span data-stu-id="89a16-366">Polymorphism Rules</span></span>

<span data-ttu-id="89a16-367">Jak wspomniano wcześniej, dostosowanie kolekcji przy użyciu <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu może zakłócać możliwość zmiany kolekcji.</span><span class="sxs-lookup"><span data-stu-id="89a16-367">As previously mentioned, customizing collections by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute may interfere with collection interchangeability.</span></span> <span data-ttu-id="89a16-368">Dwa niestandardowe typy kolekcji mogą być uważane za równoważne tylko wtedy, gdy ich nazwy, przestrzeń nazw, nazwa elementu, a także nazwy kluczy i wartości (jeśli są to kolekcje słownika), są zgodne.</span><span class="sxs-lookup"><span data-stu-id="89a16-368">Two customized collection types can only be considered equivalent if their name, namespace, item name, as well as key and value names (if these are dictionary collections) match.</span></span>

<span data-ttu-id="89a16-369">Ze względu na dostosowania można przypadkowo użyć jednego kontraktu danych kolekcji, w którym jest oczekiwany inny.</span><span class="sxs-lookup"><span data-stu-id="89a16-369">Due to customizations, it is possible to inadvertently use one collection data contract where another is expected.</span></span> <span data-ttu-id="89a16-370">Należy to uniknąć.</span><span class="sxs-lookup"><span data-stu-id="89a16-370">This should be avoided.</span></span> <span data-ttu-id="89a16-371">Zobacz następujące typy.</span><span class="sxs-lookup"><span data-stu-id="89a16-371">See the following types.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#11)]
[!code-vb[c_collection_types_in_data_contracts#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#11)]

<span data-ttu-id="89a16-372">W takim przypadku wystąpienie `Marks1` może być przypisane do `testMarks` .</span><span class="sxs-lookup"><span data-stu-id="89a16-372">In this case, an instance of `Marks1` can be assigned to `testMarks`.</span></span> <span data-ttu-id="89a16-373">`Marks2`Nie należy jednak używać, ponieważ jego kontrakt danych nie jest uważany za odpowiednik `IList<int>` kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="89a16-373">However, `Marks2` should not be used because its data contract is not considered equivalent to the `IList<int>` data contract.</span></span> <span data-ttu-id="89a16-374">Nazwa kontraktu danych to "Marks2", a nie "ArrayOfint", a powtarzająca się nazwa elementu to " \<mark> ", a nie " \<int> ".</span><span class="sxs-lookup"><span data-stu-id="89a16-374">The data contract name is "Marks2" and not "ArrayOfint", and the repeating element name is "\<mark>" and not "\<int>".</span></span>

<span data-ttu-id="89a16-375">Reguły w poniższej tabeli dotyczą przypisywania polimorficznych kolekcji.</span><span class="sxs-lookup"><span data-stu-id="89a16-375">The rules in the following table apply to polymorphic assignment of collections.</span></span>

|<span data-ttu-id="89a16-376">Zadeklarowany typ</span><span class="sxs-lookup"><span data-stu-id="89a16-376">Declared type</span></span>|<span data-ttu-id="89a16-377">Przypisywanie niedostosowanej kolekcji</span><span class="sxs-lookup"><span data-stu-id="89a16-377">Assigning a non-customized collection</span></span>|<span data-ttu-id="89a16-378">Przypisywanie dostosowanej kolekcji</span><span class="sxs-lookup"><span data-stu-id="89a16-378">Assigning a customized collection</span></span>|
|-------------------|--------------------------------------------|---------------------------------------|
|<span data-ttu-id="89a16-379">Obiekt</span><span class="sxs-lookup"><span data-stu-id="89a16-379">Object</span></span>|<span data-ttu-id="89a16-380">Nazwa kontraktu jest serializowana.</span><span class="sxs-lookup"><span data-stu-id="89a16-380">Contract name is serialized.</span></span>|<span data-ttu-id="89a16-381">Nazwa kontraktu jest serializowana.</span><span class="sxs-lookup"><span data-stu-id="89a16-381">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="89a16-382">Użycie dostosowania.</span><span class="sxs-lookup"><span data-stu-id="89a16-382">Customization is used.</span></span>|
|<span data-ttu-id="89a16-383">Interfejs kolekcji</span><span class="sxs-lookup"><span data-stu-id="89a16-383">Collection interface</span></span>|<span data-ttu-id="89a16-384">Nazwa kontraktu nie jest serializowana.</span><span class="sxs-lookup"><span data-stu-id="89a16-384">Contract name is not serialized.</span></span>|<span data-ttu-id="89a16-385">Nazwa kontraktu nie jest serializowana.</span><span class="sxs-lookup"><span data-stu-id="89a16-385">Contract name is not serialized.</span></span><br /><br /> <span data-ttu-id="89a16-386">Dostosowywanie nie jest używane.\*</span><span class="sxs-lookup"><span data-stu-id="89a16-386">Customization is not used.\*</span></span>|
|<span data-ttu-id="89a16-387">Dostosowana kolekcja</span><span class="sxs-lookup"><span data-stu-id="89a16-387">Non-customized collection</span></span>|<span data-ttu-id="89a16-388">Nazwa kontraktu nie jest serializowana.</span><span class="sxs-lookup"><span data-stu-id="89a16-388">Contract name is not serialized.</span></span>|<span data-ttu-id="89a16-389">Nazwa kontraktu jest serializowana.</span><span class="sxs-lookup"><span data-stu-id="89a16-389">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="89a16-390">Użyto dostosowania. \* \*</span><span class="sxs-lookup"><span data-stu-id="89a16-390">Customization is used.\*\*</span></span>|
|<span data-ttu-id="89a16-391">Dostosowana kolekcja</span><span class="sxs-lookup"><span data-stu-id="89a16-391">Customized collection</span></span>|<span data-ttu-id="89a16-392">Nazwa kontraktu jest serializowana.</span><span class="sxs-lookup"><span data-stu-id="89a16-392">Contract name is serialized.</span></span> <span data-ttu-id="89a16-393">Dostosowywanie nie jest używane.\*\*</span><span class="sxs-lookup"><span data-stu-id="89a16-393">Customization is not used.\*\*</span></span>|<span data-ttu-id="89a16-394">Nazwa kontraktu jest serializowana.</span><span class="sxs-lookup"><span data-stu-id="89a16-394">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="89a16-395">Używane jest dostosowanie przypisanego typu.\*\*</span><span class="sxs-lookup"><span data-stu-id="89a16-395">Customization of the assigned type is used.\*\*</span></span>|

<span data-ttu-id="89a16-396">\*<xref:System.Runtime.Serialization.NetDataContractSerializer>W przypadku klasy dostosowanie jest używane w tym przypadku.</span><span class="sxs-lookup"><span data-stu-id="89a16-396">\*With the <xref:System.Runtime.Serialization.NetDataContractSerializer> class, customization is used in this case.</span></span> <span data-ttu-id="89a16-397"><xref:System.Runtime.Serialization.NetDataContractSerializer>Klasa również serializacji rzeczywistej nazwy typu w tym przypadku, dlatego deserializacja działa zgodnie z oczekiwaniami.</span><span class="sxs-lookup"><span data-stu-id="89a16-397">The <xref:System.Runtime.Serialization.NetDataContractSerializer> class also serializes the actual type name in this case, so deserialization works as expected.</span></span>

<span data-ttu-id="89a16-398">\*\*Te przypadki powodują wystąpienie nieprawidłowych wystąpień schematu i dlatego należy je unikać.</span><span class="sxs-lookup"><span data-stu-id="89a16-398">\*\*These cases result in schema-invalid instances and thus should be avoided.</span></span>

<span data-ttu-id="89a16-399">W przypadkach, gdy nazwa kontraktu jest serializowana, przypisany typ kolekcji powinien znajdować się na liście znanych typów.</span><span class="sxs-lookup"><span data-stu-id="89a16-399">In the cases where the contract name is serialized, the assigned collection type should be in the known types list.</span></span> <span data-ttu-id="89a16-400">Przeciwieństwo również jest prawdziwe: w przypadkach, gdy nazwa nie jest serializowana, dodanie typu do listy znanych typów nie jest wymagane.</span><span class="sxs-lookup"><span data-stu-id="89a16-400">The opposite is also true: in the cases where the name is not serialized, adding the type to the known types list is not required.</span></span>

<span data-ttu-id="89a16-401">Tablica typu pochodnego może być przypisana do tablicy typu podstawowego.</span><span class="sxs-lookup"><span data-stu-id="89a16-401">An array of a derived type can be assigned to an array of a base type.</span></span> <span data-ttu-id="89a16-402">W takim przypadku nazwa kontraktu dla typu pochodnego jest serializowana dla każdego powtarzanego elementu.</span><span class="sxs-lookup"><span data-stu-id="89a16-402">In this case, the contract name for the derived type is serialized for each repeating element.</span></span> <span data-ttu-id="89a16-403">Na przykład, jeśli typ `Book` pochodzi od typu, można `LibraryItem` przypisać tablicę `Book` do tablicy `LibraryItem` .</span><span class="sxs-lookup"><span data-stu-id="89a16-403">For example, if a type `Book` derives from the type `LibraryItem`, you can assign an array of `Book` to an array of `LibraryItem`.</span></span> <span data-ttu-id="89a16-404">Nie dotyczy to innych typów kolekcji.</span><span class="sxs-lookup"><span data-stu-id="89a16-404">This does not apply to other collection types.</span></span> <span data-ttu-id="89a16-405">Na przykład nie można przypisać `Generic List of Book` do elementu `Generic List of LibraryItem` .</span><span class="sxs-lookup"><span data-stu-id="89a16-405">For example, you cannot assign a `Generic List of Book` to a `Generic List of LibraryItem`.</span></span> <span data-ttu-id="89a16-406">Można jednak przypisać obiekt zawierający `Generic List of LibraryItem` `Book` wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="89a16-406">You can, however, assign a `Generic List of LibraryItem` that contains `Book` instances.</span></span> <span data-ttu-id="89a16-407">Zarówno w tablicy, jak i w przypadku nietablicowym, `Book` powinny znajdować się na liście znanych typów.</span><span class="sxs-lookup"><span data-stu-id="89a16-407">In both the array and the non-array case, `Book` should be in the known types list.</span></span>

## <a name="collections-and-object-reference-preservation"></a><span data-ttu-id="89a16-408">Przechowywanie kolekcji i odwołań do obiektów</span><span class="sxs-lookup"><span data-stu-id="89a16-408">Collections and Object Reference Preservation</span></span>

<span data-ttu-id="89a16-409">Gdy serializator działa w trybie, w którym zachowuje odwołania do obiektów, zachowywanie odwołań do obiektów ma zastosowanie również do kolekcji.</span><span class="sxs-lookup"><span data-stu-id="89a16-409">When a serializer functions in a mode where it preserves object references, object reference preservation also applies to collections.</span></span> <span data-ttu-id="89a16-410">W konkretnym przypadku tożsamość obiektu jest zachowywana dla całej kolekcji i poszczególnych elementów zawartych w kolekcjach.</span><span class="sxs-lookup"><span data-stu-id="89a16-410">Specifically, object identity is preserved for both entire collections and individual items contained in collections.</span></span> <span data-ttu-id="89a16-411">W przypadku słowników tożsamość obiektu jest zachowywana zarówno dla obiektów pary klucz/wartość, jak i poszczególnych obiektów klucza i wartości.</span><span class="sxs-lookup"><span data-stu-id="89a16-411">For dictionaries, object identity is preserved both for the key/value pair objects and the individual key and value objects.</span></span>

## <a name="see-also"></a><span data-ttu-id="89a16-412">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="89a16-412">See also</span></span>

- <xref:System.Runtime.Serialization.CollectionDataContractAttribute>
