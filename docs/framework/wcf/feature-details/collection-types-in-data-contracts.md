---
title: Typy kolekcji w kontraktach danych
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- collection types [WCF], data contracts
- data contracts [WCF], collection types
- collection types [WCF]
ms.assetid: 9b45b28e-0a82-4ea3-8c33-ec0094aff9d5
ms.openlocfilehash: 20ed5a0dab9dfc67a242ef09f459b3d00d766593
ms.sourcegitcommit: d6e27023aeaffc4b5a3cb4b88685018d6284ada4
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 07/09/2019
ms.locfileid: "67663451"
---
# <a name="collection-types-in-data-contracts"></a><span data-ttu-id="a409b-102">Typy kolekcji w kontraktach danych</span><span class="sxs-lookup"><span data-stu-id="a409b-102">Collection Types in Data Contracts</span></span>

<span data-ttu-id="a409b-103">A *kolekcji* znajduje się lista elementów określonego typu.</span><span class="sxs-lookup"><span data-stu-id="a409b-103">A *collection* is a list of items of a certain type.</span></span> <span data-ttu-id="a409b-104">W .NET Framework, takie listy mogą być reprezentowane z przy użyciu tablic lub innych typów (listy ogólnej, ogólny <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>, lub <xref:System.Collections.ArrayList>).</span><span class="sxs-lookup"><span data-stu-id="a409b-104">In the .NET Framework, such lists can be represented using arrays or a variety of other types (Generic List, Generic <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>, or <xref:System.Collections.ArrayList>).</span></span> <span data-ttu-id="a409b-105">Na przykład kolekcja może zawierać, listę adresów dla danego klienta.</span><span class="sxs-lookup"><span data-stu-id="a409b-105">For example, a collection may hold a list of Addresses for a given Customer.</span></span> <span data-ttu-id="a409b-106">Kolekcje te są nazywane *listy kolekcji*, niezależnie od ich rzeczywistego typu.</span><span class="sxs-lookup"><span data-stu-id="a409b-106">These collections are called *list collections*, regardless of their actual type.</span></span>

<span data-ttu-id="a409b-107">Istnieje specjalną postać kolekcji, która reprezentuje skojarzenie między jednego przedmiotu ("klucz"), a inny ("wartość").</span><span class="sxs-lookup"><span data-stu-id="a409b-107">A special form of collection exists that represents an association between one item (the "key") and another (the "value").</span></span> <span data-ttu-id="a409b-108">W .NET Framework, te są reprezentowane przez typy takie jak <xref:System.Collections.Hashtable> i generyczny słownik.</span><span class="sxs-lookup"><span data-stu-id="a409b-108">In the .NET Framework, these are represented by types such as <xref:System.Collections.Hashtable> and the generic dictionary.</span></span> <span data-ttu-id="a409b-109">Na przykład w kolekcji skojarzenie może być mapowany city ("key") jego populację ("value").</span><span class="sxs-lookup"><span data-stu-id="a409b-109">For example, an association collection may map a city ("key") to its population ("value").</span></span> <span data-ttu-id="a409b-110">Kolekcje te są nazywane *kolekcji słownika*, niezależnie od ich rzeczywistego typu.</span><span class="sxs-lookup"><span data-stu-id="a409b-110">These collections are called *dictionary collections*, regardless of their actual type.</span></span>

<span data-ttu-id="a409b-111">Kolekcje otrzymują specjalnego traktowania w modelu kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="a409b-111">Collections receive special treatment in the data contract model.</span></span>

<span data-ttu-id="a409b-112">Typami, które implementują <xref:System.Collections.IEnumerable> interfejsu, w tym tablice i kolekcje ogólne są rozpoznawane jako kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a409b-112">Types that implement the <xref:System.Collections.IEnumerable> interface, including arrays and generic collections, are recognized as collections.</span></span> <span data-ttu-id="a409b-113">Takie typami, które implementują <xref:System.Collections.IDictionary> lub ogólny <xref:System.Collections.Generic.IDictionary%602> interfejsy są kolekcjami słownika; wszystkie inne są listy kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a409b-113">Of those, types that implement the <xref:System.Collections.IDictionary> or Generic <xref:System.Collections.Generic.IDictionary%602> interfaces are dictionary collections; all others are list collections.</span></span>

<span data-ttu-id="a409b-114">Dodatkowe wymagania dotyczące typów kolekcji, takich jak o metodę o nazwie `Add` i domyślnego konstruktora, opisano szczegółowo w poniższych sekcjach.</span><span class="sxs-lookup"><span data-stu-id="a409b-114">Additional requirements on collection types, such as having a method called `Add` and a default constructor, are discussed in detail in the following sections.</span></span> <span data-ttu-id="a409b-115">Gwarantuje to, że typy kolekcji może być zarówno serializacji i deserializacji.</span><span class="sxs-lookup"><span data-stu-id="a409b-115">This ensures that collection types can be both serialized and deserialized.</span></span> <span data-ttu-id="a409b-116">Oznacza to, że niektóre kolekcje nie są bezpośrednio obsługiwane, takie jak typowa <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (ponieważ go nie ma domyślnego konstruktora).</span><span class="sxs-lookup"><span data-stu-id="a409b-116">This means that some collections are not directly supported, such as the Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (because it has no default constructor).</span></span> <span data-ttu-id="a409b-117">Jednak uzyskać informacji o obejściu tych ograniczeń, zobacz sekcję "Przy użyciu kolekcji interfejs typy tylko do odczytu kolekcje i" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="a409b-117">However, for information about circumventing these restrictions, see the section "Using Collection Interface Types and Read-Only Collections" later in this topic.</span></span>

<span data-ttu-id="a409b-118">Typy zawarte w kolekcji musi być typy kontraktu danych, lub w inny sposób możliwy do serializacji.</span><span class="sxs-lookup"><span data-stu-id="a409b-118">The types contained in collections must be data contract types, or be otherwise serializable.</span></span> <span data-ttu-id="a409b-119">Aby uzyskać więcej informacji, zobacz [typy obsługiwane przez serializator kontraktu danych](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="a409b-119">For more information, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span>

<span data-ttu-id="a409b-120">Aby uzyskać więcej informacji na temat nowości i co jest uznawane za prawidłowe kolekcji, a także o jak kolekcje są serializacji zobacz informacje o serializacji kolekcji w sekcji "Zaawansowane zasady kolekcji" tego tematu.</span><span class="sxs-lookup"><span data-stu-id="a409b-120">For more information about what is and what is not considered a valid collection, as well as about how collections are serialized, see the information about serializing collections in the "Advanced Collection Rules" section of this topic.</span></span>

## <a name="interchangeable-collections"></a><span data-ttu-id="a409b-121">Wymienne kolekcji</span><span class="sxs-lookup"><span data-stu-id="a409b-121">Interchangeable Collections</span></span>

<span data-ttu-id="a409b-122">Wszystkie kolekcje list tego samego typu, jest uznawany za te same dane kontraktu (o ile nie są dostosowywane przy użyciu <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu, zgodnie z opisem w dalszej części tego tematu).</span><span class="sxs-lookup"><span data-stu-id="a409b-122">All list collections of the same type are considered to have the same data contract (unless they are customized using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, as discussed later in this topic).</span></span> <span data-ttu-id="a409b-123">W związku z tym na przykład, poniższy kontraktów danych są równoważne.</span><span class="sxs-lookup"><span data-stu-id="a409b-123">Thus, for example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#0](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#0)]
[!code-vb[c_collection_types_in_data_contracts#0](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#0)]

<span data-ttu-id="a409b-124">Zarówno kontraktów danych powodować podobne do następującego kodu XML.</span><span class="sxs-lookup"><span data-stu-id="a409b-124">Both data contracts result in XML similar to the following code.</span></span>

```xml
<PurchaseOrder>
    <customerName>...</customerName>
    <items>
        <Item>...</Item>
        <Item>...</Item>
        <Item>...</Item>
        ...
    </items>
    <comments>
        <string>...</string>
        <string>...</string>
        <string>...</string>
        ...
    </comments>
</PurchaseOrder>
```

<span data-ttu-id="a409b-125">Możliwości wymiennego stosowania kolekcji umożliwia należy użyć, na przykład, typ kolekcji, zoptymalizowana pod kątem wydajności na serwerze i typ kolekcji, które mają być powiązane z składników interfejsu użytkownika na komputerze klienckim.</span><span class="sxs-lookup"><span data-stu-id="a409b-125">Collection interchangeability allows you to use, for example, a collection type optimized for performance on the server and a collection type designed to be bound to user interface components on the client.</span></span>

<span data-ttu-id="a409b-126">Podobnie jak kolekcje list, wszystkie kolekcje słownika, które mają te same typy kluczy i wartości jest uznawany za te same dane kontraktu (chyba że dostosowywane przez <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu).</span><span class="sxs-lookup"><span data-stu-id="a409b-126">Similar to list collections, all dictionary collections that have the same key and value types are considered to have the same data contract (unless customized by the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute).</span></span>

<span data-ttu-id="a409b-127">Tylko w zakresie, w jakim dotyczy kolekcji równoważności sprawach typu kontraktu danych, nie typów .NET.</span><span class="sxs-lookup"><span data-stu-id="a409b-127">Only the data contract type matters as far as collection equivalence is concerned, not .NET types.</span></span> <span data-ttu-id="a409b-128">Oznacza to zbiór Type1 jest uważany za równoważny zbiór Type2, jeśli Type1 i Type2 kontraktów danych równoważne.</span><span class="sxs-lookup"><span data-stu-id="a409b-128">That is, a collection of Type1 is considered equivalent to a collection of Type2 if Type1 and Type2 have equivalent data contracts.</span></span>

<span data-ttu-id="a409b-129">Inne niż ogólne kolekcje są uznawane za mają te same dane kontrakt co kolekcje ogólne typu `Object`.</span><span class="sxs-lookup"><span data-stu-id="a409b-129">Non-generic collections are considered to have the same data contract as generic collections of type `Object`.</span></span> <span data-ttu-id="a409b-130">(Na przykład kontraktów danych dla <xref:System.Collections.ArrayList> i ogólny <xref:System.Collections.Generic.List%601> z `Object` są takie same.)</span><span class="sxs-lookup"><span data-stu-id="a409b-130">(For example, the data contracts for <xref:System.Collections.ArrayList> and Generic <xref:System.Collections.Generic.List%601> of `Object` are the same.)</span></span>

## <a name="using-collection-interface-types-and-read-only-collections"></a><span data-ttu-id="a409b-131">Przy użyciu typów interfejsów kolekcji i kolekcji tylko do odczytu</span><span class="sxs-lookup"><span data-stu-id="a409b-131">Using Collection Interface Types and Read-Only Collections</span></span>

<span data-ttu-id="a409b-132">Typy interfejsów kolekcji (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>ogólny <xref:System.Collections.Generic.IDictionary%602>, lub interfejsy pochodzące z tych interfejsów) również są traktowane jako jako posiadające kontraktów danych kolekcji, odpowiednikiem kontraktów danych kolekcji dla typów rzeczywista kolekcja.</span><span class="sxs-lookup"><span data-stu-id="a409b-132">Collection interface types (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, generic <xref:System.Collections.Generic.IDictionary%602>, or interfaces derived from these interfaces) are also considered as having collection data contracts, equivalent to collection data contracts for actual collection types.</span></span> <span data-ttu-id="a409b-133">W związku z tym można zadeklarować typ poddany serializacji jako typ interfejsu kolekcji, a wyniki są takie same, jak użycie typu rzeczywista kolekcja.</span><span class="sxs-lookup"><span data-stu-id="a409b-133">Thus, it is possible to declare the type being serialized as a collection interface type and the results are the same as if an actual collection type had been used.</span></span> <span data-ttu-id="a409b-134">Na przykład poniższy kontraktów danych są równoważne.</span><span class="sxs-lookup"><span data-stu-id="a409b-134">For example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#1)]
[!code-vb[c_collection_types_in_data_contracts#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#1)]

<span data-ttu-id="a409b-135">Podczas serializacji gdy deklarowany typ jest interfejsem użytej do rzeczywistego wystąpienia może być dowolnego typu, który implementuje ten interfejs.</span><span class="sxs-lookup"><span data-stu-id="a409b-135">During serialization, when the declared type is an interface, the actual instance type used can be any type that implements that interface.</span></span> <span data-ttu-id="a409b-136">Ograniczenia omówionych wcześniej (o konstruktora domyślnego i `Add` metoda) nie mają zastosowania.</span><span class="sxs-lookup"><span data-stu-id="a409b-136">Restrictions discussed previously (having a default constructor and an `Add` method) do not apply.</span></span> <span data-ttu-id="a409b-137">Na przykład można ustawić adresy w Customer2 na wystąpienie klasy ogólnej <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> adresu, nawet jeśli nie można zadeklarować bezpośrednio składowa danych klasy typu ogólnego <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="a409b-137">For example, you can set addresses in Customer2 to an instance of Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> of Address, even though you cannot directly declare a data member of type Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span></span>

<span data-ttu-id="a409b-138">Podczas deserializacji gdy deklarowany typ jest interfejsem, mechanizm serializacji wybiera typ, który implementuje interfejs zadeklarowane, a typ zostanie uruchomiony.</span><span class="sxs-lookup"><span data-stu-id="a409b-138">During deserialization, when the declared type is an interface, the serialization engine chooses a type that implements the declared interface, and the type is instantiated.</span></span> <span data-ttu-id="a409b-139">Znane typy mechanizm (opisanego w [znane typy kontraktu danych](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)) nie ma wpływu w tym miejscu; wybór typu jest wbudowana w usługi WCF.</span><span class="sxs-lookup"><span data-stu-id="a409b-139">The known types mechanism (described in [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)) has no effect here; the choice of type is built into WCF.</span></span>

## <a name="customizing-collection-types"></a><span data-ttu-id="a409b-140">Dostosowywanie typów kolekcji</span><span class="sxs-lookup"><span data-stu-id="a409b-140">Customizing Collection Types</span></span>

<span data-ttu-id="a409b-141">Typy kolekcji można dostosować przy użyciu <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybut, który ma kilka zastosowań.</span><span class="sxs-lookup"><span data-stu-id="a409b-141">You can customize collection types by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, which has several uses.</span></span>

<span data-ttu-id="a409b-142">Należy zwrócić uwagę tego Dostosowywanie kolekcji typy naruszeń kolekcji wymiennego stosowania, dlatego zazwyczaj zalecane jest aby uniknąć stosowania tego atrybutu, jeśli to możliwe.</span><span class="sxs-lookup"><span data-stu-id="a409b-142">Note that customizing collection types compromises collection interchangeability, so it is generally recommended to avoid applying this attribute whenever possible.</span></span> <span data-ttu-id="a409b-143">Aby uzyskać więcej informacji na temat tego problemu zobacz sekcję "Zaawansowane zasady kolekcji" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="a409b-143">For more information about this issue, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="collection-data-contract-naming"></a><span data-ttu-id="a409b-144">Kontraktu danych kolekcji nazewnictwa</span><span class="sxs-lookup"><span data-stu-id="a409b-144">Collection Data Contract Naming</span></span>

<span data-ttu-id="a409b-145">Reguły nazewnictwa typy kolekcji są podobne do reguł nazewnictwa typy kontraktu danych regularnie, zgodnie z opisem w [nazwy kontraktów danych](../../../../docs/framework/wcf/feature-details/data-contract-names.md), chociaż istnieją pewne ważne różnice:</span><span class="sxs-lookup"><span data-stu-id="a409b-145">The rules for naming collection types are similar to those for naming regular data contract types, as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md), although some important differences exist:</span></span>

- <span data-ttu-id="a409b-146"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> Atrybut jest używany do dostosowywania nazw, zamiast <xref:System.Runtime.Serialization.DataContractAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="a409b-146">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is used to customize the name, instead of the <xref:System.Runtime.Serialization.DataContractAttribute> attribute.</span></span> <span data-ttu-id="a409b-147"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> Atrybut ma również `Name` i `Namespace` właściwości.</span><span class="sxs-lookup"><span data-stu-id="a409b-147">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute also has `Name` and `Namespace` properties.</span></span>

- <span data-ttu-id="a409b-148">Gdy <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybut nie ma zastosowania, domyślną nazwę i przestrzeń nazw dla typów kolekcji zależą od nazwy i przestrzenie nazw, typów zawartych w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a409b-148">When the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is not applied, the default name and namespace for collection types depend on the names and namespaces of types contained within the collection.</span></span> <span data-ttu-id="a409b-149">Nie wpływają one według nazwy i przestrzeń nazw samego typu kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a409b-149">They are not affected by the name and namespace of the collection type itself.</span></span> <span data-ttu-id="a409b-150">Aby uzyskać przykład zobacz następujące typy.</span><span class="sxs-lookup"><span data-stu-id="a409b-150">For an example, see the following types.</span></span>

  ```csharp
  public CustomerList1 : Collection<string> {}
  public StringList1 : Collection<string> {}
  ```

<span data-ttu-id="a409b-151">Oba typy samej nazwie kontraktu danych "ArrayOfstring" i nie jest "CustomerList1" lub "StringList1".</span><span class="sxs-lookup"><span data-stu-id="a409b-151">Both types’ data contract name is "ArrayOfstring" and not "CustomerList1" or "StringList1".</span></span> <span data-ttu-id="a409b-152">Oznacza to, że serializacji jednego z tych typów, na poziomie głównym daje podobny do następującego kodu XML.</span><span class="sxs-lookup"><span data-stu-id="a409b-152">This means that serializing any one of these types at the root level yields XML similar to the following code.</span></span>

```xml
<ArrayOfstring>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</ArrayOfstring>
```

<span data-ttu-id="a409b-153">Ta reguła nazewnictwa został wybrany do upewnij się, że dowolnego typu bez dostosowania, który reprezentuje listę ciągów ma ten sam kontrakt danych oraz reprezentację XML.</span><span class="sxs-lookup"><span data-stu-id="a409b-153">This naming rule was chosen to ensure that any non-customized type that represents a list of strings has the same data contract and XML representation.</span></span> <span data-ttu-id="a409b-154">Umożliwia możliwości wymiennego stosowania kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a409b-154">This makes collection interchangeability possible.</span></span> <span data-ttu-id="a409b-155">W tym przykładzie CustomerList1 i StringList1 są całkowicie wymienne.</span><span class="sxs-lookup"><span data-stu-id="a409b-155">In this example, CustomerList1 and StringList1 are completely interchangeable.</span></span>

<span data-ttu-id="a409b-156">Jednak gdy <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybut jest stosowany, Kolekcja staje się kontraktu danych kolekcji niestandardowych, nawet jeśli żadne właściwości są ustawione w atrybucie.</span><span class="sxs-lookup"><span data-stu-id="a409b-156">However, when the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is applied, the collection becomes a customized collection data contract, even if no properties are set on the attribute.</span></span> <span data-ttu-id="a409b-157">Nazwa i nazw danych kolekcji umowę, a następnie są zależne od samego typu kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a409b-157">The name and namespace of the collection data contract then depend on the collection type itself.</span></span> <span data-ttu-id="a409b-158">Aby uzyskać przykład zobacz następujący typ.</span><span class="sxs-lookup"><span data-stu-id="a409b-158">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#2)]
[!code-vb[c_collection_types_in_data_contracts#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#2)]

<span data-ttu-id="a409b-159">Po serializacji, wynikowy kod XML jest podobny do następującego.</span><span class="sxs-lookup"><span data-stu-id="a409b-159">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CustomerList2>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</CustomerList2>
```

<span data-ttu-id="a409b-160">Należy zauważyć, że już nie jest to równoważne Reprezentacja XML typów innych niż dostosowanego przez producenta.</span><span class="sxs-lookup"><span data-stu-id="a409b-160">Notice that this is no longer equivalent to the XML representation of the non-customized types.</span></span>

- <span data-ttu-id="a409b-161">Możesz użyć `Name` i `Namespace` właściwości w celu dalszego dostosowywania nazw.</span><span class="sxs-lookup"><span data-stu-id="a409b-161">You can use the `Name` and `Namespace` properties to further customize the naming.</span></span> <span data-ttu-id="a409b-162">Zobacz następujące klasy.</span><span class="sxs-lookup"><span data-stu-id="a409b-162">See the following class.</span></span>

  [!code-csharp[c_collection_types_in_data_contracts#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#3)]
  [!code-vb[c_collection_types_in_data_contracts#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#3)]

<span data-ttu-id="a409b-163">Wynikowy kod XML jest podobny do następującego.</span><span class="sxs-lookup"><span data-stu-id="a409b-163">The resulting XML is similar to the following.</span></span>

```xml
<cust_list>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</cust_list>
```

<span data-ttu-id="a409b-164">Aby uzyskać więcej informacji zobacz sekcję "Zaawansowane zasady kolekcji" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="a409b-164">For more information, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="customizing-the-repeating-element-name-in-list-collections"></a><span data-ttu-id="a409b-165">Dostosowywanie powtarzające się nazwy elementu w kolekcji List</span><span class="sxs-lookup"><span data-stu-id="a409b-165">Customizing the Repeating Element Name in List Collections</span></span>

<span data-ttu-id="a409b-166">Kolekcje list zawiera powtarzające się wpisów.</span><span class="sxs-lookup"><span data-stu-id="a409b-166">List collections contain repeating entries.</span></span> <span data-ttu-id="a409b-167">Zwykle każdego wpisu powtarzające się jest reprezentowany jako elementu o nazwie zgodnej ze nazwie kontraktu danych typu zawartego w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a409b-167">Normally, each repeating entry is represented as an element named according to the data contract name of the type contained in the collection.</span></span>

<span data-ttu-id="a409b-168">W `CustomerList` przykłady, ciągi kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a409b-168">In the `CustomerList` examples, the collections contained strings.</span></span> <span data-ttu-id="a409b-169">Nazwa kontraktu danych dla typu pierwotnego ciągu jest "string", więc powtarzający się element "\<Parametry >".</span><span class="sxs-lookup"><span data-stu-id="a409b-169">The data contract name for the string primitive type is "string", so the repeating element was "\<string>".</span></span>

<span data-ttu-id="a409b-170">Jednak przy użyciu <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> właściwość <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu, powtarzając ten można dostosować nazwy elementu.</span><span class="sxs-lookup"><span data-stu-id="a409b-170">However, using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property on the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, this repeating element name can be customized.</span></span> <span data-ttu-id="a409b-171">Aby uzyskać przykład zobacz następujący typ.</span><span class="sxs-lookup"><span data-stu-id="a409b-171">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#4)]
[!code-vb[c_collection_types_in_data_contracts#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#4)]

<span data-ttu-id="a409b-172">Wynikowy kod XML jest podobny do następującego.</span><span class="sxs-lookup"><span data-stu-id="a409b-172">The resulting XML is similar to the following.</span></span>

```xml
<CustomerList4>
    <customer>...</customer>
    <customer>...</customer>
    <customer>...</customer>
    ...
</CustomerList4>
```

<span data-ttu-id="a409b-173">Przestrzeń nazw powtarzający się element jest zawsze taki sam, jak przestrzeń nazw kontraktu danych kolekcji, które można dostosować za pomocą `Namespace` właściwości, zgodnie z wcześniejszym opisem.</span><span class="sxs-lookup"><span data-stu-id="a409b-173">The namespace of the repeating element is always the same as the namespace of the collection data contract, which can be customized using the `Namespace` property, as described previously.</span></span>

### <a name="customizing-dictionary-collections"></a><span data-ttu-id="a409b-174">Dostosowywanie kolekcji słownika</span><span class="sxs-lookup"><span data-stu-id="a409b-174">Customizing Dictionary Collections</span></span>

<span data-ttu-id="a409b-175">Kolekcje słownika są zasadniczo listy wpisów, gdzie każdy wpis ma klucz, a następnie według wartości.</span><span class="sxs-lookup"><span data-stu-id="a409b-175">Dictionary collections are essentially lists of entries, where each entry has a key followed by a value.</span></span> <span data-ttu-id="a409b-176">Tak samo, jak za pomocą regularnego list, można zmienić nazwy elementu, który odpowiada elementowi powtarzające się za pomocą <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="a409b-176">Just as with regular lists, you can change the element name that corresponds to the repeating element by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property.</span></span>

<span data-ttu-id="a409b-177">Ponadto można zmienić nazw elementów, które reprezentują klucz i wartość przy użyciu <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> i <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="a409b-177">Additionally, you can change the element names that represent the key and the value by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> and <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> properties.</span></span> <span data-ttu-id="a409b-178">Przestrzenie nazw dla tych elementów jest taki sam, jak przestrzeń nazw kontraktu danych kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a409b-178">The namespaces for these elements are the same as the namespace of the collection data contract.</span></span>

<span data-ttu-id="a409b-179">Aby uzyskać przykład zobacz następujący typ.</span><span class="sxs-lookup"><span data-stu-id="a409b-179">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#5)]
[!code-vb[c_collection_types_in_data_contracts#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#5)]

<span data-ttu-id="a409b-180">Po serializacji, wynikowy kod XML jest podobny do następującego.</span><span class="sxs-lookup"><span data-stu-id="a409b-180">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CountriesOrRegionsWithCapitals>
    <entry>
        <countryorregion>USA</countryorregion>
        <capital>Washington</capital>
    </entry>
    <entry>
        <countryorregion>France</countryorregion>
        <capital>Paris</capital>
    </entry>
    ...
</CountriesOrRegionsWithCapitals>
```

<span data-ttu-id="a409b-181">Aby uzyskać więcej informacji na temat kolekcji słownika zobacz sekcję "Zaawansowane zasady kolekcji" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="a409b-181">For more information about dictionary collections, see the "Advanced Collection Rules" section later in this topic.</span></span>

## <a name="collections-and-known-types"></a><span data-ttu-id="a409b-182">Kolekcje i znanych typów</span><span class="sxs-lookup"><span data-stu-id="a409b-182">Collections and Known Types</span></span>

<span data-ttu-id="a409b-183">Nie trzeba dodać typy kolekcji do znanych typów, gdy jest używana polymorphically zamiast innych kolekcji lub interfejsów kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a409b-183">You do not need to add collection types to known types when used polymorphically in place of other collections or collection interfaces.</span></span> <span data-ttu-id="a409b-184">Na przykład, jeśli Deklarujesz element członkowski danych typu <xref:System.Collections.IEnumerable> i przy jego użyciu wysłać wystąpienia <xref:System.Collections.ArrayList>, nie trzeba dodawać <xref:System.Collections.ArrayList> znanych typów.</span><span class="sxs-lookup"><span data-stu-id="a409b-184">For example, if you declare a data member of type <xref:System.Collections.IEnumerable> and use it to send an instance of <xref:System.Collections.ArrayList>, you do not need to add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="a409b-185">Gdy używasz kolekcji polymorphically zamiast typów innych niż kolekcji, należy dodać do znanych typów.</span><span class="sxs-lookup"><span data-stu-id="a409b-185">When you use collections polymorphically in place of non-collection types, they must be added to known types.</span></span> <span data-ttu-id="a409b-186">Na przykład, jeśli Deklarujesz element członkowski danych typu `Object` i przy jego użyciu wysłać wystąpienia <xref:System.Collections.ArrayList>, Dodaj <xref:System.Collections.ArrayList> znanych typów.</span><span class="sxs-lookup"><span data-stu-id="a409b-186">For example, if you declare a data member of type `Object` and use it to send an instance of <xref:System.Collections.ArrayList>, add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="a409b-187">To pozwala na polymorphically serializacji kolekcji równoważne.</span><span class="sxs-lookup"><span data-stu-id="a409b-187">This does not allow you to serialize any equivalent collection polymorphically.</span></span> <span data-ttu-id="a409b-188">Na przykład po dodaniu <xref:System.Collections.ArrayList> do listy znanych typów w poprzednim przykładzie, to nie umożliwiają przypisywanie `Array of Object` klasy, nawet jeśli ma on kontraktu danych równoważne.</span><span class="sxs-lookup"><span data-stu-id="a409b-188">For example, when you add <xref:System.Collections.ArrayList> to the list of known types in the preceding example, this does not let you assign the `Array of Object` class, even though it has an equivalent data contract.</span></span> <span data-ttu-id="a409b-189">To nie różni się od zachowania regularne znane typy na serializacji dla typów innych niż kolekcji, ale jest szczególnie ważne, aby zrozumieć w przypadku kolekcji, ponieważ jest ono często kolekcji jako równoważne.</span><span class="sxs-lookup"><span data-stu-id="a409b-189">This is no different from regular known types behavior on serialization for non-collection types, but it is especially important to understand in the case of collections because it is very common for collections to be equivalent.</span></span>

<span data-ttu-id="a409b-190">Podczas serializacji tylko jeden typ może być znane, w dowolnym danym zakresie dla kontraktu danych, a równoważne kolekcje wszystkie mają ten sam kontraktów danych.</span><span class="sxs-lookup"><span data-stu-id="a409b-190">During serialization, only one type can be known in any given scope for a given data contract, and equivalent collections all have the same data contracts.</span></span> <span data-ttu-id="a409b-191">Oznacza to, że w poprzednim przykładzie, nie można dodać oba <xref:System.Collections.ArrayList> i `Array of Object` do znanych typów w tym samym zakresie.</span><span class="sxs-lookup"><span data-stu-id="a409b-191">This means that, in the previous example, you cannot add both <xref:System.Collections.ArrayList> and `Array of Object` to known types at the same scope.</span></span> <span data-ttu-id="a409b-192">Ponownie jest to równoważne zachowanie znane typy dla typów innych niż kolekcji, ale jest szczególnie ważne, aby zrozumieć dla kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a409b-192">Again, this is equivalent to known types behavior for non-collection types, but it is especially important to understand for collections.</span></span>

<span data-ttu-id="a409b-193">Znane typy mogą być również wymagane dla zawartości z kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a409b-193">Known types may also be required for contents of collections.</span></span> <span data-ttu-id="a409b-194">Na przykład jeśli <xref:System.Collections.ArrayList> faktycznie zawiera wystąpienia `Type1` i `Type2`, oba te typy powinny zostać dodane do znanych typów.</span><span class="sxs-lookup"><span data-stu-id="a409b-194">For example, if an <xref:System.Collections.ArrayList> actually contains instances of `Type1` and `Type2`, both of these types should be added to known types.</span></span>

<span data-ttu-id="a409b-195">Poniższy przykład przedstawia wykres obiektu poprawnie skonstruowany przy użyciu kolekcji i znanych typów.</span><span class="sxs-lookup"><span data-stu-id="a409b-195">The following example shows a properly constructed object graph using collections and known types.</span></span> <span data-ttu-id="a409b-196">Przykład jest contrived nieco, ponieważ w rzeczywistej aplikacji będzie zwykle nie definiują następujące elementy członkowskie danych jako `Object`i dlatego nie ma problemów znanego typu/polimorfizmu.</span><span class="sxs-lookup"><span data-stu-id="a409b-196">The example is somewhat contrived, because in an actual application you would normally not define the following data members as `Object`, and thus do not have any known type/polymorphism issues.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#6)]
[!code-vb[c_collection_types_in_data_contracts#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#6)]

<span data-ttu-id="a409b-197">Na deserializacji gdy deklarowany typ jest typem kolekcji deklarowany typ jest tworzone bez względu na typ, który faktycznie został wysłany.</span><span class="sxs-lookup"><span data-stu-id="a409b-197">On deserialization, if the declared type is a collection type, the declared type is instantiated regardless of the type that was actually sent.</span></span> <span data-ttu-id="a409b-198">Deklarowany typ jest interfejsem kolekcji, Deserializator wybiera typ, który ma zostać utworzona nie w odniesieniu do znanych typów.</span><span class="sxs-lookup"><span data-stu-id="a409b-198">If the declared type is a collection interface, the deserializer picks a type to be instantiated with no regard to known types.</span></span>

<span data-ttu-id="a409b-199">Również na deserializacji, jeśli deklarowany typ jest typem kolekcji, ale typem kolekcji jest przesyłany, o pasującym typie kolekcji jest pobierany z listy znanych typów.</span><span class="sxs-lookup"><span data-stu-id="a409b-199">Also on deserialization, if the declared type is not a collection type but a collection type is being sent, a matching collection type is picked out of the known types list.</span></span> <span data-ttu-id="a409b-200">Istnieje możliwość dodawania kolekcji interfejs typów do listy znanych typów, przy deserializacji.</span><span class="sxs-lookup"><span data-stu-id="a409b-200">It is possible to add collection interface types to the list of known types on deserialization.</span></span> <span data-ttu-id="a409b-201">W tym przypadku aparat deserializacji ponownie wybiera typ, który ma zostać utworzona.</span><span class="sxs-lookup"><span data-stu-id="a409b-201">In this case, the deserialization engine again picks a type to be instantiated.</span></span>

## <a name="collections-and-the-netdatacontractserializer-class"></a><span data-ttu-id="a409b-202">Kolekcje i klasa NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="a409b-202">Collections and the NetDataContractSerializer Class</span></span>

<span data-ttu-id="a409b-203">Podczas <xref:System.Runtime.Serialization.NetDataContractSerializer> klasy jest w użyciu, typy kolekcji bez dostosowania (bez <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybut), są tablice nie utracić ich specjalnego znaczenia.</span><span class="sxs-lookup"><span data-stu-id="a409b-203">When the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use, non-customized collection types (without the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute) that are not arrays lose their special meaning.</span></span>

<span data-ttu-id="a409b-204">Typy kolekcji dostosowanego przez producenta nie jest oznaczona za pomocą <xref:System.SerializableAttribute> atrybut nadal może być serializowany przez <xref:System.Runtime.Serialization.NetDataContractSerializer> klasy zgodnie z opisem w <xref:System.SerializableAttribute> atrybutu lub <xref:System.Runtime.Serialization.ISerializable> interfejsu reguły.</span><span class="sxs-lookup"><span data-stu-id="a409b-204">Non-customized collection types marked with the <xref:System.SerializableAttribute> attribute can still be serialized by the <xref:System.Runtime.Serialization.NetDataContractSerializer> class according to the <xref:System.SerializableAttribute> attribute or the <xref:System.Runtime.Serialization.ISerializable> interface rules.</span></span>

<span data-ttu-id="a409b-205">Typy kolekcji niestandardowych, interfejsów kolekcji i tablic nadal są traktowane jako kolekcji, nawet wtedy, gdy <xref:System.Runtime.Serialization.NetDataContractSerializer> klasa jest używana.</span><span class="sxs-lookup"><span data-stu-id="a409b-205">Customized collection types, collection interfaces, and arrays are still treated as collections, even when the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use.</span></span>

## <a name="collections-and-schema"></a><span data-ttu-id="a409b-206">Kolekcje i schematu</span><span class="sxs-lookup"><span data-stu-id="a409b-206">Collections and Schema</span></span>

<span data-ttu-id="a409b-207">Wszystkie kolekcje równoważne mają tę samą reprezentację w schemacie języka (XSD) definicji schematu XML.</span><span class="sxs-lookup"><span data-stu-id="a409b-207">All equivalent collections have the same representation in XML Schema definition language (XSD) schema.</span></span> <span data-ttu-id="a409b-208">W związku z tym zazwyczaj nie uzyskasz tego samego typu kolekcji w kodzie wygenerowanego klienta, na serwerze.</span><span class="sxs-lookup"><span data-stu-id="a409b-208">Because of this, you normally do not get the same collection type in the generated client code as the one on the server.</span></span> <span data-ttu-id="a409b-209">Na przykład serwer może wykorzystać kontraktu danych za pomocą rodzajowego <xref:System.Collections.Generic.List%601> liczby całkowitej składowej danych, ale w kodzie wygenerowanego klienta ten sam element członkowski danych może stać się tablicy liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="a409b-209">For example, the server may use a data contract with a Generic <xref:System.Collections.Generic.List%601> of Integer data member, but in the generated client code the same data member may become an array of integers.</span></span>

<span data-ttu-id="a409b-210">Słownik kolekcje są oznaczone adnotację schematu specyficzne dla usługi WCF, wskazujące, że są one słowników; w przeciwnym razie są nie do odróżnienia od prostych list, które zawierają wpisów z kluczem i wartością.</span><span class="sxs-lookup"><span data-stu-id="a409b-210">Dictionary collections are marked with a WCF-specific schema annotation that indicate that they are dictionaries; otherwise, they are indistinguishable from simple lists that contain entries with a key and a value.</span></span> <span data-ttu-id="a409b-211">Aby uzyskać dokładny opis jak kolekcje są reprezentowane w schematu kontraktu danych, zobacz [odwołanie do schematu kontraktu danych](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="a409b-211">For an exact description of how collections are represented in data contract schema, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>

<span data-ttu-id="a409b-212">Domyślnie typy nie są generowane dla innych dostosowanego przez producenta kolekcji w programie code zaimportowane.</span><span class="sxs-lookup"><span data-stu-id="a409b-212">By default, types are not generated for non-customized collections in imported code.</span></span> <span data-ttu-id="a409b-213">Typy kolekcji list składowych danych są importowane jako tablice i typy kolekcji: słownikowy elementów członkowskich danych są importowane jako generyczny słownik.</span><span class="sxs-lookup"><span data-stu-id="a409b-213">Data members of list collection types are imported as arrays, and data members of dictionary collection types are imported as Generic Dictionary.</span></span>

<span data-ttu-id="a409b-214">Jednak dla kolekcji niestandardowych, oddzielne typy są generowane, oznaczone <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="a409b-214">However, for customized collections, separate types are generated, marked with the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute.</span></span> <span data-ttu-id="a409b-215">(Typ kolekcji niestandardowych w schemacie to taki, który nie używa domyślny obszar nazw, nazwę, powtarzające się nazwy elementu lub klucz/wartość nazw elementów.) Te typy są puste typów, które dziedziczą z ogólnych <xref:System.Collections.Generic.List%601> dla listy typów i generyczny słownik typów słownika.</span><span class="sxs-lookup"><span data-stu-id="a409b-215">(A customized collection type in the schema is one that does not use the default namespace, name, repeating element name, or key/value element names.) These types are empty types that derive from Generic <xref:System.Collections.Generic.List%601> for list types and Generic Dictionary for dictionary types.</span></span>

<span data-ttu-id="a409b-216">Na przykład może mieć następujące typy na serwerze.</span><span class="sxs-lookup"><span data-stu-id="a409b-216">For example, you may have the following types on the server.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#7)]
[!code-vb[c_collection_types_in_data_contracts#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#7)]

<span data-ttu-id="a409b-217">Podczas schematu są eksportowane i importowane wstecz ponownie wygenerowanego kodu klienta jest podobny do następującego (pola są wyświetlane zamiast właściwości w celu ułatwienia odczytu).</span><span class="sxs-lookup"><span data-stu-id="a409b-217">When the schema is exported and imported back again, the generated client code is similar to the following (fields are shown instead of properties for ease of reading).</span></span>

[!code-csharp[c_collection_types_in_data_contracts#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#8)]
[!code-vb[c_collection_types_in_data_contracts#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#8)]

<span data-ttu-id="a409b-218">Można użyć różnych typów w wygenerowanym kodzie niż domyślne.</span><span class="sxs-lookup"><span data-stu-id="a409b-218">You may want to use different types in generated code than the default ones.</span></span> <span data-ttu-id="a409b-219">Na przykład, warto użyć ogólnej <xref:System.ComponentModel.BindingList%601> zamiast regularnych tablic swoje składowych danych ułatwić powiązać składników interfejsu użytkownika.</span><span class="sxs-lookup"><span data-stu-id="a409b-219">For example, you may want to use Generic <xref:System.ComponentModel.BindingList%601> instead of regular arrays for your data members to make it easier to bind them to user interface components.</span></span>

<span data-ttu-id="a409b-220">Wybierz typy kolekcji w celu wygenerowania, polega na przekazaniu lista typów kolekcji, której chcesz użyć do <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> właściwość <xref:System.Runtime.Serialization.ImportOptions> obiektu podczas importowania schematu.</span><span class="sxs-lookup"><span data-stu-id="a409b-220">To choose collection types to generate, pass a list of collection types you want to use into the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> property of the <xref:System.Runtime.Serialization.ImportOptions> object when importing schema.</span></span> <span data-ttu-id="a409b-221">Te typy są nazywane *przywoływane typy kolekcji*.</span><span class="sxs-lookup"><span data-stu-id="a409b-221">These types are called *referenced collection types*.</span></span>

<span data-ttu-id="a409b-222">Po odwołaniu typów ogólnych one muszą zostać ogólne pełni open lub całkowicie zamknięte typy ogólne.</span><span class="sxs-lookup"><span data-stu-id="a409b-222">When generic types are being referenced, they must either be fully-open generics or fully-closed generics.</span></span>

> [!NOTE]
> <span data-ttu-id="a409b-223">Podczas korzystania z narzędzia Svcutil.exe, to odwołanie można osiągnąć za pomocą **/collectionType** przełącznik wiersza polecenia (skrócona forma: **/ct**).</span><span class="sxs-lookup"><span data-stu-id="a409b-223">When using the Svcutil.exe tool, this reference can be accomplished by using the **/collectionType** command-line switch (short form: **/ct**).</span></span> <span data-ttu-id="a409b-224">Należy pamiętać, że należy także określić zestawu dla wskazanych typów kolekcji za pomocą **/reference** przełącznika (skrócona forma: **/r**).</span><span class="sxs-lookup"><span data-stu-id="a409b-224">Keep in mind that you must also specify the assembly for the referenced collection types using the **/reference** switch (short form: **/r**).</span></span> <span data-ttu-id="a409b-225">Typ jest ogólna, musi następować odwrócony pojedynczy cudzysłów i liczby parametrów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="a409b-225">If the type is generic, it must be followed by a back quote and the number of generic parameters.</span></span> <span data-ttu-id="a409b-226">Odwrócony pojedynczy cudzysłów (\`) nie należy go mylić z znak pojedynczego cudzysłowu (').</span><span class="sxs-lookup"><span data-stu-id="a409b-226">The back quote (\`) is not to be confused with the single quote (‘) character.</span></span> <span data-ttu-id="a409b-227">Można określić wiele wskazanych typów kolekcji przy użyciu **/collectionType** Przełącz więcej niż jeden raz.</span><span class="sxs-lookup"><span data-stu-id="a409b-227">You can specify multiple referenced collection types by using the **/collectionType** switch more than once.</span></span>

<span data-ttu-id="a409b-228">Na przykład, aby spowodować, że wszystkie listy do zaimportowania jako ogólny <xref:System.Collections.Generic.List%601>.</span><span class="sxs-lookup"><span data-stu-id="a409b-228">For example, to cause all lists to be imported as Generic <xref:System.Collections.Generic.List%601>.</span></span>

```console
svcutil.exe MyService.wsdl MyServiceSchema.xsd /r:C:\full_path_to_system_dll\System.dll /ct:System.Collections.Generic.List`1
```

<span data-ttu-id="a409b-229">Podczas importowania dowolnej kolekcji, ta lista wskazanych typów kolekcji jest skanowany, a najlepiej pasujące kolekcja jest używana, jeśli został znaleziony, jako typ element członkowski danych (w przypadku kolekcji bez dostosowanego przez producenta) lub jako typu podstawowego, aby dziedziczyć po (w przypadku kolekcji niestandardowych).</span><span class="sxs-lookup"><span data-stu-id="a409b-229">When importing any collection, this list of referenced collection types is scanned, and the best-matching collection is used if one is found, either as a data member type (for non-customized collections) or as a base type to derive from (for customized collections).</span></span> <span data-ttu-id="a409b-230">Słowniki tylko są dopasowywane słowników, podczas gdy list są dopasowywane do listy.</span><span class="sxs-lookup"><span data-stu-id="a409b-230">Dictionaries are only matched against dictionaries, while lists are matched against lists.</span></span>

<span data-ttu-id="a409b-231">Na przykład jeśli dodasz ogólnego <xref:System.ComponentModel.BindingList%601> i <xref:System.Collections.Hashtable> Lista wskazanych typów wygenerowanego kodu klienta dla poprzedniego przykładu jest podobny do następującego.</span><span class="sxs-lookup"><span data-stu-id="a409b-231">For example, if you add the Generic <xref:System.ComponentModel.BindingList%601> and <xref:System.Collections.Hashtable> to the list of referenced types, the generated client code for the preceding example is similar to the following.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#9)]
[!code-vb[c_collection_types_in_data_contracts#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#9)]

<span data-ttu-id="a409b-232">Typy interfejsów kolekcji można określić jako część Twojego wskazanych typów kolekcji, ale nie można określić typy kolekcji nieprawidłowy (takie jak te bez `Add` metoda lub Konstruktor publiczny).</span><span class="sxs-lookup"><span data-stu-id="a409b-232">You can specify collection interface types as part of your referenced collection types, but you cannot specify invalid collection types (such as ones with no `Add` method or public constructor).</span></span>

<span data-ttu-id="a409b-233">Zamknięte ogólnego jest uważana za najlepsze dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="a409b-233">A closed generic is considered to be the best match.</span></span> <span data-ttu-id="a409b-234">(Typy nieuniwersalne są uważane za równoważne do zamkniętego typów ogólnych z `Object`).</span><span class="sxs-lookup"><span data-stu-id="a409b-234">(Non-generic types are considered equivalent to closed generics of `Object`).</span></span> <span data-ttu-id="a409b-235">Na przykład jeśli typy ogólne <xref:System.Collections.Generic.List%601> z <xref:System.DateTime>ogólny <xref:System.ComponentModel.BindingList%601> (rodzajowa Otwórz), i <xref:System.Collections.ArrayList> są wskazanych typów kolekcji, że jest generowany.</span><span class="sxs-lookup"><span data-stu-id="a409b-235">For example, if the types Generic <xref:System.Collections.Generic.List%601> of <xref:System.DateTime>, Generic <xref:System.ComponentModel.BindingList%601> (open generic), and <xref:System.Collections.ArrayList> are the referenced collection types, the following is generated.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#10)]
[!code-vb[c_collection_types_in_data_contracts#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#10)]

<span data-ttu-id="a409b-236">Kolekcje list tylko przypadki w poniższej tabeli są obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="a409b-236">For list collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="a409b-237">Typ odwołania</span><span class="sxs-lookup"><span data-stu-id="a409b-237">Referenced type</span></span>|<span data-ttu-id="a409b-238">Interfejs implementowany przez typ odwołania</span><span class="sxs-lookup"><span data-stu-id="a409b-238">Interface implemented by referenced type</span></span>|<span data-ttu-id="a409b-239">Przykład</span><span class="sxs-lookup"><span data-stu-id="a409b-239">Example</span></span>|<span data-ttu-id="a409b-240">Typ traktowane jako:</span><span class="sxs-lookup"><span data-stu-id="a409b-240">Type treated as:</span></span>|
|---------------------|----------------------------------------------|-------------|----------------------|
|<span data-ttu-id="a409b-241">Ogólny nieuniwersalne lub zamknięte (dowolnej liczbie parametrów)</span><span class="sxs-lookup"><span data-stu-id="a409b-241">Non-generic or closed generic (any number of parameters)</span></span>|<span data-ttu-id="a409b-242">Inne niż ogólne</span><span class="sxs-lookup"><span data-stu-id="a409b-242">Non-generic</span></span>|`MyType : IList`<br /><br /> <span data-ttu-id="a409b-243">lub</span><span class="sxs-lookup"><span data-stu-id="a409b-243">or</span></span><br /><br /> `MyType<T> : IList`<br /><br /> <span data-ttu-id="a409b-244">gdzie T = `int`</span><span class="sxs-lookup"><span data-stu-id="a409b-244">where T= `int`</span></span>|<span data-ttu-id="a409b-245">Zamknięte ogólnego elementu `Object` (na przykład `IList<object>`)</span><span class="sxs-lookup"><span data-stu-id="a409b-245">Closed generic of `Object` (for example, `IList<object>`)</span></span>|
|<span data-ttu-id="a409b-246">Ogólny nieuniwersalne lub zamknięte (dowolną liczbę parametrów, które nie muszą odpowiadać typ kolekcji)</span><span class="sxs-lookup"><span data-stu-id="a409b-246">Non-generic or closed generic (any number of parameters that do not necessarily match the collection type)</span></span>|<span data-ttu-id="a409b-247">Zamknięte ogólny</span><span class="sxs-lookup"><span data-stu-id="a409b-247">Closed generic</span></span>|`MyType : IList<string>`<br /><br /> <span data-ttu-id="a409b-248">lub</span><span class="sxs-lookup"><span data-stu-id="a409b-248">or</span></span><br /><br /> <span data-ttu-id="a409b-249">`MyType<T> : IList<string>` gdzie T =`int`</span><span class="sxs-lookup"><span data-stu-id="a409b-249">`MyType<T> : IList<string>` where T=`int`</span></span>|<span data-ttu-id="a409b-250">Ogólny zamknięte (na przykład `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="a409b-250">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="a409b-251">Zamknięte ogólnego z dowolnej liczby parametrów</span><span class="sxs-lookup"><span data-stu-id="a409b-251">Closed generic with any number of parameters</span></span>|<span data-ttu-id="a409b-252">Otwarte ogólne przy użyciu jednego z parametrów typu</span><span class="sxs-lookup"><span data-stu-id="a409b-252">Open generic using any one of the type’s parameters</span></span>|`MyType<T,U,V> : IList<U>`<br /><br /> <span data-ttu-id="a409b-253">gdzie T =`int`, U =`string`, V =`bool`</span><span class="sxs-lookup"><span data-stu-id="a409b-253">where T=`int`, U=`string`, V=`bool`</span></span>|<span data-ttu-id="a409b-254">Ogólny zamknięte (na przykład `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="a409b-254">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="a409b-255">Otwarte ogólne z jednym parametrem</span><span class="sxs-lookup"><span data-stu-id="a409b-255">Open generic with one parameter</span></span>|<span data-ttu-id="a409b-256">Ogólny Otwórz za pomocą parametru typu</span><span class="sxs-lookup"><span data-stu-id="a409b-256">Open generic using the type’s parameter</span></span>|<span data-ttu-id="a409b-257">`MyType<T> : IList<T>`, T jest otwarty</span><span class="sxs-lookup"><span data-stu-id="a409b-257">`MyType<T> : IList<T>`, T is open</span></span>|<span data-ttu-id="a409b-258">Otwarte ogólne (na przykład `IList<T>`)</span><span class="sxs-lookup"><span data-stu-id="a409b-258">Open generic (for example, `IList<T>`)</span></span>|

<span data-ttu-id="a409b-259">Jeśli typ implementuje więcej niż jeden listy kolekcji interfejs, obowiązują następujące ograniczenia:</span><span class="sxs-lookup"><span data-stu-id="a409b-259">If a type implements more than one list collection interface, the following restrictions apply:</span></span>

- <span data-ttu-id="a409b-260">Jeśli typ implementuje ogólny <xref:System.Collections.Generic.IEnumerable%601> (lub jego interfejsy pochodne) wiele razy dla różnych typów, typ nie jest uznawany za typ prawidłową kolekcję odwołania i jest ignorowana.</span><span class="sxs-lookup"><span data-stu-id="a409b-260">If the type implements Generic <xref:System.Collections.Generic.IEnumerable%601> (or its derived interfaces) multiple times for different types, the type is not considered a valid referenced collection type and is ignored.</span></span> <span data-ttu-id="a409b-261">Ta zasada obowiązuje, nawet jeśli niektóre implementacje są nieprawidłowe lub otwartych typów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="a409b-261">This is true even if some implementations are invalid or use open generics.</span></span> <span data-ttu-id="a409b-262">Na przykład typ, który implementuje ogólny <xref:System.Collections.Generic.IEnumerable%601> z `int` i ogólny <xref:System.Collections.Generic.IEnumerable%601> t będzie nigdy używana jako kolekcja odwołania `int` lub innego typu, niezależnie od tego, czy typ ma `Add` akceptowanie — metoda `int` lub `Add` metoda akceptuje parametr typu T lub obu.</span><span class="sxs-lookup"><span data-stu-id="a409b-262">For example, a type that implements Generic <xref:System.Collections.Generic.IEnumerable%601> of `int` and Generic <xref:System.Collections.Generic.IEnumerable%601> of T would never be used as a referenced collection of `int` or any other type, regardless of whether the type has an `Add` method accepting `int` or an `Add` method accepting a parameter of type T, or both.</span></span>

- <span data-ttu-id="a409b-263">Jeśli typ implementuje interfejs kolekcji generycznej także <xref:System.Collections.IList>, typ nigdy nie jest używany jako typ kolekcji odwołania, chyba że interfejs kolekcji generycznej jest zamknięty ogólnego typu <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="a409b-263">If the type implements a generic collection interface as well as <xref:System.Collections.IList>, the type is never used as a referenced collection type unless the generic collection interface is a closed generic of type <xref:System.Object>.</span></span>

<span data-ttu-id="a409b-264">Dla kolekcji słownika obsługiwane są tylko przypadki w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="a409b-264">For dictionary collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="a409b-265">Typ odwołania</span><span class="sxs-lookup"><span data-stu-id="a409b-265">Referenced type</span></span>|<span data-ttu-id="a409b-266">Interfejs implementowany przez typ odwołania</span><span class="sxs-lookup"><span data-stu-id="a409b-266">Interface implemented by referenced type</span></span>|<span data-ttu-id="a409b-267">Przykład</span><span class="sxs-lookup"><span data-stu-id="a409b-267">Example</span></span>|<span data-ttu-id="a409b-268">Typ traktowane jako</span><span class="sxs-lookup"><span data-stu-id="a409b-268">Type treated as</span></span>|
|---------------------|----------------------------------------------|-------------|---------------------|
|<span data-ttu-id="a409b-269">Ogólny nieuniwersalne lub zamknięte (dowolnej liczbie parametrów)</span><span class="sxs-lookup"><span data-stu-id="a409b-269">Non-generic or closed generic (any number of parameters)</span></span>|<xref:System.Collections.IDictionary>|`MyType : IDictionary`<br /><br /> <span data-ttu-id="a409b-270">lub</span><span class="sxs-lookup"><span data-stu-id="a409b-270">or</span></span><br /><br /> <span data-ttu-id="a409b-271">`MyType<T> : IDictionary` gdzie T =`int`</span><span class="sxs-lookup"><span data-stu-id="a409b-271">`MyType<T> : IDictionary` where T=`int`</span></span>|<span data-ttu-id="a409b-272">Zamknięte ogólny `IDictionary<object,object>`</span><span class="sxs-lookup"><span data-stu-id="a409b-272">Closed generic `IDictionary<object,object>`</span></span>|
|<span data-ttu-id="a409b-273">Ogólny zamknięte (dowolnej liczbie parametrów)</span><span class="sxs-lookup"><span data-stu-id="a409b-273">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="a409b-274"><xref:System.Collections.Generic.IDictionary%602>, zamknięte</span><span class="sxs-lookup"><span data-stu-id="a409b-274"><xref:System.Collections.Generic.IDictionary%602>, closed</span></span>|<span data-ttu-id="a409b-275">`MyType<T> : IDictionary<string, bool>` gdzie T =`int`</span><span class="sxs-lookup"><span data-stu-id="a409b-275">`MyType<T> : IDictionary<string, bool>` where T=`int`</span></span>|<span data-ttu-id="a409b-276">Ogólny zamknięte (na przykład `IDIctionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="a409b-276">Closed generic (for example, `IDIctionary<string,bool>`)</span></span>|
|<span data-ttu-id="a409b-277">Ogólny zamknięte (dowolnej liczbie parametrów)</span><span class="sxs-lookup"><span data-stu-id="a409b-277">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="a409b-278">Ogólny <xref:System.Collections.Generic.IDictionary%602>klucza lub wartość jest zamknięty, druga jest otwarty i korzysta z jednego z parametrów typu</span><span class="sxs-lookup"><span data-stu-id="a409b-278">Generic <xref:System.Collections.Generic.IDictionary%602>, one of either key or value is closed, the other is open and uses one of type’s parameters</span></span>|<span data-ttu-id="a409b-279">`MyType<T,U,V> : IDictionary<string,V>` gdzie T =`int`, U =`float`, V =`bool`</span><span class="sxs-lookup"><span data-stu-id="a409b-279">`MyType<T,U,V> : IDictionary<string,V>` where T=`int`, U=`float`,V=`bool`</span></span><br /><br /> <span data-ttu-id="a409b-280">lub</span><span class="sxs-lookup"><span data-stu-id="a409b-280">or</span></span><br /><br /> <span data-ttu-id="a409b-281">`MyType<Z> : IDictionary<Z,bool>` gdy Z =`string`</span><span class="sxs-lookup"><span data-stu-id="a409b-281">`MyType<Z> : IDictionary<Z,bool>` where Z=`string`</span></span>|<span data-ttu-id="a409b-282">Ogólny zamknięte (na przykład `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="a409b-282">Closed generic (For example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="a409b-283">Ogólny zamknięte (dowolnej liczbie parametrów)</span><span class="sxs-lookup"><span data-stu-id="a409b-283">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="a409b-284">Ogólny <xref:System.Collections.Generic.IDictionary%602>, zarówno klucz i wartość są otwarte i każda używa parametrów typu</span><span class="sxs-lookup"><span data-stu-id="a409b-284">Generic <xref:System.Collections.Generic.IDictionary%602>, both key and value are open and each uses one of the type’s parameters</span></span>|<span data-ttu-id="a409b-285">`MyType<T,U,V> : IDictionary<V,U>` gdzie T =`int`, U =`bool`, V =`string`</span><span class="sxs-lookup"><span data-stu-id="a409b-285">`MyType<T,U,V> : IDictionary<V,U>` where T=`int`, U=`bool`, V=`string`</span></span>|<span data-ttu-id="a409b-286">Ogólny zamknięte (na przykład `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="a409b-286">Closed generic (for example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="a409b-287">Otwarte ogólne (dwa parametry)</span><span class="sxs-lookup"><span data-stu-id="a409b-287">Open generic (two parameters)</span></span>|<span data-ttu-id="a409b-288">Ogólny <xref:System.Collections.Generic.IDictionary%602>, Otwórz, będą wykorzystywane serwery ogólnych parametrów typu w kolejności, są wyświetlane</span><span class="sxs-lookup"><span data-stu-id="a409b-288">Generic <xref:System.Collections.Generic.IDictionary%602>, open, uses both of the type’s generic parameters in the order they appear</span></span>|<span data-ttu-id="a409b-289">`MyType<K,V> : IDictionary<K,V>`, K i V zarówno Otwórz</span><span class="sxs-lookup"><span data-stu-id="a409b-289">`MyType<K,V> : IDictionary<K,V>`, K and V both open</span></span>|<span data-ttu-id="a409b-290">Otwarte ogólne (na przykład `IDictionary<K,V>`)</span><span class="sxs-lookup"><span data-stu-id="a409b-290">Open generic (for example, `IDictionary<K,V>`)</span></span>|

<span data-ttu-id="a409b-291">Jeśli typ implementuje interfejsy <xref:System.Collections.IDictionary> i ogólny <xref:System.Collections.Generic.IDictionary%602>tylko ogólny <xref:System.Collections.Generic.IDictionary%602> uznaje się.</span><span class="sxs-lookup"><span data-stu-id="a409b-291">If the type implements both <xref:System.Collections.IDictionary> and Generic <xref:System.Collections.Generic.IDictionary%602>, only Generic <xref:System.Collections.Generic.IDictionary%602> is considered.</span></span>

<span data-ttu-id="a409b-292">Odwoływanie się do typów ogólnych częściowych nie jest obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="a409b-292">Referencing partial generic types is not supported.</span></span>

<span data-ttu-id="a409b-293">Duplikaty są niedozwolone, na przykład nie można dodać zarówno ogólnego <xref:System.Collections.Generic.List%601> z `Integer` i ogólny zbiór `Integer` do <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, ponieważ dzięki temu możliwe ustalenie, znajduje się on do użycia podczas na liście liczb całkowitych w schemacie.</span><span class="sxs-lookup"><span data-stu-id="a409b-293">Duplicates are not allowed, for example, you cannot add both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` to <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, because this makes it impossible to determine which one to use when a list of integers is found in the schema.</span></span> <span data-ttu-id="a409b-294">Duplikaty są wykrywane tylko wtedy, gdy typem w schemacie, który udostępnia problem duplikaty.</span><span class="sxs-lookup"><span data-stu-id="a409b-294">Duplicates are detected only if there is a type in the schema that exposes the duplicates problem.</span></span> <span data-ttu-id="a409b-295">Na przykład, jeśli schemat importowanych nie zawiera listy liczb całkowitych, może on być ma zarówno ogólnego <xref:System.Collections.Generic.List%601> z `Integer` i ogólny zbiór `Integer` w <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, ale nie ma żadnego efektu.</span><span class="sxs-lookup"><span data-stu-id="a409b-295">For example, if the schema being imported does not contain lists of integers, it is allowed to have both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` in the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, but neither has any effect.</span></span>

## <a name="advanced-collection-rules"></a><span data-ttu-id="a409b-296">Kolekcja zaawansowanych reguł</span><span class="sxs-lookup"><span data-stu-id="a409b-296">Advanced Collection Rules</span></span>

### <a name="serializing-collections"></a><span data-ttu-id="a409b-297">Serializowanie kolekcji</span><span class="sxs-lookup"><span data-stu-id="a409b-297">Serializing Collections</span></span>

<span data-ttu-id="a409b-298">Oto lista reguł kolekcji serializacji:</span><span class="sxs-lookup"><span data-stu-id="a409b-298">The following is a list of collection rules for serialization:</span></span>

- <span data-ttu-id="a409b-299">Łączenie typów kolekcji (o kolekcji kolekcji) jest dozwolone.</span><span class="sxs-lookup"><span data-stu-id="a409b-299">Combining collection types (having collections of collections) is allowed.</span></span> <span data-ttu-id="a409b-300">Tablice nieregularne są traktowane jako kolekcji z kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a409b-300">Jagged arrays are treated as collections of collections.</span></span> <span data-ttu-id="a409b-301">Tablice wielowymiarowe nie są obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="a409b-301">Multidimensional arrays are not supported.</span></span>

- <span data-ttu-id="a409b-302">Tablice bajtów i tablice <xref:System.Xml.XmlNode> są typy specjalne tablic, które są traktowane jako podstawowych, nie kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a409b-302">Arrays of byte and arrays of <xref:System.Xml.XmlNode> are special array types that are treated as primitives, not collections.</span></span> <span data-ttu-id="a409b-303">Szeregowanie tablicę bajtów wyników w pojedynczy element XML, który zawiera fragment dane zakodowane w formacie Base64, zamiast element osobne dla każdego bajtu.</span><span class="sxs-lookup"><span data-stu-id="a409b-303">Serializing an array of byte results in a single XML element that contains a chunk of Base64-encoded data, instead of a separate element for each byte.</span></span> <span data-ttu-id="a409b-304">Aby uzyskać więcej informacji o tym, jak tablica <xref:System.Xml.XmlNode> jest traktowane, zobacz [typy XML i ADO.NET w kontraktach danych](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="a409b-304">For more information about how an array of <xref:System.Xml.XmlNode> is treated, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span> <span data-ttu-id="a409b-305">Oczywiście tych specjalnych typów mogą się uczestniczyć w kolekcji: tablica tablicy bajtów powoduje powstanie wielu elementów XML za pomocą zawierającego fragmentów danych w formacie Base64.</span><span class="sxs-lookup"><span data-stu-id="a409b-305">Of course, these special types can themselves participate in collections: an array of array of byte results in multiple XML elements, with each containing a chunk of Base64-encoded data.</span></span>

- <span data-ttu-id="a409b-306">Jeśli <xref:System.Runtime.Serialization.DataContractAttribute> atrybut jest stosowany do typu kolekcji, typ jest traktowany jako typ kontraktu regularnych danych, nie jako kolekcję.</span><span class="sxs-lookup"><span data-stu-id="a409b-306">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a collection type, the type is treated as a regular data contract type, not as a collection.</span></span>

- <span data-ttu-id="a409b-307">Jeśli typ kolekcji implementuje <xref:System.Xml.Serialization.IXmlSerializable> interfejs, są stosowane następujące reguły, posiada typ `myType:IList<string>, IXmlSerializable`:</span><span class="sxs-lookup"><span data-stu-id="a409b-307">If a collection type implements the <xref:System.Xml.Serialization.IXmlSerializable> interface, the following rules apply, given a type `myType:IList<string>, IXmlSerializable`:</span></span>

  - <span data-ttu-id="a409b-308">Gdy deklarowany typ jest `IList<string>`, typ jest serializowana jako listę.</span><span class="sxs-lookup"><span data-stu-id="a409b-308">If the declared type is `IList<string>`, the type is serialized as a list.</span></span>

  - <span data-ttu-id="a409b-309">Gdy deklarowany typ jest `myType`, jest serializowany jako `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="a409b-309">If the declared type is `myType`, it is serialized as `IXmlSerializable`.</span></span>

  - <span data-ttu-id="a409b-310">Gdy deklarowany typ jest `IXmlSerializable`, jest serializowany jako `IXmlSerializable`, ale tylko wtedy, gdy dodasz `myType` do listy znanych typów.</span><span class="sxs-lookup"><span data-stu-id="a409b-310">If the declared type is `IXmlSerializable`, it is serialized as `IXmlSerializable`, but only if you add `myType` to the list of known types.</span></span>

- <span data-ttu-id="a409b-311">Kolekcje są serializacji i deserializacji za pomocą metod przedstawiono w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="a409b-311">Collections are serialized and deserialized using the methods shown in the following table.</span></span>

|<span data-ttu-id="a409b-312">Implementuje — typ kolekcji</span><span class="sxs-lookup"><span data-stu-id="a409b-312">Collection type implements</span></span>|<span data-ttu-id="a409b-313">Metody o nazwie na serializacji</span><span class="sxs-lookup"><span data-stu-id="a409b-313">Method(s) called on serialization</span></span>|<span data-ttu-id="a409b-314">Metody o nazwie na deserializacji</span><span class="sxs-lookup"><span data-stu-id="a409b-314">Method(s) called on deserialization</span></span>|
|--------------------------------|-----------------------------------------|-------------------------------------------|
|<span data-ttu-id="a409b-315">Ogólny <xref:System.Collections.Generic.IDictionary%602></span><span class="sxs-lookup"><span data-stu-id="a409b-315">Generic <xref:System.Collections.Generic.IDictionary%602></span></span>|<span data-ttu-id="a409b-316">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="a409b-316">`get_Keys`, `get_Values`</span></span>|<span data-ttu-id="a409b-317">Dodaj ogólny</span><span class="sxs-lookup"><span data-stu-id="a409b-317">Generic Add</span></span>|
|<xref:System.Collections.IDictionary>|<span data-ttu-id="a409b-318">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="a409b-318">`get_Keys`, `get_Values`</span></span>|`Add`|
|<span data-ttu-id="a409b-319">Ogólny <xref:System.Collections.Generic.IList%601></span><span class="sxs-lookup"><span data-stu-id="a409b-319">Generic <xref:System.Collections.Generic.IList%601></span></span>|<span data-ttu-id="a409b-320">Ogólny <xref:System.Collections.Generic.IList%601> indeksatora</span><span class="sxs-lookup"><span data-stu-id="a409b-320">Generic <xref:System.Collections.Generic.IList%601> indexer</span></span>|<span data-ttu-id="a409b-321">Dodaj ogólny</span><span class="sxs-lookup"><span data-stu-id="a409b-321">Generic Add</span></span>|
|<span data-ttu-id="a409b-322">Ogólny <xref:System.Collections.Generic.ICollection%601></span><span class="sxs-lookup"><span data-stu-id="a409b-322">Generic <xref:System.Collections.Generic.ICollection%601></span></span>|<span data-ttu-id="a409b-323">Moduł wyliczający</span><span class="sxs-lookup"><span data-stu-id="a409b-323">Enumerator</span></span>|<span data-ttu-id="a409b-324">Dodaj ogólny</span><span class="sxs-lookup"><span data-stu-id="a409b-324">Generic Add</span></span>|
|<xref:System.Collections.IList>|<span data-ttu-id="a409b-325"><xref:System.Collections.IList> Indeksator</span><span class="sxs-lookup"><span data-stu-id="a409b-325"><xref:System.Collections.IList> Indexer</span></span>|`Add`|
|<span data-ttu-id="a409b-326">Ogólny <xref:System.Collections.Generic.IEnumerable%601></span><span class="sxs-lookup"><span data-stu-id="a409b-326">Generic <xref:System.Collections.Generic.IEnumerable%601></span></span>|`GetEnumerator`|<span data-ttu-id="a409b-327">Wywołana metoda statyczna `Add` przyjmującą jeden parametr odpowiedniego typu (typ parametru ogólnego) lub jednej z jej typów podstawowych.</span><span class="sxs-lookup"><span data-stu-id="a409b-327">A non-static method called `Add` that takes one parameter of the appropriate type (the type of the generic parameter or one of its base types).</span></span> <span data-ttu-id="a409b-328">Taka metoda musi istnieć przez serializator traktowanie typ kolekcji jako kolekcji zarówno podczas serializacji i deserializacji.</span><span class="sxs-lookup"><span data-stu-id="a409b-328">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|
|<span data-ttu-id="a409b-329"><xref:System.Collections.IEnumerable> (i w związku z tym <xref:System.Collections.ICollection>, co wynika z niego)</span><span class="sxs-lookup"><span data-stu-id="a409b-329"><xref:System.Collections.IEnumerable> (and thus <xref:System.Collections.ICollection>, which derives from it)</span></span>|`GetEnumerator`|<span data-ttu-id="a409b-330">Wywołana metoda niestatycznych `Add` przyjmującą jeden parametr typu `Object`.</span><span class="sxs-lookup"><span data-stu-id="a409b-330">A non-static method called `Add` that takes one parameter of type `Object`.</span></span> <span data-ttu-id="a409b-331">Taka metoda musi istnieć przez serializator traktowanie typ kolekcji jako kolekcji zarówno podczas serializacji i deserializacji.</span><span class="sxs-lookup"><span data-stu-id="a409b-331">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|

<span data-ttu-id="a409b-332">Powyższa tabela zawiera interfejsy kolekcji w kolejności malejącej.</span><span class="sxs-lookup"><span data-stu-id="a409b-332">The preceding table lists collection interfaces in descending order of precedence.</span></span> <span data-ttu-id="a409b-333">Oznacza to, na przykład, że typ implementuje interfejsy <xref:System.Collections.IList> i ogólny <xref:System.Collections.Generic.IEnumerable%601>, kolekcji jest serializacji i deserializacji zgodnie z opisem w <xref:System.Collections.IList> reguły:</span><span class="sxs-lookup"><span data-stu-id="a409b-333">This means, for example, that if a type implements both <xref:System.Collections.IList> and Generic <xref:System.Collections.Generic.IEnumerable%601>, the collection is serialized and deserialized according to the <xref:System.Collections.IList> rules:</span></span>

- <span data-ttu-id="a409b-334">Po deserializacji wszystkie kolekcje są deserializacji przez utworzenie wystąpienia typu przez wywołanie konstruktora domyślnego, który musi być obecny serializator traktowanie typ kolekcji jako kolekcji zarówno podczas serializacji i deserializacji.</span><span class="sxs-lookup"><span data-stu-id="a409b-334">At deserialization, all collections are deserialized by first creating an instance of the type by calling the default constructor, which must be present for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>

- <span data-ttu-id="a409b-335">Jeśli ten sam interfejs kolekcji generycznej jest więcej niż raz (na przykład, jeśli typ implementuje zarówno ogólnego <xref:System.Collections.Generic.ICollection%601> z `Integer` i ogólny <xref:System.Collections.Generic.ICollection%601> z <xref:System.String>) i znajduje się interfejs nie jest wyższy priorytet, jest kolekcji nie są traktowane jako prawidłową kolekcję.</span><span class="sxs-lookup"><span data-stu-id="a409b-335">If the same generic collection interface is implemented more than once (for example, if a type implements both Generic <xref:System.Collections.Generic.ICollection%601> of `Integer` and Generic <xref:System.Collections.Generic.ICollection%601> of <xref:System.String>) and no higher-precedence interface is found, the collection is not treated as a valid collection.</span></span>

- <span data-ttu-id="a409b-336">Typy kolekcji mogą mieć <xref:System.SerializableAttribute> atrybut zastosowanych do nich i zaimplementować <xref:System.Runtime.Serialization.ISerializable> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="a409b-336">Collection types can have the <xref:System.SerializableAttribute> attribute applied to them and can implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span> <span data-ttu-id="a409b-337">Oba te są ignorowane.</span><span class="sxs-lookup"><span data-stu-id="a409b-337">Both of these are ignored.</span></span> <span data-ttu-id="a409b-338">Jednak jeśli typ nie spełnia całkowicie wymagań typu kolekcji (na przykład `Add` Brak metody), typ nie jest uważany za typem kolekcji i w związku z tym <xref:System.SerializableAttribute> atrybutu i <xref:System.Runtime.Serialization.ISerializable> interfejsu służą do określania czy typ może być serializowany.</span><span class="sxs-lookup"><span data-stu-id="a409b-338">However, if the type does not fully meet collection type requirements (for example, the `Add` method is missing), the type is not considered a collection type, and thus the <xref:System.SerializableAttribute> attribute and the <xref:System.Runtime.Serialization.ISerializable> interface are used to determine whether the type can be serialized.</span></span>

- <span data-ttu-id="a409b-339">Stosowanie <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu kolekcję, aby dostosować go usuwa <xref:System.SerializableAttribute> poprzedzających mechanizm rezerwowy.</span><span class="sxs-lookup"><span data-stu-id="a409b-339">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a collection to customize it removes the <xref:System.SerializableAttribute> preceding fallback mechanism.</span></span> <span data-ttu-id="a409b-340">Zamiast tego, jeśli dostosowany kolekcji jest kolekcji nie spełniają wpisz wymagań, <xref:System.Runtime.Serialization.InvalidDataContractException> wyjątku.</span><span class="sxs-lookup"><span data-stu-id="a409b-340">Instead, if a customized collection does not meet collection type requirements, an <xref:System.Runtime.Serialization.InvalidDataContractException> exception is thrown.</span></span> <span data-ttu-id="a409b-341">Parametry wyjątków często zawierają informacje, który wyjaśnia, dlaczego danego typu nie jest uważany za prawidłowy kolekcji (nie `Add` metody, bez konstruktora domyślnego i tak dalej), więc jest często przydatne w celu zastosowania <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu dla celów debugowania.</span><span class="sxs-lookup"><span data-stu-id="a409b-341">The exception string often contains information that explains why a given type is not considered a valid collection (no `Add` method, no default constructor, and so on), so it is often useful to apply the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute for debugging purposes.</span></span>

### <a name="collection-naming"></a><span data-ttu-id="a409b-342">Nadawanie nazw kolekcji</span><span class="sxs-lookup"><span data-stu-id="a409b-342">Collection Naming</span></span>

<span data-ttu-id="a409b-343">Oto lista kolekcji reguł nazewnictwa:</span><span class="sxs-lookup"><span data-stu-id="a409b-343">The following is a list of collection naming rules:</span></span>

- <span data-ttu-id="a409b-344">Domyślny obszar nazw dla wszystkich umów danych kolekcji słownika, a także dla kontraktów danych kolekcji listy, które zawierają typy pierwotne, jest `http://schemas.microsoft.com/2003/10/Serialization/Arrays` chyba że zastąpione przy użyciu Namespace.</span><span class="sxs-lookup"><span data-stu-id="a409b-344">The default namespace for all dictionary collection data contracts, as well as for list collection data contracts that contain primitive types, is `http://schemas.microsoft.com/2003/10/Serialization/Arrays` unless overridden using Namespace.</span></span> <span data-ttu-id="a409b-345">Typy, które mapują na wbudowane typy XSD, a także `char`, `Timespan`, i `Guid` typów, są traktowane jako podstawowych, w tym celu.</span><span class="sxs-lookup"><span data-stu-id="a409b-345">Types that map to built-in XSD types, as well as `char`, `Timespan`, and `Guid` types, are considered primitives for this purpose.</span></span>

- <span data-ttu-id="a409b-346">Domyślny obszar nazw dla typów kolekcji, które zawierają niepodstawowe typy, chyba że zostanie on przesłonięty za pomocą Namespace, jest taka sama jak przestrzeń nazw kontraktu danych typu zawartego w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a409b-346">The default namespace for collection types that contain non-primitive types, unless it is overridden using Namespace, is the same as the data contract namespace of the type contained in the collection.</span></span>

- <span data-ttu-id="a409b-347">Domyślnej nazwy kontraktów danych kolekcji listy, chyba że zastąpione przy użyciu nazwy, to ciąg, który "ArrayOf" w połączeniu z nazwą kontraktu danych typu zawartego w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a409b-347">The default name for list collection data contracts, unless overridden using Name, is the string "ArrayOf" combined with the data contract name of the type contained in the collection.</span></span> <span data-ttu-id="a409b-348">Na przykład w nazwie kontraktu danych dla ogólnego listy liczb całkowitych jest "ArrayOfint".</span><span class="sxs-lookup"><span data-stu-id="a409b-348">For example, the data contract name for a Generic List of Integers is "ArrayOfint".</span></span> <span data-ttu-id="a409b-349">Należy pamiętać, że nazwa kontraktu danych `Object` jest "anyType", więc nazwa kontraktu danych nieogólnego list, takich jak <xref:System.Collections.ArrayList> jest "ArrayOfanyType".</span><span class="sxs-lookup"><span data-stu-id="a409b-349">Keep in mind that the data contract name of `Object` is "anyType", so the data contract name of non-generic lists like <xref:System.Collections.ArrayList> is "ArrayOfanyType".</span></span>

<span data-ttu-id="a409b-350">Domyślna nazwa dla słownika danych kolekcji kontraktów, chyba że zastąpione przy użyciu `Name`, jest ciąg "ArrayOfKeyValueOf" w połączeniu z nazwą kontraktu danych typu klucza, następuje nazwa kontraktu danych o typie wartości.</span><span class="sxs-lookup"><span data-stu-id="a409b-350">The default name for dictionary collection data contracts, unless overridden using `Name`, is the string "ArrayOfKeyValueOf" combined with the data contract name of the key type followed by the data contract name of the value type.</span></span> <span data-ttu-id="a409b-351">Na przykład dane Nazwa kontraktu dla słownika ogólny ciąg i liczba całkowita jest "ArrayOfKeyValueOfstringint".</span><span class="sxs-lookup"><span data-stu-id="a409b-351">For example, the data contract name for a Generic Dictionary of String and Integer is "ArrayOfKeyValueOfstringint".</span></span> <span data-ttu-id="a409b-352">Ponadto jeśli klucz i typy wartości nie są typami pierwotnymi, skrótu przestrzeni nazw z przestrzeni nazw kontraktu danych typów kluczy i wartości jest dołączany do nazwy.</span><span class="sxs-lookup"><span data-stu-id="a409b-352">Additionally, if either the key or the value types are not primitive types, a namespace hash of the data contract namespaces of the key and value types is appended to the name.</span></span> <span data-ttu-id="a409b-353">Aby uzyskać więcej informacji na temat skrótów przestrzeni nazw, zobacz [nazwy kontraktów danych](../../../../docs/framework/wcf/feature-details/data-contract-names.md).</span><span class="sxs-lookup"><span data-stu-id="a409b-353">For more information about namespace hashes, see [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md).</span></span>

<span data-ttu-id="a409b-354">Każdy kontraktu danych kolekcji słownika ma pomocnika kontraktu danych, który reprezentuje jeden wpis w słowniku.</span><span class="sxs-lookup"><span data-stu-id="a409b-354">Each dictionary collection data contract has a companion data contract that represents one entry in the dictionary.</span></span> <span data-ttu-id="a409b-355">Jego nazwa jest taka sama jak słownik kontraktu danych, z wyjątkiem prefiks "ArrayOf" i jego przestrzeń nazw są takie same jak dla kontraktu danych słownika.</span><span class="sxs-lookup"><span data-stu-id="a409b-355">Its name is the same as for the dictionary data contract, except for the "ArrayOf" prefix, and its namespace is the same as for the dictionary data contract.</span></span> <span data-ttu-id="a409b-356">Na przykład dla kontraktu danych "ArrayOfKeyValueOfstringint" słownik, kontraktu danych "KeyValueofstringint" reprezentuje jeden wpis w słowniku.</span><span class="sxs-lookup"><span data-stu-id="a409b-356">For example, for the "ArrayOfKeyValueOfstringint" dictionary data contract, the "KeyValueofstringint" data contract represents one entry in the dictionary.</span></span> <span data-ttu-id="a409b-357">Można dostosować nazwę tohoto kontraktu danych za pomocą `ItemName` właściwości, zgodnie z opisem w następnej sekcji.</span><span class="sxs-lookup"><span data-stu-id="a409b-357">You can customize the name of this data contract by using the `ItemName` property, as described in the next section.</span></span>

<span data-ttu-id="a409b-358">Reguły nazewnictwa typu ogólnego, zgodnie z opisem w [nazwy kontraktów danych](../../../../docs/framework/wcf/feature-details/data-contract-names.md)pełni mają zastosowanie do typów kolekcji; będący, nawiasy klamrowe w nazwie służy do wskazania parametrów typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="a409b-358">Generic type naming rules, as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md), fully apply to collection types; that is, you can use curly braces within Name to indicate generic type parameters.</span></span> <span data-ttu-id="a409b-359">Jednak numery w nawiasy klamrowe dotyczą parametrów ogólnych i nie typy zawarte w tej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a409b-359">However, numbers within the braces refer to generic parameters and not types contained within the collection.</span></span>

## <a name="collection-customization"></a><span data-ttu-id="a409b-360">Dostosowywanie kolekcji</span><span class="sxs-lookup"><span data-stu-id="a409b-360">Collection Customization</span></span>

<span data-ttu-id="a409b-361">Zastosowań następujące <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu jest zabronione i spowodować <xref:System.Runtime.Serialization.InvalidDataContractException> wyjątek:</span><span class="sxs-lookup"><span data-stu-id="a409b-361">The following uses of the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute are forbidden and result in an <xref:System.Runtime.Serialization.InvalidDataContractException> exception:</span></span>

- <span data-ttu-id="a409b-362">Stosowanie <xref:System.Runtime.Serialization.DataContractAttribute> atrybutu z typem, do którego <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybut została zastosowana, lub do jednego z jego typów pochodnych.</span><span class="sxs-lookup"><span data-stu-id="a409b-362">Applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to a type to which the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute has been applied, or to one of its derived types.</span></span>

- <span data-ttu-id="a409b-363">Stosowanie <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu typu, który implementuje <xref:System.Xml.Serialization.IXmlSerializable> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="a409b-363">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a type that implements the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>

- <span data-ttu-id="a409b-364">Stosowanie <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu typu innego niż kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a409b-364">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a non-collection type.</span></span>

- <span data-ttu-id="a409b-365">Trwa próba skonfigurowania <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> lub <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> na <xref:System.Runtime.Serialization.CollectionDataContractAttribute> zastosowany do typu innego niż słownika.</span><span class="sxs-lookup"><span data-stu-id="a409b-365">Attempting to set <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> or <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> on a <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute applied to a non-dictionary type.</span></span>

### <a name="polymorphism-rules"></a><span data-ttu-id="a409b-366">Polimorfizm reguły</span><span class="sxs-lookup"><span data-stu-id="a409b-366">Polymorphism Rules</span></span>

<span data-ttu-id="a409b-367">Jak wcześniej wspomniano, dostosowywanie kolekcji za pomocą <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybut może zakłócać możliwości wymiennego stosowania kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a409b-367">As previously mentioned, customizing collections by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute may interfere with collection interchangeability.</span></span> <span data-ttu-id="a409b-368">Dwa typy kolekcji niestandardowych tylko jest uznawana za równoważne, jeśli ich nazwy, przestrzeń nazw, nazwa elementu, a także nazwy klucza i wartości (jeśli są to kolekcje słownika) są zgodne.</span><span class="sxs-lookup"><span data-stu-id="a409b-368">Two customized collection types can only be considered equivalent if their name, namespace, item name, as well as key and value names (if these are dictionary collections) match.</span></span>

<span data-ttu-id="a409b-369">Z powodu dostosowań istnieje możliwość przypadkowo Użyj kontraktu danych kolekcji jednego gdy oczekiwany jest inny.</span><span class="sxs-lookup"><span data-stu-id="a409b-369">Due to customizations, it is possible to inadvertently use one collection data contract where another is expected.</span></span> <span data-ttu-id="a409b-370">Należy ich unikać.</span><span class="sxs-lookup"><span data-stu-id="a409b-370">This should be avoided.</span></span> <span data-ttu-id="a409b-371">Zobacz następujące typy.</span><span class="sxs-lookup"><span data-stu-id="a409b-371">See the following types.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#11)]
[!code-vb[c_collection_types_in_data_contracts#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#11)]

<span data-ttu-id="a409b-372">W tym przypadku wystąpienie `Marks1` mogą być przypisane do `testMarks`.</span><span class="sxs-lookup"><span data-stu-id="a409b-372">In this case, an instance of `Marks1` can be assigned to `testMarks`.</span></span> <span data-ttu-id="a409b-373">Jednak `Marks2` nie należy używać, ponieważ jego kontraktu danych nie jest uważany za równoważny `IList<int>` kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="a409b-373">However, `Marks2` should not be used because its data contract is not considered equivalent to the `IList<int>` data contract.</span></span> <span data-ttu-id="a409b-374">Nazwa kontraktu danych jest "Marks2", a nie "ArrayOfint" i powtarzające się nazwa elementu jest "\<oznaczyć >" ale nie "\<int >".</span><span class="sxs-lookup"><span data-stu-id="a409b-374">The data contract name is "Marks2" and not "ArrayOfint", and the repeating element name is "\<mark>" and not "\<int>".</span></span>

<span data-ttu-id="a409b-375">Reguły w tabeli poniżej dotyczą polimorficznego przypisania kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a409b-375">The rules in the following table apply to polymorphic assignment of collections.</span></span>

|<span data-ttu-id="a409b-376">Deklarowany typ</span><span class="sxs-lookup"><span data-stu-id="a409b-376">Declared type</span></span>|<span data-ttu-id="a409b-377">Przypisanie kolekcji bez dostosowania</span><span class="sxs-lookup"><span data-stu-id="a409b-377">Assigning a non-customized collection</span></span>|<span data-ttu-id="a409b-378">Przypisanie kolekcji niestandardowych</span><span class="sxs-lookup"><span data-stu-id="a409b-378">Assigning a customized collection</span></span>|
|-------------------|--------------------------------------------|---------------------------------------|
|<span data-ttu-id="a409b-379">Obiekt</span><span class="sxs-lookup"><span data-stu-id="a409b-379">Object</span></span>|<span data-ttu-id="a409b-380">Nazwa kontraktu jest serializowana.</span><span class="sxs-lookup"><span data-stu-id="a409b-380">Contract name is serialized.</span></span>|<span data-ttu-id="a409b-381">Nazwa kontraktu jest serializowana.</span><span class="sxs-lookup"><span data-stu-id="a409b-381">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="a409b-382">Dostosowywanie jest używany.</span><span class="sxs-lookup"><span data-stu-id="a409b-382">Customization is used.</span></span>|
|<span data-ttu-id="a409b-383">Interfejs kolekcji</span><span class="sxs-lookup"><span data-stu-id="a409b-383">Collection interface</span></span>|<span data-ttu-id="a409b-384">Nazwa umowy nie jest serializowana.</span><span class="sxs-lookup"><span data-stu-id="a409b-384">Contract name is not serialized.</span></span>|<span data-ttu-id="a409b-385">Nazwa umowy nie jest serializowana.</span><span class="sxs-lookup"><span data-stu-id="a409b-385">Contract name is not serialized.</span></span><br /><br /> <span data-ttu-id="a409b-386">Dostosowanie nie jest używana.\*</span><span class="sxs-lookup"><span data-stu-id="a409b-386">Customization is not used.\*</span></span>|
|<span data-ttu-id="a409b-387">Dostosowanego przez producenta spoza zbioru</span><span class="sxs-lookup"><span data-stu-id="a409b-387">Non-customized collection</span></span>|<span data-ttu-id="a409b-388">Nazwa umowy nie jest serializowana.</span><span class="sxs-lookup"><span data-stu-id="a409b-388">Contract name is not serialized.</span></span>|<span data-ttu-id="a409b-389">Nazwa kontraktu jest serializowana.</span><span class="sxs-lookup"><span data-stu-id="a409b-389">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="a409b-390">Dostosowanie jest used.\* \*</span><span class="sxs-lookup"><span data-stu-id="a409b-390">Customization is used.\*\*</span></span>|
|<span data-ttu-id="a409b-391">Kolekcja niestandardowych</span><span class="sxs-lookup"><span data-stu-id="a409b-391">Customized collection</span></span>|<span data-ttu-id="a409b-392">Nazwa kontraktu jest serializowana.</span><span class="sxs-lookup"><span data-stu-id="a409b-392">Contract name is serialized.</span></span> <span data-ttu-id="a409b-393">Dostosowanie nie jest używana.\*\*</span><span class="sxs-lookup"><span data-stu-id="a409b-393">Customization is not used.\*\*</span></span>|<span data-ttu-id="a409b-394">Nazwa kontraktu jest serializowana.</span><span class="sxs-lookup"><span data-stu-id="a409b-394">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="a409b-395">Dostosowywanie przypisany typ jest używany.\*\*</span><span class="sxs-lookup"><span data-stu-id="a409b-395">Customization of the assigned type is used.\*\*</span></span>|

<span data-ttu-id="a409b-396">\*Za pomocą <xref:System.Runtime.Serialization.NetDataContractSerializer> klas, dostosowywanie jest używany w tym przypadku.</span><span class="sxs-lookup"><span data-stu-id="a409b-396">\*With the <xref:System.Runtime.Serialization.NetDataContractSerializer> class, customization is used in this case.</span></span> <span data-ttu-id="a409b-397"><xref:System.Runtime.Serialization.NetDataContractSerializer> Klasy w tym przypadku również serializuje nazwą rzeczywistego typu, więc deserializacji działa zgodnie z oczekiwaniami.</span><span class="sxs-lookup"><span data-stu-id="a409b-397">The <xref:System.Runtime.Serialization.NetDataContractSerializer> class also serializes the actual type name in this case, so deserialization works as expected.</span></span>

<span data-ttu-id="a409b-398">\*\*Te przypadki wystąpień nieprawidłowy schemat i dlatego należy unikać.</span><span class="sxs-lookup"><span data-stu-id="a409b-398">\*\*These cases result in schema-invalid instances and thus should be avoided.</span></span>

<span data-ttu-id="a409b-399">W przypadkach, w którym Nazwa kontraktu jest serializowana typ kolekcji przypisanej powinien być na liście znanych typów.</span><span class="sxs-lookup"><span data-stu-id="a409b-399">In the cases where the contract name is serialized, the assigned collection type should be in the known types list.</span></span> <span data-ttu-id="a409b-400">Odwrotny również ma wartość true: w przypadkach, w którym nazwa nie jest serializowana, dodając typ do listy znanych typów nie jest wymagana.</span><span class="sxs-lookup"><span data-stu-id="a409b-400">The opposite is also true: in the cases where the name is not serialized, adding the type to the known types list is not required.</span></span>

<span data-ttu-id="a409b-401">Tablica typu pochodnego można przypisać do tablicy typu podstawowego.</span><span class="sxs-lookup"><span data-stu-id="a409b-401">An array of a derived type can be assigned to an array of a base type.</span></span> <span data-ttu-id="a409b-402">W takim przypadku Nazwa kontraktu przypadku typ pochodny jest serializowany dla każdego elementu powtarzające się.</span><span class="sxs-lookup"><span data-stu-id="a409b-402">In this case, the contract name for the derived type is serialized for each repeating element.</span></span> <span data-ttu-id="a409b-403">Na przykład, jeśli typ `Book` pochodzi od typu `LibraryItem`, można przypisać tablicę `Book` tablicę `LibraryItem`.</span><span class="sxs-lookup"><span data-stu-id="a409b-403">For example, if a type `Book` derives from the type `LibraryItem`, you can assign an array of `Book` to an array of `LibraryItem`.</span></span> <span data-ttu-id="a409b-404">To nie ma zastosowania do innych typów kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a409b-404">This does not apply to other collection types.</span></span> <span data-ttu-id="a409b-405">Na przykład nie można przypisać `Generic List of Book` do `Generic List of LibraryItem`.</span><span class="sxs-lookup"><span data-stu-id="a409b-405">For example, you cannot assign a `Generic List of Book` to a `Generic List of LibraryItem`.</span></span> <span data-ttu-id="a409b-406">Można jednak przypisywać `Generic List of LibraryItem` zawierający `Book` wystąpień.</span><span class="sxs-lookup"><span data-stu-id="a409b-406">You can, however, assign a `Generic List of LibraryItem` that contains `Book` instances.</span></span> <span data-ttu-id="a409b-407">Zarówno w tablicy, jak i w przypadku nietablicowego `Book` powinien znajdować się na liście znanych typów.</span><span class="sxs-lookup"><span data-stu-id="a409b-407">In both the array and the non-array case, `Book` should be in the known types list.</span></span>

## <a name="collections-and-object-reference-preservation"></a><span data-ttu-id="a409b-408">Kolekcje i zachowywania odwołanie do obiektu</span><span class="sxs-lookup"><span data-stu-id="a409b-408">Collections and Object Reference Preservation</span></span>

<span data-ttu-id="a409b-409">Funkcje serializatora w trybie, w których zostaje zachowany odwołania do obiektu, zachowywanie odwołanie do obiektu również zastosowanie do kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a409b-409">When a serializer functions in a mode where it preserves object references, object reference preservation also applies to collections.</span></span> <span data-ttu-id="a409b-410">W szczególności tożsamość obiektu są zachowywane dla całej kolekcji i pojedynczych elementów zawartych w kolekcjach.</span><span class="sxs-lookup"><span data-stu-id="a409b-410">Specifically, object identity is preserved for both entire collections and individual items contained in collections.</span></span> <span data-ttu-id="a409b-411">Słowników tożsamość obiektu są zachowywane, zarówno dla obiektów pary klucz/wartość i poszczególnych obiektów kluczy i wartości.</span><span class="sxs-lookup"><span data-stu-id="a409b-411">For dictionaries, object identity is preserved both for the key/value pair objects and the individual key and value objects.</span></span>

## <a name="see-also"></a><span data-ttu-id="a409b-412">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="a409b-412">See also</span></span>

- <xref:System.Runtime.Serialization.CollectionDataContractAttribute>
