---
title: Typy kolekcji w kontraktach danych
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- collection types [WCF], data contracts
- data contracts [WCF], collection types
- collection types [WCF]
ms.assetid: 9b45b28e-0a82-4ea3-8c33-ec0094aff9d5
caps.latest.revision: "19"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: e74bd7d90d5653890fd5cf48e76c81d0227c6172
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 12/22/2017
---
# <a name="collection-types-in-data-contracts"></a><span data-ttu-id="e85c3-102">Typy kolekcji w kontraktach danych</span><span class="sxs-lookup"><span data-stu-id="e85c3-102">Collection Types in Data Contracts</span></span>
<span data-ttu-id="e85c3-103">A *kolekcji* znajduje się lista elementów określonego typu.</span><span class="sxs-lookup"><span data-stu-id="e85c3-103">A *collection* is a list of items of a certain type.</span></span> <span data-ttu-id="e85c3-104">W [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)], tych list można przedstawić przy użyciu tablic lub innych typów (listy ogólnej, ogólny <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>, lub <xref:System.Collections.ArrayList>).</span><span class="sxs-lookup"><span data-stu-id="e85c3-104">In the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)], such lists can be represented using arrays or a variety of other types (Generic List, Generic <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>, or <xref:System.Collections.ArrayList>).</span></span> <span data-ttu-id="e85c3-105">Na przykład kolekcja może utrzymywać listę adresów dla danego klienta.</span><span class="sxs-lookup"><span data-stu-id="e85c3-105">For example, a collection may hold a list of Addresses for a given Customer.</span></span> <span data-ttu-id="e85c3-106">Kolekcje te są nazywane *listy kolekcji*, niezależnie od ich rzeczywistego typu.</span><span class="sxs-lookup"><span data-stu-id="e85c3-106">These collections are called *list collections*, regardless of their actual type.</span></span>  
  
 <span data-ttu-id="e85c3-107">Istnieje specjalny rodzaj kolekcji, która reprezentuje skojarzenie między jeden element ("klucza") i innej ("wartość").</span><span class="sxs-lookup"><span data-stu-id="e85c3-107">A special form of collection exists that represents an association between one item (the "key") and another (the "value").</span></span> <span data-ttu-id="e85c3-108">W [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)], takich jak, te są reprezentowane przez typy <xref:System.Collections.Hashtable> i rodzajowy słownika.</span><span class="sxs-lookup"><span data-stu-id="e85c3-108">In the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)], these are represented by types such as <xref:System.Collections.Hashtable> and the generic dictionary.</span></span> <span data-ttu-id="e85c3-109">Na przykład w kolekcji skojarzenie może być mapowany Miasto ("klucza") jego wypełniania ("value").</span><span class="sxs-lookup"><span data-stu-id="e85c3-109">For example, an association collection may map a city ("key") to its population ("value").</span></span> <span data-ttu-id="e85c3-110">Kolekcje te są nazywane *kolekcje słownika*, niezależnie od ich rzeczywistego typu.</span><span class="sxs-lookup"><span data-stu-id="e85c3-110">These collections are called *dictionary collections*, regardless of their actual type.</span></span>  
  
 <span data-ttu-id="e85c3-111">Kolekcje odbierać szczególnego traktowania w modelu kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="e85c3-111">Collections receive special treatment in the data contract model.</span></span>  
  
 <span data-ttu-id="e85c3-112">Typy, które implementują <xref:System.Collections.IEnumerable> interfejsu, łącznie z tablicami i kolekcje ogólne są uznawane za kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-112">Types that implement the <xref:System.Collections.IEnumerable> interface, including arrays and generic collections, are recognized as collections.</span></span> <span data-ttu-id="e85c3-113">Typy które implementują <xref:System.Collections.IDictionary> lub ogólny <xref:System.Collections.Generic.IDictionary%602> interfejsy są kolekcjami słownika; pozostałe są kolekcjami listy.</span><span class="sxs-lookup"><span data-stu-id="e85c3-113">Of those, types that implement the <xref:System.Collections.IDictionary> or Generic <xref:System.Collections.Generic.IDictionary%602> interfaces are dictionary collections; all others are list collections.</span></span>  
  
 <span data-ttu-id="e85c3-114">Dodatkowe wymagania dla typów kolekcji, takie jak o metodę o nazwie `Add` i konstruktora domyślnego opisano szczegółowo w poniższych sekcjach.</span><span class="sxs-lookup"><span data-stu-id="e85c3-114">Additional requirements on collection types, such as having a method called `Add` and a default constructor, are discussed in detail in the following sections.</span></span> <span data-ttu-id="e85c3-115">Dzięki temu, że typy kolekcji można zarówno serializacji i deserializacji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-115">This ensures that collection types can be both serialized and deserialized.</span></span> <span data-ttu-id="e85c3-116">Oznacza to, że niektóre kolekcje nie są bezpośrednio obsługiwane, takie jak ogólnego <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (ponieważ go nie ma konstruktora domyślnego).</span><span class="sxs-lookup"><span data-stu-id="e85c3-116">This means that some collections are not directly supported, such as the Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (because it has no default constructor).</span></span> <span data-ttu-id="e85c3-117">Jednak uzyskać informacji o tych ograniczeń obejścia, zobacz sekcję "Przy użyciu kolekcji interfejsu typów i tylko do odczytu kolekcji" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="e85c3-117">However, for information about circumventing these restrictions, see the section "Using Collection Interface Types and Read-Only Collections" later in this topic.</span></span>  
  
 <span data-ttu-id="e85c3-118">Typy zawarte w kolekcji musi być typy kontraktu danych, lub w inny sposób możliwy do serializacji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-118">The types contained in collections must be data contract types, or be otherwise serializable.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="e85c3-119">[Typy obsługiwane przez serializator kontraktu danych](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="e85c3-119"> [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span>  
  
 [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="e85c3-120">Co to jest i co to jest uznawane za prawidłowe kolekcji, jak również informacje jak kolekcje są serializowane, zapoznaj się z informacjami o serializowanie kolekcji w sekcji "Zaawansowane zasady kolekcji" tego tematu.</span><span class="sxs-lookup"><span data-stu-id="e85c3-120"> what is and what is not considered a valid collection, as well as about how collections are serialized, see the information about serializing collections in the "Advanced Collection Rules" section of this topic.</span></span>  
  
## <a name="interchangeable-collections"></a><span data-ttu-id="e85c3-121">Wymienne kolekcje</span><span class="sxs-lookup"><span data-stu-id="e85c3-121">Interchangeable Collections</span></span>  
 <span data-ttu-id="e85c3-122">Wszystkie kolekcje listy tego samego typu, jest uznawany za tych samych danych kontraktu (chyba że są one dostosowane przy użyciu <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu, zgodnie z opisem w dalszej części tego tematu).</span><span class="sxs-lookup"><span data-stu-id="e85c3-122">All list collections of the same type are considered to have the same data contract (unless they are customized using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, as discussed later in this topic).</span></span> <span data-ttu-id="e85c3-123">W związku z tym na przykład następujące kontraktów danych są równoważne.</span><span class="sxs-lookup"><span data-stu-id="e85c3-123">Thus, for example, the following data contracts are equivalent.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#0](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#0)]
 [!code-vb[c_collection_types_in_data_contracts#0](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#0)]  
  
 <span data-ttu-id="e85c3-124">Zarówno kontraktów danych powoduje podobny do następującego kodu XML.</span><span class="sxs-lookup"><span data-stu-id="e85c3-124">Both data contracts result in XML similar to the following code.</span></span>  
  
```xml  
<PurchaseOrder>  
    <customerName>...</customerName>  
    <items>  
        <Item>...</Item>  
        <Item>...</Item>  
        <Item>...</Item>  
        ...  
    </items>  
    <comments>  
        <string>...</string>  
        <string>...</string>  
        <string>...</string>  
        ...  
    </comments>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="e85c3-125">Możliwości wymiennego stosowania kolekcji umożliwia można użyć, na przykład typ kolekcji, zoptymalizowana pod kątem wydajności na serwerze i typ kolekcji zaprojektowane powiązać składniki interfejsu użytkownika na komputerze klienckim.</span><span class="sxs-lookup"><span data-stu-id="e85c3-125">Collection interchangeability allows you to use, for example, a collection type optimized for performance on the server and a collection type designed to be bound to user interface components on the client.</span></span>  
  
 <span data-ttu-id="e85c3-126">Podobnie jak listy kolekcji, wszystkie kolekcje słownika, które mają taki sam klucz i wartość typy jest uznawany za tych samych danych kontraktu (chyba że dostosowane przez <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu).</span><span class="sxs-lookup"><span data-stu-id="e85c3-126">Similar to list collections, all dictionary collections that have the same key and value types are considered to have the same data contract (unless customized by the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute).</span></span>  
  
 <span data-ttu-id="e85c3-127">Tylko w zakresie, w jakim dotyczy kolekcji pełnienia roli równoważnika sprawach typu kontraktu danych, nie typów .NET.</span><span class="sxs-lookup"><span data-stu-id="e85c3-127">Only the data contract type matters as far as collection equivalence is concerned, not .NET types.</span></span> <span data-ttu-id="e85c3-128">Oznacza to zbiór Type1 jest uznane za równorzędne kolekcji Type2, jeśli Type1 i Type2 kontraktów danych równoważne.</span><span class="sxs-lookup"><span data-stu-id="e85c3-128">That is, a collection of Type1 is considered equivalent to a collection of Type2 if Type1 and Type2 have equivalent data contracts.</span></span>  
  
 <span data-ttu-id="e85c3-129">Inne niż ogólne kolekcje są traktowane jako mają te same dane kontrakt, co kolekcje ogólne typu `Object`.</span><span class="sxs-lookup"><span data-stu-id="e85c3-129">Non-generic collections are considered to have the same data contract as generic collections of type `Object`.</span></span> <span data-ttu-id="e85c3-130">(Na przykład kontraktów danych do <xref:System.Collections.ArrayList> i rodzajowy <xref:System.Collections.Generic.List%601> z `Object` są takie same.)</span><span class="sxs-lookup"><span data-stu-id="e85c3-130">(For example, the data contracts for <xref:System.Collections.ArrayList> and Generic <xref:System.Collections.Generic.List%601> of `Object` are the same.)</span></span>  
  
## <a name="using-collection-interface-types-and-read-only-collections"></a><span data-ttu-id="e85c3-131">Przy użyciu typów interfejsów kolekcji i kolekcji tylko do odczytu</span><span class="sxs-lookup"><span data-stu-id="e85c3-131">Using Collection Interface Types and Read-Only Collections</span></span>  
 <span data-ttu-id="e85c3-132">Typy interfejsów kolekcji (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>ogólny <xref:System.Collections.Generic.IDictionary%602>, lub interfejsy pochodzące z tych interfejsów) są również uznać kontraktów danych kolekcji, odpowiednikiem kontraktów danych kolekcji dla typów rzeczywista kolekcja.</span><span class="sxs-lookup"><span data-stu-id="e85c3-132">Collection interface types (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, generic <xref:System.Collections.Generic.IDictionary%602>, or interfaces derived from these interfaces) are also considered as having collection data contracts, equivalent to collection data contracts for actual collection types.</span></span> <span data-ttu-id="e85c3-133">W związku z tym można zadeklarować typ poddany serializacji jako typ interfejsu kolekcji, a wyniki są takie same jak użycie typu rzeczywistego kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-133">Thus, it is possible to declare the type being serialized as a collection interface type and the results are the same as if an actual collection type had been used.</span></span> <span data-ttu-id="e85c3-134">Na przykład następujące kontraktów danych są równoważne.</span><span class="sxs-lookup"><span data-stu-id="e85c3-134">For example, the following data contracts are equivalent.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#1)]
 [!code-vb[c_collection_types_in_data_contracts#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#1)]  
  
 <span data-ttu-id="e85c3-135">Podczas serializacji gdy deklarowany typ jest interfejsem, typ rzeczywistego wystąpienia używany może być dowolnego typu, który implementuje ten interfejs.</span><span class="sxs-lookup"><span data-stu-id="e85c3-135">During serialization, when the declared type is an interface, the actual instance type used can be any type that implements that interface.</span></span> <span data-ttu-id="e85c3-136">Ograniczenia omówionych wcześniej (o konstruktora domyślnego i `Add` metoda) nie są stosowane.</span><span class="sxs-lookup"><span data-stu-id="e85c3-136">Restrictions discussed previously (having a default constructor and an `Add` method) do not apply.</span></span> <span data-ttu-id="e85c3-137">Na przykład można ustawić adresów w Customer2 na wystąpienie ogólnej <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> adresu, mimo że element członkowski danych klasy bezpośrednio nie można zadeklarować typu ogólnego <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="e85c3-137">For example, you can set addresses in Customer2 to an instance of Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> of Address, even though you cannot directly declare a data member of type Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span></span>  
  
 <span data-ttu-id="e85c3-138">Podczas deserializacji, gdy deklarowany typ jest interfejsem, aparat serializacji wybiera typ, który implementuje interfejs zadeklarowane i tworzenia wystąpienia typu klasy.</span><span class="sxs-lookup"><span data-stu-id="e85c3-138">During deserialization, when the declared type is an interface, the serialization engine chooses a type that implements the declared interface, and the type is instantiated.</span></span> <span data-ttu-id="e85c3-139">Znane typy mechanizmu (opisany w [znane typy kontraktu danych](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)) nie ma wpływu; wbudowane wybór typu [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span><span class="sxs-lookup"><span data-stu-id="e85c3-139">The known types mechanism (described in [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)) has no effect here; the choice of type is built into [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span></span>  
  
## <a name="customizing-collection-types"></a><span data-ttu-id="e85c3-140">Dostosowywanie typów kolekcji</span><span class="sxs-lookup"><span data-stu-id="e85c3-140">Customizing Collection Types</span></span>  
 <span data-ttu-id="e85c3-141">Typy kolekcji można dostosować, używając <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybut, który ma kilka zastosowań.</span><span class="sxs-lookup"><span data-stu-id="e85c3-141">You can customize collection types by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, which has several uses.</span></span>  
  
 <span data-ttu-id="e85c3-142">Należy zwrócić uwagę tego Dostosowywanie kolekcji typów dokonywania kolekcji wymiennego stosowania, dlatego zazwyczaj zalecane jest aby uniknąć stosowania tego atrybutu, jeśli to możliwe.</span><span class="sxs-lookup"><span data-stu-id="e85c3-142">Note that customizing collection types compromises collection interchangeability, so it is generally recommended to avoid applying this attribute whenever possible.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="e85c3-143">Ten problem, zobacz sekcję "Zaawansowane zasady kolekcji" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="e85c3-143"> this issue, see the "Advanced Collection Rules" section later in this topic.</span></span>  
  
### <a name="collection-data-contract-naming"></a><span data-ttu-id="e85c3-144">Kontraktu danych kolekcji nazewnictwa</span><span class="sxs-lookup"><span data-stu-id="e85c3-144">Collection Data Contract Naming</span></span>  
 <span data-ttu-id="e85c3-145">Reguły nazewnictwa typy kolekcji są podobne do reguł nazewnictwa typy kontraktu danych regularne, zgodnie z opisem w [nazwy kontraktów danych](../../../../docs/framework/wcf/feature-details/data-contract-names.md), mimo że istnieje kilka istotnych różnic:</span><span class="sxs-lookup"><span data-stu-id="e85c3-145">The rules for naming collection types are similar to those for naming regular data contract types, as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md), although some important differences exist:</span></span>  
  
-   <span data-ttu-id="e85c3-146"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> Atrybut służy do dostosowywania nazwę, a nie <xref:System.Runtime.Serialization.DataContractAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="e85c3-146">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is used to customize the name, instead of the <xref:System.Runtime.Serialization.DataContractAttribute> attribute.</span></span> <span data-ttu-id="e85c3-147"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> Ma również atrybut `Name` i `Namespace` właściwości.</span><span class="sxs-lookup"><span data-stu-id="e85c3-147">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute also has `Name` and `Namespace` properties.</span></span>  
  
-   <span data-ttu-id="e85c3-148">Gdy <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybut nie ma zastosowania, domyślną nazwę i przestrzeń nazw dla typów kolekcji są zależne od nazwy i przestrzenie nazw typów zawartych w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-148">When the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is not applied, the default name and namespace for collection types depend on the names and namespaces of types contained within the collection.</span></span> <span data-ttu-id="e85c3-149">Nie jest narażony na nazwę i przestrzeń nazw samego typu kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-149">They are not affected by the name and namespace of the collection type itself.</span></span> <span data-ttu-id="e85c3-150">Na przykład zobacz następujące typy.</span><span class="sxs-lookup"><span data-stu-id="e85c3-150">For an example, see the following types.</span></span>  
  
    ```  
    public CustomerList1 : Collection<string> {}  
    public StringList1 : Collection<string> {}  
    ```  
  
 <span data-ttu-id="e85c3-151">Nazwa kontraktu danych obu typów "ArrayOfstring" i nie jest "CustomerList1" lub "StringList1".</span><span class="sxs-lookup"><span data-stu-id="e85c3-151">Both types’ data contract name is "ArrayOfstring" and not "CustomerList1" or "StringList1".</span></span> <span data-ttu-id="e85c3-152">Oznacza to, że serializacji jednego z następujących typów na poziomie głównym daje podobny do następującego kodu XML.</span><span class="sxs-lookup"><span data-stu-id="e85c3-152">This means that serializing any one of these types at the root level yields XML similar to the following code.</span></span>  
  
```xml  
<ArrayOfstring>  
    <string>...</string>  
    <string>...</string>  
    <string>...</string>  
    ...  
</ArrayOfstring>  
```  
  
 <span data-ttu-id="e85c3-153">Ta reguła nazewnictwa została wybrana, aby upewnić się, że wszelkie bez dostosowania typ, który reprezentuje listę ciągów ma sam kontrakt danych oraz reprezentacji XML.</span><span class="sxs-lookup"><span data-stu-id="e85c3-153">This naming rule was chosen to ensure that any non-customized type that represents a list of strings has the same data contract and XML representation.</span></span> <span data-ttu-id="e85c3-154">Umożliwia możliwości wymiennego stosowania kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-154">This makes collection interchangeability possible.</span></span> <span data-ttu-id="e85c3-155">W tym przykładzie CustomerList1 i StringList1 są całkowicie wymienne.</span><span class="sxs-lookup"><span data-stu-id="e85c3-155">In this example, CustomerList1 and StringList1 are completely interchangeable.</span></span>  
  
 <span data-ttu-id="e85c3-156">Jednakże, gdy <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybut jest stosowany, kolekcji staje się kontraktu danych kolekcji niestandardowych, nawet jeśli żadne właściwości są ustawiane w ustawieniach atrybutu.</span><span class="sxs-lookup"><span data-stu-id="e85c3-156">However, when the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is applied, the collection becomes a customized collection data contract, even if no properties are set on the attribute.</span></span> <span data-ttu-id="e85c3-157">Nazwę i przestrzeń nazw zebrania danych kontraktu, a następnie są zależne od samego typu kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-157">The name and namespace of the collection data contract then depend on the collection type itself.</span></span> <span data-ttu-id="e85c3-158">Na przykład zobacz następujący typ.</span><span class="sxs-lookup"><span data-stu-id="e85c3-158">For an example, see the following type.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#2)]
 [!code-vb[c_collection_types_in_data_contracts#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#2)]  
  
 <span data-ttu-id="e85c3-159">Podczas serializacji, wynikowy kod XML jest podobny do następującego.</span><span class="sxs-lookup"><span data-stu-id="e85c3-159">When serialized, the resulting XML is similar to the following.</span></span>  
  
```xml  
<CustomerList2>  
    <string>...</string>  
    <string>...</string>  
    <string>...</string>  
    ...  
</CustomerList2>  
```  
  
 <span data-ttu-id="e85c3-160">Zwróć uwagę, że nie jest to już odpowiednikiem reprezentację XML typy bez dostosowania.</span><span class="sxs-lookup"><span data-stu-id="e85c3-160">Notice that this is no longer equivalent to the XML representation of the non-customized types.</span></span>  
  
-   <span data-ttu-id="e85c3-161">Można użyć `Name` i `Namespace` właściwości w celu przeprowadzenia dalszej dostosowywania nazw.</span><span class="sxs-lookup"><span data-stu-id="e85c3-161">You can use the `Name` and `Namespace` properties to further customize the naming.</span></span> <span data-ttu-id="e85c3-162">Zobacz następujące klasy.</span><span class="sxs-lookup"><span data-stu-id="e85c3-162">See the following class.</span></span>  
  
     [!code-csharp[c_collection_types_in_data_contracts#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#3)]
     [!code-vb[c_collection_types_in_data_contracts#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#3)]  
  
 <span data-ttu-id="e85c3-163">Wynikowy kod XML jest podobny do następującego.</span><span class="sxs-lookup"><span data-stu-id="e85c3-163">The resulting XML is similar to the following.</span></span>  
  
```xml  
<cust_list>  
    <string>...</string>  
    <string>...</string>  
    <string>...</string>  
    ...  
</cust_list>  
```  
  
 [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="e85c3-164">w sekcji "Zaawansowane zasady kolekcji" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="e85c3-164"> the "Advanced Collection Rules" section later in this topic.</span></span>  
  
### <a name="customizing-the-repeating-element-name-in-list-collections"></a><span data-ttu-id="e85c3-165">Dostosowywanie identycznych nazwa elementu w kolekcji listy</span><span class="sxs-lookup"><span data-stu-id="e85c3-165">Customizing the Repeating Element Name in List Collections</span></span>  
 <span data-ttu-id="e85c3-166">Lista kolekcje zawierają identycznych wpisów.</span><span class="sxs-lookup"><span data-stu-id="e85c3-166">List collections contain repeating entries.</span></span> <span data-ttu-id="e85c3-167">Zazwyczaj każdy wpis identycznych jest reprezentowany jako element o nazwie zgodnie z nazwą kontraktu danych typu zawartego w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-167">Normally, each repeating entry is represented as an element named according to the data contract name of the type contained in the collection.</span></span>  
  
 <span data-ttu-id="e85c3-168">W `CustomerList` przykłady, kolekcje zawiera ciągi.</span><span class="sxs-lookup"><span data-stu-id="e85c3-168">In the `CustomerList` examples, the collections contained strings.</span></span> <span data-ttu-id="e85c3-169">Nazwie kontraktu danych dla typu pierwotnego ciągu jest "string", dlatego został powtarzający się element "\<ciągu >".</span><span class="sxs-lookup"><span data-stu-id="e85c3-169">The data contract name for the string primitive type is "string", so the repeating element was "\<string>".</span></span>  
  
 <span data-ttu-id="e85c3-170">Jednak przy użyciu <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> właściwość <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu to powtarzające się nazwy elementu można dostosować.</span><span class="sxs-lookup"><span data-stu-id="e85c3-170">However, using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property on the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, this repeating element name can be customized.</span></span> <span data-ttu-id="e85c3-171">Na przykład zobacz następujący typ.</span><span class="sxs-lookup"><span data-stu-id="e85c3-171">For an example, see the following type.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#4)]
 [!code-vb[c_collection_types_in_data_contracts#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#4)]  
  
 <span data-ttu-id="e85c3-172">Wynikowy kod XML jest podobny do następującego.</span><span class="sxs-lookup"><span data-stu-id="e85c3-172">The resulting XML is similar to the following.</span></span>  
  
```xml  
<CustomerList4>  
    <customer>...</customer>  
    <customer>...</customer>  
    <customer>...</customer>  
    ...  
</CustomerList4>  
```  
  
 <span data-ttu-id="e85c3-173">Przestrzeń nazw elementu powtarzalnego zawsze jest taka sama jak przestrzeń nazw kontraktu danych kolekcji, które można dostosować za pomocą `Namespace` właściwości, jak opisano wcześniej.</span><span class="sxs-lookup"><span data-stu-id="e85c3-173">The namespace of the repeating element is always the same as the namespace of the collection data contract, which can be customized using the `Namespace` property, as described previously.</span></span>  
  
### <a name="customizing-dictionary-collections"></a><span data-ttu-id="e85c3-174">Dostosowywanie słownika kolekcje</span><span class="sxs-lookup"><span data-stu-id="e85c3-174">Customizing Dictionary Collections</span></span>  
 <span data-ttu-id="e85c3-175">Słownik kolekcje są zasadniczo listy wpisów, gdzie każdy wpis ma klucz, a następnie według wartości.</span><span class="sxs-lookup"><span data-stu-id="e85c3-175">Dictionary collections are essentially lists of entries, where each entry has a key followed by a value.</span></span> <span data-ttu-id="e85c3-176">Tak samo, jak przy użyciu list regularne, można zmienić nazwy elementu, który odpowiada na powtarzający się element za pomocą <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="e85c3-176">Just as with regular lists, you can change the element name that corresponds to the repeating element by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property.</span></span>  
  
 <span data-ttu-id="e85c3-177">Ponadto można zmienić nazw elementów reprezentujących klucz i wartość przy użyciu <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> i <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="e85c3-177">Additionally, you can change the element names that represent the key and the value by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> and <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> properties.</span></span> <span data-ttu-id="e85c3-178">Przestrzenie nazw dla tych elementów są takie same jak przestrzeń nazw kontraktu danych kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-178">The namespaces for these elements are the same as the namespace of the collection data contract.</span></span>  
  
 <span data-ttu-id="e85c3-179">Na przykład zobacz następujący typ.</span><span class="sxs-lookup"><span data-stu-id="e85c3-179">For an example, see the following type.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#5)]
 [!code-vb[c_collection_types_in_data_contracts#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#5)]  
  
 <span data-ttu-id="e85c3-180">Podczas serializacji, wynikowy kod XML jest podobny do następującego.</span><span class="sxs-lookup"><span data-stu-id="e85c3-180">When serialized, the resulting XML is similar to the following.</span></span>  
  
```xml  
<CountriesOrRegionsWithCapitals>  
    <entry>  
        <countryorregion>USA</countryorregion>  
        <capital>Washington</capital>  
    </entry>  
    <entry>  
        <countryorregion>France</countryorregion>  
        <capital>Paris</capital>  
    </entry>  
    ...  
</CountriesOrRegionsWithCapitals>  
```  
  
 [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="e85c3-181">Słownik kolekcji, zobacz sekcję "Zaawansowane zasady kolekcji" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="e85c3-181"> dictionary collections, see the "Advanced Collection Rules" section later in this topic.</span></span>  
  
## <a name="collections-and-known-types"></a><span data-ttu-id="e85c3-182">Kolekcje i znanych typów</span><span class="sxs-lookup"><span data-stu-id="e85c3-182">Collections and Known Types</span></span>  
 <span data-ttu-id="e85c3-183">Dodawanie typów kolekcji znanych typów stosowania polymorphically zamiast inne kolekcje lub interfejsy kolekcji nie jest konieczne.</span><span class="sxs-lookup"><span data-stu-id="e85c3-183">You do not need to add collection types to known types when used polymorphically in place of other collections or collection interfaces.</span></span> <span data-ttu-id="e85c3-184">Na przykład w przypadku elementu członkowskiego danych typu <xref:System.Collections.IEnumerable> i umożliwia wysyłanie wystąpienia <xref:System.Collections.ArrayList>, nie trzeba dodać <xref:System.Collections.ArrayList> do znanych typów.</span><span class="sxs-lookup"><span data-stu-id="e85c3-184">For example, if you declare a data member of type <xref:System.Collections.IEnumerable> and use it to send an instance of <xref:System.Collections.ArrayList>, you do not need to add <xref:System.Collections.ArrayList> to known types.</span></span>  
  
 <span data-ttu-id="e85c3-185">Gdy używasz kolekcji polymorphically zamiast typy kolekcji nie muszą zostać dodane do znanych typów.</span><span class="sxs-lookup"><span data-stu-id="e85c3-185">When you use collections polymorphically in place of non-collection types, they must be added to known types.</span></span> <span data-ttu-id="e85c3-186">Na przykład w przypadku elementu członkowskiego danych typu `Object` i umożliwia wysyłanie wystąpienia <xref:System.Collections.ArrayList>, Dodaj <xref:System.Collections.ArrayList> do znanych typów.</span><span class="sxs-lookup"><span data-stu-id="e85c3-186">For example, if you declare a data member of type `Object` and use it to send an instance of <xref:System.Collections.ArrayList>, add <xref:System.Collections.ArrayList> to known types.</span></span>  
  
 <span data-ttu-id="e85c3-187">To nie pozwalają na polymorphically serializować równoważne kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-187">This does not allow you to serialize any equivalent collection polymorphically.</span></span> <span data-ttu-id="e85c3-188">Na przykład podczas dodawania <xref:System.Collections.ArrayList> do listy znanych typów w poprzednim przykładzie, to nie jest możliwe przypisanie `Array of Object` klasy, nawet jeśli ma kontraktu danych równoważne.</span><span class="sxs-lookup"><span data-stu-id="e85c3-188">For example, when you add <xref:System.Collections.ArrayList> to the list of known types in the preceding example, this does not let you assign the `Array of Object` class, even though it has an equivalent data contract.</span></span> <span data-ttu-id="e85c3-189">To nie różni się od w serializacji dla typów innych niż kolekcji zachowanie regularne znanych typów, ale jest szczególnie ważne zrozumieć w przypadku kolekcji, ponieważ bardzo często kolekcji jako równoważne.</span><span class="sxs-lookup"><span data-stu-id="e85c3-189">This is no different from regular known types behavior on serialization for non-collection types, but it is especially important to understand in the case of collections because it is very common for collections to be equivalent.</span></span>  
  
 <span data-ttu-id="e85c3-190">Podczas serializacji może być znane tylko jeden typ w dowolnym danym zakresie dla kontraktu danych danego i równoważne kolekcje wszystkie mają tego samego kontraktów danych.</span><span class="sxs-lookup"><span data-stu-id="e85c3-190">During serialization, only one type can be known in any given scope for a given data contract, and equivalent collections all have the same data contracts.</span></span> <span data-ttu-id="e85c3-191">Oznacza to, że w poprzednim przykładzie, nie można dodać zarówno <xref:System.Collections.ArrayList> i `Array of Object` do znanych typów, w tym samym zakresie.</span><span class="sxs-lookup"><span data-stu-id="e85c3-191">This means that, in the previous example, you cannot add both <xref:System.Collections.ArrayList> and `Array of Object` to known types at the same scope.</span></span> <span data-ttu-id="e85c3-192">Ponownie co jest równoważne zachowanie znanych typów dla typów innych niż kolekcji, ale jest szczególnie ważne zrozumieć dla kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-192">Again, this is equivalent to known types behavior for non-collection types, but it is especially important to understand for collections.</span></span>  
  
 <span data-ttu-id="e85c3-193">Znane typy mogą być również wymagane dla zawartości kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-193">Known types may also be required for contents of collections.</span></span> <span data-ttu-id="e85c3-194">Na przykład jeśli <xref:System.Collections.ArrayList> faktycznie zawiera wystąpienia `Type1` i `Type2`, oba te typy powinny zostać dodane do znanych typów.</span><span class="sxs-lookup"><span data-stu-id="e85c3-194">For example, if an <xref:System.Collections.ArrayList> actually contains instances of `Type1` and `Type2`, both of these types should be added to known types.</span></span>  
  
 <span data-ttu-id="e85c3-195">Poniższy przykład przedstawia wykres obiektu poprawnie skonstruowany przy użyciu kolekcji i znanych typów.</span><span class="sxs-lookup"><span data-stu-id="e85c3-195">The following example shows a properly constructed object graph using collections and known types.</span></span> <span data-ttu-id="e85c3-196">Przykład jest contrived nieco, ponieważ w rzeczywistej aplikacji zwykle nie definiuje się następujące elementy członkowskie danych jako `Object`i dlatego nie ma typu/polimorfizm znane problemy.</span><span class="sxs-lookup"><span data-stu-id="e85c3-196">The example is somewhat contrived, because in an actual application you would normally not define the following data members as `Object`, and thus do not have any known type/polymorphism issues.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#6)]
 [!code-vb[c_collection_types_in_data_contracts#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#6)]  
  
 <span data-ttu-id="e85c3-197">Podczas deserializacji gdy deklarowany typ jest typem kolekcji deklarowany typ jest utworzona bez względu na typ faktycznie wysłane.</span><span class="sxs-lookup"><span data-stu-id="e85c3-197">On deserialization, if the declared type is a collection type, the declared type is instantiated regardless of the type that was actually sent.</span></span> <span data-ttu-id="e85c3-198">Deklarowany typ jest interfejsem kolekcji, Deserializator wybiera typ, który ma zostać utworzone nie w odniesieniu do znanych typów.</span><span class="sxs-lookup"><span data-stu-id="e85c3-198">If the declared type is a collection interface, the deserializer picks a type to be instantiated with no regard to known types.</span></span>  
  
 <span data-ttu-id="e85c3-199">Również podczas deserializacji, jeśli deklarowany typ nie jest typem kolekcji, ale typ kolekcji jest wysyłany, odpowiedniego typu kolekcji jest pobierany z listy znanych typów.</span><span class="sxs-lookup"><span data-stu-id="e85c3-199">Also on deserialization, if the declared type is not a collection type but a collection type is being sent, a matching collection type is picked out of the known types list.</span></span> <span data-ttu-id="e85c3-200">Istnieje możliwość Dodaj typy kolekcji interfejs do listy znanych typów przy deserializacji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-200">It is possible to add collection interface types to the list of known types on deserialization.</span></span> <span data-ttu-id="e85c3-201">W takim przypadku aparat deserializacji ponownie wybiera typ, który ma zostać utworzona.</span><span class="sxs-lookup"><span data-stu-id="e85c3-201">In this case, the deserialization engine again picks a type to be instantiated.</span></span>  
  
## <a name="collections-and-the-netdatacontractserializer-class"></a><span data-ttu-id="e85c3-202">Kolekcje i klasy NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="e85c3-202">Collections and the NetDataContractSerializer Class</span></span>  
 <span data-ttu-id="e85c3-203">Gdy <xref:System.Runtime.Serialization.NetDataContractSerializer> klasa jest używana, typy kolekcji bez dostosowania (bez <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybut) czy są tablice nie utracić ich specjalne znaczenie.</span><span class="sxs-lookup"><span data-stu-id="e85c3-203">When the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use, non-customized collection types (without the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute) that are not arrays lose their special meaning.</span></span>  
  
 <span data-ttu-id="e85c3-204">Typy kolekcji dostosowane nie jest oznaczony atrybutem <xref:System.SerializableAttribute> atrybutu nadal może być serializowany przez <xref:System.Runtime.Serialization.NetDataContractSerializer> klasy zgodnie z <xref:System.SerializableAttribute> atrybutu lub <xref:System.Runtime.Serialization.ISerializable> interfejsu reguły.</span><span class="sxs-lookup"><span data-stu-id="e85c3-204">Non-customized collection types marked with the <xref:System.SerializableAttribute> attribute can still be serialized by the <xref:System.Runtime.Serialization.NetDataContractSerializer> class according to the <xref:System.SerializableAttribute> attribute or the <xref:System.Runtime.Serialization.ISerializable> interface rules.</span></span>  
  
 <span data-ttu-id="e85c3-205">Typy kolekcji niestandardowych, interfejsy kolekcji i tablic nadal są traktowane jako kolekcje, nawet wtedy, gdy <xref:System.Runtime.Serialization.NetDataContractSerializer> klasy jest używany.</span><span class="sxs-lookup"><span data-stu-id="e85c3-205">Customized collection types, collection interfaces, and arrays are still treated as collections, even when the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use.</span></span>  
  
## <a name="collections-and-schema"></a><span data-ttu-id="e85c3-206">Kolekcje i schematu</span><span class="sxs-lookup"><span data-stu-id="e85c3-206">Collections and Schema</span></span>  
 <span data-ttu-id="e85c3-207">Wszystkie kolekcje równoważne mają taką samą reprezentację w schemacie (XSD) języka definicji schematu XML.</span><span class="sxs-lookup"><span data-stu-id="e85c3-207">All equivalent collections have the same representation in XML Schema definition language (XSD) schema.</span></span> <span data-ttu-id="e85c3-208">W związku z tym zazwyczaj nie otrzymasz ten sam typ kolekcji w kodzie wygenerowanego klienta co na serwerze.</span><span class="sxs-lookup"><span data-stu-id="e85c3-208">Because of this, you normally do not get the same collection type in the generated client code as the one on the server.</span></span> <span data-ttu-id="e85c3-209">Na przykład serwer może wykorzystać kontraktu danych z ogólnego <xref:System.Collections.Generic.List%601> elementu członkowskiego danych Liczba całkowita, ale w kodzie wygenerowanego klienta elementu członkowskiego danych może stać się tablica liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="e85c3-209">For example, the server may use a data contract with a Generic <xref:System.Collections.Generic.List%601> of Integer data member, but in the generated client code the same data member may become an array of integers.</span></span>  
  
 <span data-ttu-id="e85c3-210">Słownik kolekcje są oznaczone ikoną z [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]— adnotacja schematu, wskazujące, że znajdują się słowniki; w przeciwnym razie są nierozróżnialne z prostej listy zawierające wpisów z klucza i wartości.</span><span class="sxs-lookup"><span data-stu-id="e85c3-210">Dictionary collections are marked with a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]-specific schema annotation that indicate that they are dictionaries; otherwise, they are indistinguishable from simple lists that contain entries with a key and a value.</span></span> <span data-ttu-id="e85c3-211">Aby uzyskać dokładny opis sposobu kolekcje są reprezentowane w schemacie kontraktu danych, zobacz [odwołanie do schematu kontraktu danych](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="e85c3-211">For an exact description of how collections are represented in data contract schema, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>  
  
 <span data-ttu-id="e85c3-212">Domyślnie typy nie są generowane bez dostosowania kolekcji w kodzie zaimportowany.</span><span class="sxs-lookup"><span data-stu-id="e85c3-212">By default, types are not generated for non-customized collections in imported code.</span></span> <span data-ttu-id="e85c3-213">Elementy członkowskie danych typów kolekcji listy są importowane jako tablic, a elementy członkowskie danych typów kolekcji słownika są importowane jako ogólnego słownika.</span><span class="sxs-lookup"><span data-stu-id="e85c3-213">Data members of list collection types are imported as arrays, and data members of dictionary collection types are imported as Generic Dictionary.</span></span>  
  
 <span data-ttu-id="e85c3-214">Jednak dla kolekcji niestandardowych, osobne typy są generowane, oznaczone <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="e85c3-214">However, for customized collections, separate types are generated, marked with the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute.</span></span> <span data-ttu-id="e85c3-215">(Typ kolekcji niestandardowych w schemacie to taki, który nie używa domyślnej przestrzeni nazw, nazwę, identycznych nazwy elementu lub klucza i wartości nazwy elementu.) Te typy są puste typów, które pochodzą od zwykłego <xref:System.Collections.Generic.List%601> dla listy typów i rodzajowy słownika dla typów słownika.</span><span class="sxs-lookup"><span data-stu-id="e85c3-215">(A customized collection type in the schema is one that does not use the default namespace, name, repeating element name, or key/value element names.) These types are empty types that derive from Generic <xref:System.Collections.Generic.List%601> for list types and Generic Dictionary for dictionary types.</span></span>  
  
 <span data-ttu-id="e85c3-216">Na przykład może mieć następujące typy na serwerze.</span><span class="sxs-lookup"><span data-stu-id="e85c3-216">For example, you may have the following types on the server.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#7)]
 [!code-vb[c_collection_types_in_data_contracts#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#7)]  
  
 <span data-ttu-id="e85c3-217">Gdy schematu są eksportowane i importowane spód ponownie wygenerowanego kodu klienta jest podobne do następujących (pola są wyświetlane zamiast właściwości czytelnej).</span><span class="sxs-lookup"><span data-stu-id="e85c3-217">When the schema is exported and imported back again, the generated client code is similar to the following (fields are shown instead of properties for ease of reading).</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#8)]
 [!code-vb[c_collection_types_in_data_contracts#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#8)]  
  
 <span data-ttu-id="e85c3-218">Można użyć różnych typów w wygenerowanym kodzie niż domyślne.</span><span class="sxs-lookup"><span data-stu-id="e85c3-218">You may want to use different types in generated code than the default ones.</span></span> <span data-ttu-id="e85c3-219">Na przykład można używać zwykłego <xref:System.ComponentModel.BindingList%601> zamiast regularne tablice sieci elementów członkowskich danych ułatwić powiązać składników interfejsu użytkownika.</span><span class="sxs-lookup"><span data-stu-id="e85c3-219">For example, you may want to use Generic <xref:System.ComponentModel.BindingList%601> instead of regular arrays for your data members to make it easier to bind them to user interface components.</span></span>  
  
 <span data-ttu-id="e85c3-220">Aby wybrać typy kolekcji w celu wygenerowania, Przekaż listę typów kolekcji, którego chcesz użyć do <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> właściwość <xref:System.Runtime.Serialization.ImportOptions> obiektu podczas importowania schematu.</span><span class="sxs-lookup"><span data-stu-id="e85c3-220">To choose collection types to generate, pass a list of collection types you want to use into the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> property of the <xref:System.Runtime.Serialization.ImportOptions> object when importing schema.</span></span> <span data-ttu-id="e85c3-221">Te typy są nazywane *odwołuje się do typów kolekcji*.</span><span class="sxs-lookup"><span data-stu-id="e85c3-221">These types are called *referenced collection types*.</span></span>  
  
 <span data-ttu-id="e85c3-222">Po odwołaniu typów ogólnych one musi być całkowicie otwarte ogólne lub ogólne całkowicie zamknięty.</span><span class="sxs-lookup"><span data-stu-id="e85c3-222">When generic types are being referenced, they must either be fully-open generics or fully-closed generics.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e85c3-223">Podczas korzystania z narzędzia Svcutil.exe, to odwołanie można osiągnąć za pomocą **/collectionType** przełącznik wiersza polecenia (forma krótka: **/ct**).</span><span class="sxs-lookup"><span data-stu-id="e85c3-223">When using the Svcutil.exe tool, this reference can be accomplished by using the **/collectionType** command-line switch (short form: **/ct**).</span></span> <span data-ttu-id="e85c3-224">Należy pamiętać, że musi również określać zestawu dla wskazanych typów kolekcji przy użyciu **/reference** przełącznika (forma krótka: **/r**).</span><span class="sxs-lookup"><span data-stu-id="e85c3-224">Keep in mind that you must also specify the assembly for the referenced collection types using the **/reference** switch (short form: **/r**).</span></span> <span data-ttu-id="e85c3-225">Typ jest rodzajowy, musi występować oferty Wstecz i liczby parametrów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="e85c3-225">If the type is generic, it must be followed by a back quote and the number of generic parameters.</span></span> <span data-ttu-id="e85c3-226">Wstecz cudzysłowu (') jest nie należy mylić z znak pojedynczego cudzysłowu (').</span><span class="sxs-lookup"><span data-stu-id="e85c3-226">The back quote (\`) is not to be confused with the single quote (‘) character.</span></span> <span data-ttu-id="e85c3-227">Można określić wiele wskazanych typów kolekcji za pomocą **/collectionType** przełącznika więcej niż raz.</span><span class="sxs-lookup"><span data-stu-id="e85c3-227">You can specify multiple referenced collection types by using the **/collectionType** switch more than once.</span></span>  
  
 <span data-ttu-id="e85c3-228">Na przykład, aby spowodować, że wszystkie listy do zaimportowania jako zwykłego <xref:System.Collections.Generic.List%601>.</span><span class="sxs-lookup"><span data-stu-id="e85c3-228">For example, to cause all lists to be imported as Generic <xref:System.Collections.Generic.List%601>.</span></span>  
  
```  
svcutil.exe MyService.wsdl MyServiceSchema.xsd /r:C:\full_path_to_system_dll\System.dll /ct:System.Collections.Generic.List`1  
```  
  
 <span data-ttu-id="e85c3-229">Podczas importowania kolekcji, ta lista wskazanych typów kolekcji jest skanowany i najlepiej pasujące kolekcja jest używana, jeśli został znaleziony, jako typ elementu członkowskiego danych (w przypadku kolekcji bez dostosowania) lub jako podstawowy typ wyprowadzenia z (dla kolekcji niestandardowych).</span><span class="sxs-lookup"><span data-stu-id="e85c3-229">When importing any collection, this list of referenced collection types is scanned, and the best-matching collection is used if one is found, either as a data member type (for non-customized collections) or as a base type to derive from (for customized collections).</span></span> <span data-ttu-id="e85c3-230">Słowniki tylko są dopasowywane słowników, podczas gdy listy są dopasowywane do listy.</span><span class="sxs-lookup"><span data-stu-id="e85c3-230">Dictionaries are only matched against dictionaries, while lists are matched against lists.</span></span>  
  
 <span data-ttu-id="e85c3-231">Na przykład, jeśli dodasz ogólnego <xref:System.ComponentModel.BindingList%601> i <xref:System.Collections.Hashtable> do listy typów do którego istnieje odwołanie, jest podobny do następującego wygenerowanego kodu klienta dla poprzedniego przykładu.</span><span class="sxs-lookup"><span data-stu-id="e85c3-231">For example, if you add the Generic <xref:System.ComponentModel.BindingList%601> and <xref:System.Collections.Hashtable> to the list of referenced types, the generated client code for the preceding example is similar to the following.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#9)]
 [!code-vb[c_collection_types_in_data_contracts#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#9)]  
  
 <span data-ttu-id="e85c3-232">Typy interfejsów kolekcji można określić jako część programu wskazanych typów kolekcji, ale nie można określić typy kolekcji nieprawidłowe (takich jak te, których nie `Add` metody lub konstruktora publicznego).</span><span class="sxs-lookup"><span data-stu-id="e85c3-232">You can specify collection interface types as part of your referenced collection types, but you cannot specify invalid collection types (such as ones with no `Add` method or public constructor).</span></span>  
  
 <span data-ttu-id="e85c3-233">Zamknięte rodzajowa jest uważana za najlepsze dopasowanie.</span><span class="sxs-lookup"><span data-stu-id="e85c3-233">A closed generic is considered to be the best match.</span></span> <span data-ttu-id="e85c3-234">(Inne niż ogólne typy zostały uznane za równorzędne do zamkniętego typów ogólnych z `Object`).</span><span class="sxs-lookup"><span data-stu-id="e85c3-234">(Non-generic types are considered equivalent to closed generics of `Object`).</span></span> <span data-ttu-id="e85c3-235">Na przykład jeśli typy ogólne <xref:System.Collections.Generic.List%601> z <xref:System.DateTime>ogólny <xref:System.ComponentModel.BindingList%601> (Otwórz ogólny), i <xref:System.Collections.ArrayList> są typy kolekcji do którego istnieje odwołanie, poniżej zostanie wygenerowany.</span><span class="sxs-lookup"><span data-stu-id="e85c3-235">For example, if the types Generic <xref:System.Collections.Generic.List%601> of <xref:System.DateTime>, Generic <xref:System.ComponentModel.BindingList%601> (open generic), and <xref:System.Collections.ArrayList> are the referenced collection types, the following is generated.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#10)]
 [!code-vb[c_collection_types_in_data_contracts#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#10)]  
  
 <span data-ttu-id="e85c3-236">Dla listy kolekcji są obsługiwane tylko przypadków w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="e85c3-236">For list collections, only the cases in the following table are supported.</span></span>  
  
|<span data-ttu-id="e85c3-237">Typu występującego w odwołaniu</span><span class="sxs-lookup"><span data-stu-id="e85c3-237">Referenced type</span></span>|<span data-ttu-id="e85c3-238">Typ odwołania do interfejsu implementowanego przez</span><span class="sxs-lookup"><span data-stu-id="e85c3-238">Interface implemented by referenced type</span></span>|<span data-ttu-id="e85c3-239">Przykład</span><span class="sxs-lookup"><span data-stu-id="e85c3-239">Example</span></span>|<span data-ttu-id="e85c3-240">Typ traktowane jako:</span><span class="sxs-lookup"><span data-stu-id="e85c3-240">Type treated as:</span></span>|  
|---------------------|----------------------------------------------|-------------|----------------------|  
|<span data-ttu-id="e85c3-241">Inne niż ogólne lub zamkniętych ogólny (dowolną liczbę parametrów)</span><span class="sxs-lookup"><span data-stu-id="e85c3-241">Non-generic or closed generic (any number of parameters)</span></span>|<span data-ttu-id="e85c3-242">Inne niż ogólne</span><span class="sxs-lookup"><span data-stu-id="e85c3-242">Non-generic</span></span>|`MyType : IList`<br /><br /> <span data-ttu-id="e85c3-243">lub</span><span class="sxs-lookup"><span data-stu-id="e85c3-243">or</span></span><br /><br /> `MyType<T> : IList`<br /><br /> <span data-ttu-id="e85c3-244">gdzie T =`int`</span><span class="sxs-lookup"><span data-stu-id="e85c3-244">where T= `int`</span></span>|<span data-ttu-id="e85c3-245">Zamknięte ogólnego z `Object` (na przykład `IList<object>`)</span><span class="sxs-lookup"><span data-stu-id="e85c3-245">Closed generic of `Object` (for example, `IList<object>`)</span></span>|  
|<span data-ttu-id="e85c3-246">Inne niż ogólne lub zamkniętych ogólny (dowolną liczbę parametrów, które nie muszą odpowiadać typ kolekcji)</span><span class="sxs-lookup"><span data-stu-id="e85c3-246">Non-generic or closed generic (any number of parameters that do not necessarily match the collection type)</span></span>|<span data-ttu-id="e85c3-247">Zamknięte ogólny</span><span class="sxs-lookup"><span data-stu-id="e85c3-247">Closed generic</span></span>|`MyType : IList<string>`<br /><br /> <span data-ttu-id="e85c3-248">lub</span><span class="sxs-lookup"><span data-stu-id="e85c3-248">or</span></span><br /><br /> <span data-ttu-id="e85c3-249">`MyType<T> : IList<string>`gdzie T =`int`</span><span class="sxs-lookup"><span data-stu-id="e85c3-249">`MyType<T> : IList<string>` where T=`int`</span></span>|<span data-ttu-id="e85c3-250">Ogólny zamkniętego (na przykład `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="e85c3-250">Closed generic (for example, `IList<string>`)</span></span>|  
|<span data-ttu-id="e85c3-251">Zamknięte z dowolnej liczby parametrów ogólnych</span><span class="sxs-lookup"><span data-stu-id="e85c3-251">Closed generic with any number of parameters</span></span>|<span data-ttu-id="e85c3-252">Otwarte ogólne przy użyciu jednego z parametrów typu</span><span class="sxs-lookup"><span data-stu-id="e85c3-252">Open generic using any one of the type’s parameters</span></span>|`MyType<T,U,V> : IList<U>`<br /><br /> <span data-ttu-id="e85c3-253">gdzie T =`int`, U =`string`, V =`bool`</span><span class="sxs-lookup"><span data-stu-id="e85c3-253">where T=`int`, U=`string`, V=`bool`</span></span>|<span data-ttu-id="e85c3-254">Ogólny zamkniętego (na przykład `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="e85c3-254">Closed generic (for example, `IList<string>`)</span></span>|  
|<span data-ttu-id="e85c3-255">Otwarte ogólne z jednym parametrem</span><span class="sxs-lookup"><span data-stu-id="e85c3-255">Open generic with one parameter</span></span>|<span data-ttu-id="e85c3-256">Ogólny Otwórz za pomocą parametru typu</span><span class="sxs-lookup"><span data-stu-id="e85c3-256">Open generic using the type’s parameter</span></span>|<span data-ttu-id="e85c3-257">`MyType<T> : IList<T>`, T jest otwarty</span><span class="sxs-lookup"><span data-stu-id="e85c3-257">`MyType<T> : IList<T>`, T is open</span></span>|<span data-ttu-id="e85c3-258">Otwarte ogólne (na przykład `IList<T>`)</span><span class="sxs-lookup"><span data-stu-id="e85c3-258">Open generic (for example, `IList<T>`)</span></span>|  
  
 <span data-ttu-id="e85c3-259">Jeśli typ implementuje więcej niż jeden interfejs kolekcji listy, obowiązują następujące ograniczenia:</span><span class="sxs-lookup"><span data-stu-id="e85c3-259">If a type implements more than one list collection interface, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="e85c3-260">Jeśli typ implementuje ogólny <xref:System.Collections.Generic.IEnumerable%601> (lub pochodne interfejsy) wiele razy dla różnych typów, typ nie jest uznawany za typ prawidłowej kolekcji przywoływany i jest ignorowana.</span><span class="sxs-lookup"><span data-stu-id="e85c3-260">If the type implements Generic <xref:System.Collections.Generic.IEnumerable%601> (or its derived interfaces) multiple times for different types, the type is not considered a valid referenced collection type and is ignored.</span></span> <span data-ttu-id="e85c3-261">Dotyczy to nawet wtedy, gdy niektóre implementacje są nieprawidłowe lub Otwórz ogólne.</span><span class="sxs-lookup"><span data-stu-id="e85c3-261">This is true even if some implementations are invalid or use open generics.</span></span> <span data-ttu-id="e85c3-262">Na przykład typu, który implementuje ogólny <xref:System.Collections.Generic.IEnumerable%601> z `int` i rodzajowy <xref:System.Collections.Generic.IEnumerable%601> t nigdy nie będzie można użyć jako kolekcja przywoływanego `int` lub innego typu, niezależnie od tego, czy typ ma `Add` akceptowanie — metoda `int` lub `Add` metoda przyjmuje parametr typu T lub oba.</span><span class="sxs-lookup"><span data-stu-id="e85c3-262">For example, a type that implements Generic <xref:System.Collections.Generic.IEnumerable%601> of `int` and Generic <xref:System.Collections.Generic.IEnumerable%601> of T would never be used as a referenced collection of `int` or any other type, regardless of whether the type has an `Add` method accepting `int` or an `Add` method accepting a parameter of type T, or both.</span></span>  
  
-   <span data-ttu-id="e85c3-263">Jeśli typ implementuje interfejs kolekcji ogólnych oraz <xref:System.Collections.IList>, typ nigdy nie jest używany jako typ kolekcji do którego istnieje odwołanie, chyba, że interfejs kolekcji ogólnych jest zamknięty ogólnego typu <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="e85c3-263">If the type implements a generic collection interface as well as <xref:System.Collections.IList>, the type is never used as a referenced collection type unless the generic collection interface is a closed generic of type <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="e85c3-264">Kolekcje słownika przypadkach w poniższej tabeli są obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="e85c3-264">For dictionary collections, only the cases in the following table are supported.</span></span>  
  
|<span data-ttu-id="e85c3-265">Typu występującego w odwołaniu</span><span class="sxs-lookup"><span data-stu-id="e85c3-265">Referenced type</span></span>|<span data-ttu-id="e85c3-266">Typ odwołania do interfejsu implementowanego przez</span><span class="sxs-lookup"><span data-stu-id="e85c3-266">Interface implemented by referenced type</span></span>|<span data-ttu-id="e85c3-267">Przykład</span><span class="sxs-lookup"><span data-stu-id="e85c3-267">Example</span></span>|<span data-ttu-id="e85c3-268">Typ traktowane jako</span><span class="sxs-lookup"><span data-stu-id="e85c3-268">Type treated as</span></span>|  
|---------------------|----------------------------------------------|-------------|---------------------|  
|<span data-ttu-id="e85c3-269">Inne niż ogólne lub zamkniętych ogólny (dowolną liczbę parametrów)</span><span class="sxs-lookup"><span data-stu-id="e85c3-269">Non-generic or closed generic (any number of parameters)</span></span>|<xref:System.Collections.IDictionary>|`MyType : IDictionary`<br /><br /> <span data-ttu-id="e85c3-270">lub</span><span class="sxs-lookup"><span data-stu-id="e85c3-270">or</span></span><br /><br /> <span data-ttu-id="e85c3-271">`MyType<T> : IDictionary`gdzie T =`int`</span><span class="sxs-lookup"><span data-stu-id="e85c3-271">`MyType<T> : IDictionary` where T=`int`</span></span>|<span data-ttu-id="e85c3-272">Zamknięte ogólny`IDictionary<object,object>`</span><span class="sxs-lookup"><span data-stu-id="e85c3-272">Closed generic `IDictionary<object,object>`</span></span>|  
|<span data-ttu-id="e85c3-273">Ogólny zamkniętego (dowolną liczbę parametrów)</span><span class="sxs-lookup"><span data-stu-id="e85c3-273">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="e85c3-274"><xref:System.Collections.Generic.IDictionary%602>, zamknięty</span><span class="sxs-lookup"><span data-stu-id="e85c3-274"><xref:System.Collections.Generic.IDictionary%602>, closed</span></span>|<span data-ttu-id="e85c3-275">`MyType<T> : IDictionary<string, bool>`gdzie T =`int`</span><span class="sxs-lookup"><span data-stu-id="e85c3-275">`MyType<T> : IDictionary<string, bool>` where T=`int`</span></span>|<span data-ttu-id="e85c3-276">Ogólny zamkniętego (na przykład `IDIctionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="e85c3-276">Closed generic (for example, `IDIctionary<string,bool>`)</span></span>|  
|<span data-ttu-id="e85c3-277">Ogólny zamkniętego (dowolną liczbę parametrów)</span><span class="sxs-lookup"><span data-stu-id="e85c3-277">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="e85c3-278">Ogólny <xref:System.Collections.Generic.IDictionary%602>, klucz lub wartość jest zamknięty, drugi jest otwarty i korzysta z jednego z parametrów typu</span><span class="sxs-lookup"><span data-stu-id="e85c3-278">Generic <xref:System.Collections.Generic.IDictionary%602>, one of either key or value is closed, the other is open and uses one of type’s parameters</span></span>|<span data-ttu-id="e85c3-279">`MyType<T,U,V> : IDictionary<string,V>`gdzie T =`int`, U =`float`, V =`bool`</span><span class="sxs-lookup"><span data-stu-id="e85c3-279">`MyType<T,U,V> : IDictionary<string,V>` where T=`int`, U=`float`,V=`bool`</span></span><br /><br /> <span data-ttu-id="e85c3-280">lub</span><span class="sxs-lookup"><span data-stu-id="e85c3-280">or</span></span><br /><br /> <span data-ttu-id="e85c3-281">`MyType<Z> : IDictionary<Z,bool>`gdy Z =`string`</span><span class="sxs-lookup"><span data-stu-id="e85c3-281">`MyType<Z> : IDictionary<Z,bool>` where Z=`string`</span></span>|<span data-ttu-id="e85c3-282">Ogólny zamkniętego (na przykład `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="e85c3-282">Closed generic (For example, `IDictionary<string,bool>`)</span></span>|  
|<span data-ttu-id="e85c3-283">Ogólny zamkniętego (dowolną liczbę parametrów)</span><span class="sxs-lookup"><span data-stu-id="e85c3-283">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="e85c3-284">Ogólny <xref:System.Collections.Generic.IDictionary%602>, zarówno klucz i wartość są otwarte i każda używa jednego z parametrów typu</span><span class="sxs-lookup"><span data-stu-id="e85c3-284">Generic <xref:System.Collections.Generic.IDictionary%602>, both key and value are open and each uses one of the type’s parameters</span></span>|<span data-ttu-id="e85c3-285">`MyType<T,U,V> : IDictionary<V,U>`gdzie T =`int`, U =`bool`, V =`string`</span><span class="sxs-lookup"><span data-stu-id="e85c3-285">`MyType<T,U,V> : IDictionary<V,U>` where T=`int`, U=`bool`, V=`string`</span></span>|<span data-ttu-id="e85c3-286">Ogólny zamkniętego (na przykład `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="e85c3-286">Closed generic (for example, `IDictionary<string,bool>`)</span></span>|  
|<span data-ttu-id="e85c3-287">Otwarte ogólne (dwa parametry)</span><span class="sxs-lookup"><span data-stu-id="e85c3-287">Open generic (two parameters)</span></span>|<span data-ttu-id="e85c3-288">Ogólny <xref:System.Collections.Generic.IDictionary%602>, Otwórz, używa zarówno ogólnych parametrów typu w kolejności ich występowania</span><span class="sxs-lookup"><span data-stu-id="e85c3-288">Generic <xref:System.Collections.Generic.IDictionary%602>, open, uses both of the type’s generic parameters in the order they appear</span></span>|<span data-ttu-id="e85c3-289">`MyType<K,V> : IDictionary<K,V>`, K i V zarówno Otwórz</span><span class="sxs-lookup"><span data-stu-id="e85c3-289">`MyType<K,V> : IDictionary<K,V>`, K and V both open</span></span>|<span data-ttu-id="e85c3-290">Otwarte ogólne (na przykład `IDictionary<K,V>`)</span><span class="sxs-lookup"><span data-stu-id="e85c3-290">Open generic (for example, `IDictionary<K,V>`)</span></span>|  
  
 <span data-ttu-id="e85c3-291">Jeśli typ implementuje zarówno <xref:System.Collections.IDictionary> i rodzajowy <xref:System.Collections.Generic.IDictionary%602>tylko ogólny <xref:System.Collections.Generic.IDictionary%602> jest uznawany za.</span><span class="sxs-lookup"><span data-stu-id="e85c3-291">If the type implements both <xref:System.Collections.IDictionary> and Generic <xref:System.Collections.Generic.IDictionary%602>, only Generic <xref:System.Collections.Generic.IDictionary%602> is considered.</span></span>  
  
 <span data-ttu-id="e85c3-292">Odwołania do typów ogólnych z częściowa nie jest obsługiwana.</span><span class="sxs-lookup"><span data-stu-id="e85c3-292">Referencing partial generic types is not supported.</span></span>  
  
 <span data-ttu-id="e85c3-293">Duplikaty są niedozwolone, na przykład nie można dodać zarówno ogólnego <xref:System.Collections.Generic.List%601> z `Integer` i rodzajowy zbiór `Integer` do <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, ponieważ dzięki temu możliwa do określenia, które do użycia podczas listy liczb całkowitych został znaleziony w schemacie.</span><span class="sxs-lookup"><span data-stu-id="e85c3-293">Duplicates are not allowed, for example, you cannot add both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` to <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, because this makes it impossible to determine which one to use when a list of integers is found in the schema.</span></span> <span data-ttu-id="e85c3-294">Duplikaty są wykrywane tylko wtedy, gdy jest typem w schemacie, który ujawnia problem duplikaty.</span><span class="sxs-lookup"><span data-stu-id="e85c3-294">Duplicates are detected only if there is a type in the schema that exposes the duplicates problem.</span></span> <span data-ttu-id="e85c3-295">Na przykład, jeśli schemat importowana nie zawiera listy liczb całkowitych, jego może mieć zarówno ogólnego <xref:System.Collections.Generic.List%601> z `Integer` i rodzajowy zbiór `Integer` w <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, ale nie ma żadnego efektu.</span><span class="sxs-lookup"><span data-stu-id="e85c3-295">For example, if the schema being imported does not contain lists of integers, it is allowed to have both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` in the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, but neither has any effect.</span></span>  
  
## <a name="advanced-collection-rules"></a><span data-ttu-id="e85c3-296">Zaawansowane kolekcji reguł</span><span class="sxs-lookup"><span data-stu-id="e85c3-296">Advanced Collection Rules</span></span>  
  
### <a name="serializing-collections"></a><span data-ttu-id="e85c3-297">Serializowanie kolekcji</span><span class="sxs-lookup"><span data-stu-id="e85c3-297">Serializing Collections</span></span>  
 <span data-ttu-id="e85c3-298">Oto lista reguł kolekcji serializacji:</span><span class="sxs-lookup"><span data-stu-id="e85c3-298">The following is a list of collection rules for serialization:</span></span>  
  
-   <span data-ttu-id="e85c3-299">Łączenie typów kolekcji (o kolekcji kolekcje) jest dozwolone.</span><span class="sxs-lookup"><span data-stu-id="e85c3-299">Combining collection types (having collections of collections) is allowed.</span></span> <span data-ttu-id="e85c3-300">Tablice nieregularne są traktowane jako kolekcje z kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-300">Jagged arrays are treated as collections of collections.</span></span> <span data-ttu-id="e85c3-301">Tablice wielowymiarowe nie są obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="e85c3-301">Multidimensional arrays are not supported.</span></span>  
  
-   <span data-ttu-id="e85c3-302">Tablice typu byte i tablice <xref:System.Xml.XmlNode> to typy tablicy specjalne, które są traktowane jako typów podstawowych, nie kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-302">Arrays of byte and arrays of <xref:System.Xml.XmlNode> are special array types that are treated as primitives, not collections.</span></span> <span data-ttu-id="e85c3-303">Serializacja tablicę bajtów wyników w pojedynczy element XML zawierający fragmentów danych algorytmem Base64, zamiast elementu osobne dla każdego bajtu.</span><span class="sxs-lookup"><span data-stu-id="e85c3-303">Serializing an array of byte results in a single XML element that contains a chunk of Base64-encoded data, instead of a separate element for each byte.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="e85c3-304">w jaki sposób tablicę <xref:System.Xml.XmlNode> jest traktowane, zobacz [typy XML i ADO.NET w kontraktach danych](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="e85c3-304"> how an array of <xref:System.Xml.XmlNode> is treated, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span> <span data-ttu-id="e85c3-305">Oczywiście te typy specjalne mogą się uczestniczyć w kolekcji: tablica tablicy bajtów skutkuje wiele elementów XML, z zawierających fragmentów danych algorytmem Base64.</span><span class="sxs-lookup"><span data-stu-id="e85c3-305">Of course, these special types can themselves participate in collections: an array of array of byte results in multiple XML elements, with each containing a chunk of Base64-encoded data.</span></span>  
  
-   <span data-ttu-id="e85c3-306">Jeśli <xref:System.Runtime.Serialization.DataContractAttribute> atrybut jest stosowany do typu kolekcji, typ jest traktowany jako typ kontraktu regularnych danych, nie jako kolekcja.</span><span class="sxs-lookup"><span data-stu-id="e85c3-306">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a collection type, the type is treated as a regular data contract type, not as a collection.</span></span>  
  
-   <span data-ttu-id="e85c3-307">Jeśli typ kolekcji implementuje <xref:System.Xml.Serialization.IXmlSerializable> interfejsu, stosowane są następujące reguły, określony typ `myType:IList<string>, IXmlSerializable`:</span><span class="sxs-lookup"><span data-stu-id="e85c3-307">If a collection type implements the <xref:System.Xml.Serialization.IXmlSerializable> interface, the following rules apply, given a type `myType:IList<string>, IXmlSerializable`:</span></span>  
  
    -   <span data-ttu-id="e85c3-308">Jeśli jest zadeklarowanym typem `IList<string>`, typ jest szeregowana jako listę.</span><span class="sxs-lookup"><span data-stu-id="e85c3-308">If the declared type is `IList<string>`, the type is serialized as a list.</span></span>  
  
    -   <span data-ttu-id="e85c3-309">Jeśli jest zadeklarowanym typem `myType`, jest szeregowana jako `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="e85c3-309">If the declared type is `myType`, it is serialized as `IXmlSerializable`.</span></span>  
  
    -   <span data-ttu-id="e85c3-310">Jeśli jest zadeklarowanym typem `IXmlSerializable`, jest szeregowana jako `IXmlSerializable`, ale tylko wtedy, gdy dodasz `myType` do listy znanych typów.</span><span class="sxs-lookup"><span data-stu-id="e85c3-310">If the declared type is `IXmlSerializable`, it is serialized as `IXmlSerializable`, but only if you add `myType` to the list of known types.</span></span>  
  
-   <span data-ttu-id="e85c3-311">Kolekcje są serializacji i deserializacji za pomocą metod przedstawiono w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="e85c3-311">Collections are serialized and deserialized using the methods shown in the following table.</span></span>  
  
|<span data-ttu-id="e85c3-312">Implementuje typ kolekcji</span><span class="sxs-lookup"><span data-stu-id="e85c3-312">Collection type implements</span></span>|<span data-ttu-id="e85c3-313">Metody wywołano serializacji</span><span class="sxs-lookup"><span data-stu-id="e85c3-313">Method(s) called on serialization</span></span>|<span data-ttu-id="e85c3-314">Metody o nazwie przy deserializacji</span><span class="sxs-lookup"><span data-stu-id="e85c3-314">Method(s) called on deserialization</span></span>|  
|--------------------------------|-----------------------------------------|-------------------------------------------|  
|<span data-ttu-id="e85c3-315">Ogólny<xref:System.Collections.Generic.IDictionary%602></span><span class="sxs-lookup"><span data-stu-id="e85c3-315">Generic <xref:System.Collections.Generic.IDictionary%602></span></span>|<span data-ttu-id="e85c3-316">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="e85c3-316">`get_Keys`, `get_Values`</span></span>|<span data-ttu-id="e85c3-317">Dodaj ogólny</span><span class="sxs-lookup"><span data-stu-id="e85c3-317">Generic Add</span></span>|  
|<xref:System.Collections.IDictionary>|<span data-ttu-id="e85c3-318">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="e85c3-318">`get_Keys`, `get_Values`</span></span>|`Add`|  
|<span data-ttu-id="e85c3-319">Ogólny<xref:System.Collections.Generic.IList%601></span><span class="sxs-lookup"><span data-stu-id="e85c3-319">Generic <xref:System.Collections.Generic.IList%601></span></span>|<span data-ttu-id="e85c3-320">Ogólny <xref:System.Collections.Generic.IList%601> indeksatora</span><span class="sxs-lookup"><span data-stu-id="e85c3-320">Generic <xref:System.Collections.Generic.IList%601> indexer</span></span>|<span data-ttu-id="e85c3-321">Dodaj ogólny</span><span class="sxs-lookup"><span data-stu-id="e85c3-321">Generic Add</span></span>|  
|<span data-ttu-id="e85c3-322">Ogólny<xref:System.Collections.Generic.ICollection%601></span><span class="sxs-lookup"><span data-stu-id="e85c3-322">Generic <xref:System.Collections.Generic.ICollection%601></span></span>|<span data-ttu-id="e85c3-323">Moduł wyliczający</span><span class="sxs-lookup"><span data-stu-id="e85c3-323">Enumerator</span></span>|<span data-ttu-id="e85c3-324">Dodaj ogólny</span><span class="sxs-lookup"><span data-stu-id="e85c3-324">Generic Add</span></span>|  
|<xref:System.Collections.IList>|<span data-ttu-id="e85c3-325"><xref:System.Collections.IList>Indeksator</span><span class="sxs-lookup"><span data-stu-id="e85c3-325"><xref:System.Collections.IList> Indexer</span></span>|`Add`|  
|<span data-ttu-id="e85c3-326">Ogólny<xref:System.Collections.Generic.IEnumerable%601></span><span class="sxs-lookup"><span data-stu-id="e85c3-326">Generic <xref:System.Collections.Generic.IEnumerable%601></span></span>|`GetEnumerator`|<span data-ttu-id="e85c3-327">Wywołana metoda niestatyczna `Add` który przyjmuje jeden parametr odpowiedniego typu (typ parametru ogólnego) lub jeden z jego typów podstawowych.</span><span class="sxs-lookup"><span data-stu-id="e85c3-327">A non-static method called `Add` that takes one parameter of the appropriate type (the type of the generic parameter or one of its base types).</span></span> <span data-ttu-id="e85c3-328">Taka metoda musi istnieć dla serializatora traktowanie typ kolekcji jako kolekcji zarówno podczas serializacji i deserializacji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-328">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|  
|<span data-ttu-id="e85c3-329"><xref:System.Collections.IEnumerable>(a zatem <xref:System.Collections.ICollection>, co wynika z niego)</span><span class="sxs-lookup"><span data-stu-id="e85c3-329"><xref:System.Collections.IEnumerable> (and thus <xref:System.Collections.ICollection>, which derives from it)</span></span>|`GetEnumerator`|<span data-ttu-id="e85c3-330">Wywołana metoda niestatyczna `Add` który przyjmuje jeden parametr typu `Object`.</span><span class="sxs-lookup"><span data-stu-id="e85c3-330">A non-static method called `Add` that takes one parameter of type `Object`.</span></span> <span data-ttu-id="e85c3-331">Taka metoda musi istnieć dla serializatora traktowanie typ kolekcji jako kolekcji zarówno podczas serializacji i deserializacji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-331">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|  
  
 <span data-ttu-id="e85c3-332">W poprzedniej tabeli wymieniono interfejsy kolekcji w kolejności malejącej.</span><span class="sxs-lookup"><span data-stu-id="e85c3-332">The preceding table lists collection interfaces in descending order of precedence.</span></span> <span data-ttu-id="e85c3-333">Oznacza to, na przykład, że jeśli typ implementuje zarówno <xref:System.Collections.IList> i rodzajowy <xref:System.Collections.Generic.IEnumerable%601>, Kolekcja jest serializacji i deserializacji zgodnie z <xref:System.Collections.IList> reguł:</span><span class="sxs-lookup"><span data-stu-id="e85c3-333">This means, for example, that if a type implements both <xref:System.Collections.IList> and Generic <xref:System.Collections.Generic.IEnumerable%601>, the collection is serialized and deserialized according to the <xref:System.Collections.IList> rules:</span></span>  
  
-   <span data-ttu-id="e85c3-334">Przy deserializacji wszystkie kolekcje są rozszeregować przez utworzenie wystąpienia typu przez wywołanie domyślnego konstruktora, który musi być obecny dla serializatora traktowanie typ kolekcji jako kolekcji zarówno podczas serializacji i deserializacji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-334">At deserialization, all collections are deserialized by first creating an instance of the type by calling the default constructor, which must be present for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>  
  
-   <span data-ttu-id="e85c3-335">Jeśli ten sam interfejs rodzajowej kolekcji jest więcej niż raz (na przykład, jeśli typ implementuje zarówno ogólnego <xref:System.Collections.Generic.ICollection%601> z `Integer` i rodzajowy <xref:System.Collections.Generic.ICollection%601> z <xref:System.String>) i zostanie znaleziony żaden interfejs wyższy priorytet, Kolekcja jest nie są traktowane jako prawidłowe kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-335">If the same generic collection interface is implemented more than once (for example, if a type implements both Generic <xref:System.Collections.Generic.ICollection%601> of `Integer` and Generic <xref:System.Collections.Generic.ICollection%601> of <xref:System.String>) and no higher-precedence interface is found, the collection is not treated as a valid collection.</span></span>  
  
-   <span data-ttu-id="e85c3-336">Typy kolekcji może mieć <xref:System.SerializableAttribute> atrybut zastosowanych do nich i można zaimplementować <xref:System.Runtime.Serialization.ISerializable> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="e85c3-336">Collection types can have the <xref:System.SerializableAttribute> attribute applied to them and can implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span> <span data-ttu-id="e85c3-337">Oba te są ignorowane.</span><span class="sxs-lookup"><span data-stu-id="e85c3-337">Both of these are ignored.</span></span> <span data-ttu-id="e85c3-338">Jednak jeśli typ nie pełni spełnia wymagania typu kolekcji (na przykład `Add` brakuje metody), typ nie jest uznawany za typ kolekcji i w związku z tym <xref:System.SerializableAttribute> atrybutu i <xref:System.Runtime.Serialization.ISerializable> interfejsu są używane do określania Określa, czy można zserializować typu.</span><span class="sxs-lookup"><span data-stu-id="e85c3-338">However, if the type does not fully meet collection type requirements (for example, the `Add` method is missing), the type is not considered a collection type, and thus the <xref:System.SerializableAttribute> attribute and the <xref:System.Runtime.Serialization.ISerializable> interface are used to determine whether the type can be serialized.</span></span>  
  
-   <span data-ttu-id="e85c3-339">Stosowanie <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu do kolekcji, aby dostosować go usuwa <xref:System.SerializableAttribute> poprzedzających mechanizm rezerwowy.</span><span class="sxs-lookup"><span data-stu-id="e85c3-339">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a collection to customize it removes the <xref:System.SerializableAttribute> preceding fallback mechanism.</span></span> <span data-ttu-id="e85c3-340">Zamiast tego, jeśli dostosowany zbiór jest kolekcji nie spełniają wymagania dotyczące typu, <xref:System.Runtime.Serialization.InvalidDataContractException> wyjątku.</span><span class="sxs-lookup"><span data-stu-id="e85c3-340">Instead, if a customized collection does not meet collection type requirements, an <xref:System.Runtime.Serialization.InvalidDataContractException> exception is thrown.</span></span> <span data-ttu-id="e85c3-341">Parametry wyjątków często zawierają informacje, wyjaśniający, dlaczego danego typu nie jest uznawane za prawidłowe kolekcji (nie `Add` metody, brak konstruktora domyślnego i tak dalej), więc często jest to przydatne w celu zastosowania <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu na potrzeby debugowania.</span><span class="sxs-lookup"><span data-stu-id="e85c3-341">The exception string often contains information that explains why a given type is not considered a valid collection (no `Add` method, no default constructor, and so on), so it is often useful to apply the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute for debugging purposes.</span></span>  
  
### <a name="collection-naming"></a><span data-ttu-id="e85c3-342">Kolekcja nazw</span><span class="sxs-lookup"><span data-stu-id="e85c3-342">Collection Naming</span></span>  
 <span data-ttu-id="e85c3-343">Oto lista kolekcji reguł nazewnictwa:</span><span class="sxs-lookup"><span data-stu-id="e85c3-343">The following is a list of collection naming rules:</span></span>  
  
-   <span data-ttu-id="e85c3-344">Domyślny obszar nazw dla wszystkich umów danych kolekcji słownika, a także listy kontraktów danych kolekcji, które zawierają typy pierwotne, jest http://schemas.microsoft.com/2003/10/Serialization/Arrays, chyba że przesłonić przy użyciu Namespace.</span><span class="sxs-lookup"><span data-stu-id="e85c3-344">The default namespace for all dictionary collection data contracts, as well as for list collection data contracts that contain primitive types, is http://schemas.microsoft.com/2003/10/Serialization/Arrays unless overridden using Namespace.</span></span> <span data-ttu-id="e85c3-345">Typy, które mapują na wbudowane typy XSD, jak również `char`, `Timespan`, i `Guid` typów, są traktowane jako podstawowych, w tym celu.</span><span class="sxs-lookup"><span data-stu-id="e85c3-345">Types that map to built-in XSD types, as well as `char`, `Timespan`, and `Guid` types, are considered primitives for this purpose.</span></span>  
  
-   <span data-ttu-id="e85c3-346">Domyślny obszar nazw dla typów kolekcji, które zawierają typy innego niż pierwotny, chyba że jest on przesłaniany przy użyciu Namespace, jest taka sama jak przestrzeń nazw kontraktu danych typu zawartego w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-346">The default namespace for collection types that contain non-primitive types, unless it is overridden using Namespace, is the same as the data contract namespace of the type contained in the collection.</span></span>  
  
-   <span data-ttu-id="e85c3-347">Domyślna nazwa listy kontraktów danych kolekcji, chyba że zastąpione przy użyciu nazwy, jest ciąg "ArrayOf" łączyć o nazwie kontraktu danych typu zawartego w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-347">The default name for list collection data contracts, unless overridden using Name, is the string "ArrayOf" combined with the data contract name of the type contained in the collection.</span></span> <span data-ttu-id="e85c3-348">Na przykład nazwa kontraktu danych ogólnych listy liczb całkowitych jest "ArrayOfint".</span><span class="sxs-lookup"><span data-stu-id="e85c3-348">For example, the data contract name for a Generic List of Integers is "ArrayOfint".</span></span> <span data-ttu-id="e85c3-349">Należy pamiętać, że nazwa kontraktu danych `Object` jest "anyType", takie jak nazwa kontraktu danych list nieogólnego <xref:System.Collections.ArrayList> jest "ArrayOfanyType".</span><span class="sxs-lookup"><span data-stu-id="e85c3-349">Keep in mind that the data contract name of `Object` is "anyType", so the data contract name of non-generic lists like <xref:System.Collections.ArrayList> is "ArrayOfanyType".</span></span>  
  
 <span data-ttu-id="e85c3-350">Domyślna nazwa dla słownika danych kolekcji umów, chyba że przesłonić przy użyciu `Name`, to ciąg "ArrayOfKeyValueOf" połączone z nazwą kontraktu danych typu klucza następuje nazwa kontraktu danych typu wartości.</span><span class="sxs-lookup"><span data-stu-id="e85c3-350">The default name for dictionary collection data contracts, unless overridden using `Name`, is the string "ArrayOfKeyValueOf" combined with the data contract name of the key type followed by the data contract name of the value type.</span></span> <span data-ttu-id="e85c3-351">Na przykład dane nazwy kontraktu dla ogólnego słownika ciągiem, a liczba całkowita jest "ArrayOfKeyValueOfstringint".</span><span class="sxs-lookup"><span data-stu-id="e85c3-351">For example, the data contract name for a Generic Dictionary of String and Integer is "ArrayOfKeyValueOfstringint".</span></span> <span data-ttu-id="e85c3-352">Ponadto jeśli klucz lub typów wartości nie są typy pierwotne, skrót przestrzeni nazw z przestrzeni nazw kontraktu danych typów kluczy i wartości jest dołączany do nazwy.</span><span class="sxs-lookup"><span data-stu-id="e85c3-352">Additionally, if either the key or the value types are not primitive types, a namespace hash of the data contract namespaces of the key and value types is appended to the name.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="e85c3-353">skróty przestrzeni nazw, zobacz [nazwy kontraktów danych](../../../../docs/framework/wcf/feature-details/data-contract-names.md).</span><span class="sxs-lookup"><span data-stu-id="e85c3-353"> namespace hashes, see [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md).</span></span>  
  
 <span data-ttu-id="e85c3-354">Każdy kontraktu danych kolekcji słownik ma pomocnika kontraktu danych, który reprezentuje jeden wpis w słowniku.</span><span class="sxs-lookup"><span data-stu-id="e85c3-354">Each dictionary collection data contract has a companion data contract that represents one entry in the dictionary.</span></span> <span data-ttu-id="e85c3-355">Jego nazwa jest taka sama jak w przypadku słownika kontraktu danych, z wyjątkiem prefiksu "ArrayOf" i jego przestrzeni nazw są takie same jak kontraktu danych słownika.</span><span class="sxs-lookup"><span data-stu-id="e85c3-355">Its name is the same as for the dictionary data contract, except for the "ArrayOf" prefix, and its namespace is the same as for the dictionary data contract.</span></span> <span data-ttu-id="e85c3-356">Na przykład dla kontraktu danych słownika "ArrayOfKeyValueOfstringint", "KeyValueofstringint" kontraktu danych reprezentuje jeden wpis w słowniku.</span><span class="sxs-lookup"><span data-stu-id="e85c3-356">For example, for the "ArrayOfKeyValueOfstringint" dictionary data contract, the "KeyValueofstringint" data contract represents one entry in the dictionary.</span></span> <span data-ttu-id="e85c3-357">Nazwa tego kontraktu danych można dostosować, używając `ItemName` właściwości, zgodnie z opisem w następnej sekcji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-357">You can customize the name of this data contract by using the `ItemName` property, as described in the next section.</span></span>  
  
 <span data-ttu-id="e85c3-358">Ogólny typ reguły nazewnictwa, zgodnie z opisem w [nazwy kontraktów danych](../../../../docs/framework/wcf/feature-details/data-contract-names.md)pełni dotyczą typów kolekcji; które jest, można podać parametry typu ogólnego nawiasy klamrowe w nazwie.</span><span class="sxs-lookup"><span data-stu-id="e85c3-358">Generic type naming rules, as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md), fully apply to collection types; that is, you can use curly braces within Name to indicate generic type parameters.</span></span> <span data-ttu-id="e85c3-359">Jednak liczb w nawiasy klamrowe dotyczą parametrów ogólnych i nie typów zawartych w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-359">However, numbers within the braces refer to generic parameters and not types contained within the collection.</span></span>  
  
## <a name="collection-customization"></a><span data-ttu-id="e85c3-360">Dostosowywanie kolekcji</span><span class="sxs-lookup"><span data-stu-id="e85c3-360">Collection Customization</span></span>  
 <span data-ttu-id="e85c3-361">Następujące zastosowania <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu jest zabronione i spowodować <xref:System.Runtime.Serialization.InvalidDataContractException> wyjątek:</span><span class="sxs-lookup"><span data-stu-id="e85c3-361">The following uses of the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute are forbidden and result in an <xref:System.Runtime.Serialization.InvalidDataContractException> exception:</span></span>  
  
-   <span data-ttu-id="e85c3-362">Stosowanie <xref:System.Runtime.Serialization.DataContractAttribute> atrybutu z typem, do którego <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybut został zastosowany, lub do jednego z jego typów pochodnych.</span><span class="sxs-lookup"><span data-stu-id="e85c3-362">Applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to a type to which the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute has been applied, or to one of its derived types.</span></span>  
  
-   <span data-ttu-id="e85c3-363">Stosowanie <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu typu, który implementuje <xref:System.Xml.Serialization.IXmlSerializable> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="e85c3-363">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a type that implements the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>  
  
-   <span data-ttu-id="e85c3-364">Stosowanie <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybutu typu będącego kolekcją.</span><span class="sxs-lookup"><span data-stu-id="e85c3-364">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a non-collection type.</span></span>  
  
-   <span data-ttu-id="e85c3-365">Trwa próba skonfigurowania <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> lub <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> na <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybut zastosowany do typu z systemem innym niż słownika.</span><span class="sxs-lookup"><span data-stu-id="e85c3-365">Attempting to set <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> or <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> on a <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute applied to a non-dictionary type.</span></span>  
  
### <a name="polymorphism-rules"></a><span data-ttu-id="e85c3-366">Polimorfizm reguły</span><span class="sxs-lookup"><span data-stu-id="e85c3-366">Polymorphism Rules</span></span>  
 <span data-ttu-id="e85c3-367">Jak wcześniej wspomniano, dostosowywanie kolekcji przy użyciu <xref:System.Runtime.Serialization.CollectionDataContractAttribute> atrybut może zakłócać możliwości wymiennego stosowania kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-367">As previously mentioned, customizing collections by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute may interfere with collection interchangeability.</span></span> <span data-ttu-id="e85c3-368">Dwa typy dostosowany zbiór tylko jest uznawana za równoważne, jeśli ich nazwy, przestrzeń nazw, nazwa elementu, a także nazwy kluczy i wartości (jeśli są one kolekcje słownika) są zgodne.</span><span class="sxs-lookup"><span data-stu-id="e85c3-368">Two customized collection types can only be considered equivalent if their name, namespace, item name, as well as key and value names (if these are dictionary collections) match.</span></span>  
  
 <span data-ttu-id="e85c3-369">Z powodu dostosowań istnieje możliwość przypadkowego Użyj kontraktu danych kolekcji jednego gdy oczekiwano innego.</span><span class="sxs-lookup"><span data-stu-id="e85c3-369">Due to customizations, it is possible to inadvertently use one collection data contract where another is expected.</span></span> <span data-ttu-id="e85c3-370">Należy unikać to.</span><span class="sxs-lookup"><span data-stu-id="e85c3-370">This should be avoided.</span></span> <span data-ttu-id="e85c3-371">Zobacz następujące typy.</span><span class="sxs-lookup"><span data-stu-id="e85c3-371">See the following types.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#11)]
 [!code-vb[c_collection_types_in_data_contracts#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#11)]  
  
 <span data-ttu-id="e85c3-372">W tym przypadku wystąpienie `Marks1` można przypisać do `testMarks`.</span><span class="sxs-lookup"><span data-stu-id="e85c3-372">In this case, an instance of `Marks1` can be assigned to `testMarks`.</span></span> <span data-ttu-id="e85c3-373">Jednak `Marks2` nie powinna być używana, ponieważ jego kontraktu danych nie jest uznawane za równoważne `IList<int>` kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="e85c3-373">However, `Marks2` should not be used because its data contract is not considered equivalent to the `IList<int>` data contract.</span></span> <span data-ttu-id="e85c3-374">Nazwa kontraktu danych jest "Marks2", a nie "ArrayOfint" i identycznych nazwa elementu jest "\<oznaczyć >", a nie "\<int >".</span><span class="sxs-lookup"><span data-stu-id="e85c3-374">The data contract name is "Marks2" and not "ArrayOfint", and the repeating element name is "\<mark>" and not "\<int>".</span></span>  
  
 <span data-ttu-id="e85c3-375">Reguły w poniższej tabeli dotyczą polimorficznych przypisania kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-375">The rules in the following table apply to polymorphic assignment of collections.</span></span>  
  
|<span data-ttu-id="e85c3-376">Deklarowany typ</span><span class="sxs-lookup"><span data-stu-id="e85c3-376">Declared type</span></span>|<span data-ttu-id="e85c3-377">Przypisywanie bez dostosowania kolekcji</span><span class="sxs-lookup"><span data-stu-id="e85c3-377">Assigning a non-customized collection</span></span>|<span data-ttu-id="e85c3-378">Przypisywanie dostosowany zbiór</span><span class="sxs-lookup"><span data-stu-id="e85c3-378">Assigning a customized collection</span></span>|  
|-------------------|--------------------------------------------|---------------------------------------|  
|<span data-ttu-id="e85c3-379">Obiekt</span><span class="sxs-lookup"><span data-stu-id="e85c3-379">Object</span></span>|<span data-ttu-id="e85c3-380">Nazwa kontraktu jest serializowany.</span><span class="sxs-lookup"><span data-stu-id="e85c3-380">Contract name is serialized.</span></span>|<span data-ttu-id="e85c3-381">Nazwa kontraktu jest serializowany.</span><span class="sxs-lookup"><span data-stu-id="e85c3-381">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="e85c3-382">Dostosowywanie jest używany.</span><span class="sxs-lookup"><span data-stu-id="e85c3-382">Customization is used.</span></span>|  
|<span data-ttu-id="e85c3-383">Interfejs kolekcji</span><span class="sxs-lookup"><span data-stu-id="e85c3-383">Collection interface</span></span>|<span data-ttu-id="e85c3-384">Nazwa kontraktu nie jest serializowany.</span><span class="sxs-lookup"><span data-stu-id="e85c3-384">Contract name is not serialized.</span></span>|<span data-ttu-id="e85c3-385">Nazwa kontraktu nie jest serializowany.</span><span class="sxs-lookup"><span data-stu-id="e85c3-385">Contract name is not serialized.</span></span><br /><br /> <span data-ttu-id="e85c3-386">Dostosowanie nie jest used.*</span><span class="sxs-lookup"><span data-stu-id="e85c3-386">Customization is not used.*</span></span>|  
|<span data-ttu-id="e85c3-387">Dostosowane spoza zbioru</span><span class="sxs-lookup"><span data-stu-id="e85c3-387">Non-customized collection</span></span>|<span data-ttu-id="e85c3-388">Nazwa kontraktu nie jest serializowany.</span><span class="sxs-lookup"><span data-stu-id="e85c3-388">Contract name is not serialized.</span></span>|<span data-ttu-id="e85c3-389">Nazwa kontraktu jest serializowany.</span><span class="sxs-lookup"><span data-stu-id="e85c3-389">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="e85c3-390">Dostosowywanie jest used.* *</span><span class="sxs-lookup"><span data-stu-id="e85c3-390">Customization is used.**</span></span>|  
|<span data-ttu-id="e85c3-391">Kolekcja niestandardowych</span><span class="sxs-lookup"><span data-stu-id="e85c3-391">Customized collection</span></span>|<span data-ttu-id="e85c3-392">Nazwa kontraktu jest serializowany.</span><span class="sxs-lookup"><span data-stu-id="e85c3-392">Contract name is serialized.</span></span> <span data-ttu-id="e85c3-393">Dostosowanie nie jest used.* *</span><span class="sxs-lookup"><span data-stu-id="e85c3-393">Customization is not used.**</span></span>|<span data-ttu-id="e85c3-394">Nazwa kontraktu jest serializowany.</span><span class="sxs-lookup"><span data-stu-id="e85c3-394">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="e85c3-395">Dostosowanie typu przypisany jest used.* *</span><span class="sxs-lookup"><span data-stu-id="e85c3-395">Customization of the assigned type is used.**</span></span>|  
  
 <span data-ttu-id="e85c3-396">* Z <xref:System.Runtime.Serialization.NetDataContractSerializer> klas, dostosowywanie jest używany w tym przypadku.</span><span class="sxs-lookup"><span data-stu-id="e85c3-396">*With the <xref:System.Runtime.Serialization.NetDataContractSerializer> class, customization is used in this case.</span></span> <span data-ttu-id="e85c3-397"><xref:System.Runtime.Serialization.NetDataContractSerializer> w takim przypadku klasa nazwy typu rzeczywistego serializuje również, więc deserializacji działa zgodnie z oczekiwaniami.</span><span class="sxs-lookup"><span data-stu-id="e85c3-397">The <xref:System.Runtime.Serialization.NetDataContractSerializer> class also serializes the actual type name in this case, so deserialization works as expected.</span></span>  
  
 <span data-ttu-id="e85c3-398">** Tych przypadkach spowodować nieprawidłowy schemat wystąpień i w związku z tym należy unikać.</span><span class="sxs-lookup"><span data-stu-id="e85c3-398">**These cases result in schema-invalid instances and thus should be avoided.</span></span>  
  
 <span data-ttu-id="e85c3-399">W przypadkach, gdy jest serializowany nazwy kontraktu typ kolekcji przypisanej musi należeć do listy znanych typów.</span><span class="sxs-lookup"><span data-stu-id="e85c3-399">In the cases where the contract name is serialized, the assigned collection type should be in the known types list.</span></span> <span data-ttu-id="e85c3-400">Odwrotny również ma wartość true: w przypadku, gdy nazwa nie jest serializowany, dodanie typu do listy znanych typów nie jest wymagana.</span><span class="sxs-lookup"><span data-stu-id="e85c3-400">The opposite is also true: in the cases where the name is not serialized, adding the type to the known types list is not required.</span></span>  
  
 <span data-ttu-id="e85c3-401">Tablica typu pochodnego można przypisać do tablicy typu podstawowego.</span><span class="sxs-lookup"><span data-stu-id="e85c3-401">An array of a derived type can be assigned to an array of a base type.</span></span> <span data-ttu-id="e85c3-402">W takim przypadku Nazwa kontraktu dla typu pochodnego jest serializowany dla każdego elementu powtarzających się.</span><span class="sxs-lookup"><span data-stu-id="e85c3-402">In this case, the contract name for the derived type is serialized for each repeating element.</span></span> <span data-ttu-id="e85c3-403">Na przykład, jeśli typem `Book` pochodzi z typu `LibraryItem`, można przypisać tablicę `Book` do tablicy `LibraryItem`.</span><span class="sxs-lookup"><span data-stu-id="e85c3-403">For example, if a type `Book` derives from the type `LibraryItem`, you can assign an array of `Book` to an array of `LibraryItem`.</span></span> <span data-ttu-id="e85c3-404">Nie dotyczy innych typów kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-404">This does not apply to other collection types.</span></span> <span data-ttu-id="e85c3-405">Na przykład nie można przypisać `Generic List of Book` do `Generic List of LibraryItem`.</span><span class="sxs-lookup"><span data-stu-id="e85c3-405">For example, you cannot assign a `Generic List of Book` to a `Generic List of LibraryItem`.</span></span> <span data-ttu-id="e85c3-406">Można jednak przypisywać `Generic List of LibraryItem` zawierający `Book` wystąpień.</span><span class="sxs-lookup"><span data-stu-id="e85c3-406">You can, however, assign a `Generic List of LibraryItem` that contains `Book` instances.</span></span> <span data-ttu-id="e85c3-407">Zarówno w tablicy, jak i w przypadku nietablicowego `Book` musi należeć do listy znanych typów.</span><span class="sxs-lookup"><span data-stu-id="e85c3-407">In both the array and the non-array case, `Book` should be in the known types list.</span></span>  
  
## <a name="collections-and-object-reference-preservation"></a><span data-ttu-id="e85c3-408">Kolekcje i zachowywania odwołanie do obiektu</span><span class="sxs-lookup"><span data-stu-id="e85c3-408">Collections and Object Reference Preservation</span></span>  
 <span data-ttu-id="e85c3-409">Funkcje serializator w trybie, w którym zachowuje on odwołania do obiektów, zachowywania odwołanie do obiektu również zastosowanie do kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-409">When a serializer functions in a mode where it preserves object references, object reference preservation also applies to collections.</span></span> <span data-ttu-id="e85c3-410">W szczególności tożsamość obiektu są zachowywane dla całej kolekcji i indywidualnych elementów zawartych w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="e85c3-410">Specifically, object identity is preserved for both entire collections and individual items contained in collections.</span></span> <span data-ttu-id="e85c3-411">Słowników tożsamość obiektu jest zachowywana zarówno dla obiekt pary klucz/wartość i pojedyncze obiekty klucz i wartość.</span><span class="sxs-lookup"><span data-stu-id="e85c3-411">For dictionaries, object identity is preserved both for the key/value pair objects and the individual key and value objects.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e85c3-412">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="e85c3-412">See Also</span></span>  
 <xref:System.Runtime.Serialization.CollectionDataContractAttribute>
