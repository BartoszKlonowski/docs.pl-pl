---
title: Autonomiczna serializacja kodu JSON
ms.date: 03/30/2017
ms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287
ms.openlocfilehash: 701ad05b7432c36950ff514ad8c7c18a54c7f020
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/28/2019
ms.locfileid: "64586195"
---
# <a name="stand-alone-json-serialization"></a><span data-ttu-id="f93d8-102">Autonomiczna serializacja kodu JSON</span><span class="sxs-lookup"><span data-stu-id="f93d8-102">Stand-Alone JSON Serialization</span></span>
<span data-ttu-id="f93d8-103">JSON (JavaScript Object Notation) jest formatem danych przeznaczone do użycia przez kod JavaScript na stronach sieci Web uruchomionych w przeglądarce.</span><span class="sxs-lookup"><span data-stu-id="f93d8-103">JSON (JavaScript Object Notation) is a data format that is specifically designed to be used by JavaScript code running on Web pages inside the browser.</span></span> <span data-ttu-id="f93d8-104">Jest to domyślny format danych używany przez usługi ASP.NET AJAX, utworzone w Windows Communication Foundation (WCF).</span><span class="sxs-lookup"><span data-stu-id="f93d8-104">It is the default data format used by ASP.NET AJAX services created in Windows Communication Foundation (WCF).</span></span>  
  
 <span data-ttu-id="f93d8-105">Ten format można również podczas tworzenie usług AJAX bez integracji z usługą ASP.NET — w tym przypadku XML jest ustawieniem domyślnym, ale można wybrać JSON.</span><span class="sxs-lookup"><span data-stu-id="f93d8-105">This format can also be used when creating AJAX services without integrating with ASP.NET - in this case, XML is the default but JSON can be chosen.</span></span>  
  
 <span data-ttu-id="f93d8-106">Na koniec, jeśli wymagana jest obsługa JSON, ale są nietworzenie usługa AJAX <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> umożliwia bezpośrednio serializować obiekty platformy .NET na dane JSON i deserializować tych danych do wystąpienia typów .NET.</span><span class="sxs-lookup"><span data-stu-id="f93d8-106">Finally, if you require JSON support but are not creating an AJAX service, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> makes it possible to directly serialize .NET objects into JSON data and to deserialize such data back into instances of .NET types.</span></span> <span data-ttu-id="f93d8-107">Aby uzyskać opis jak to zrobić, zobacz [jak: Serializowanie i Deserializowanie danych JSON](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span><span class="sxs-lookup"><span data-stu-id="f93d8-107">For a description of how to do this, see [How to: Serialize and Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span></span>  
  
 <span data-ttu-id="f93d8-108">Podczas pracy z formatu JSON, te same typy .NET są obsługiwane, z pewnymi wyjątkami, ponieważ są obsługiwane przez <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="f93d8-108">When working with JSON, the same .NET types are supported, with a few exceptions, as are supported by the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="f93d8-109">Aby uzyskać listę typów obsługiwanych zobacz [typy obsługiwane przez serializator kontraktu danych](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="f93d8-109">For a list of the types supported, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="f93d8-110">Obejmuje to najbardziej pierwotnych typów, większość tablicy i typy kolekcji, jak również tak złożonego typy używające <xref:System.Runtime.Serialization.DataContractAttribute> i <xref:System.Runtime.Serialization.DataMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f93d8-110">This includes most primitive types, most array and collection types, as well as complex types that use the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute>.</span></span>  
  
## <a name="mapping-net-types-to-json-types"></a><span data-ttu-id="f93d8-111">Mapowania typów .NET do formatu JSON typów</span><span class="sxs-lookup"><span data-stu-id="f93d8-111">Mapping .NET types to JSON Types</span></span>  
 <span data-ttu-id="f93d8-112">W poniższej tabeli przedstawiono związek między typami .NET i typy JSON/JavaScript, gdy mapowany przez procedury serializacji i deserializacji.</span><span class="sxs-lookup"><span data-stu-id="f93d8-112">The following table shows the correspondence between .NET types and JSON/JavaScript types when mapped by serialization and deserialization procedures.</span></span>  
  
|<span data-ttu-id="f93d8-113">Typy .NET</span><span class="sxs-lookup"><span data-stu-id="f93d8-113">.NET Types</span></span>|<span data-ttu-id="f93d8-114">JSON/JavaScript</span><span class="sxs-lookup"><span data-stu-id="f93d8-114">JSON/JavaScript</span></span>|<span data-ttu-id="f93d8-115">Uwagi</span><span class="sxs-lookup"><span data-stu-id="f93d8-115">Notes</span></span>|  
|----------------|----------------------|-----------|  
|<span data-ttu-id="f93d8-116">Wszystkie typy liczbowe, na przykład <xref:System.Int32>, <xref:System.Decimal> lub <xref:System.Double></span><span class="sxs-lookup"><span data-stu-id="f93d8-116">All numeric types, for example <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double></span></span>|<span data-ttu-id="f93d8-117">Wartość liczbowa</span><span class="sxs-lookup"><span data-stu-id="f93d8-117">Number</span></span>|<span data-ttu-id="f93d8-118">Specjalne wartości, takich jak `Double.NaN`, `Double.PositiveInfinity` i `Double.NegativeInfinity` nie są obsługiwane i spowodować obiekt JSON jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="f93d8-118">Special values such as  `Double.NaN`, `Double.PositiveInfinity` and `Double.NegativeInfinity` are not supported and result in invalid JSON.</span></span>|  
|<xref:System.Enum>|<span data-ttu-id="f93d8-119">Wartość liczbowa</span><span class="sxs-lookup"><span data-stu-id="f93d8-119">Number</span></span>|<span data-ttu-id="f93d8-120">Zobacz "Wyliczeń i JSON" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="f93d8-120">See "Enumerations and JSON" later in this topic.</span></span>|  
|<xref:System.Boolean>|<span data-ttu-id="f93d8-121">Boolean</span><span class="sxs-lookup"><span data-stu-id="f93d8-121">Boolean</span></span>|--|  
|<span data-ttu-id="f93d8-122"><xref:System.String>, <xref:System.Char></span><span class="sxs-lookup"><span data-stu-id="f93d8-122"><xref:System.String>, <xref:System.Char></span></span>|<span data-ttu-id="f93d8-123">String</span><span class="sxs-lookup"><span data-stu-id="f93d8-123">String</span></span>|--|  
|<span data-ttu-id="f93d8-124"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span><span class="sxs-lookup"><span data-stu-id="f93d8-124"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span></span>|<span data-ttu-id="f93d8-125">String</span><span class="sxs-lookup"><span data-stu-id="f93d8-125">String</span></span>|<span data-ttu-id="f93d8-126">Format tych typów w formacie JSON jest taki sam jak XML (zasadniczo przedział czasu w formacie ISO 8601 czas, identyfikator GUID w formacie "12345678-ABCD-ABCD-ABCD-1234567890AB" i identyfikatora URI w postaci ciągu fizyczne, takie jak "http://www.example.com").</span><span class="sxs-lookup"><span data-stu-id="f93d8-126">The format of these types in JSON is the same as in XML (essentially, TimeSpan in the ISO 8601 Duration format, GUID in the "12345678-ABCD-ABCD-ABCD-1234567890AB" format and URI in its natural string form like "http://www.example.com").</span></span> <span data-ttu-id="f93d8-127">Aby uzyskać dokładne informacje, zobacz [odwołanie do schematu kontraktu danych](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="f93d8-127">For precise information, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>|  
|<xref:System.Xml.XmlQualifiedName>|<span data-ttu-id="f93d8-128">String</span><span class="sxs-lookup"><span data-stu-id="f93d8-128">String</span></span>|<span data-ttu-id="f93d8-129">Format jest "Nazwa: namespace" (wszystko przed pierwszym dwukropkiem nazywa się).</span><span class="sxs-lookup"><span data-stu-id="f93d8-129">The format is "name:namespace" (anything before the first colon is the name).</span></span> <span data-ttu-id="f93d8-130">Nazwa lub obszar nazw może być brak.</span><span class="sxs-lookup"><span data-stu-id="f93d8-130">Either the name or the namespace can be missing.</span></span> <span data-ttu-id="f93d8-131">Przypadku żadnej przestrzeni nazw można również pominąć dwukropkiem.</span><span class="sxs-lookup"><span data-stu-id="f93d8-131">If there is no namespace the colon can be omitted as well.</span></span>|  
|<span data-ttu-id="f93d8-132"><xref:System.Array> tego typu <xref:System.Byte></span><span class="sxs-lookup"><span data-stu-id="f93d8-132"><xref:System.Array> of type <xref:System.Byte></span></span>|<span data-ttu-id="f93d8-133">Tablica liczb</span><span class="sxs-lookup"><span data-stu-id="f93d8-133">Array of numbers</span></span>|<span data-ttu-id="f93d8-134">Każdy numer reprezentuje wartość jednego bajtu.</span><span class="sxs-lookup"><span data-stu-id="f93d8-134">Each number represents the value of one byte.</span></span>|  
|<xref:System.DateTime>|<span data-ttu-id="f93d8-135">Data i godzina lub ciągu</span><span class="sxs-lookup"><span data-stu-id="f93d8-135">DateTime or String</span></span>|<span data-ttu-id="f93d8-136">Zobacz daty / godziny i JSON w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="f93d8-136">See Dates/Times and JSON later in this topic.</span></span>|  
|<xref:System.DateTimeOffset>|<span data-ttu-id="f93d8-137">Typ złożony</span><span class="sxs-lookup"><span data-stu-id="f93d8-137">Complex type</span></span>|<span data-ttu-id="f93d8-138">Zobacz daty / godziny i JSON w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="f93d8-138">See Dates/Times and JSON later in this topic.</span></span>|  
|<span data-ttu-id="f93d8-139">Typy XML i ADO.NET (<xref:System.Xml.XmlElement>,</span><span class="sxs-lookup"><span data-stu-id="f93d8-139">XML and ADO.NET types (<xref:System.Xml.XmlElement>,</span></span><br /><br /> <span data-ttu-id="f93d8-140"><xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="f93d8-140"><xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="f93d8-141">Tablice <xref:System.Xml.XmlNode>,</span><span class="sxs-lookup"><span data-stu-id="f93d8-141">Arrays of <xref:System.Xml.XmlNode>,</span></span><br /><br /> <span data-ttu-id="f93d8-142"><xref:System.Runtime.Serialization.ISerializable>,</span><span class="sxs-lookup"><span data-stu-id="f93d8-142"><xref:System.Runtime.Serialization.ISerializable>,</span></span><br /><br /> <span data-ttu-id="f93d8-143"><xref:System.Data.DataSet>).</span><span class="sxs-lookup"><span data-stu-id="f93d8-143"><xref:System.Data.DataSet>).</span></span>|<span data-ttu-id="f93d8-144">String</span><span class="sxs-lookup"><span data-stu-id="f93d8-144">String</span></span>|<span data-ttu-id="f93d8-145">Zobacz sekcję typy XML i JSON w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="f93d8-145">See the XML Types and JSON section of this topic.</span></span>|  
|<xref:System.DBNull>|<span data-ttu-id="f93d8-146">Pusty typ złożony</span><span class="sxs-lookup"><span data-stu-id="f93d8-146">Empty complex type</span></span>|--|  
|<span data-ttu-id="f93d8-147">Kolekcje, słowniki i tablic</span><span class="sxs-lookup"><span data-stu-id="f93d8-147">Collections, dictionaries, and arrays</span></span>|<span data-ttu-id="f93d8-148">Tablica</span><span class="sxs-lookup"><span data-stu-id="f93d8-148">Array</span></span>|<span data-ttu-id="f93d8-149">Zobacz sekcję kolekcje, słowniki i tablic w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="f93d8-149">See the Collections, Dictionaries, and Arrays section of this topic.</span></span>|  
|<span data-ttu-id="f93d8-150">Typy złożone (przy użyciu <xref:System.Runtime.Serialization.DataContractAttribute> lub <xref:System.SerializableAttribute> zastosowane)</span><span class="sxs-lookup"><span data-stu-id="f93d8-150">Complex types (with the <xref:System.Runtime.Serialization.DataContractAttribute> or <xref:System.SerializableAttribute> applied)</span></span>|<span data-ttu-id="f93d8-151">Typ złożony</span><span class="sxs-lookup"><span data-stu-id="f93d8-151">Complex type</span></span>|<span data-ttu-id="f93d8-152">Elementy członkowskie danych stają się elementy członkowskie typu złożonego kodu JavaScript.</span><span class="sxs-lookup"><span data-stu-id="f93d8-152">Data members become members of the JavaScript complex type.</span></span>|  
|<span data-ttu-id="f93d8-153">Typy złożone Implementowanie <xref:System.Runtime.Serialization.ISerializable> interfejsu)</span><span class="sxs-lookup"><span data-stu-id="f93d8-153">Complex types implementing the <xref:System.Runtime.Serialization.ISerializable> interface)</span></span>|<span data-ttu-id="f93d8-154">Typ złożony</span><span class="sxs-lookup"><span data-stu-id="f93d8-154">Complex type</span></span>|<span data-ttu-id="f93d8-155">Taki sam jak inne typy złożone, ale niektóre <xref:System.Runtime.Serialization.ISerializable> typy nie są obsługiwane — zobacz temat pomocy technicznej ISerializable część sekcji Zaawansowane informacje o tym temacie.</span><span class="sxs-lookup"><span data-stu-id="f93d8-155">Same as other complex types but some <xref:System.Runtime.Serialization.ISerializable> types are not supported – see the ISerializable Support part of the Advanced Information section of this topic.</span></span>|  
|<span data-ttu-id="f93d8-156">`Null` wartość dla dowolnego typu</span><span class="sxs-lookup"><span data-stu-id="f93d8-156">`Null` value for any type</span></span>|<span data-ttu-id="f93d8-157">Null</span><span class="sxs-lookup"><span data-stu-id="f93d8-157">Null</span></span>|<span data-ttu-id="f93d8-158">Typy dopuszczające wartości zerowe są również obsługiwane i mapowanie do formatu JSON w taki sam sposób, jak typy niedopuszczające.</span><span class="sxs-lookup"><span data-stu-id="f93d8-158">Nullable types are also supported and map to JSON in the same way as non-nullable types.</span></span>|  
  
### <a name="enumerations-and-json"></a><span data-ttu-id="f93d8-159">Wyliczenia i JSON</span><span class="sxs-lookup"><span data-stu-id="f93d8-159">Enumerations and JSON</span></span>  
 <span data-ttu-id="f93d8-160">Wartości elementów członkowskich wyliczenia są traktowane jako liczby w formacie JSON, który jest inny niż jak są traktowane w kontraktach danych, w którym zostaną one dołączone jako nazwy elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="f93d8-160">Enumeration member values are treated as numbers in JSON, which is different from how they are treated in data contracts, where they are included as member names.</span></span> <span data-ttu-id="f93d8-161">Aby uzyskać więcej informacji na temat przetwarzania kontraktu danych, zobacz [Typy wyliczeniowe w kontraktach danych](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="f93d8-161">For more information about the data contract treatment, see [Enumeration Types in Data Contracts](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span></span>  
  
- <span data-ttu-id="f93d8-162">Na przykład, jeśli masz `public enum Color {red, green, blue, yellow, pink}`, serializacji `yellow` generuje numer 3 i nie ciągu "yellow".</span><span class="sxs-lookup"><span data-stu-id="f93d8-162">For example, if you have `public enum Color {red, green, blue, yellow, pink}`, serializing `yellow` produces the number 3 and not the string "yellow".</span></span>  
  
- <span data-ttu-id="f93d8-163">Wszystkie `enum` elementy członkowskie są możliwe do serializacji.</span><span class="sxs-lookup"><span data-stu-id="f93d8-163">All `enum` members are serializable.</span></span> <span data-ttu-id="f93d8-164"><xref:System.Runtime.Serialization.EnumMemberAttribute> i <xref:System.NonSerializedAttribute> atrybuty są ignorowane, jeśli używany.</span><span class="sxs-lookup"><span data-stu-id="f93d8-164">The <xref:System.Runtime.Serialization.EnumMemberAttribute> and the <xref:System.NonSerializedAttribute> attributes are ignored if used.</span></span>  
  
- <span data-ttu-id="f93d8-165">Można wykonać deserializacji nieistniejącej `enum` wartość — na przykład, wartość 87 może być zdeserializowany do poprzedniego wyliczenia Color, nawet jeśli istnieje bez odpowiedniej nazwy zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="f93d8-165">It is possible to deserialize a nonexistent `enum` value - for example, the value 87 can be deserialized into the previous Color enum even though there is no corresponding color name defined.</span></span>  
  
- <span data-ttu-id="f93d8-166">Flagi `enum` nie specjalnych i jest traktowane jako taki sam jak każdy inny `enum`.</span><span class="sxs-lookup"><span data-stu-id="f93d8-166">A flags `enum` is not special and is treated the same as any other `enum`.</span></span>  
  
### <a name="datestimes-and-json"></a><span data-ttu-id="f93d8-167">Daty/godziny i JSON</span><span class="sxs-lookup"><span data-stu-id="f93d8-167">Dates/Times and JSON</span></span>  
 <span data-ttu-id="f93d8-168">JSON format nie obsługuje bezpośrednio daty i godziny.</span><span class="sxs-lookup"><span data-stu-id="f93d8-168">The JSON format does not directly support dates and times.</span></span> <span data-ttu-id="f93d8-169">Jednak bardzo często są one używane, i ASP.NET AJAX zapewnia obsługę specjalnego rodzaju.</span><span class="sxs-lookup"><span data-stu-id="f93d8-169">However, they are very commonly used and ASP.NET AJAX provides special support for these types.</span></span> <span data-ttu-id="f93d8-170">Korzystając z serwerów proxy ASP.NET AJAX, <xref:System.DateTime> typ na platformie .NET, ale w pełni odpowiada `DateTime` typ w języku JavaScript.</span><span class="sxs-lookup"><span data-stu-id="f93d8-170">When using ASP.NET AJAX proxies, the <xref:System.DateTime> type in .NET fully corresponds to the `DateTime` type in JavaScript.</span></span>  
  
- <span data-ttu-id="f93d8-171">Bez korzystania z platformy ASP.NET, <xref:System.DateTime> typ jest reprezentowany w formacie JSON jako ciąg znaków za pomocą specjalnych formatu, który opisano w sekcji Zaawansowane informacje o tym temacie.</span><span class="sxs-lookup"><span data-stu-id="f93d8-171">When not using ASP.NET, a <xref:System.DateTime> type is represented in JSON as a string with a special format that is described in the Advanced Information section of this topic.</span></span>  
  
- <span data-ttu-id="f93d8-172"><xref:System.DateTimeOffset> jest reprezentowana w formacie JSON jako typ złożony: {"DateTime": dateTime, "OffsetMinutes": offsetMinutes}.</span><span class="sxs-lookup"><span data-stu-id="f93d8-172"><xref:System.DateTimeOffset> is represented in JSON as a complex type: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span></span> <span data-ttu-id="f93d8-173">`offsetMinutes` Element członkowski jest przesunięcie czasu lokalnego z czasu uniwersalnego Greenwich (GMT), teraz również określane jako uniwersalny czas koordynowany (UTC), skojarzona z lokalizacją zdarzenia zainteresowania.</span><span class="sxs-lookup"><span data-stu-id="f93d8-173">The `offsetMinutes` member is the local time offset from Greenwich Mean Time (GMT), also now referred to as Coordinated Universal Time (UTC), associated with the location of the event of interest.</span></span> <span data-ttu-id="f93d8-174">`dateTime` Elementu członkowskiego reprezentuje wystąpienie w czasie, kiedy wystąpiło zdarzenie zainteresowania (ponownie staje się `DateTime` w języku JavaScript, gdy ASP.NET AJAX jest w użyciu i ciąg, gdy nie jest).</span><span class="sxs-lookup"><span data-stu-id="f93d8-174">The `dateTime` member represents the instance in time when the event of interest occurred (again, it becomes a `DateTime` in JavaScript when ASP.NET AJAX is in use and a string when it is not).</span></span> <span data-ttu-id="f93d8-175">Na serializacji `dateTime` element członkowski zawsze jest serializowany w strefie czasowej GMT.</span><span class="sxs-lookup"><span data-stu-id="f93d8-175">On serialization, the `dateTime` member is always serialized in GMT.</span></span> <span data-ttu-id="f93d8-176">Jeśli opisujące 3:00 czasu Nowy Jork, więc `dateTime` składnik czasu w 8:00:00 i `offsetMinutes` to 300 (minus 300 minut lub 5 godzin od GMT).</span><span class="sxs-lookup"><span data-stu-id="f93d8-176">So, if describing 3:00 AM New York time, `dateTime` has a time component of 8:00 AM and `offsetMinutes` are 300 (minus 300 minutes or 5 hours from GMT).</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="f93d8-177"><xref:System.DateTime> i <xref:System.DateTimeOffset> obiektów, gdy serializować do notacji JSON, tylko zachować informacje dokładności do milisekundy.</span><span class="sxs-lookup"><span data-stu-id="f93d8-177"><xref:System.DateTime> and <xref:System.DateTimeOffset> objects, when serialized to JSON, only preserve information to millisecond precision.</span></span> <span data-ttu-id="f93d8-178">Liczone w ułamkach milisekund wartości (micro/nanosekundach) zostaną utracone podczas serializacji.</span><span class="sxs-lookup"><span data-stu-id="f93d8-178">Sub-millisecond values (micro/nanoseconds) are lost during serialization.</span></span>  
  
### <a name="xml-types-and-json"></a><span data-ttu-id="f93d8-179">Typy XML i JSON</span><span class="sxs-lookup"><span data-stu-id="f93d8-179">XML Types and JSON</span></span>  
 <span data-ttu-id="f93d8-180">Typy XML stają się ciągów JSON.</span><span class="sxs-lookup"><span data-stu-id="f93d8-180">XML types become JSON strings.</span></span>  
  
- <span data-ttu-id="f93d8-181">Na przykład, jeśli element członkowski danych "q" z typu klasy XElement zawiera \<abc / >, za pomocą pliku JSON jest {"q": "\<abc / >"}.</span><span class="sxs-lookup"><span data-stu-id="f93d8-181">For example, if a data member "q" of type XElement contains \<abc/>, the JSON is {"q":"\<abc/>"}.</span></span>  
  
- <span data-ttu-id="f93d8-182">Istnieją pewne specjalne reguły, które Określ, jak opakowane XML — Aby uzyskać więcej informacji, zobacz sekcję zaawansowane informacje w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="f93d8-182">There are some special rules that specify how XML is wrapped - for more information, see the Advanced Information section later in this topic.</span></span>  
  
- <span data-ttu-id="f93d8-183">Jeśli używasz rozszerzeń ASP.NET AJAX i nie chcesz używać parametrów w języku JavaScript, ale zamiast tego chcesz modelu DOM języka XML, ustaw <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> właściwości XML <xref:System.ServiceModel.Web.WebGetAttribute> lub <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> właściwości XML <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f93d8-183">If you are using ASP.NET AJAX and do not want to use strings in the JavaScript, but want the XML DOM instead, set the <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> property to XML on <xref:System.ServiceModel.Web.WebGetAttribute> or the <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> property to XML on the <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span></span>  
  
### <a name="collections-dictionaries-and-arrays"></a><span data-ttu-id="f93d8-184">Kolekcje, słowniki i tablice</span><span class="sxs-lookup"><span data-stu-id="f93d8-184">Collections, Dictionaries and Arrays</span></span>  
 <span data-ttu-id="f93d8-185">Wszystkie kolekcje słowników i tablice są reprezentowane w formacie JSON jako tablice.</span><span class="sxs-lookup"><span data-stu-id="f93d8-185">All collections, dictionaries, and arrays are represented in JSON as arrays.</span></span>  
  
- <span data-ttu-id="f93d8-186">Wszelkie dostosowania, który używa <xref:System.Runtime.Serialization.CollectionDataContractAttribute> jest ignorowana w reprezentacji JSON.</span><span class="sxs-lookup"><span data-stu-id="f93d8-186">Any customization that uses the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> is ignored in the JSON representation.</span></span>  
  
- <span data-ttu-id="f93d8-187">Słowniki są nowy sposób pracy bezpośrednio z formatu JSON.</span><span class="sxs-lookup"><span data-stu-id="f93d8-187">Dictionaries are not a way to work directly with JSON.</span></span> <span data-ttu-id="f93d8-188">Słownik\<string, object > mogą nie być obsługiwane w taki sam sposób, w programie WCF zgodnie z oczekiwaniami działanie z innymi technologiami w formacie JSON.</span><span class="sxs-lookup"><span data-stu-id="f93d8-188">Dictionary\<string,object> may not be supported in the same way in WCF as expected from working with other JSON technologies.</span></span> <span data-ttu-id="f93d8-189">Na przykład, jeśli "abc" jest mapowana do ciągu "xyz", "def" jest mapowana do 42 w słowniku reprezentacji JSON nie jest {"abc": "xyz", "def": 42}, ale jest [{"Key": "abc", "Wartość": "xyz"}, {"Key": "def", "Value": 42}] zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="f93d8-189">For example, if "abc" is mapped to "xyz" and "def" is mapped to 42 in a dictionary, the JSON representation is not {"abc":"xyz","def":42} but is [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] instead.</span></span>  
  
- <span data-ttu-id="f93d8-190">Jeśli chcesz pracować z JSON bezpośrednio (Uzyskiwanie dostępu do kluczy i wartości dynamicznie bez wstępnie definiowanie kontraktu sztywne), masz kilka opcji:</span><span class="sxs-lookup"><span data-stu-id="f93d8-190">If you would like to work with JSON directly (accessing keys and values dynamically, without pre-defining a rigid contract), you have several options:</span></span>  
  
    - <span data-ttu-id="f93d8-191">Należy rozważyć użycie [ze słabą kontrolą typów serializacji JSON (technologia AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) próbki.</span><span class="sxs-lookup"><span data-stu-id="f93d8-191">Consider using the [Weakly-typed JSON Serialization (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) sample.</span></span>  
  
    - <span data-ttu-id="f93d8-192">Należy rozważyć użycie <xref:System.Runtime.Serialization.ISerializable> interfejsu i deserializacji konstruktory — pozwala na uzyskiwanie dostępu do pary klucz/wartość JSON na serializacji i deserializacji odpowiednio te dwa mechanizmy, ale nie działają w scenariuszach częściowej relacji zaufania.</span><span class="sxs-lookup"><span data-stu-id="f93d8-192">Consider using the <xref:System.Runtime.Serialization.ISerializable> interface and deserialization constructors - these two mechanisms allow you to access JSON key/value pairs on serialization and deserialization respectively, but do not work in partial trust scenarios.</span></span>  
  
    - <span data-ttu-id="f93d8-193">Rozważ współpracę z [mapowanie między formatami JSON i XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) zamiast serializatora.</span><span class="sxs-lookup"><span data-stu-id="f93d8-193">Consider working with the [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) instead of using a serializer.</span></span>  
  
    - <span data-ttu-id="f93d8-194">*Polimorfizm* w kontekście serializacji odnosi się do możliwości, które można serializować typu pochodnego, gdy jego typ podstawowy jest oczekiwany.</span><span class="sxs-lookup"><span data-stu-id="f93d8-194">*Polymorphism* in the context of serialization refers to the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="f93d8-195">Istnieją specjalne reguły specyficzne dla formatu JSON przy użyciu kolekcji polymorphically, przypisując, na przykład, kolekcję, aby <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="f93d8-195">There are special JSON-specific rules when using collections polymorphically, when, for example, assigning a collection to an <xref:System.Object>.</span></span> <span data-ttu-id="f93d8-196">Ten problem jest dokładniej omówione w sekcji informacje o zaawansowanych w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="f93d8-196">This issue is more fully discussed in the Advanced Information section later in this topic.</span></span>  
  
## <a name="additional-details"></a><span data-ttu-id="f93d8-197">Dodatkowe szczegóły</span><span class="sxs-lookup"><span data-stu-id="f93d8-197">Additional Details</span></span>  
  
### <a name="order-of-data-members"></a><span data-ttu-id="f93d8-198">Kolejność elementów członkowskich danych</span><span class="sxs-lookup"><span data-stu-id="f93d8-198">Order of Data Members</span></span>  
 <span data-ttu-id="f93d8-199">Kolejność elementów członkowskich danych nie jest ważna w przypadku korzystania z formatu JSON.</span><span class="sxs-lookup"><span data-stu-id="f93d8-199">Order of data members is not important when using JSON.</span></span> <span data-ttu-id="f93d8-200">Ściślej mówiąc, nawet jeśli <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> ustawiono JSON danych nadal może być zdeserializowany w dowolnej kolejności.</span><span class="sxs-lookup"><span data-stu-id="f93d8-200">Specifically, even if <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> is set, JSON data can still be deserialized in any order.</span></span>  
  
### <a name="json-types"></a><span data-ttu-id="f93d8-201">Typy JSON</span><span class="sxs-lookup"><span data-stu-id="f93d8-201">JSON Types</span></span>  
 <span data-ttu-id="f93d8-202">Typu JSON nie musi odpowiadać zgodnie z poprzednią tabelą przy deserializacji.</span><span class="sxs-lookup"><span data-stu-id="f93d8-202">The JSON type does not have to match the preceding table on deserialization.</span></span> <span data-ttu-id="f93d8-203">Na przykład `Int` zwykle mapy numer JSON, ale można też pomyślnie po deserializacji z ciągu JSON tak długo, jak ciąg zawiera prawidłowy numer.</span><span class="sxs-lookup"><span data-stu-id="f93d8-203">For example, an `Int` normally maps to a JSON number, but it can also be successfully deserialized from a JSON string as long as that string contains a valid number.</span></span> <span data-ttu-id="f93d8-204">Oznacza to, że zarówno {"q": 42} i {"q": "42"} są prawidłowe w przypadku `Int` element członkowski danych o nazwie "q".</span><span class="sxs-lookup"><span data-stu-id="f93d8-204">That is, both {"q":42} and {"q":"42"} are valid if there is an `Int` data member called "q".</span></span>  
  
### <a name="polymorphism"></a><span data-ttu-id="f93d8-205">Polimorfizm</span><span class="sxs-lookup"><span data-stu-id="f93d8-205">Polymorphism</span></span>  
 <span data-ttu-id="f93d8-206">Serializacji polimorficznych składa się z możliwością serializacji typu pochodnego, gdy jego typ podstawowy jest oczekiwany.</span><span class="sxs-lookup"><span data-stu-id="f93d8-206">Polymorphic serialization consists of the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="f93d8-207">Jest to obsługiwane dla serializacji JSON przez architekturę WCF porównywalne do sposobu serializacji XML jest obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="f93d8-207">This is supported for JSON serialization by WCF comparable to the way XML serialization is supported.</span></span> <span data-ttu-id="f93d8-208">Na przykład można serializować `MyDerivedType` gdzie `MyBaseType` oczekuje się, w przeciwnym razie serializacji `Int` gdzie `Object` oczekuje.</span><span class="sxs-lookup"><span data-stu-id="f93d8-208">For example, you can serialize `MyDerivedType` where `MyBaseType` is expected, or serialize `Int` where `Object` is expected.</span></span>  
  
 <span data-ttu-id="f93d8-209">Informacje o typie mogą zostać utracone podczas deserializacji typem pochodnym, jeśli oczekiwany jest typ podstawowy, chyba że są deserializacji typie złożonym.</span><span class="sxs-lookup"><span data-stu-id="f93d8-209">Type information may be lost when deserializing a derived type if the base type is expected, unless you are deserializing a complex type.</span></span> <span data-ttu-id="f93d8-210">Na przykład jeśli <xref:System.Uri> jest serializowana gdzie <xref:System.Object> oczekuje się, czego wynikiem ciągu JSON.</span><span class="sxs-lookup"><span data-stu-id="f93d8-210">For example, if <xref:System.Uri> is serialized where <xref:System.Object> is expected, it results in a JSON string.</span></span> <span data-ttu-id="f93d8-211">Jeśli ten ciąg jest następnie deserializowany do <xref:System.Object>, .NET <xref:System.String> jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="f93d8-211">If this string is then deserialized back into <xref:System.Object>, a .NET <xref:System.String> is returned.</span></span> <span data-ttu-id="f93d8-212">Deserializator nie zna ten ciąg został początkowo typu <xref:System.Uri>.</span><span class="sxs-lookup"><span data-stu-id="f93d8-212">The deserializer does not know that the string was initially of type <xref:System.Uri>.</span></span> <span data-ttu-id="f93d8-213">Ogólnie rzecz biorąc gdy oczekiwano <xref:System.Object>, wszystkie ciągi JSON są deserializacji jako ciągi .NET i wszystkie tablice JSON służący do serializowania słowników, kolekcjach .NET i tablice są deserializacji jako .NET <xref:System.Array> typu <xref:System.Object>, niezależnie od tego, co dotychczas rzeczywiste oryginalnego typu.</span><span class="sxs-lookup"><span data-stu-id="f93d8-213">Generally, when expecting <xref:System.Object>, all JSON strings are deserialized as .NET strings, and all JSON arrays used to serialize .NET collections, dictionaries, and arrays are deserialized as .NET <xref:System.Array> of type <xref:System.Object>, regardless of what the actual original type had been.</span></span> <span data-ttu-id="f93d8-214">Wartość logiczna JSON mapowany na .NET <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="f93d8-214">A JSON boolean maps to a .NET <xref:System.Boolean>.</span></span> <span data-ttu-id="f93d8-215">Jednak gdy oczekiwano <xref:System.Object>, JSON cyfry są deserializacji jako .NET albo <xref:System.Int32>, <xref:System.Decimal> lub <xref:System.Double>, której najbardziej odpowiednim typem jest pobierany automatycznie.</span><span class="sxs-lookup"><span data-stu-id="f93d8-215">However when expecting an <xref:System.Object>, JSON numbers are deserialized as either .NET <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double>, where the most appropriate type is automatically picked.</span></span>  
  
 <span data-ttu-id="f93d8-216">Podczas deserializacji do typu interfejsu <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializuje tak, jakby zadeklarowanym typem zostały obiektu.</span><span class="sxs-lookup"><span data-stu-id="f93d8-216">When deserializing into an interface type, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializes as if the declared type were object.</span></span>  
  
 <span data-ttu-id="f93d8-217">Podczas pracy z własnych typów podstawowych i pochodnych, za pomocą <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> lub równoważnego mechanizmu jest zwykle wymagany.</span><span class="sxs-lookup"><span data-stu-id="f93d8-217">When working with your own base and derived types, using the <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> or an equivalent mechanism is normally required.</span></span> <span data-ttu-id="f93d8-218">Na przykład, jeśli operacja, która ma `Animal` zwracać wartości i faktycznie Zwraca wystąpienie `Cat` (pochodną `Animal`), należy albo zastosować <xref:System.Runtime.Serialization.KnownTypeAttribute>, `Animal` typu lub <xref:System.ServiceModel.ServiceKnownTypeAttribute> do operację i określ `Cat` typu w tych atrybutów.</span><span class="sxs-lookup"><span data-stu-id="f93d8-218">For example, if you have an operation that has an `Animal` return value and it actually returns an instance of `Cat` (derived from `Animal`), you should either apply the <xref:System.Runtime.Serialization.KnownTypeAttribute>, to the `Animal` type or the <xref:System.ServiceModel.ServiceKnownTypeAttribute> to the operation and specify the `Cat` type in these attributes.</span></span> <span data-ttu-id="f93d8-219">Aby uzyskać więcej informacji, zobacz [znane typy kontraktu danych](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span><span class="sxs-lookup"><span data-stu-id="f93d8-219">For more information, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span></span>  
  
 <span data-ttu-id="f93d8-220">Szczegółowe informacje, jak polimorficznych działa serializacji i dyskusji niektórych ograniczeń, które należy przestrzegać podczas korzystania z niego zobacz sekcję zaawansowane informacje w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="f93d8-220">For details of how polymorphic serialization works and a discussion of some of the limitations that must be respected when using it, see the Advanced Information section later in this topic.</span></span>  
  
### <a name="versioning"></a><span data-ttu-id="f93d8-221">Przechowywanie wersji</span><span class="sxs-lookup"><span data-stu-id="f93d8-221">Versioning</span></span>  
 <span data-ttu-id="f93d8-222">Przechowywanie wersji funkcji, takich jak kontraktu danych <xref:System.Runtime.Serialization.IExtensibleDataObject> interfejs, są w pełni obsługiwane w formacie JSON.</span><span class="sxs-lookup"><span data-stu-id="f93d8-222">The data contract versioning features, including the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, are fully supported in JSON.</span></span> <span data-ttu-id="f93d8-223">Ponadto, w większości przypadków użytkownik może zdeserializować typ w jednym formacie (na przykład XML) i serializować go do innego formatu (na przykład JSON), a także zachować dane w <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span><span class="sxs-lookup"><span data-stu-id="f93d8-223">Furthermore, in most cases it is possible to deserialize a type in one format (for example, XML) and then serialize it into another format (for example, JSON) and still preserve the data in <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span></span> <span data-ttu-id="f93d8-224">Aby uzyskać więcej informacji, zobacz [kontrakty danych zgodne](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="f93d8-224">For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span></span> <span data-ttu-id="f93d8-225">Należy pamiętać, JSON jest nieuporządkowaną, dzięki czemu utracenie wszelkich informacji o zamówieniu.</span><span class="sxs-lookup"><span data-stu-id="f93d8-225">Remember that JSON is unordered so any order information is lost.</span></span> <span data-ttu-id="f93d8-226">Ponadto JSON nie obsługuje wiele pary klucz/wartość z taką samą nazwę klucza.</span><span class="sxs-lookup"><span data-stu-id="f93d8-226">Furthermore, JSON does not support multiple key/value pairs with the same key name.</span></span> <span data-ttu-id="f93d8-227">Ponadto wszystkie operacje na <xref:System.Runtime.Serialization.IExtensibleDataObject> są założenia polimorficznych —, która jest ich typ pochodny są przypisane do <xref:System.Object>, typ podstawowy dla wszystkich typów.</span><span class="sxs-lookup"><span data-stu-id="f93d8-227">Finally, all operations on <xref:System.Runtime.Serialization.IExtensibleDataObject> are inherently polymorphic - that is their derived type are assigned to <xref:System.Object>, the base type for all types.</span></span>  
  
## <a name="json-in-urls"></a><span data-ttu-id="f93d8-228">JSON w adresach URL</span><span class="sxs-lookup"><span data-stu-id="f93d8-228">JSON in URLs</span></span>  
 <span data-ttu-id="f93d8-229">Podczas korzystania z punktów końcowych ASP.NET AJAX przy użyciu czasownik HTTP GET (przy użyciu <xref:System.ServiceModel.Web.WebGetAttribute> atrybut), parametry przychodzące są wyświetlane w adresie URL żądania, a nie treści komunikatu.</span><span class="sxs-lookup"><span data-stu-id="f93d8-229">When using ASP.NET AJAX endpoints with the HTTP GET verb (using the <xref:System.ServiceModel.Web.WebGetAttribute> attribute), incoming parameters appear in the request URL instead of the message body.</span></span> <span data-ttu-id="f93d8-230">JSON jest obsługiwane, nawet w adresie URL żądania, więc jeśli masz operacją, która przyjmuje `Int` o nazwie "number" i `Person` typu złożonego o nazwie "p", adres URL może przypominać następujący adres URL.</span><span class="sxs-lookup"><span data-stu-id="f93d8-230">JSON is supported even in the request URL, so if you have an operation that takes an `Int` called "number" and a `Person` complex type called "p", the URL may resemble the following URL.</span></span>  
  
```  
http://example.com/myservice.svc/MyOperation?number=7&p={"name":"John","age":42}  
```  
  
 <span data-ttu-id="f93d8-231">Jeśli używasz kontrolki Menedżera skryptów AJAX programu ASP.NET i serwera proxy do wywołania, ten adres URL jest generowana automatycznie przez serwer proxy i nie jest widoczny.</span><span class="sxs-lookup"><span data-stu-id="f93d8-231">If you are using an ASP.NET AJAX Script Manager control and proxy to call the service, this URL is automatically generated by the proxy and is not seen.</span></span> <span data-ttu-id="f93d8-232">Punkty końcowe — ASP.NET AJAX, JSON nie można używać w adresach URL.</span><span class="sxs-lookup"><span data-stu-id="f93d8-232">JSON cannot be used in URLs on non-ASP.NET AJAX endpoints.</span></span>  
  
## <a name="advanced-information"></a><span data-ttu-id="f93d8-233">Informacje zaawansowane</span><span class="sxs-lookup"><span data-stu-id="f93d8-233">Advanced information</span></span>  
  
### <a name="iserializable-support"></a><span data-ttu-id="f93d8-234">Obsługa iSerializable</span><span class="sxs-lookup"><span data-stu-id="f93d8-234">ISerializable Support</span></span>  
  
#### <a name="supported-and-unsupported-iserializable-types"></a><span data-ttu-id="f93d8-235">Obsługiwane i nieobsługiwane typy ISerializable</span><span class="sxs-lookup"><span data-stu-id="f93d8-235">Supported and Unsupported ISerializable Types</span></span>  
 <span data-ttu-id="f93d8-236">Ogólnie rzecz biorąc, typami, które implementują <xref:System.Runtime.Serialization.ISerializable> interfejsu są w pełni obsługiwane podczas serializacji/deserializacji JSON.</span><span class="sxs-lookup"><span data-stu-id="f93d8-236">In general, types that implement the <xref:System.Runtime.Serialization.ISerializable> interface are fully supported when serializing/deserializing JSON.</span></span> <span data-ttu-id="f93d8-237">Jednak niektóre z tych typów (w tym niektórych typów programu .NET Framework) są implementowane w taki sposób, aby aspekty serializacji specyficzne dla formatu JSON spowodować ich zdeserializować nie prawidłowo:</span><span class="sxs-lookup"><span data-stu-id="f93d8-237">However, some of these types (including some .NET Framework types) are implemented in such a way that the JSON-specific serialization aspects cause them to not deserialize correctly:</span></span>  
  
- <span data-ttu-id="f93d8-238">Za pomocą <xref:System.Runtime.Serialization.ISerializable>, typ danych elementów członkowskich nigdy nie jest znana z wyprzedzeniem.</span><span class="sxs-lookup"><span data-stu-id="f93d8-238">With <xref:System.Runtime.Serialization.ISerializable>, the type of individual data members is never known in advance.</span></span> <span data-ttu-id="f93d8-239">Prowadzi to do sytuacji polimorficznych, podobnie jak na obiekt podczas deserializacji typów.</span><span class="sxs-lookup"><span data-stu-id="f93d8-239">This leads to a polymorphic situation similar to deserializing types into an object.</span></span> <span data-ttu-id="f93d8-240">Jak wspomniano wcześniej, może to prowadzić do utraty informacji o typie w formacie JSON.</span><span class="sxs-lookup"><span data-stu-id="f93d8-240">As mentioned before, this may lead to loss of type information in JSON.</span></span> <span data-ttu-id="f93d8-241">Na przykład typ, który serializuje `enum` w jego <xref:System.Runtime.Serialization.ISerializable> implementacji, próba deserializacji z powrotem bezpośrednio do `enum` (bez prawidłowego rzutowania) zakończy się niepowodzeniem, ponieważ `enum` jest serializowana, przy użyciu liczb w formacie JSON i JSON numery deserializuje na wbudowane typy liczbowe .NET (Int32, Decimal lub podwójne).</span><span class="sxs-lookup"><span data-stu-id="f93d8-241">For example, a type that serializes an `enum` in its <xref:System.Runtime.Serialization.ISerializable> implementation and attempts to deserialize back directly into an `enum` (without proper casts) fails, because an `enum` is serialized using numbers in JSON and JSON numbers deserialize into built-in .NET numeric types (Int32, Decimal or Double).</span></span> <span data-ttu-id="f93d8-242">Więc fakt, numer używany `enum` wartości zostaną utracone.</span><span class="sxs-lookup"><span data-stu-id="f93d8-242">So the fact that the number used to be an `enum` value is lost.</span></span>  
  
- <span data-ttu-id="f93d8-243"><xref:System.Runtime.Serialization.ISerializable> Typ, który zależy od określonej kolejności deserializacji w jego konstruktorze deserializacji mogą zakończyć się niepowodzeniem do deserializacji niektóre dane JSON, ponieważ większość serializatory JSON nie gwarantują jakiejkolwiek ustalonej kolejności.</span><span class="sxs-lookup"><span data-stu-id="f93d8-243">An <xref:System.Runtime.Serialization.ISerializable> type that depends on a particular order of deserialization in its deserialization constructor may also fail to deserialize some JSON data, because most JSON serializers do not guarantee any specific order.</span></span>  
  
#### <a name="factory-types"></a><span data-ttu-id="f93d8-244">Typy fabryki</span><span class="sxs-lookup"><span data-stu-id="f93d8-244">Factory Types</span></span>  
 <span data-ttu-id="f93d8-245">Gdy <xref:System.Runtime.Serialization.IObjectReference> interfejs jest obsługiwany w formacie JSON, ogólnie rzecz biorąc, wszelkie typy, które wymagają funkcji "fabryki type" (zwrócenia wystąpienia innego typu niż <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> niż typ, który implementuje interfejs) nie są obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="f93d8-245">While the <xref:System.Runtime.Serialization.IObjectReference> interface is supported in JSON in general, any types that require the "factory type" feature (returning an instance of a different type from <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> than the type that implements the interface) are not supported.</span></span>  
  
### <a name="datetime-wire-format"></a><span data-ttu-id="f93d8-246">DateTime Wire Format</span><span class="sxs-lookup"><span data-stu-id="f93d8-246">DateTime Wire Format</span></span>  
 <span data-ttu-id="f93d8-247"><xref:System.DateTime> wartości są wyświetlane jako ciągi JSON w formie "/ Date(700000+0500) /", gdzie jest to pierwszy numer (700000 w przykładzie przedstawionym) liczbę milisekund w strefie czasowej GMT regularne (innych niż-letniego) czas od północy 1 stycznia 1970.</span><span class="sxs-lookup"><span data-stu-id="f93d8-247"><xref:System.DateTime> values appear as JSON strings in the form of "/Date(700000+0500)/", where the first number (700000 in the example provided) is the number of milliseconds in the GMT time zone, regular (non-daylight savings) time since midnight, January 1, 1970.</span></span> <span data-ttu-id="f93d8-248">Liczba może być ujemna do reprezentowania wcześniej razy.</span><span class="sxs-lookup"><span data-stu-id="f93d8-248">The number may be negative to represent earlier times.</span></span> <span data-ttu-id="f93d8-249">Element, który składa się z "+0500" w przykładzie jest opcjonalny, a także wskazuje, że czas jest <xref:System.DateTimeKind.Local> rodzaj — oznacza to, że powinny być konwertowane na podstawie lokalnej strefy czasowej na deserializacji.</span><span class="sxs-lookup"><span data-stu-id="f93d8-249">The part that consists of "+0500" in the example is optional and indicates that the time is of the <xref:System.DateTimeKind.Local> kind - that is, should be converted to the local time zone on deserialization.</span></span> <span data-ttu-id="f93d8-250">Jeśli jest nieobecne, czas jest przeprowadzona jako <xref:System.DateTimeKind.Utc>.</span><span class="sxs-lookup"><span data-stu-id="f93d8-250">If it is absent, the time is deserialized as <xref:System.DateTimeKind.Utc>.</span></span> <span data-ttu-id="f93d8-251">Rzeczywista liczba ("0500" w tym przykładzie) i jej znak (+ lub -), są ignorowane.</span><span class="sxs-lookup"><span data-stu-id="f93d8-251">The actual number ("0500" in this example) and its sign (+ or -) are ignored.</span></span>  
  
 <span data-ttu-id="f93d8-252">Podczas serializacji <xref:System.DateTime>, <xref:System.DateTimeKind.Local> i <xref:System.DateTimeKind.Unspecified> godziny są zapisywane z użyciem przesunięcie i <xref:System.DateTimeKind.Utc> są zapisywane bez.</span><span class="sxs-lookup"><span data-stu-id="f93d8-252">When serializing <xref:System.DateTime>, <xref:System.DateTimeKind.Local> and <xref:System.DateTimeKind.Unspecified> times are written with an offset, and <xref:System.DateTimeKind.Utc> is written without.</span></span>  
  
 <span data-ttu-id="f93d8-253">Kod JavaScript klienta ASP.NET AJAX automatycznie konwertuje takie ciągi na język JavaScript `DateTime` wystąpień.</span><span class="sxs-lookup"><span data-stu-id="f93d8-253">The ASP.NET AJAX client JavaScript code automatically converts such strings into JavaScript `DateTime` instances.</span></span> <span data-ttu-id="f93d8-254">W przypadku innych ciągów, które mają podobne formularza, które nie mają wartości typu <xref:System.DateTime> na platformie .NET, są one konwertowane również.</span><span class="sxs-lookup"><span data-stu-id="f93d8-254">If there are other strings that have a similar form that are not of type <xref:System.DateTime> in .NET, they are converted as well.</span></span>  
  
 <span data-ttu-id="f93d8-255">Konwersja tylko ma miejsce, jeśli są poprzedzone znakiem zmiany znaczenia znakami "/" (oznacza to, za pomocą pliku JSON wygląda "\\/Date(700000+0500)\\/") i WCF ta Przyczyna JSON encoder (włączane przez <xref:System.ServiceModel.WebHttpBinding>) zawsze zmienia znaczenie znaku "/".</span><span class="sxs-lookup"><span data-stu-id="f93d8-255">The conversion only takes place if the "/" characters are escaped (that is, the JSON looks like "\\/Date(700000+0500)\\/"), and for this reason WCF's JSON encoder (enabled by the <xref:System.ServiceModel.WebHttpBinding>) always escapes the "/" character.</span></span>  
  
### <a name="xml-in-json-strings"></a><span data-ttu-id="f93d8-256">Kod XML w ciągów JSON</span><span class="sxs-lookup"><span data-stu-id="f93d8-256">XML in JSON Strings</span></span>  
  
#### <a name="xmlelement"></a><span data-ttu-id="f93d8-257">XmlElement</span><span class="sxs-lookup"><span data-stu-id="f93d8-257">XmlElement</span></span>  
 <span data-ttu-id="f93d8-258"><xref:System.Xml.XmlElement> jest serializowany z bez zawijania.</span><span class="sxs-lookup"><span data-stu-id="f93d8-258"><xref:System.Xml.XmlElement> is serialized as is, with no wrapping.</span></span> <span data-ttu-id="f93d8-259">Na przykład element członkowski danych "x" o typie <xref:System.Xml.XmlElement> zawierający \<abc / > jest reprezentowany w następujący sposób.</span><span class="sxs-lookup"><span data-stu-id="f93d8-259">For example, data member "x" of type <xref:System.Xml.XmlElement> that contains \<abc/> is as represented as follows.</span></span>  
  
```json  
{"x":"<abc/>"}  
```  
  
#### <a name="arrays-of-xmlnode"></a><span data-ttu-id="f93d8-260">Tablic elementów XmlNode</span><span class="sxs-lookup"><span data-stu-id="f93d8-260">Arrays of XmlNode</span></span>  
 <span data-ttu-id="f93d8-261"><xref:System.Array> obiekty typu <xref:System.Xml.XmlNode> zostaną opakowane w elemencie o nazwie ArrayOfXmlNode w przestrzeni nazw kontraktu danych w warstwie standardowa dla typu.</span><span class="sxs-lookup"><span data-stu-id="f93d8-261"><xref:System.Array> objects of type <xref:System.Xml.XmlNode> are wrapped in an element called ArrayOfXmlNode in the standard data contract namespace for the type.</span></span> <span data-ttu-id="f93d8-262">Jeśli "x" jest tablicą, która zawiera węzeł atrybutu "N" w przestrzeni nazw "ns", który zawiera "value" i węzeł pustego elementu "M", reprezentacja jest następujący.</span><span class="sxs-lookup"><span data-stu-id="f93d8-262">If "x" is an array that contains attribute node "N" in namespace "ns" that contains "value" and an empty element node "M", the representation is as follows.</span></span>  
  
```  
{"x":"<ArrayOfXmlNode xmlns=\"http://schemas.datacontract.org/2004/07/System.Xml\" a:N=\"value\" xmlns:a=\"ns\"><M/></ArrayOfXmlNode>"}  
```  
  
 <span data-ttu-id="f93d8-263">Atrybuty w pustej przestrzeni nazw na początku XmlNode tablic (przed innymi elementami) nie są obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="f93d8-263">Attributes in the empty namespace at the beginning of XmlNode arrays (before other elements) are unsupported.</span></span>  
  
#### <a name="ixmlserializable-types-including-xelement-and-dataset"></a><span data-ttu-id="f93d8-264">Typy interfejsu IXmlSerializable, w tym XElement i zestaw danych</span><span class="sxs-lookup"><span data-stu-id="f93d8-264">IXmlSerializable Types including XElement and DataSet</span></span>  
 <span data-ttu-id="f93d8-265"><xref:System.Runtime.Serialization.ISerializable> typy podzielić na "typów zawartości", "Typy zestawu danych" i "typy elementów".</span><span class="sxs-lookup"><span data-stu-id="f93d8-265"><xref:System.Runtime.Serialization.ISerializable> types subdivide into "content types", "DataSet types" and "element types".</span></span> <span data-ttu-id="f93d8-266">Aby uzyskać definicje tych typów, zobacz [typy XML i ADO.NET w kontraktach danych](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="f93d8-266">For definitions of these types, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span>  
  
 <span data-ttu-id="f93d8-267">"Zawartość" oraz "Zestaw danych" typy są serializowane podobne do <xref:System.Array> obiektów <xref:System.Xml.XmlNode> opisanych w poprzedniej sekcji.</span><span class="sxs-lookup"><span data-stu-id="f93d8-267">"Content" and "DataSet" types are serialized similar to <xref:System.Array> objects of <xref:System.Xml.XmlNode> discussed in the previous section.</span></span> <span data-ttu-id="f93d8-268">Są one opakowane w elemencie o nazwie i przestrzeni nazw odpowiada nazwie kontraktu danych i przestrzeni nazw typu zagrożona.</span><span class="sxs-lookup"><span data-stu-id="f93d8-268">They are wrapped in an element whose name and namespace corresponds to the data contract name and namespace of the type in question.</span></span>  
  
 <span data-ttu-id="f93d8-269">"Element" typy, takie jak <xref:System.Xml.Linq.XElement> są serializowane, tak jak, podobnie jak <xref:System.Xml.XmlElement> omówionych wcześniej w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="f93d8-269">"Element" types such as <xref:System.Xml.Linq.XElement> are serialized as is, similar to <xref:System.Xml.XmlElement> previously discussed in this topic.</span></span>  
  
### <a name="polymorphism"></a><span data-ttu-id="f93d8-270">Polimorfizm</span><span class="sxs-lookup"><span data-stu-id="f93d8-270">Polymorphism</span></span>  
  
#### <a name="preserving-type-information"></a><span data-ttu-id="f93d8-271">Zachowywanie informacji o typie</span><span class="sxs-lookup"><span data-stu-id="f93d8-271">Preserving Type Information</span></span>  
 <span data-ttu-id="f93d8-272">Jak wspomniano wcześniej, polimorfizm jest obsługiwane w formacie JSON z pewnymi ograniczeniami.</span><span class="sxs-lookup"><span data-stu-id="f93d8-272">As stated earlier, polymorphism is supported in JSON with some limitations.</span></span> <span data-ttu-id="f93d8-273">JavaScript jest językiem ze słabą kontrolą typów, a typ tożsamości zwykle nie jest problemem.</span><span class="sxs-lookup"><span data-stu-id="f93d8-273">JavaScript is a weakly-typed language and type identity is normally not an issue.</span></span> <span data-ttu-id="f93d8-274">Korzystając z formatu JSON do komunikowania się między systemem silnie typizowane (.NET), a system ze słabą kontrolą typów (JavaScript), zaleca się zachować typ tożsamości.</span><span class="sxs-lookup"><span data-stu-id="f93d8-274">However, when using JSON to communicate between a strongly-typed system (.NET) and a weakly-typed system (JavaScript), it is useful to preserve type identity.</span></span> <span data-ttu-id="f93d8-275">Na przykład typy przy użyciu danych umowy nazwy "Patrol" i "Koło" pochodzić od typu o nazwie kontraktu danych "Kształt".</span><span class="sxs-lookup"><span data-stu-id="f93d8-275">For example, types with data contract names "Square" and "Circle" derive from a type with a data contract name of "Shape".</span></span> <span data-ttu-id="f93d8-276">Jeśli "Koło" są wysyłane z .NET do JavaScript i nowszej jest zwracany do metody .NET, który oczekuje, że "Kształt", jest przydatne w przypadku po stronie platformy .NET dowiedzieć się, że danego obiektu była pierwotnie "Koło" — w przeciwnym razie wszelkie informacje specyficzne dla typu pochodnego (na przykład element członkowski danych "radius" na "Koło") mogą zostać utracone.</span><span class="sxs-lookup"><span data-stu-id="f93d8-276">If "Circle" is sent from .NET to JavaScript and is later returned to a .NET method that expects "Shape", it is useful for the .NET side to know that the object in question was originally a "Circle" - otherwise any information specific to the derived type (for example, "radius" data member on "Circle") may be lost.</span></span>  
  
 <span data-ttu-id="f93d8-277">Aby zachować tożsamości typu serializacji typy złożone do formatu JSON wskazówką"typu" można dodać, gdy Deserializator rozpoznaje wskazówka i działa prawidłowo.</span><span class="sxs-lookup"><span data-stu-id="f93d8-277">To preserve type identity, when serializing complex types to JSON a "type hint" can be added, and the deserializer recognizes the hint and acts appropriately.</span></span> <span data-ttu-id="f93d8-278">Wskazówka"typu" jest para klucza i wartości JSON, nazwą klucza "\_\_typu" (dwóch znaków podkreślenia następuje od słowa "type").</span><span class="sxs-lookup"><span data-stu-id="f93d8-278">The "type hint" is a JSON key/value pair with the key name of "\_\_type" (two underscores followed by the word "type").</span></span> <span data-ttu-id="f93d8-279">Wartość ciągu JSON w postaci "DataContractName:DataContractNamespace" (niczego maksymalnie pierwszym dwukropkiem ma na imię).</span><span class="sxs-lookup"><span data-stu-id="f93d8-279">The value is a JSON string of the form "DataContractName:DataContractNamespace" (anything up to the first colon is the name).</span></span> <span data-ttu-id="f93d8-280">Korzystając z poprzedniego przykładu, "Koło" może być serializowany w następujący sposób.</span><span class="sxs-lookup"><span data-stu-id="f93d8-280">Using the earlier example, "Circle" can be serialized as follows.</span></span>  
  
```json  
{"__type":"Circle:http://example.com/myNamespace","x":50,"y":70,"radius":10}  
```  
  
 <span data-ttu-id="f93d8-281">Wskazówka typu jest bardzo podobny do `xsi:type` Atrybut zdefiniowanym przez standard wystąpienia schematu XML, używany podczas serializacji/deserializacji XML.</span><span class="sxs-lookup"><span data-stu-id="f93d8-281">The type hint is very similar to the `xsi:type` attribute defined by the XML Schema Instance standard and used when serializing/deserializing XML.</span></span>  
  
 <span data-ttu-id="f93d8-282">Elementy członkowskie danych o nazwie "\_\_typu" są zabronione ze względu na potencjalne konflikt ze wskazówką typu.</span><span class="sxs-lookup"><span data-stu-id="f93d8-282">Data members called "\_\_type" are forbidden due to potential conflict with the type hint.</span></span>  
  
#### <a name="reducing-the-size-of-type-hints"></a><span data-ttu-id="f93d8-283">Zmniejszenie rozmiaru wskazówek dotyczących typów</span><span class="sxs-lookup"><span data-stu-id="f93d8-283">Reducing the Size of Type Hints</span></span>  
 <span data-ttu-id="f93d8-284">Aby zmniejszyć rozmiar JSON komunikaty, domyślny prefiks przestrzeni nazw kontraktu danych (`http://schemas.datacontract.org/2004/07/`) jest zastępowany znaku "#".</span><span class="sxs-lookup"><span data-stu-id="f93d8-284">To reduce the size of JSON messages, the default data contract namespace prefix (`http://schemas.datacontract.org/2004/07/`) is replaced with the "#" character.</span></span> <span data-ttu-id="f93d8-285">(Aby ta zastępowania odwracalny, odwrócony reguła jest używana: Jeśli przestrzeń nazw, który rozpoczyna się od "#" lub "\\" znaków, są one dołączane za pomocą dodatkowych "\\" znaków).</span><span class="sxs-lookup"><span data-stu-id="f93d8-285">(To make this replacement reversible, an escaping rule is used: if the namespace starts with the "#" or "\\" characters, they are appended with an extra "\\" character).</span></span> <span data-ttu-id="f93d8-286">W związku z tym, czy "Koło" jest typem w przestrzeni nazw .NET "MyApp.Shapes", jest jego domyślna przestrzeń nazw kontraktu danych `http://schemas.datacontract.org/2004/07/MyApp`.</span><span class="sxs-lookup"><span data-stu-id="f93d8-286">Thus, if "Circle" is a type in the .NET namespace "MyApp.Shapes", its default data contract namespace is `http://schemas.datacontract.org/2004/07/MyApp`.</span></span> <span data-ttu-id="f93d8-287">Kształty i reprezentacji JSON wygląda następująco:</span><span class="sxs-lookup"><span data-stu-id="f93d8-287">Shapes and the JSON representation is as follows.</span></span>  
  
```json  
{"__type":"Circle:#MyApp.Shapes","x":50,"y":70,"radius":10}  
```  
  
 <span data-ttu-id="f93d8-288">Skrócona (#MyApp.Shapes) i pełną (http://schemas.datacontract.org/2004/07/MyApp.Shapes) nazw jest zrozumiały przy deserializacji.</span><span class="sxs-lookup"><span data-stu-id="f93d8-288">Both the truncated (#MyApp.Shapes) and the full (http://schemas.datacontract.org/2004/07/MyApp.Shapes) names is understood on deserialization.</span></span>  
  
#### <a name="type-hint-position-in-json-objects"></a><span data-ttu-id="f93d8-289">Pozycja wskazówki dotyczącej typu w obiekty JSON</span><span class="sxs-lookup"><span data-stu-id="f93d8-289">Type Hint Position in JSON Objects</span></span>  
 <span data-ttu-id="f93d8-290">Należy pamiętać, że wskazówki dotyczącej typu musi występować jako pierwszy w reprezentacji JSON.</span><span class="sxs-lookup"><span data-stu-id="f93d8-290">Note that the type hint must appear first in the JSON representation.</span></span> <span data-ttu-id="f93d8-291">Jest to tylko wówczas, których kolejność pary klucz/wartość jest ważna w przetwarzaniu JSON.</span><span class="sxs-lookup"><span data-stu-id="f93d8-291">This is the only case where order of key/value pairs is important in JSON processing.</span></span> <span data-ttu-id="f93d8-292">Na przykład następujące nie jest prawidłowy sposób określania wskazówki dotyczącej typu.</span><span class="sxs-lookup"><span data-stu-id="f93d8-292">For example, the following is not a valid way to specify the type hint.</span></span>  
  
```json  
{"x":50,"y":70,"radius":10,"__type":"Circle:#MyApp.Shapes"}  
```  
  
 <span data-ttu-id="f93d8-293">Zarówno <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> używane przez program WCF i ASP.NET AJAX stron klienta zawsze emitować wskazówki dotyczącej typu najpierw.</span><span class="sxs-lookup"><span data-stu-id="f93d8-293">Both the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> used by WCF and ASP.NET AJAX client pages always emit the type hint first.</span></span>  
  
#### <a name="type-hints-apply-only-to-complex-types"></a><span data-ttu-id="f93d8-294">Wskazówek dotyczących typów mają zastosowanie tylko do typów złożonych</span><span class="sxs-lookup"><span data-stu-id="f93d8-294">Type Hints Apply Only to Complex Types</span></span>  
 <span data-ttu-id="f93d8-295">Nie ma możliwości do emitowania wskazówką typu dla typów innych niż złożone.</span><span class="sxs-lookup"><span data-stu-id="f93d8-295">There is no way to emit a type hint for non-complex types.</span></span> <span data-ttu-id="f93d8-296">Na przykład, jeśli operacja ma <xref:System.Object> zwracany typ, ale zwraca okrąg, może być reprezentacji JSON, jak pokazano wcześniej i informacje o typie są zachowywane.</span><span class="sxs-lookup"><span data-stu-id="f93d8-296">For example, if an operation has an <xref:System.Object> return type but returns a Circle, the JSON representation can be as shown earlier and the type information is preserved.</span></span> <span data-ttu-id="f93d8-297">Jednak jeśli zostanie zwrócony identyfikator Uri, reprezentacja JSON jest ciąg się oraz fakt, że ciąg używany do reprezentowania identyfikatora Uri zostaną utracone.</span><span class="sxs-lookup"><span data-stu-id="f93d8-297">However, if Uri is returned, the JSON representation is a string and the fact that the string used to represent a Uri is lost.</span></span> <span data-ttu-id="f93d8-298">Dotyczy to nie tylko dla typów pierwotnych, ale także do kolekcji i tablic.</span><span class="sxs-lookup"><span data-stu-id="f93d8-298">This applies not only to primitive types but also to collections and arrays.</span></span>  
  
#### <a name="when-are-type-hints-emitted"></a><span data-ttu-id="f93d8-299">Kiedy są emitowane wskazówek dotyczących typów</span><span class="sxs-lookup"><span data-stu-id="f93d8-299">When Are Type Hints Emitted</span></span>  
 <span data-ttu-id="f93d8-300">Wskazówek dotyczących typów może znacznie zwiększyć rozmiar komunikatu (jednym ze sposobów, aby zmniejszyć to jest Użyj krótszych nazw kontraktu danych, jeśli to możliwe).</span><span class="sxs-lookup"><span data-stu-id="f93d8-300">Type hints may increase message size significantly (one way to mitigate this is to use shorter data contract namespaces if possible).</span></span> <span data-ttu-id="f93d8-301">W związku z tym następujące reguły określają, czy wskazówek dotyczących typów są emitowane:</span><span class="sxs-lookup"><span data-stu-id="f93d8-301">Therefore, the following rules govern whether type hints are emitted:</span></span>  
  
- <span data-ttu-id="f93d8-302">Korzystając z technologii ASP.NET AJAX, wskazówek dotyczących typów są zawsze emitowane zawsze, gdy jest to możliwe, nawet jeśli dostępny jest nie przypisania bazową/dziedziczoną — na przykład, nawet jeśli okrąg jest przypisany do okrąg.</span><span class="sxs-lookup"><span data-stu-id="f93d8-302">When using ASP.NET AJAX, type hints are always emitted whenever possible, even if there is no base/derived assignment - for example, even if a Circle is assigned to a Circle.</span></span> <span data-ttu-id="f93d8-303">(Jest to wymagane, aby w pełni włączyć proces wywoływania ze środowiska JSON ze słabą kontrolą typów, w środowisku .NET silnie typizowane bez Zaskakujące utraty informacji.)</span><span class="sxs-lookup"><span data-stu-id="f93d8-303">(This is required to fully enable the process of calling from the weakly-typed JSON environment into the strongly-typed .NET environment with no surprising loss of information.)</span></span>  
  
- <span data-ttu-id="f93d8-304">Podczas korzystania z usług AJAX dzięki integracji platformy ASP.NET, nie wskazówek dotyczących typów tylko są emitowane po przypisanie bazową/dziedziczoną — emitowanego po okręgu jest przypisany do kształtu lub <xref:System.Object> , ale nie po przypisaniu do okrąg.</span><span class="sxs-lookup"><span data-stu-id="f93d8-304">When using AJAX services with no ASP.NET integration, type hints are only emitted when there is a base/derived assignment - that is, emitted when Circle is assigned to Shape or <xref:System.Object> but not when assigned to Circle.</span></span> <span data-ttu-id="f93d8-305">To zapewnia minimalne informacje wymagane do poprawnego zaimplementowania klienta JavaScript, co poprawia wydajność, ale nie chroni przed utratą informacji typu w klientach niepoprawnie zaprojektowany.</span><span class="sxs-lookup"><span data-stu-id="f93d8-305">This provides the minimum information required to correctly implement a JavaScript client, thus improving performance, but does not protect against type information loss in incorrectly-designed clients.</span></span> <span data-ttu-id="f93d8-306">Należy unikać bazową/dziedziczoną przypisania całkowicie na serwerze, aby uniknąć tego problemu na komputerze klienckim.</span><span class="sxs-lookup"><span data-stu-id="f93d8-306">Avoid base/derived assignments altogether on the server if you want to avoid dealing with this issue on the client.</span></span>  
  
- <span data-ttu-id="f93d8-307">Korzystając z <xref:System.Runtime.Serialization.DataContractSerializer> typu `alwaysEmitTypeInformation` parametr konstruktora można wybrać z poprzednich dwóch trybów z jest domyślna "`false`" (Emituj tylko wskazówek dotyczących typów, gdy jest to wymagane).</span><span class="sxs-lookup"><span data-stu-id="f93d8-307">When using the <xref:System.Runtime.Serialization.DataContractSerializer> type, the `alwaysEmitTypeInformation` constructor parameter allows you to choose between the preceding two modes, with the default being "`false`" (only emit type hints when required).</span></span>  
  
#### <a name="duplicate-data-member-names"></a><span data-ttu-id="f93d8-308">Zduplikowane nazwy elementów członkowskich danych</span><span class="sxs-lookup"><span data-stu-id="f93d8-308">Duplicate Data Member Names</span></span>  
 <span data-ttu-id="f93d8-309">Typ pochodny informacji znajduje się w ten sam obiekt JSON, wraz z informacjami o typie podstawowym, a może występować w dowolnej kolejności.</span><span class="sxs-lookup"><span data-stu-id="f93d8-309">Derived type information is present in the same JSON object together with base type information, and can occur in any order.</span></span> <span data-ttu-id="f93d8-310">Na przykład `Shape` mogą być reprezentowane w następujący sposób.</span><span class="sxs-lookup"><span data-stu-id="f93d8-310">For example, `Shape` may be represented as follows.</span></span>  
  
```json  
{"__type":"Shape:#MyApp.Shapes","x":50,"y":70}  
```  
  
 <span data-ttu-id="f93d8-311">Natomiast okrąg mogą być reprezentowane w następujący sposób.</span><span class="sxs-lookup"><span data-stu-id="f93d8-311">Whereas Circle may be represented as follows.</span></span>  
  
```json  
{"__type":"Circle:#MyApp.Shapes","x":50, "radius":10,"y":70}  
```  
  
 <span data-ttu-id="f93d8-312">Jeśli podstawowy `Shape` typu również znajdują się element członkowski danych o nazwie "`radius`", prowadzi to do kolizji na obu serializacji (ponieważ obiekty JSON nie może mieć powtarzające się nazwy kluczy) oraz deserializacji (ponieważ nie jest jasne, czy "radius" odnosi się do `Shape.radius` lub `Circle.radius`).</span><span class="sxs-lookup"><span data-stu-id="f93d8-312">If the base `Shape` type also contained a data member called "`radius`", this leads to a collision on both serialization (because JSON objects cannot have repeating key names) and deserialization (because it is unclear whether "radius" refers to `Shape.radius` or `Circle.radius`).</span></span> <span data-ttu-id="f93d8-313">W związku z tym, podczas gdy pojęcie "ukrywanie właściwości" (elementy członkowskie danych o takiej samej nazwie w podstawie i klas pochodnych) zwykle nie jest zalecane w klasach kontraktu danych faktycznie jest niedozwolona w przypadku formatu JSON.</span><span class="sxs-lookup"><span data-stu-id="f93d8-313">Therefore, while the concept of "property hiding" (data members of the same name on based and derived classes) is generally not recommended in data contract classes, it is actually forbidden in the case of JSON.</span></span>  
  
#### <a name="polymorphism-and-ixmlserializable-types"></a><span data-ttu-id="f93d8-314">Polimorfizm i typów IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="f93d8-314">Polymorphism and IXmlSerializable Types</span></span>  
 <span data-ttu-id="f93d8-315"><xref:System.Xml.Serialization.IXmlSerializable> typy może być polymorphically przypisana do siebie nawzajem w zwykły sposób tak długo, jak są spełnione wymagania znane typy, zgodnie z regułami kontraktu danych zwykle.</span><span class="sxs-lookup"><span data-stu-id="f93d8-315"><xref:System.Xml.Serialization.IXmlSerializable> types may be polymorphically assigned to each other as usual as long as Known Types requirements are met, according to usual data contract rules.</span></span> <span data-ttu-id="f93d8-316">Jednak serializacji <xref:System.Xml.Serialization.IXmlSerializable> wpisz zamiast <xref:System.Object> powoduje utratę informacji o typie, ponieważ ciąg JSON.</span><span class="sxs-lookup"><span data-stu-id="f93d8-316">However, serializing an <xref:System.Xml.Serialization.IXmlSerializable> type in place of <xref:System.Object> results in loss of type information as the result is a JSON string.</span></span>  
  
#### <a name="polymorphism-and-certain-interface-types"></a><span data-ttu-id="f93d8-317">Polimorfizm i niektórych typów interfejsu</span><span class="sxs-lookup"><span data-stu-id="f93d8-317">Polymorphism and Certain Interface Types</span></span>  
 <span data-ttu-id="f93d8-318">Jest zabroniona można serializować typu kolekcji lub typu, który implementuje <xref:System.Xml.Serialization.IXmlSerializable> w przypadku, gdy typ — do kolekcji, który nie jest <xref:System.Xml.Serialization.IXmlSerializable> (z wyjątkiem <xref:System.Object>) jest oczekiwany.</span><span class="sxs-lookup"><span data-stu-id="f93d8-318">It is forbidden to serialize a collection type or a type that implements <xref:System.Xml.Serialization.IXmlSerializable> where a non-collection type that is not <xref:System.Xml.Serialization.IXmlSerializable> (except for <xref:System.Object>) is expected.</span></span> <span data-ttu-id="f93d8-319">Na przykład niestandardowy interfejs o nazwie `IMyInterface` i typ `MyType` zaimplementować obu <xref:System.Collections.Generic.IEnumerable%601> typu `int` i `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="f93d8-319">For example, a custom interface called `IMyInterface` and a type `MyType` that implement both <xref:System.Collections.Generic.IEnumerable%601> of type `int` and `IMyInterface`.</span></span> <span data-ttu-id="f93d8-320">Jest zabroniona do zwrócenia `MyType` z operacją, którego typem zwracanym jest `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="f93d8-320">It is forbidden to return `MyType` from an operation whose return type is `IMyInterface`.</span></span> <span data-ttu-id="f93d8-321">Jest to spowodowane `MyType` muszą być serializowane jako tablicę JSON i wymaga wskazówką typu, a podana przed nie może zawierać wskazówką typu z tablicami, tylko z typów złożonych.</span><span class="sxs-lookup"><span data-stu-id="f93d8-321">This is because `MyType` must be serialized as a JSON array and requires a type hint, and as stated before you cannot include a type hint with arrays, only with complex types.</span></span>  
  
#### <a name="known-types-and-configuration"></a><span data-ttu-id="f93d8-322">Znane typy i Konfiguracja</span><span class="sxs-lookup"><span data-stu-id="f93d8-322">Known Types and Configuration</span></span>  
 <span data-ttu-id="f93d8-323">Wszystkie mechanizmów znany typ używany przez <xref:System.Runtime.Serialization.DataContractSerializer> są również obsługiwane w taki sam sposób, <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span><span class="sxs-lookup"><span data-stu-id="f93d8-323">All of the Known Type mechanisms used by the <xref:System.Runtime.Serialization.DataContractSerializer> are also supported in the same way by the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="f93d8-324">Zarówno serializatory odczytu tego samego elementu konfiguracji [ \<dataContractSerializer >](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) w [ \<system.runtime.serialization >](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), aby odnaleźć znanych typów dodanych za pomocą pliku konfiguracji.</span><span class="sxs-lookup"><span data-stu-id="f93d8-324">Both serializers read the same configuration element, [\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) in [\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), to discover known types added through a configuration file.</span></span>  
  
#### <a name="collections-assigned-to-object"></a><span data-ttu-id="f93d8-325">Kolekcji przypisanych do obiektu</span><span class="sxs-lookup"><span data-stu-id="f93d8-325">Collections Assigned to Object</span></span>  
 <span data-ttu-id="f93d8-326">Przypisane do obiektu kolekcji są serializowane, tak, jakby są kolekcjami, które implementują <xref:System.Collections.Generic.IEnumerable%601>: tablica JSON z każdego wpisu, który ma wskazówką typu, jeśli jest to typ złożony.</span><span class="sxs-lookup"><span data-stu-id="f93d8-326">Collections assigned to Object are serialized as if they are collections that implement <xref:System.Collections.Generic.IEnumerable%601>: a JSON array with each entry that has a type hint if it is a complex type.</span></span> <span data-ttu-id="f93d8-327">Na przykład <xref:System.Collections.Generic.List%601> typu `Shape` przypisane do <xref:System.Object> wygląda podobnie do następującego.</span><span class="sxs-lookup"><span data-stu-id="f93d8-327">For example, a <xref:System.Collections.Generic.List%601> of type `Shape` assigned to <xref:System.Object> looks like the following.</span></span>  
  
```json  
[{"__type":"Shape:#MyApp.Shapes","x":50,"y":70},  
{"__type":"Shape:#MyApp.Shapes","x":58,"y":73},  
{"__type":"Shape:#MyApp.Shapes","x":41,"y":32}]  
```  
  
 <span data-ttu-id="f93d8-328">Podczas deserializacji do <xref:System.Object>:</span><span class="sxs-lookup"><span data-stu-id="f93d8-328">When deserialized back into <xref:System.Object>:</span></span>  
  
- <span data-ttu-id="f93d8-329">`Shape` musi należeć do listy znanych typów.</span><span class="sxs-lookup"><span data-stu-id="f93d8-329">`Shape` must be in the Known Types list.</span></span> <span data-ttu-id="f93d8-330">Posiadanie <xref:System.Collections.Generic.List%601> typu `Shape` w znanych typów nie ma wpływu.</span><span class="sxs-lookup"><span data-stu-id="f93d8-330">Having <xref:System.Collections.Generic.List%601> of type `Shape` in known types has no effect.</span></span> <span data-ttu-id="f93d8-331">Należy zauważyć, że nie trzeba dodawać `Shape` do znanych typów na serializacji w tym przypadku — odbywa się to automatycznie.</span><span class="sxs-lookup"><span data-stu-id="f93d8-331">Note that you do not have to add `Shape` to known types on serialization in this case - this is done automatically.</span></span>  
  
- <span data-ttu-id="f93d8-332">Kolekcja jest przeprowadzona jako <xref:System.Array> typu <xref:System.Object> zawierający `Shape` wystąpień.</span><span class="sxs-lookup"><span data-stu-id="f93d8-332">The collection is deserialized as an <xref:System.Array> of type <xref:System.Object> that contains `Shape` instances.</span></span>  
  
#### <a name="derived-collections-assigned-to-base-collections"></a><span data-ttu-id="f93d8-333">Pochodne kolekcji przypisane do podstawowej kolekcji</span><span class="sxs-lookup"><span data-stu-id="f93d8-333">Derived Collections Assigned to Base Collections</span></span>  
 <span data-ttu-id="f93d8-334">Po przypisaniu pochodnej kolekcji do podstawowej kolekcji, Kolekcja zwykle jest serializowana, tak jakby znajdowała się kolekcja typu podstawowego.</span><span class="sxs-lookup"><span data-stu-id="f93d8-334">When a derived collection is assigned to a base collection, the collection is usually serialized as if it was a collection of the base type.</span></span> <span data-ttu-id="f93d8-335">Jednak jeśli typ elementu kolekcji pochodnych nie można przypisać do typu elementu podstawowego kolekcji, jest zgłaszany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="f93d8-335">However, if the item type of the derived collection cannot be assigned to the item type of the base collection, an exception is thrown.</span></span>  
  
#### <a name="type-hints-and-dictionaries"></a><span data-ttu-id="f93d8-336">Wskazówek dotyczących typów i słowników</span><span class="sxs-lookup"><span data-stu-id="f93d8-336">Type Hints and Dictionaries</span></span>  
 <span data-ttu-id="f93d8-337">Po przypisaniu do słownika <xref:System.Object>, każdego wpisu klucza i wartości w słowniku jest traktowany tak, jakby został przypisany do <xref:System.Object> i pobiera wskazówkę z typu.</span><span class="sxs-lookup"><span data-stu-id="f93d8-337">When a dictionary is assigned to an <xref:System.Object>, each Key and Value entry in the dictionary is treated as if it was assigned to <xref:System.Object> and gets a type hint.</span></span>  
  
 <span data-ttu-id="f93d8-338">Podczas serializacji typów słownika, obiekt JSON, który zawiera elementy członkowskie "Key" i "Wartość" nie jest zależny od `alwaysEmitTypeInformation` ustawienie i zawiera tylko wskazówką typu podczas poprzednich zasad zbierania tego wymagają.</span><span class="sxs-lookup"><span data-stu-id="f93d8-338">When serializing dictionary types, the JSON object that contains the "Key" and "Value" members is unaffected by the `alwaysEmitTypeInformation` setting and only contains a type hint when the preceding collection rules require it.</span></span>  
  
### <a name="valid-json-key-names"></a><span data-ttu-id="f93d8-339">Nazwy kluczy z prawidłowym kodem JSON</span><span class="sxs-lookup"><span data-stu-id="f93d8-339">Valid JSON Key Names</span></span>  
 <span data-ttu-id="f93d8-340">Serializator koduje XML nazwy kluczy, które nie są prawidłowe nazwy XML.</span><span class="sxs-lookup"><span data-stu-id="f93d8-340">The serializer XML-encodes key names that are not valid XML names.</span></span> <span data-ttu-id="f93d8-341">Na przykład element członkowski danych o nazwie "123" miałby zakodowane nazwę taką jak "\_x0031\_\_x0032\_\_x0033\_" ponieważ "123" jest nieprawidłową nazwą — element XML (rozpoczyna się od cyfry).</span><span class="sxs-lookup"><span data-stu-id="f93d8-341">For example, a data member with the name of "123" would have an encoded name such as "\_x0031\_\_x0032\_\_x0033\_" because "123" is an invalid XML element name (starts with a digit).</span></span> <span data-ttu-id="f93d8-342">Podobna sytuacja może powstać z niektórych zestawów znaków międzynarodowych nazw XML nie jest prawidłowy.</span><span class="sxs-lookup"><span data-stu-id="f93d8-342">A similar situation may arise with some international character sets not valid in XML names.</span></span> <span data-ttu-id="f93d8-343">Opis ten efekt XML na przetwarzanie JSON zawiera [mapowanie między formatami JSON i XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="f93d8-343">For an explanation of this effect of XML on JSON processing, see [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f93d8-344">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="f93d8-344">See also</span></span>

- [<span data-ttu-id="f93d8-345">Obsługa formatu JSON i innych formatów transferowania danych</span><span class="sxs-lookup"><span data-stu-id="f93d8-345">Support for JSON and Other Data Transfer Formats</span></span>](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)
