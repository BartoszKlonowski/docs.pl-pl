---
title: Autonomiczna serializacja kodu JSON
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287
caps.latest.revision: "32"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: 8583ac00f1216e68f95c3d41d8c896b555d0aa8d
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 12/22/2017
---
# <a name="stand-alone-json-serialization"></a><span data-ttu-id="a8425-102">Autonomiczna serializacja kodu JSON</span><span class="sxs-lookup"><span data-stu-id="a8425-102">Stand-Alone JSON Serialization</span></span>
<span data-ttu-id="a8425-103">JSON (JavaScript Object Notation) to format danych przeznaczone do użycia przez kod JavaScript uruchomionych na stronach sieci Web w przeglądarce.</span><span class="sxs-lookup"><span data-stu-id="a8425-103">JSON (JavaScript Object Notation) is a data format that is specifically designed to be used by JavaScript code running on Web pages inside the browser.</span></span> <span data-ttu-id="a8425-104">Jest to domyślny format danych używany przez usługi ASP.NET AJAX utworzone w [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)].</span><span class="sxs-lookup"><span data-stu-id="a8425-104">It is the default data format used by ASP.NET AJAX services created in [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)].</span></span>  
  
 <span data-ttu-id="a8425-105">Ten format można również tworzenie usług AJAX bez integracji z platformy ASP.NET — w takim przypadku XML jest domyślnie, ale można wybrać JSON.</span><span class="sxs-lookup"><span data-stu-id="a8425-105">This format can also be used when creating AJAX services without integrating with ASP.NET - in this case, XML is the default but JSON can be chosen.</span></span>  
  
 <span data-ttu-id="a8425-106">Na koniec, jeśli jest wymagana obsługa JSON, ale nie są tworzone usługa AJAX <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> umożliwia bezpośrednio serializować obiekty .NET na dane JSON i deserializować tych danych do wystąpienia typów .NET.</span><span class="sxs-lookup"><span data-stu-id="a8425-106">Finally, if you require JSON support but are not creating an AJAX service, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> makes it possible to directly serialize .NET objects into JSON data and to deserialize such data back into instances of .NET types.</span></span> <span data-ttu-id="a8425-107">Opis jak to zrobić, zobacz [porady: serializacji i deserializacji danych JSON](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span><span class="sxs-lookup"><span data-stu-id="a8425-107">For a description of how to do this, see [How to: Serialize and Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span></span>  
  
 <span data-ttu-id="a8425-108">Podczas pracy z formatu JSON, ten sam typ .NET są obsługiwane, z kilkoma wyjątkami, jak są obsługiwane przez <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="a8425-108">When working with JSON, the same .NET types are supported, with a few exceptions, as are supported by the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="a8425-109">Aby uzyskać listę obsługiwanych typów, zobacz [typy obsługiwane przez serializator kontraktu danych](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="a8425-109">For a list of the types supported, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="a8425-110">Obejmuje to najbardziej pierwotne typy, większość tablicy i typy kolekcji, również w złożonych typów używające <xref:System.Runtime.Serialization.DataContractAttribute> i <xref:System.Runtime.Serialization.DataMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a8425-110">This includes most primitive types, most array and collection types, as well as complex types that use the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute>.</span></span>  
  
## <a name="mapping-net-types-to-json-types"></a><span data-ttu-id="a8425-111">Mapowania typów .NET do typów JSON</span><span class="sxs-lookup"><span data-stu-id="a8425-111">Mapping .NET types to JSON Types</span></span>  
 <span data-ttu-id="a8425-112">W poniższej tabeli przedstawiono związek między typy .NET i JSON/JavaScript po zmapowaniu przez procedury serializacji i deserializacji.</span><span class="sxs-lookup"><span data-stu-id="a8425-112">The following table shows the correspondence between .NET types and JSON/JavaScript types when mapped by serialization and deserialization procedures.</span></span>  
  
|<span data-ttu-id="a8425-113">Typy .NET</span><span class="sxs-lookup"><span data-stu-id="a8425-113">.NET Types</span></span>|<span data-ttu-id="a8425-114">JSON/JavaScript</span><span class="sxs-lookup"><span data-stu-id="a8425-114">JSON/JavaScript</span></span>|<span data-ttu-id="a8425-115">Uwagi</span><span class="sxs-lookup"><span data-stu-id="a8425-115">Notes</span></span>|  
|----------------|----------------------|-----------|  
|<span data-ttu-id="a8425-116">Wszystkie typy liczbowe, na przykład <xref:System.Int32>, <xref:System.Decimal> lub<xref:System.Double></span><span class="sxs-lookup"><span data-stu-id="a8425-116">All numeric types, for example <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double></span></span>|<span data-ttu-id="a8425-117">Wartość liczbowa</span><span class="sxs-lookup"><span data-stu-id="a8425-117">Number</span></span>|<span data-ttu-id="a8425-118">Specjalne wartości, takich jak `Double.NaN`, `Double.PositiveInfinity` i `Double.NegativeInfinity` nie są obsługiwane i powoduje nieprawidłowe JSON.</span><span class="sxs-lookup"><span data-stu-id="a8425-118">Special values such as  `Double.NaN`, `Double.PositiveInfinity` and `Double.NegativeInfinity` are not supported and result in invalid JSON.</span></span>|  
|<xref:System.Enum>|<span data-ttu-id="a8425-119">Wartość liczbowa</span><span class="sxs-lookup"><span data-stu-id="a8425-119">Number</span></span>|<span data-ttu-id="a8425-120">Zobacz "Wyliczenia i JSON" w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="a8425-120">See "Enumerations and JSON" later in this topic.</span></span>|  
|<xref:System.Boolean>|<span data-ttu-id="a8425-121">Boolean</span><span class="sxs-lookup"><span data-stu-id="a8425-121">Boolean</span></span>|--|  
|<span data-ttu-id="a8425-122"><xref:System.String>, <xref:System.Char></span><span class="sxs-lookup"><span data-stu-id="a8425-122"><xref:System.String>, <xref:System.Char></span></span>|<span data-ttu-id="a8425-123">String</span><span class="sxs-lookup"><span data-stu-id="a8425-123">String</span></span>|--|  
|<span data-ttu-id="a8425-124"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span><span class="sxs-lookup"><span data-stu-id="a8425-124"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span></span>|<span data-ttu-id="a8425-125">String</span><span class="sxs-lookup"><span data-stu-id="a8425-125">String</span></span>|<span data-ttu-id="a8425-126">Format tych typów w formacie JSON jest taki sam jak XML (zasadniczo TimeSpan w formacie ISO 8601 Duration, identyfikator GUID w formacie "12345678-ABCD-ABCD-ABCD-1234567890AB" oraz identyfikatora URI w postaci ciągu fizyczne, takie jak "http://www.example.com").</span><span class="sxs-lookup"><span data-stu-id="a8425-126">The format of these types in JSON is the same as in XML (essentially, TimeSpan in the ISO 8601 Duration format, GUID in the "12345678-ABCD-ABCD-ABCD-1234567890AB" format and URI in its natural string form like "http://www.example.com").</span></span> <span data-ttu-id="a8425-127">Aby uzyskać dokładne informacje, zobacz [odwołanie do schematu kontraktu danych](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="a8425-127">For precise information, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>|  
|<xref:System.Xml.XmlQualifiedName>|<span data-ttu-id="a8425-128">String</span><span class="sxs-lookup"><span data-stu-id="a8425-128">String</span></span>|<span data-ttu-id="a8425-129">Ma format "Nazwa: przestrzeń nazw" (wszystko przed dwukropkiem pierwszy to nazwa).</span><span class="sxs-lookup"><span data-stu-id="a8425-129">The format is "name:namespace" (anything before the first colon is the name).</span></span> <span data-ttu-id="a8425-130">Nazwa lub obszar nazw może brakować.</span><span class="sxs-lookup"><span data-stu-id="a8425-130">Either the name or the namespace can be missing.</span></span> <span data-ttu-id="a8425-131">Brak obszaru nazw również można pominąć dwukropkiem.</span><span class="sxs-lookup"><span data-stu-id="a8425-131">If there is no namespace the colon can be omitted as well.</span></span>|  
|<span data-ttu-id="a8425-132"><xref:System.Array>typu<xref:System.Byte></span><span class="sxs-lookup"><span data-stu-id="a8425-132"><xref:System.Array> of type <xref:System.Byte></span></span>|<span data-ttu-id="a8425-133">Tablica liczb</span><span class="sxs-lookup"><span data-stu-id="a8425-133">Array of numbers</span></span>|<span data-ttu-id="a8425-134">Każdy numer reprezentuje wartość jednego bajtu.</span><span class="sxs-lookup"><span data-stu-id="a8425-134">Each number represents the value of one byte.</span></span>|  
|<xref:System.DateTime>|<span data-ttu-id="a8425-135">Data/Godzina lub ciąg</span><span class="sxs-lookup"><span data-stu-id="a8425-135">DateTime or String</span></span>|<span data-ttu-id="a8425-136">Zobacz daty / godziny i JSON w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="a8425-136">See Dates/Times and JSON later in this topic.</span></span>|  
|<xref:System.DateTimeOffset>|<span data-ttu-id="a8425-137">Typ złożony</span><span class="sxs-lookup"><span data-stu-id="a8425-137">Complex type</span></span>|<span data-ttu-id="a8425-138">Zobacz daty / godziny i JSON w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="a8425-138">See Dates/Times and JSON later in this topic.</span></span>|  
|<span data-ttu-id="a8425-139">Typy XML i ADO.NET (<xref:System.Xml.XmlElement>,</span><span class="sxs-lookup"><span data-stu-id="a8425-139">XML and ADO.NET types (<xref:System.Xml.XmlElement>,</span></span><br /><br /> <span data-ttu-id="a8425-140"><xref:System.Xml.Linq.XElement>.,</span><span class="sxs-lookup"><span data-stu-id="a8425-140"><xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="a8425-141">Tablice <xref:System.Xml.XmlNode>,</span><span class="sxs-lookup"><span data-stu-id="a8425-141">Arrays of <xref:System.Xml.XmlNode>,</span></span><br /><br /> <span data-ttu-id="a8425-142"><xref:System.Runtime.Serialization.ISerializable>,</span><span class="sxs-lookup"><span data-stu-id="a8425-142"><xref:System.Runtime.Serialization.ISerializable>,</span></span><br /><br /> <span data-ttu-id="a8425-143"><xref:System.Data.DataSet>).</span><span class="sxs-lookup"><span data-stu-id="a8425-143"><xref:System.Data.DataSet>).</span></span>|<span data-ttu-id="a8425-144">String</span><span class="sxs-lookup"><span data-stu-id="a8425-144">String</span></span>|<span data-ttu-id="a8425-145">Zobacz sekcję typów XML i JSON w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="a8425-145">See the XML Types and JSON section of this topic.</span></span>|  
|<xref:System.DBNull>|<span data-ttu-id="a8425-146">Pusty typu złożonego</span><span class="sxs-lookup"><span data-stu-id="a8425-146">Empty complex type</span></span>|--|  
|<span data-ttu-id="a8425-147">Kolekcje, słowniki i tablice</span><span class="sxs-lookup"><span data-stu-id="a8425-147">Collections, dictionaries, and arrays</span></span>|<span data-ttu-id="a8425-148">Tablica</span><span class="sxs-lookup"><span data-stu-id="a8425-148">Array</span></span>|<span data-ttu-id="a8425-149">Zobacz sekcję kolekcje, słowniki i tablic w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="a8425-149">See the Collections, Dictionaries, and Arrays section of this topic.</span></span>|  
|<span data-ttu-id="a8425-150">Typy złożone (z <xref:System.Runtime.Serialization.DataContractAttribute> lub <xref:System.SerializableAttribute> zastosowane)</span><span class="sxs-lookup"><span data-stu-id="a8425-150">Complex types (with the <xref:System.Runtime.Serialization.DataContractAttribute> or <xref:System.SerializableAttribute> applied)</span></span>|<span data-ttu-id="a8425-151">Typ złożony</span><span class="sxs-lookup"><span data-stu-id="a8425-151">Complex type</span></span>|<span data-ttu-id="a8425-152">Elementy członkowskie danych stają się elementami typu złożonego kodu JavaScript.</span><span class="sxs-lookup"><span data-stu-id="a8425-152">Data members become members of the JavaScript complex type.</span></span>|  
|<span data-ttu-id="a8425-153">Typy złożone implementacja <xref:System.Runtime.Serialization.ISerializable> interfejsu)</span><span class="sxs-lookup"><span data-stu-id="a8425-153">Complex types implementing the <xref:System.Runtime.Serialization.ISerializable> interface)</span></span>|<span data-ttu-id="a8425-154">Typ złożony</span><span class="sxs-lookup"><span data-stu-id="a8425-154">Complex type</span></span>|<span data-ttu-id="a8425-155">Taki sam jak inne typy złożone, ale niektóre <xref:System.Runtime.Serialization.ISerializable> typy nie są obsługiwane — zobacz część ISerializable pomocy technicznej w sekcji Zaawansowane informacje w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="a8425-155">Same as other complex types but some <xref:System.Runtime.Serialization.ISerializable> types are not supported – see the ISerializable Support part of the Advanced Information section of this topic.</span></span>|  
|<span data-ttu-id="a8425-156">`Null`wartość dla każdego typu</span><span class="sxs-lookup"><span data-stu-id="a8425-156">`Null` value for any type</span></span>|<span data-ttu-id="a8425-157">Null</span><span class="sxs-lookup"><span data-stu-id="a8425-157">Null</span></span>|<span data-ttu-id="a8425-158">Typy dopuszczające wartości null są również obsługiwane i mapowanie do formatu JSON w taki sam sposób jak typów wartości null.</span><span class="sxs-lookup"><span data-stu-id="a8425-158">Nullable types are also supported and map to JSON in the same way as non-nullable types.</span></span>|  
  
### <a name="enumerations-and-json"></a><span data-ttu-id="a8425-159">Wyliczenia i JSON</span><span class="sxs-lookup"><span data-stu-id="a8425-159">Enumerations and JSON</span></span>  
 <span data-ttu-id="a8425-160">Wartości elementu członkowskiego wyliczenia są traktowane jako liczby w formacie JSON, który jest inny niż jak są traktowane w kontraktach danych, w którym zostaną one dołączone jako nazwy elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="a8425-160">Enumeration member values are treated as numbers in JSON, which is different from how they are treated in data contracts, where they are included as member names.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="a8425-161">traktowanie, kontraktu danych zobacz [Typy wyliczeniowe w kontraktach danych](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="a8425-161"> the data contract treatment, see [Enumeration Types in Data Contracts](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span></span>  
  
-   <span data-ttu-id="a8425-162">Na przykład, jeśli masz `public enum Color {red, green, blue, yellow, pink}`, serializacji `yellow` tworzy liczbę 3, a nie ciąg "żółty".</span><span class="sxs-lookup"><span data-stu-id="a8425-162">For example, if you have `public enum Color {red, green, blue, yellow, pink}`, serializing `yellow` produces the number 3 and not the string "yellow".</span></span>  
  
-   <span data-ttu-id="a8425-163">Wszystkie `enum` należą do serializacji.</span><span class="sxs-lookup"><span data-stu-id="a8425-163">All `enum` members are serializable.</span></span> <span data-ttu-id="a8425-164"><xref:System.Runtime.Serialization.EnumMemberAttribute> i <xref:System.NonSerializedAttribute> atrybuty są ignorowane w przypadku użycia.</span><span class="sxs-lookup"><span data-stu-id="a8425-164">The <xref:System.Runtime.Serialization.EnumMemberAttribute> and the <xref:System.NonSerializedAttribute> attributes are ignored if used.</span></span>  
  
-   <span data-ttu-id="a8425-165">Istnieje możliwość deserializacji nieistniejącą `enum` wartość — na przykład wartość 87 może być zdeserializowany do poprzedniego wyliczenia kolor nawet, jeśli nie wystąpi żadne odpowiadającą jej nazwą kolor zdefiniowany.</span><span class="sxs-lookup"><span data-stu-id="a8425-165">It is possible to deserialize a nonexistent `enum` value - for example, the value 87 can be deserialized into the previous Color enum even though there is no corresponding color name defined.</span></span>  
  
-   <span data-ttu-id="a8425-166">Flagi `enum` nie specjalne i jest traktowane jako taki sam jak wszystkie inne `enum`.</span><span class="sxs-lookup"><span data-stu-id="a8425-166">A flags `enum` is not special and is treated the same as any other `enum`.</span></span>  
  
### <a name="datestimes-and-json"></a><span data-ttu-id="a8425-167">Daty/godziny i JSON</span><span class="sxs-lookup"><span data-stu-id="a8425-167">Dates/Times and JSON</span></span>  
 <span data-ttu-id="a8425-168">JSON format nie obsługuje bezpośrednio daty i godziny.</span><span class="sxs-lookup"><span data-stu-id="a8425-168">The JSON format does not directly support dates and times.</span></span> <span data-ttu-id="a8425-169">Jednak bardzo często są one używane i ASP.NET AJAX zapewnia specjalną obsługę tych typów.</span><span class="sxs-lookup"><span data-stu-id="a8425-169">However, they are very commonly used and ASP.NET AJAX provides special support for these types.</span></span> <span data-ttu-id="a8425-170">Korzystając z serwerów proxy ASP.NET AJAX, <xref:System.DateTime> typu w środowisku .NET pełni odpowiada `DateTime` typu w języku JavaScript.</span><span class="sxs-lookup"><span data-stu-id="a8425-170">When using ASP.NET AJAX proxies, the <xref:System.DateTime> type in .NET fully corresponds to the `DateTime` type in JavaScript.</span></span>  
  
-   <span data-ttu-id="a8425-171">Gdy nie za pomocą programu ASP.NET, <xref:System.DateTime> typu jest reprezentowana w formacie JSON jako ciąg w formacie specjalne opisaną w sekcji Zaawansowane informacje w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="a8425-171">When not using ASP.NET, a <xref:System.DateTime> type is represented in JSON as a string with a special format that is described in the Advanced Information section of this topic.</span></span>  
  
-   <span data-ttu-id="a8425-172"><xref:System.DateTimeOffset>jest wyświetlana w formacie JSON jako typ złożony: {"DateTime": dateTime, "OffsetMinutes": offsetMinutes}.</span><span class="sxs-lookup"><span data-stu-id="a8425-172"><xref:System.DateTimeOffset> is represented in JSON as a complex type: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span></span> <span data-ttu-id="a8425-173">`offsetMinutes` Element członkowski jest przesunięcie czasu lokalnego z czas uniwersalny Greenwich (GMT), teraz również określany jako uniwersalny czas koordynowany (UTC), związane z lokalizacją zdarzenia zainteresowań.</span><span class="sxs-lookup"><span data-stu-id="a8425-173">The `offsetMinutes` member is the local time offset from Greenwich Mean Time (GMT), also now referred to as Coordinated Universal Time (UTC), associated with the location of the event of interest.</span></span> <span data-ttu-id="a8425-174">`dateTime` Elementu członkowskiego reprezentuje wystąpienie w godzina wystąpienia zdarzenia zainteresowań (ponownie, staje się `DateTime` w języku JavaScript, jeśli ASP.NET AJAX w użycie i ciąg, gdy nie jest on).</span><span class="sxs-lookup"><span data-stu-id="a8425-174">The `dateTime` member represents the instance in time when the event of interest occurred (again, it becomes a `DateTime` in JavaScript when ASP.NET AJAX is in use and a string when it is not).</span></span> <span data-ttu-id="a8425-175">W serializacji `dateTime` Członek serializowany jest zawsze GMT.</span><span class="sxs-lookup"><span data-stu-id="a8425-175">On serialization, the `dateTime` member is always serialized in GMT.</span></span> <span data-ttu-id="a8425-176">Jeśli opisujące 3:00 czasu Nowym Jorku, więc `dateTime` ma składnik godziny z 8:00 AM a `offsetMinutes` to 300 (minus 300 minut lub 5 godzin od GMT).</span><span class="sxs-lookup"><span data-stu-id="a8425-176">So, if describing 3:00 AM New York time, `dateTime` has a time component of 8:00 AM and `offsetMinutes` are 300 (minus 300 minutes or 5 hours from GMT).</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a8425-177"><xref:System.DateTime>i <xref:System.DateTimeOffset> obiektów serializować do notacji JSON, tylko zachować informacje dokładnością do milisekund.</span><span class="sxs-lookup"><span data-stu-id="a8425-177"><xref:System.DateTime> and <xref:System.DateTimeOffset> objects, when serialized to JSON, only preserve information to millisecond precision.</span></span> <span data-ttu-id="a8425-178">Wartości podrzędne milisekund (micro/nanosekundach) zostaną utracone podczas serializacji.</span><span class="sxs-lookup"><span data-stu-id="a8425-178">Sub-millisecond values (micro/nanoseconds) are lost during serialization.</span></span>  
  
### <a name="xml-types-and-json"></a><span data-ttu-id="a8425-179">Typy XML i JSON</span><span class="sxs-lookup"><span data-stu-id="a8425-179">XML Types and JSON</span></span>  
 <span data-ttu-id="a8425-180">Typy XML stają się ciągi formatu JSON.</span><span class="sxs-lookup"><span data-stu-id="a8425-180">XML types become JSON strings.</span></span>  
  
-   <span data-ttu-id="a8425-181">Na przykład, jeśli element członkowski danych "q" z typu klasy XElement zawiera \<abc / >, jest w formacie JSON {"q": "\<abc / >"}.</span><span class="sxs-lookup"><span data-stu-id="a8425-181">For example, if a data member "q" of type XElement contains \<abc/>, the JSON is {"q":"\<abc/>"}.</span></span>  
  
-   <span data-ttu-id="a8425-182">Istnieje kilka specjalnych zasad, które Określ sposób opakowana XML — Aby uzyskać więcej informacji, zobacz sekcję zaawansowane informacje w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="a8425-182">There are some special rules that specify how XML is wrapped - for more information, see the Advanced Information section later in this topic.</span></span>  
  
-   <span data-ttu-id="a8425-183">Jeśli używasz środowiska ASP.NET AJAX i nie chcesz użyć ciągów w języku JavaScript, ale zamiast tego chcesz XML modelu DOM, ustaw <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> właściwości do pliku XML na <xref:System.ServiceModel.Web.WebGetAttribute> lub <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> właściwości do pliku XML na <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a8425-183">If you are using ASP.NET AJAX and do not want to use strings in the JavaScript, but want the XML DOM instead, set the <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> property to XML on <xref:System.ServiceModel.Web.WebGetAttribute> or the <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> property to XML on the <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span></span>  
  
### <a name="collections-dictionaries-and-arrays"></a><span data-ttu-id="a8425-184">Kolekcje, słowniki i tablice</span><span class="sxs-lookup"><span data-stu-id="a8425-184">Collections, Dictionaries and Arrays</span></span>  
 <span data-ttu-id="a8425-185">Wszystkie kolekcje, słowniki i tablice są reprezentowane jako tablice w formacie JSON.</span><span class="sxs-lookup"><span data-stu-id="a8425-185">All collections, dictionaries, and arrays are represented in JSON as arrays.</span></span>  
  
-   <span data-ttu-id="a8425-186">Wszystkie dostosowania, który używa <xref:System.Runtime.Serialization.CollectionDataContractAttribute> jest ignorowana w reprezentacja JSON.</span><span class="sxs-lookup"><span data-stu-id="a8425-186">Any customization that uses the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> is ignored in the JSON representation.</span></span>  
  
-   <span data-ttu-id="a8425-187">Słowniki nie są sposób pracy bezpośrednio z formatu JSON.</span><span class="sxs-lookup"><span data-stu-id="a8425-187">Dictionaries are not a way to work directly with JSON.</span></span> <span data-ttu-id="a8425-188">Słownik\<string, object > może nie być obsługiwana w taki sam sposób w [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] zgodnie z oczekiwaniami na współpracę z innymi technologiami JSON.</span><span class="sxs-lookup"><span data-stu-id="a8425-188">Dictionary\<string,object> may not be supported in the same way in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] as expected from working with other JSON technologies.</span></span> <span data-ttu-id="a8425-189">Na przykład, jeśli "abc" jest zamapowany na "xyz" i "def" jest zamapowany na 42 w słowniku, reprezentacja JSON nie jest {"abc": "xyz", "def": 42}, ale jest [{"Klucz": "abc", "Wartość": "xyz"}, {"Klucz": "def", "Value": 42}] zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="a8425-189">For example, if "abc" is mapped to "xyz" and "def" is mapped to 42 in a dictionary, the JSON representation is not {"abc":"xyz","def":42} but is [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] instead.</span></span>  
  
-   <span data-ttu-id="a8425-190">Jeśli chcesz pracować bezpośrednio z JSON (Uzyskiwanie dostępu do kluczy i wartości dynamicznie, bez wstępnie definiujący kontrakt sztywne), masz kilka opcji:</span><span class="sxs-lookup"><span data-stu-id="a8425-190">If you would like to work with JSON directly (accessing keys and values dynamically, without pre-defining a rigid contract), you have several options:</span></span>  
  
    -   <span data-ttu-id="a8425-191">Należy rozważyć użycie [słabą kontrolą serializacji JSON (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) próbki.</span><span class="sxs-lookup"><span data-stu-id="a8425-191">Consider using the [Weakly-typed JSON Serialization (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) sample.</span></span>  
  
    -   <span data-ttu-id="a8425-192">Należy rozważyć użycie <xref:System.Runtime.Serialization.ISerializable> konstruktorów interfejsu i deserializacji — umożliwiają dostęp do pary klucz wartość JSON na serializacji i deserializacji odpowiednio te dwa mechanizmy, ale nie działają w scenariuszach częściowo zaufanych.</span><span class="sxs-lookup"><span data-stu-id="a8425-192">Consider using the <xref:System.Runtime.Serialization.ISerializable> interface and deserialization constructors - these two mechanisms allow you to access JSON key/value pairs on serialization and deserialization respectively, but do not work in partial trust scenarios.</span></span>  
  
    -   <span data-ttu-id="a8425-193">Należy wziąć pod uwagę pracy z [mapowanie między formatami JSON i XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) zamiast przy użyciu serializatora.</span><span class="sxs-lookup"><span data-stu-id="a8425-193">Consider working with the [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) instead of using a serializer.</span></span>  
  
    -   <span data-ttu-id="a8425-194">*Polimorfizm* w kontekście serializacji odnosi się do możliwości serializacji typu pochodnego, których można oczekiwać jego typ podstawowy.</span><span class="sxs-lookup"><span data-stu-id="a8425-194">*Polymorphism* in the context of serialization refers to the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="a8425-195">Istnieją reguły specjalne specyficzne dla formatu JSON, podczas korzystania z kolekcji polymorphically, przypisując, na przykład, aby <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="a8425-195">There are special JSON-specific rules when using collections polymorphically, when, for example, assigning a collection to an <xref:System.Object>.</span></span> <span data-ttu-id="a8425-196">Ten problem jest bardziej dokładnie opisane w sekcji Zaawansowane informacje w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="a8425-196">This issue is more fully discussed in the Advanced Information section later in this topic.</span></span>  
  
## <a name="additional-details"></a><span data-ttu-id="a8425-197">Dodatkowe szczegóły</span><span class="sxs-lookup"><span data-stu-id="a8425-197">Additional Details</span></span>  
  
### <a name="order-of-data-members"></a><span data-ttu-id="a8425-198">Kolejność elementów członkowskich danych</span><span class="sxs-lookup"><span data-stu-id="a8425-198">Order of Data Members</span></span>  
 <span data-ttu-id="a8425-199">Kolejność elementów członkowskich danych nie jest ważna, korzystając z formatu JSON.</span><span class="sxs-lookup"><span data-stu-id="a8425-199">Order of data members is not important when using JSON.</span></span> <span data-ttu-id="a8425-200">W szczególności, nawet jeśli <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> ustawiono JSON danych może nadal być zdeserializowany, w dowolnej kolejności.</span><span class="sxs-lookup"><span data-stu-id="a8425-200">Specifically, even if <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> is set, JSON data can still be deserialized in any order.</span></span>  
  
### <a name="json-types"></a><span data-ttu-id="a8425-201">Typy JSON</span><span class="sxs-lookup"><span data-stu-id="a8425-201">JSON Types</span></span>  
 <span data-ttu-id="a8425-202">Typ JSON nie musi odpowiadać powyższej tabeli przy deserializacji.</span><span class="sxs-lookup"><span data-stu-id="a8425-202">The JSON type does not have to match the preceding table on deserialization.</span></span> <span data-ttu-id="a8425-203">Na przykład `Int` zwykle mapy numer JSON, ale można też pomyślnie zdeserializowany z ciągu JSON pod warunkiem, że ciąg zawiera prawidłową liczbę.</span><span class="sxs-lookup"><span data-stu-id="a8425-203">For example, an `Int` normally maps to a JSON number, but it can also be successfully deserialized from a JSON string as long as that string contains a valid number.</span></span> <span data-ttu-id="a8425-204">Oznacza to, że oba {"q": 42} i {"q": "42"} są prawidłowe w przypadku braku `Int` członka danych o nazwie "q".</span><span class="sxs-lookup"><span data-stu-id="a8425-204">That is, both {"q":42} and {"q":"42"} are valid if there is an `Int` data member called "q".</span></span>  
  
### <a name="polymorphism"></a><span data-ttu-id="a8425-205">Polimorfizm</span><span class="sxs-lookup"><span data-stu-id="a8425-205">Polymorphism</span></span>  
 <span data-ttu-id="a8425-206">Serializacja polimorficznych składa się z możliwość serializować typ pochodny, których można oczekiwać jego typ podstawowy.</span><span class="sxs-lookup"><span data-stu-id="a8425-206">Polymorphic serialization consists of the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="a8425-207">Ta funkcja jest obsługiwana dla serializacji JSON przez [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] serializacja XML można porównywać pod względem sposobu jest obsługiwana.</span><span class="sxs-lookup"><span data-stu-id="a8425-207">This is supported for JSON serialization by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] comparable to the way XML serialization is supported.</span></span> <span data-ttu-id="a8425-208">Na przykład można serializować `MyDerivedType` gdzie `MyBaseType` jest zgodne z oczekiwaniami albo serializować `Int` gdzie `Object` jest oczekiwany.</span><span class="sxs-lookup"><span data-stu-id="a8425-208">For example, you can serialize `MyDerivedType` where `MyBaseType` is expected, or serialize `Int` where `Object` is expected.</span></span>  
  
 <span data-ttu-id="a8425-209">Informacje o typie mogą zostać utracone podczas deserializacji typem pochodnym, jeśli oczekiwany jest typ podstawowy, chyba że są deserializacji typu złożonego.</span><span class="sxs-lookup"><span data-stu-id="a8425-209">Type information may be lost when deserializing a derived type if the base type is expected, unless you are deserializing a complex type.</span></span> <span data-ttu-id="a8425-210">Na przykład jeśli <xref:System.Uri> jest serializowany gdzie <xref:System.Object> oczekuje powoduje ciągu JSON.</span><span class="sxs-lookup"><span data-stu-id="a8425-210">For example, if <xref:System.Uri> is serialized where <xref:System.Object> is expected, it results in a JSON string.</span></span> <span data-ttu-id="a8425-211">Jeśli ten ciąg jest następnie deserializowany do <xref:System.Object>, .NET <xref:System.String> jest zwracany.</span><span class="sxs-lookup"><span data-stu-id="a8425-211">If this string is then deserialized back into <xref:System.Object>, a .NET <xref:System.String> is returned.</span></span> <span data-ttu-id="a8425-212">Deserializator nie wie, ciąg został początkowo typu <xref:System.Uri>.</span><span class="sxs-lookup"><span data-stu-id="a8425-212">The deserializer does not know that the string was initially of type <xref:System.Uri>.</span></span> <span data-ttu-id="a8425-213">Ogólnie rzecz biorąc gdy oczekiwano <xref:System.Object>, wszystkie ciągi JSON są zdeserializować jako ciągi .NET i wszystkie tablice notacji JSON używany do serializacji kolekcji .NET, słowniki, i tablice są rozszeregować jako .NET <xref:System.Array> typu <xref:System.Object>, niezależnie od tego, co rzeczywisty typ oryginalny został.</span><span class="sxs-lookup"><span data-stu-id="a8425-213">Generally, when expecting <xref:System.Object>, all JSON strings are deserialized as .NET strings, and all JSON arrays used to serialize .NET collections, dictionaries, and arrays are deserialized as .NET <xref:System.Array> of type <xref:System.Object>, regardless of what the actual original type had been.</span></span> <span data-ttu-id="a8425-214">Wartość logiczna JSON mapuje .NET <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="a8425-214">A JSON boolean maps to a .NET <xref:System.Boolean>.</span></span> <span data-ttu-id="a8425-215">Jednak gdy oczekiwano <xref:System.Object>, numery JSON są rozszeregować jako albo .NET <xref:System.Int32>, <xref:System.Decimal> lub <xref:System.Double>, gdzie automatycznego pobrania najbardziej odpowiedniego typu.</span><span class="sxs-lookup"><span data-stu-id="a8425-215">However when expecting an <xref:System.Object>, JSON numbers are deserialized as either .NET <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double>, where the most appropriate type is automatically picked.</span></span>  
  
 <span data-ttu-id="a8425-216">Podczas deserializacji do typu interfejsu <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializuje tak, jakby obiekt był deklarowanego typu.</span><span class="sxs-lookup"><span data-stu-id="a8425-216">When deserializing into an interface type, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializes as if the declared type were object.</span></span>  
  
 <span data-ttu-id="a8425-217">Podczas pracy z własnych typów podstawowych i pochodnych, za pomocą <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> lub równoważnego mechanizmu jest zwykle wymagane.</span><span class="sxs-lookup"><span data-stu-id="a8425-217">When working with your own base and derived types, using the <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> or an equivalent mechanism is normally required.</span></span> <span data-ttu-id="a8425-218">Na przykład, jeśli masz operację, która ma `Animal` zwracać wartości i faktycznie zwraca moduł wystąpienia `Cat` (pochodną `Animal`), albo stosuje <xref:System.Runtime.Serialization.KnownTypeAttribute>, do `Animal` typu lub <xref:System.ServiceModel.ServiceKnownTypeAttribute> do operację i określ `Cat` typu w tych atrybutów.</span><span class="sxs-lookup"><span data-stu-id="a8425-218">For example, if you have an operation that has an `Animal` return value and it actually returns an instance of `Cat` (derived from `Animal`), you should either apply the <xref:System.Runtime.Serialization.KnownTypeAttribute>, to the `Animal` type or the <xref:System.ServiceModel.ServiceKnownTypeAttribute> to the operation and specify the `Cat` type in these attributes.</span></span> <span data-ttu-id="a8425-219">Aby uzyskać więcej informacji, zobacz [znane typy kontraktu danych](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span><span class="sxs-lookup"><span data-stu-id="a8425-219">For more information, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span></span>  
  
 <span data-ttu-id="a8425-220">Szczegółowe informacje, jak polimorficznych prac serializacji i omówienie niektóre ograniczenia, które należy przestrzegać podczas korzystania z niego zobacz sekcję zaawansowane informacje w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="a8425-220">For details of how polymorphic serialization works and a discussion of some of the limitations that must be respected when using it, see the Advanced Information section later in this topic.</span></span>  
  
### <a name="versioning"></a><span data-ttu-id="a8425-221">Przechowywanie wersji</span><span class="sxs-lookup"><span data-stu-id="a8425-221">Versioning</span></span>  
 <span data-ttu-id="a8425-222">Funkcji przechowywania wersji, w tym kontraktu danych <xref:System.Runtime.Serialization.IExtensibleDataObject> interfejsu, są w pełni obsługiwane w formacie JSON.</span><span class="sxs-lookup"><span data-stu-id="a8425-222">The data contract versioning features, including the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, are fully supported in JSON.</span></span> <span data-ttu-id="a8425-223">Ponadto, w większości przypadków użytkownik może deserializować typu w jednym formacie (na przykład XML) i serializować go w innym formacie (na przykład JSON) i nadal zachowania danych w <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span><span class="sxs-lookup"><span data-stu-id="a8425-223">Furthermore, in most cases it is possible to deserialize a type in one format (for example, XML) and then serialize it into another format (for example, JSON) and still preserve the data in <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="a8425-224">[Kontrakty danych zgodne z nowszymi](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="a8425-224"> [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span></span> <span data-ttu-id="a8425-225">Należy pamiętać, że JSON jest nieuporządkowaną, więc wszystkie informacje o kolejności zostaną utracone.</span><span class="sxs-lookup"><span data-stu-id="a8425-225">Remember that JSON is unordered so any order information is lost.</span></span> <span data-ttu-id="a8425-226">Ponadto JSON nie obsługuje wielu pary klucz wartość o takiej samej nazwie klucza.</span><span class="sxs-lookup"><span data-stu-id="a8425-226">Furthermore, JSON does not support multiple key/value pairs with the same key name.</span></span> <span data-ttu-id="a8425-227">Ponadto wszystkie operacje na <xref:System.Runtime.Serialization.IExtensibleDataObject> są z założenia polimorficznych - będący ich typ pochodny są przypisane do <xref:System.Object>, typ podstawowy dla wszystkich typów.</span><span class="sxs-lookup"><span data-stu-id="a8425-227">Finally, all operations on <xref:System.Runtime.Serialization.IExtensibleDataObject> are inherently polymorphic - that is their derived type are assigned to <xref:System.Object>, the base type for all types.</span></span>  
  
## <a name="json-in-urls"></a><span data-ttu-id="a8425-228">JSON w adresach URL</span><span class="sxs-lookup"><span data-stu-id="a8425-228">JSON in URLs</span></span>  
 <span data-ttu-id="a8425-229">Podczas korzystania z punktów końcowych ASP.NET AJAX z zlecenie HTTP GET (przy użyciu <xref:System.ServiceModel.Web.WebGetAttribute> atrybut), parametry przychodzące są wyświetlane w adresie URL żądania, zamiast treść komunikatu.</span><span class="sxs-lookup"><span data-stu-id="a8425-229">When using ASP.NET AJAX endpoints with the HTTP GET verb (using the <xref:System.ServiceModel.Web.WebGetAttribute> attribute), incoming parameters appear in the request URL instead of the message body.</span></span> <span data-ttu-id="a8425-230">JSON jest obsługiwany, nawet w adresie URL żądania, tak więc jeśli masz operację, która przyjmuje `Int` o nazwie "numer" i `Person` typu złożonego o nazwie "p", adres URL może przypominać następujący adres URL.</span><span class="sxs-lookup"><span data-stu-id="a8425-230">JSON is supported even in the request URL, so if you have an operation that takes an `Int` called "number" and a `Person` complex type called "p", the URL may resemble the following URL.</span></span>  
  
```  
http://example.com/myservice.svc/MyOperation?number=7&p={"name":"John","age":42}  
```  
  
 <span data-ttu-id="a8425-231">Jeśli używasz kontrolki Menedżera skryptów AJAX ASP.NET i serwera proxy do wywołania tej usługi, ten adres URL jest generowana automatycznie przez serwer proxy i nie jest widoczne.</span><span class="sxs-lookup"><span data-stu-id="a8425-231">If you are using an ASP.NET AJAX Script Manager control and proxy to call the service, this URL is automatically generated by the proxy and is not seen.</span></span> <span data-ttu-id="a8425-232">JSON nie można używać w adresach URL dla punktów końcowych - ASP.NET AJAX.</span><span class="sxs-lookup"><span data-stu-id="a8425-232">JSON cannot be used in URLs on non-ASP.NET AJAX endpoints.</span></span>  
  
## <a name="advanced-information"></a><span data-ttu-id="a8425-233">Zaawansowane informacje</span><span class="sxs-lookup"><span data-stu-id="a8425-233">Advanced information</span></span>  
  
### <a name="iserializable-support"></a><span data-ttu-id="a8425-234">Obsługa iSerializable</span><span class="sxs-lookup"><span data-stu-id="a8425-234">ISerializable Support</span></span>  
  
#### <a name="supported-and-unsupported-iserializable-types"></a><span data-ttu-id="a8425-235">Obsługiwane i nieobsługiwane typy ISerializable</span><span class="sxs-lookup"><span data-stu-id="a8425-235">Supported and Unsupported ISerializable Types</span></span>  
 <span data-ttu-id="a8425-236">Ogólnie rzecz biorąc, typy, które implementują <xref:System.Runtime.Serialization.ISerializable> interfejsu są w pełni obsługiwane podczas serializacji/deserializacji JSON.</span><span class="sxs-lookup"><span data-stu-id="a8425-236">In general, types that implement the <xref:System.Runtime.Serialization.ISerializable> interface are fully supported when serializing/deserializing JSON.</span></span> <span data-ttu-id="a8425-237">Jednak niektóre z tych typów (w tym niektórych typów .NET Framework) są wykonywane w taki sposób, aspekty serializacji JSON specyficzne spowodować ich zdeserializować nie prawidłowo:</span><span class="sxs-lookup"><span data-stu-id="a8425-237">However, some of these types (including some .NET Framework types) are implemented in such a way that the JSON-specific serialization aspects cause them to not deserialize correctly:</span></span>  
  
-   <span data-ttu-id="a8425-238">Z <xref:System.Runtime.Serialization.ISerializable>, typ danych poszczególnych członków nigdy nie jest znany wcześniej.</span><span class="sxs-lookup"><span data-stu-id="a8425-238">With <xref:System.Runtime.Serialization.ISerializable>, the type of individual data members is never known in advance.</span></span> <span data-ttu-id="a8425-239">Prowadzi to do sytuacji polimorficznych podobne do deserializacji do obiektu typu.</span><span class="sxs-lookup"><span data-stu-id="a8425-239">This leads to a polymorphic situation similar to deserializing types into an object.</span></span> <span data-ttu-id="a8425-240">Jak wspomniano wcześniej, może to doprowadzić do utraty informacji o typie w formacie JSON.</span><span class="sxs-lookup"><span data-stu-id="a8425-240">As mentioned before, this may lead to loss of type information in JSON.</span></span> <span data-ttu-id="a8425-241">Na przykład typ, który serializuje `enum` w jego <xref:System.Runtime.Serialization.ISerializable> implementacji i podejmuje próbę deserializacji z powrotem bezpośrednio do `enum` (bez prawidłowego rzutowania) nie powiedzie się, ponieważ `enum` jest serializowany w postaci liczb w formacie JSON i JSON deserializuje liczb na wbudowane typy liczbowe .NET (Int32, Decimal lub o podwójnej precyzji).</span><span class="sxs-lookup"><span data-stu-id="a8425-241">For example, a type that serializes an `enum` in its <xref:System.Runtime.Serialization.ISerializable> implementation and attempts to deserialize back directly into an `enum` (without proper casts) fails, because an `enum` is serialized using numbers in JSON and JSON numbers deserialize into built-in .NET numeric types (Int32, Decimal or Double).</span></span> <span data-ttu-id="a8425-242">Dlatego fakt użytą jako numer `enum` wartości zostaną utracone.</span><span class="sxs-lookup"><span data-stu-id="a8425-242">So the fact that the number used to be an `enum` value is lost.</span></span>  
  
-   <span data-ttu-id="a8425-243"><xref:System.Runtime.Serialization.ISerializable> Typu, który jest zależny od określonej kolejności deserializacji w Konstruktorze jego deserializacji może również się nie powieść deserializacji niektóre dane JSON, ponieważ większość serializatorów JSON nie gwarantuje dowolnej kolejności.</span><span class="sxs-lookup"><span data-stu-id="a8425-243">An <xref:System.Runtime.Serialization.ISerializable> type that depends on a particular order of deserialization in its deserialization constructor may also fail to deserialize some JSON data, because most JSON serializers do not guarantee any specific order.</span></span>  
  
#### <a name="factory-types"></a><span data-ttu-id="a8425-244">Typy fabryki</span><span class="sxs-lookup"><span data-stu-id="a8425-244">Factory Types</span></span>  
 <span data-ttu-id="a8425-245">Gdy <xref:System.Runtime.Serialization.IObjectReference> interfejs jest obsługiwany w formacie JSON na ogół żadnych typów, które wymagają funkcji "Typ fabryki" (zwracanie wystąpienia innego typu niż <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> niż typ, który implementuje interfejs) nie są obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="a8425-245">While the <xref:System.Runtime.Serialization.IObjectReference> interface is supported in JSON in general, any types that require the "factory type" feature (returning an instance of a different type from <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> than the type that implements the interface) are not supported.</span></span>  
  
### <a name="datetime-wire-format"></a><span data-ttu-id="a8425-246">Format daty/godziny podczas transmisji</span><span class="sxs-lookup"><span data-stu-id="a8425-246">DateTime Wire Format</span></span>  
 <span data-ttu-id="a8425-247"><xref:System.DateTime>wartości są wyświetlane jako ciągi JSON w formie "/ Date(700000+0500) /", gdzie numer pierwszej (700000 w przykładzie przedstawionym) to wyrażony w milisekundach czas w strefie czasowej GMT regularne (z systemem innym niż-letniego) czas od północy, 1 stycznia 1970.</span><span class="sxs-lookup"><span data-stu-id="a8425-247"><xref:System.DateTime> values appear as JSON strings in the form of "/Date(700000+0500)/", where the first number (700000 in the example provided) is the number of milliseconds in the GMT time zone, regular (non-daylight savings) time since midnight, January 1, 1970.</span></span> <span data-ttu-id="a8425-248">Liczba może być ujemna do reprezentowania wcześniejszych razy.</span><span class="sxs-lookup"><span data-stu-id="a8425-248">The number may be negative to represent earlier times.</span></span> <span data-ttu-id="a8425-249">Element, który składa się z "+0500" w tym przykładzie jest opcjonalna i wskazuje, że czas jest o <xref:System.DateTimeKind.Local> rodzaj — to znaczy powinny być konwertowane na lokalnej strefie czasowej przy deserializacji.</span><span class="sxs-lookup"><span data-stu-id="a8425-249">The part that consists of "+0500" in the example is optional and indicates that the time is of the <xref:System.DateTimeKind.Local> kind - that is, should be converted to the local time zone on deserialization.</span></span> <span data-ttu-id="a8425-250">Jeśli nie ma czasu jest rozszeregować jako <xref:System.DateTimeKind.Utc>.</span><span class="sxs-lookup"><span data-stu-id="a8425-250">If it is absent, the time is deserialized as <xref:System.DateTimeKind.Utc>.</span></span> <span data-ttu-id="a8425-251">Rzeczywista liczba ("0500" w tym przykładzie) i znaku (+ lub -) są ignorowane.</span><span class="sxs-lookup"><span data-stu-id="a8425-251">The actual number ("0500" in this example) and its sign (+ or -) are ignored.</span></span>  
  
 <span data-ttu-id="a8425-252">Podczas serializowania <xref:System.DateTime>, <xref:System.DateTimeKind.Local> i <xref:System.DateTimeKind.Unspecified> czasy są zapisywane z przesunięciem i <xref:System.DateTimeKind.Utc> napisano bez.</span><span class="sxs-lookup"><span data-stu-id="a8425-252">When serializing <xref:System.DateTime>, <xref:System.DateTimeKind.Local> and <xref:System.DateTimeKind.Unspecified> times are written with an offset, and <xref:System.DateTimeKind.Utc> is written without.</span></span>  
  
 <span data-ttu-id="a8425-253">Kod JavaScript klienta ASP.NET AJAX powoduje automatyczną konwersję takich ciągów na język JavaScript `DateTime` wystąpień.</span><span class="sxs-lookup"><span data-stu-id="a8425-253">The ASP.NET AJAX client JavaScript code automatically converts such strings into JavaScript `DateTime` instances.</span></span> <span data-ttu-id="a8425-254">Jeśli istnieją inne ciągów, które mają podobne formularza, które nie są typu <xref:System.DateTime> w środowisku .NET, zostaną one przetworzone również.</span><span class="sxs-lookup"><span data-stu-id="a8425-254">If there are other strings that have a similar form that are not of type <xref:System.DateTime> in .NET, they are converted as well.</span></span>  
  
 <span data-ttu-id="a8425-255">Konwersja tylko ma miejsce, jeśli będą miały zmienione znaczenie znaków "/" (czyli JSON wygląda następująco: "\\/Date(700000+0500)\\/") i z tego powodu [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]przez koder JSON (włączane przez <xref:System.ServiceModel.WebHttpBinding>) zawsze specjalne "/" znak.</span><span class="sxs-lookup"><span data-stu-id="a8425-255">The conversion only takes place if the "/" characters are escaped (that is, the JSON looks like "\\/Date(700000+0500)\\/"), and for this reason [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]'s JSON encoder (enabled by the <xref:System.ServiceModel.WebHttpBinding>) always escapes the "/" character.</span></span>  
  
### <a name="xml-in-json-strings"></a><span data-ttu-id="a8425-256">XML w ciągach formatu JSON</span><span class="sxs-lookup"><span data-stu-id="a8425-256">XML in JSON Strings</span></span>  
  
#### <a name="xmlelement"></a><span data-ttu-id="a8425-257">Element XmlElement</span><span class="sxs-lookup"><span data-stu-id="a8425-257">XmlElement</span></span>  
 <span data-ttu-id="a8425-258"><xref:System.Xml.XmlElement>jest serializowany, ponieważ jest z bez zawijania.</span><span class="sxs-lookup"><span data-stu-id="a8425-258"><xref:System.Xml.XmlElement> is serialized as is, with no wrapping.</span></span> <span data-ttu-id="a8425-259">Na przykład elementu członkowskiego danych "x" typu <xref:System.Xml.XmlElement> zawierający \<abc / > jest reprezentowany w następujący sposób.</span><span class="sxs-lookup"><span data-stu-id="a8425-259">For example, data member "x" of type <xref:System.Xml.XmlElement> that contains \<abc/> is as represented as follows.</span></span>  
  
```json  
{"x":"<abc/>"}  
```  
  
#### <a name="arrays-of-xmlnode"></a><span data-ttu-id="a8425-260">Tablic elementów XmlNode</span><span class="sxs-lookup"><span data-stu-id="a8425-260">Arrays of XmlNode</span></span>  
 <span data-ttu-id="a8425-261"><xref:System.Array>obiekty typu <xref:System.Xml.XmlNode> są ujęte w element o nazwie ArrayOfXmlNode w przestrzeni nazw kontraktu danych standardowych dla typu.</span><span class="sxs-lookup"><span data-stu-id="a8425-261"><xref:System.Array> objects of type <xref:System.Xml.XmlNode> are wrapped in an element called ArrayOfXmlNode in the standard data contract namespace for the type.</span></span> <span data-ttu-id="a8425-262">Jeśli tablica zawierająca węzła atrybutu "N" w przestrzeni nazw "ns", który zawiera "value" i węzeł pustego elementu "M", "x" reprezentacja ma następującą składnię.</span><span class="sxs-lookup"><span data-stu-id="a8425-262">If "x" is an array that contains attribute node "N" in namespace "ns" that contains "value" and an empty element node "M", the representation is as follows.</span></span>  
  
```  
{"x":"<ArrayOfXmlNode xmlns=\"http://schemas.datacontract.org/2004/07/System.Xml\" a:N=\"value\" xmlns:a=\"ns\"><M/></ArrayOfXmlNode>"}  
```  
  
 <span data-ttu-id="a8425-263">Atrybuty w pustej przestrzeni nazw na początku XmlNode tablic (przed innymi elementami) nie są obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="a8425-263">Attributes in the empty namespace at the beginning of XmlNode arrays (before other elements) are unsupported.</span></span>  
  
#### <a name="ixmlserializable-types-including-xelement-and-dataset"></a><span data-ttu-id="a8425-264">Typy interfejsu IXmlSerializable, w tym klasy XElement i zestawu danych</span><span class="sxs-lookup"><span data-stu-id="a8425-264">IXmlSerializable Types including XElement and DataSet</span></span>  
 <span data-ttu-id="a8425-265"><xref:System.Runtime.Serialization.ISerializable>typy podzielić na "typy zawartości", "Typów zestawu danych" i "typów elementów".</span><span class="sxs-lookup"><span data-stu-id="a8425-265"><xref:System.Runtime.Serialization.ISerializable> types subdivide into "content types", "DataSet types" and "element types".</span></span> <span data-ttu-id="a8425-266">Dla definicji tego typu, zobacz [typy XML i ADO.NET w kontraktach danych](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="a8425-266">For definitions of these types, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span>  
  
 <span data-ttu-id="a8425-267">"Zawartość" i "Zestawu danych" typy są serializowane podobny do <xref:System.Array> obiektów <xref:System.Xml.XmlNode> opisanych w poprzedniej sekcji.</span><span class="sxs-lookup"><span data-stu-id="a8425-267">"Content" and "DataSet" types are serialized similar to <xref:System.Array> objects of <xref:System.Xml.XmlNode> discussed in the previous section.</span></span> <span data-ttu-id="a8425-268">Są one ujęte w element o nazwie i przestrzeni nazw odpowiada nazwie kontraktu danych i przestrzeni nazw typu zagrożona.</span><span class="sxs-lookup"><span data-stu-id="a8425-268">They are wrapped in an element whose name and namespace corresponds to the data contract name and namespace of the type in question.</span></span>  
  
 <span data-ttu-id="a8425-269">"Element" typów, takie jak <xref:System.Xml.Linq.XElement> są serializowane, tak jak, podobnie jak <xref:System.Xml.XmlElement> wcześniej omówione w tym temacie.</span><span class="sxs-lookup"><span data-stu-id="a8425-269">"Element" types such as <xref:System.Xml.Linq.XElement> are serialized as is, similar to <xref:System.Xml.XmlElement> previously discussed in this topic.</span></span>  
  
### <a name="polymorphism"></a><span data-ttu-id="a8425-270">Polimorfizm</span><span class="sxs-lookup"><span data-stu-id="a8425-270">Polymorphism</span></span>  
  
#### <a name="preserving-type-information"></a><span data-ttu-id="a8425-271">Informacje o typie zachowania</span><span class="sxs-lookup"><span data-stu-id="a8425-271">Preserving Type Information</span></span>  
 <span data-ttu-id="a8425-272">Jak wspomniano wcześniej, polimorfizm jest obsługiwane w formacie JSON z pewnymi ograniczeniami.</span><span class="sxs-lookup"><span data-stu-id="a8425-272">As stated earlier, polymorphism is supported in JSON with some limitations.</span></span> <span data-ttu-id="a8425-273">JavaScript jest językiem słabą kontrolą i typ tożsamości zwykle nie jest istotna.</span><span class="sxs-lookup"><span data-stu-id="a8425-273">JavaScript is a weakly-typed language and type identity is normally not an issue.</span></span> <span data-ttu-id="a8425-274">Korzystając z formatu JSON do komunikacji między systemem jednoznacznie (.NET) i słabą kontrolą systemu (JavaScript), zaleca się zachowanie tożsamości typu.</span><span class="sxs-lookup"><span data-stu-id="a8425-274">However, when using JSON to communicate between a strongly-typed system (.NET) and a weakly-typed system (JavaScript), it is useful to preserve type identity.</span></span> <span data-ttu-id="a8425-275">Na przykład typy danych kontraktu nazwy "Kwadrat" i "Koło" pochodzi z typu o nazwie kontraktu danych "Kształtu".</span><span class="sxs-lookup"><span data-stu-id="a8425-275">For example, types with data contract names "Square" and "Circle" derive from a type with a data contract name of "Shape".</span></span> <span data-ttu-id="a8425-276">Jeśli "Okrąg" są wysyłane z .NET do języka JavaScript, a później są zwracane do metody .NET, która oczekuje "Kształtu", jest przydatne w przypadku po stronie .NET dowiedzieć się, że danego obiektu pierwotnie "Okrąg" — w przeciwnym razie żadnych informacji specyficznych dla typu pochodnego (np. element członkowski danych "radius" na "Okręgu") mogą zostać utracone.</span><span class="sxs-lookup"><span data-stu-id="a8425-276">If "Circle" is sent from .NET to JavaScript and is later returned to a .NET method that expects "Shape", it is useful for the .NET side to know that the object in question was originally a "Circle" - otherwise any information specific to the derived type (for example, "radius" data member on "Circle") may be lost.</span></span>  
  
 <span data-ttu-id="a8425-277">Aby zachować typu tożsamości, gdy serializacji typy złożone do formatu JSON wskazówkę"typu" można dodać, a Deserializator rozpoznaje wskazówka i działa prawidłowo.</span><span class="sxs-lookup"><span data-stu-id="a8425-277">To preserve type identity, when serializing complex types to JSON a "type hint" can be added, and the deserializer recognizes the hint and acts appropriately.</span></span> <span data-ttu-id="a8425-278">Wskazówka"typu" jest parę klucz/wartość JSON z nazwą klucza "__type" (dwa podkreślenia następuje słowo "type").</span><span class="sxs-lookup"><span data-stu-id="a8425-278">The "type hint" is a JSON key/value pair with the key name of "__type" (two underscores followed by the word "type").</span></span> <span data-ttu-id="a8425-279">Wartość jest ciągiem JSON w postaci "DataContractName:DataContractNamespace" (niczego do pierwszego dwukropka to nazwa).</span><span class="sxs-lookup"><span data-stu-id="a8425-279">The value is a JSON string of the form "DataContractName:DataContractNamespace" (anything up to the first colon is the name).</span></span> <span data-ttu-id="a8425-280">Przy użyciu wcześniejszego przykładu, "Okrąg" może być Zserializowany w następujący sposób.</span><span class="sxs-lookup"><span data-stu-id="a8425-280">Using the earlier example, "Circle" can be serialized as follows.</span></span>  
  
```json  
{"__type":"Circle:http://example.com/myNamespace","x":50,"y":70,"radius":10}  
```  
  
 <span data-ttu-id="a8425-281">Wskazówka typu jest bardzo podobny do `xsi:type` atrybutu zdefiniowanym przez standardowe wystąpienie schematu XML, używane podczas serializacji/deserializacji XML.</span><span class="sxs-lookup"><span data-stu-id="a8425-281">The type hint is very similar to the `xsi:type` attribute defined by the XML Schema Instance standard and used when serializing/deserializing XML.</span></span>  
  
 <span data-ttu-id="a8425-282">Elementy członkowskie danych o nazwie "__type" są zabronione ze względu na potencjalne konflikt ze wskazówką typu.</span><span class="sxs-lookup"><span data-stu-id="a8425-282">Data members called "__type" are forbidden due to potential conflict with the type hint.</span></span>  
  
#### <a name="reducing-the-size-of-type-hints"></a><span data-ttu-id="a8425-283">Zmniejszenie rozmiaru wskazówek typu</span><span class="sxs-lookup"><span data-stu-id="a8425-283">Reducing the Size of Type Hints</span></span>  
 <span data-ttu-id="a8425-284">Aby zmniejszyć rozmiar wiadomości w formacie JSON, prefiks przestrzeni nazw kontraktu danych domyślne (http://schemas.datacontract.org/2004/07/) jest zastępowany znaku "#".</span><span class="sxs-lookup"><span data-stu-id="a8425-284">To reduce the size of JSON messages, the default data contract namespace prefix (http://schemas.datacontract.org/2004/07/) is replaced with the "#" character.</span></span> <span data-ttu-id="a8425-285">(Aby zamiany odwracalny, ucieczki reguła jest używana: Jeśli przestrzeń nazw rozpoczyna się od znaku "#" lub "\\" znaki, są dołączony dodatkowy "\\" znaków).</span><span class="sxs-lookup"><span data-stu-id="a8425-285">(To make this replacement reversible, an escaping rule is used: if the namespace starts with the "#" or "\\" characters, they are appended with an extra "\\" character).</span></span> <span data-ttu-id="a8425-286">W związku z tym "Okrąg" jest typem w przestrzeni nazw .NET "MyApp.Shapes", jego domyślnej przestrzeni nazw kontraktu danych jest http://schemas.datacontract.org/2004/07/MyApp.</span><span class="sxs-lookup"><span data-stu-id="a8425-286">Thus, if "Circle" is a type in the .NET namespace "MyApp.Shapes", its default data contract namespace is http://schemas.datacontract.org/2004/07/MyApp.</span></span> <span data-ttu-id="a8425-287">Kształty i reprezentacja JSON ma następującą składnię.</span><span class="sxs-lookup"><span data-stu-id="a8425-287">Shapes and the JSON representation is as follows.</span></span>  
  
```json  
{"__type":"Circle:#MyApp.Shapes","x":50,"y":70,"radius":10}  
```  
  
 <span data-ttu-id="a8425-288">Zarówno skróconą (#MyApp.Shapes), jak i nazwy pełny (http://schemas.datacontract.org/2004/07/MyApp.Shapes) jest rozpoznawany przy deserializacji.</span><span class="sxs-lookup"><span data-stu-id="a8425-288">Both the truncated (#MyApp.Shapes) and the full (http://schemas.datacontract.org/2004/07/MyApp.Shapes) names is understood on deserialization.</span></span>  
  
#### <a name="type-hint-position-in-json-objects"></a><span data-ttu-id="a8425-289">Typ pozycji wskazówka obiektów JSON</span><span class="sxs-lookup"><span data-stu-id="a8425-289">Type Hint Position in JSON Objects</span></span>  
 <span data-ttu-id="a8425-290">Należy pamiętać, że wskazówki dotyczącej typu musi występować jako pierwszy w reprezentacja JSON.</span><span class="sxs-lookup"><span data-stu-id="a8425-290">Note that the type hint must appear first in the JSON representation.</span></span> <span data-ttu-id="a8425-291">Jest to tylko wówczas, gdy kolejność par klucz/wartość jest ważna w formacie JSON przetwarzania.</span><span class="sxs-lookup"><span data-stu-id="a8425-291">This is the only case where order of key/value pairs is important in JSON processing.</span></span> <span data-ttu-id="a8425-292">Na przykład następujący ciąg nie jest prawidłową sposobem określania wskazówki dotyczącej typu.</span><span class="sxs-lookup"><span data-stu-id="a8425-292">For example, the following is not a valid way to specify the type hint.</span></span>  
  
```json  
{"x":50,"y":70,"radius":10,"__type":"Circle:#MyApp.Shapes"}  
```  
  
 <span data-ttu-id="a8425-293">Zarówno <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> używane przez [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] i strony klienta ASP.NET AJAX najpierw zawsze Emituj wskazówki dotyczącej typu.</span><span class="sxs-lookup"><span data-stu-id="a8425-293">Both the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> used by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] and ASP.NET AJAX client pages always emit the type hint first.</span></span>  
  
#### <a name="type-hints-apply-only-to-complex-types"></a><span data-ttu-id="a8425-294">Typ stosuje się tylko do typów złożonych</span><span class="sxs-lookup"><span data-stu-id="a8425-294">Type Hints Apply Only to Complex Types</span></span>  
 <span data-ttu-id="a8425-295">Nie istnieje sposób można wyemitować wskazówkę typu dla typów innych niż złożone.</span><span class="sxs-lookup"><span data-stu-id="a8425-295">There is no way to emit a type hint for non-complex types.</span></span> <span data-ttu-id="a8425-296">Na przykład, jeśli operacja ma <xref:System.Object> zwracany typ, ale zwraca koło, może być reprezentacja JSON, jak pokazano wcześniej i informacje o typie zostaną zachowane.</span><span class="sxs-lookup"><span data-stu-id="a8425-296">For example, if an operation has an <xref:System.Object> return type but returns a Circle, the JSON representation can be as shown earlier and the type information is preserved.</span></span> <span data-ttu-id="a8425-297">Jednak jeśli identyfikator Uri jest zwracany, reprezentacja JSON jest ciągiem i fakt, że ciąg używany do reprezentowania identyfikatora Uri jest utracone.</span><span class="sxs-lookup"><span data-stu-id="a8425-297">However, if Uri is returned, the JSON representation is a string and the fact that the string used to represent a Uri is lost.</span></span> <span data-ttu-id="a8425-298">Dotyczy to nie tylko typy pierwotne, ale również do kolekcji i tablic.</span><span class="sxs-lookup"><span data-stu-id="a8425-298">This applies not only to primitive types but also to collections and arrays.</span></span>  
  
#### <a name="when-are-type-hints-emitted"></a><span data-ttu-id="a8425-299">Gdy są emitowane wskazówek typu</span><span class="sxs-lookup"><span data-stu-id="a8425-299">When Are Type Hints Emitted</span></span>  
 <span data-ttu-id="a8425-300">Typ wskazówki może zwiększyć rozmiar komunikatu znacznie (Aby zmniejszyć to Użyj krótszej przestrzeni nazw kontraktu danych, jeśli to możliwe).</span><span class="sxs-lookup"><span data-stu-id="a8425-300">Type hints may increase message size significantly (one way to mitigate this is to use shorter data contract namespaces if possible).</span></span> <span data-ttu-id="a8425-301">W związku z tym następujące reguły decydować, czy są emitowane typu wskazówek:</span><span class="sxs-lookup"><span data-stu-id="a8425-301">Therefore, the following rules govern whether type hints are emitted:</span></span>  
  
-   <span data-ttu-id="a8425-302">Gdy za pomocą kodu ASP.NET AJAX, wskazówki dotyczące typu są zawsze emitowane Jeśli to możliwe, nawet jeśli dostępny jest brak przypisania bazową/dziedziczoną — na przykład, nawet jeśli koło jest przypisany do okręgu.</span><span class="sxs-lookup"><span data-stu-id="a8425-302">When using ASP.NET AJAX, type hints are always emitted whenever possible, even if there is no base/derived assignment - for example, even if a Circle is assigned to a Circle.</span></span> <span data-ttu-id="a8425-303">(Jest to wymagane, aby w pełni włączyć proces wywoływania ze środowiska JSON słabą kontrolą do środowiska .NET jednoznacznie zaskakująco bez utraty informacji.)</span><span class="sxs-lookup"><span data-stu-id="a8425-303">(This is required to fully enable the process of calling from the weakly-typed JSON environment into the strongly-typed .NET environment with no surprising loss of information.)</span></span>  
  
-   <span data-ttu-id="a8425-304">Podczas korzystania z usług AJAX z Brak integracji ASP.NET, po przypisaniu bazową/dziedziczoną - emitowanego gdy kółko jest przypisany do kształtu typu wskazówki tylko są emitowane lub <xref:System.Object> , ale nie po przypisaniu do okręgu.</span><span class="sxs-lookup"><span data-stu-id="a8425-304">When using AJAX services with no ASP.NET integration, type hints are only emitted when there is a base/derived assignment - that is, emitted when Circle is assigned to Shape or <xref:System.Object> but not when assigned to Circle.</span></span> <span data-ttu-id="a8425-305">Zawiera minimalne informacje wymagane do poprawnego zaimplementowania klienta JavaScript, co poprawia wydajność, ale nie chroni przed utratą informacji typu w klientach niepoprawnie zaprojektowane.</span><span class="sxs-lookup"><span data-stu-id="a8425-305">This provides the minimum information required to correctly implement a JavaScript client, thus improving performance, but does not protect against type information loss in incorrectly-designed clients.</span></span> <span data-ttu-id="a8425-306">Całkowicie Unikaj bazową/dziedziczoną przypisań na serwerze, jeśli chce się uniknąć dotyczącą tego problemu na kliencie.</span><span class="sxs-lookup"><span data-stu-id="a8425-306">Avoid base/derived assignments altogether on the server if you want to avoid dealing with this issue on the client.</span></span>  
  
-   <span data-ttu-id="a8425-307">Korzystając z <xref:System.Runtime.Serialization.DataContractSerializer> typu `alwaysEmitTypeInformation` parametru Konstruktora Umożliwia wybór między poprzednim dwa tryby z są domyślne "`false`" (Emituj tylko typ wskazówek, gdy jest to wymagane).</span><span class="sxs-lookup"><span data-stu-id="a8425-307">When using the <xref:System.Runtime.Serialization.DataContractSerializer> type, the `alwaysEmitTypeInformation` constructor parameter allows you to choose between the preceding two modes, with the default being "`false`" (only emit type hints when required).</span></span>  
  
#### <a name="duplicate-data-member-names"></a><span data-ttu-id="a8425-308">Zduplikowane nazwy elementów członkowskich danych</span><span class="sxs-lookup"><span data-stu-id="a8425-308">Duplicate Data Member Names</span></span>  
 <span data-ttu-id="a8425-309">Typ pochodny informacji znajduje się w ten sam obiekt JSON, wraz z informacjami w typie podstawowym, a może wystąpić w dowolnej kolejności.</span><span class="sxs-lookup"><span data-stu-id="a8425-309">Derived type information is present in the same JSON object together with base type information, and can occur in any order.</span></span> <span data-ttu-id="a8425-310">Na przykład `Shape` mogą być reprezentowane w następujący sposób.</span><span class="sxs-lookup"><span data-stu-id="a8425-310">For example, `Shape` may be represented as follows.</span></span>  
  
```json  
{"__type":"Shape:#MyApp.Shapes","x":50,"y":70}  
```  
  
 <span data-ttu-id="a8425-311">Podczas gdy kółko mogą być reprezentowane w następujący sposób.</span><span class="sxs-lookup"><span data-stu-id="a8425-311">Whereas Circle may be represented as follows.</span></span>  
  
```json  
{"__type":"Circle:#MyApp.Shapes","x":50, "radius":10,"y":70}  
```  
  
 <span data-ttu-id="a8425-312">Jeśli bazie `Shape` typu zawiera również element członkowski danych o nazwie "`radius`", to prowadzi do kolizji na obu serializacji (ponieważ obiektów JSON nie może mieć powtarzające się nazwy kluczy) oraz deserializację (ponieważ nie jest jasne, czy "radius" odwołuje się do `Shape.radius` lub `Circle.radius`).</span><span class="sxs-lookup"><span data-stu-id="a8425-312">If the base `Shape` type also contained a data member called "`radius`", this leads to a collision on both serialization (because JSON objects cannot have repeating key names) and deserialization (because it is unclear whether "radius" refers to `Shape.radius` or `Circle.radius`).</span></span> <span data-ttu-id="a8425-313">W związku z tym podczas pojęcie "ukrywanie właściwości" (elementy członkowskie danych o takiej samej nazwie, na podstawie i klasy pochodne) jest zwykle nie jest zalecane w klasach kontraktu danych, faktycznie jest zabroniony w przypadku JSON.</span><span class="sxs-lookup"><span data-stu-id="a8425-313">Therefore, while the concept of "property hiding" (data members of the same name on based and derived classes) is generally not recommended in data contract classes, it is actually forbidden in the case of JSON.</span></span>  
  
#### <a name="polymorphism-and-ixmlserializable-types"></a><span data-ttu-id="a8425-314">Polimorfizm i typów IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="a8425-314">Polymorphism and IXmlSerializable Types</span></span>  
 <span data-ttu-id="a8425-315"><xref:System.Xml.Serialization.IXmlSerializable>typy mogły zostać polymorphically przypisane do siebie nawzajem w zwykły sposób tak długo, jak są spełnione wymagania znane typy, zgodnie z regułami kontraktu danych zwykle.</span><span class="sxs-lookup"><span data-stu-id="a8425-315"><xref:System.Xml.Serialization.IXmlSerializable> types may be polymorphically assigned to each other as usual as long as Known Types requirements are met, according to usual data contract rules.</span></span> <span data-ttu-id="a8425-316">Jednak serializacji <xref:System.Xml.Serialization.IXmlSerializable> wpisz zamiast <xref:System.Object> powoduje utratę danych typu jako wynik jest ciągiem formatu JSON.</span><span class="sxs-lookup"><span data-stu-id="a8425-316">However, serializing an <xref:System.Xml.Serialization.IXmlSerializable> type in place of <xref:System.Object> results in loss of type information as the result is a JSON string.</span></span>  
  
#### <a name="polymorphism-and-certain-interface-types"></a><span data-ttu-id="a8425-317">Polimorfizm i niektórych typów interfejsów</span><span class="sxs-lookup"><span data-stu-id="a8425-317">Polymorphism and Certain Interface Types</span></span>  
 <span data-ttu-id="a8425-318">Jest zabronione serializować typ kolekcji lub typu, który implementuje <xref:System.Xml.Serialization.IXmlSerializable> w przypadku, gdy typ innych niż kolekcji, który nie jest <xref:System.Xml.Serialization.IXmlSerializable> (z wyjątkiem <xref:System.Object>) jest oczekiwany.</span><span class="sxs-lookup"><span data-stu-id="a8425-318">It is forbidden to serialize a collection type or a type that implements <xref:System.Xml.Serialization.IXmlSerializable> where a non-collection type that is not <xref:System.Xml.Serialization.IXmlSerializable> (except for <xref:System.Object>) is expected.</span></span> <span data-ttu-id="a8425-319">Na przykład niestandardowy interfejs o nazwie `IMyInterface` i typ `MyType` implementować jednocześnie <xref:System.Collections.Generic.IEnumerable%601> typu `int` i `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="a8425-319">For example, a custom interface called `IMyInterface` and a type `MyType` that implement both <xref:System.Collections.Generic.IEnumerable%601> of type `int` and `IMyInterface`.</span></span> <span data-ttu-id="a8425-320">Zwracany jest zabronione `MyType` z operacji, których typem zwracanym jest `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="a8425-320">It is forbidden to return `MyType` from an operation whose return type is `IMyInterface`.</span></span> <span data-ttu-id="a8425-321">Jest to spowodowane `MyType` muszą być zserializowane jako tablica JSON i wymaga wskazówkę typu i podaną przed nie może zawierać wskazówkę typu z tablicami tylko z typów złożonych.</span><span class="sxs-lookup"><span data-stu-id="a8425-321">This is because `MyType` must be serialized as a JSON array and requires a type hint, and as stated before you cannot include a type hint with arrays, only with complex types.</span></span>  
  
#### <a name="known-types-and-configuration"></a><span data-ttu-id="a8425-322">Znane typy i konfiguracji</span><span class="sxs-lookup"><span data-stu-id="a8425-322">Known Types and Configuration</span></span>  
 <span data-ttu-id="a8425-323">Wszystkie te mechanizmy znany typ używany przez <xref:System.Runtime.Serialization.DataContractSerializer> są również obsługiwane w taki sam sposób przez <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span><span class="sxs-lookup"><span data-stu-id="a8425-323">All of the Known Type mechanisms used by the <xref:System.Runtime.Serialization.DataContractSerializer> are also supported in the same way by the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="a8425-324">Serializatorów zarówno do odczytu tego samego elementu konfiguracji [ \<dataContractSerializer >](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) w [ \<system.runtime.serialization >](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), aby odnaleźć dodany ze znanych typów za pomocą pliku konfiguracji.</span><span class="sxs-lookup"><span data-stu-id="a8425-324">Both serializers read the same configuration element, [\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) in [\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), to discover known types added through a configuration file.</span></span>  
  
#### <a name="collections-assigned-to-object"></a><span data-ttu-id="a8425-325">Kolekcji przypisanych do obiektu</span><span class="sxs-lookup"><span data-stu-id="a8425-325">Collections Assigned to Object</span></span>  
 <span data-ttu-id="a8425-326">Kolekcji przypisanych do obiektu są serializowane, tak jakby są kolekcje, które implementują <xref:System.Collections.Generic.IEnumerable%601>: tablica JSON z każdego wpisu, który ma typ wskazówkę, jeśli jest typem złożonym.</span><span class="sxs-lookup"><span data-stu-id="a8425-326">Collections assigned to Object are serialized as if they are collections that implement <xref:System.Collections.Generic.IEnumerable%601>: a JSON array with each entry that has a type hint if it is a complex type.</span></span> <span data-ttu-id="a8425-327">Na przykład <xref:System.Collections.Generic.List%601> typu `Shape` przypisane do <xref:System.Object> wygląda podobnie do następującego.</span><span class="sxs-lookup"><span data-stu-id="a8425-327">For example, a <xref:System.Collections.Generic.List%601> of type `Shape` assigned to <xref:System.Object> looks like the following.</span></span>  
  
```json  
[{"__type":"Shape:#MyApp.Shapes","x":50,"y":70},  
{"__type":"Shape:#MyApp.Shapes","x":58,"y":73},  
{"__type":"Shape:#MyApp.Shapes","x":41,"y":32}]  
```  
  
 <span data-ttu-id="a8425-328">Podczas deserializacji do <xref:System.Object>:</span><span class="sxs-lookup"><span data-stu-id="a8425-328">When deserialized back into <xref:System.Object>:</span></span>  
  
-   <span data-ttu-id="a8425-329">`Shape`musi należeć do listy znanych typów.</span><span class="sxs-lookup"><span data-stu-id="a8425-329">`Shape` must be in the Known Types list.</span></span> <span data-ttu-id="a8425-330">O <xref:System.Collections.Generic.List%601> typu `Shape` w znanych typów nie ma wpływu.</span><span class="sxs-lookup"><span data-stu-id="a8425-330">Having <xref:System.Collections.Generic.List%601> of type `Shape` in known types has no effect.</span></span> <span data-ttu-id="a8425-331">Należy pamiętać, że nie trzeba dodać `Shape` do znanych typów na serializacji w takim przypadku - odbywa się to automatycznie.</span><span class="sxs-lookup"><span data-stu-id="a8425-331">Note that you do not have to add `Shape` to known types on serialization in this case - this is done automatically.</span></span>  
  
-   <span data-ttu-id="a8425-332">Kolekcja jest rozszeregować jako <xref:System.Array> typu <xref:System.Object> zawierający `Shape` wystąpień.</span><span class="sxs-lookup"><span data-stu-id="a8425-332">The collection is deserialized as an <xref:System.Array> of type <xref:System.Object> that contains `Shape` instances.</span></span>  
  
#### <a name="derived-collections-assigned-to-base-collections"></a><span data-ttu-id="a8425-333">Pochodne kolekcji przypisanych do kolekcji podstawowej</span><span class="sxs-lookup"><span data-stu-id="a8425-333">Derived Collections Assigned to Base Collections</span></span>  
 <span data-ttu-id="a8425-334">Gdy pochodnej kolekcji jest przypisany do kolekcji podstawowej, kolekcji zwykle jest serializowany tak, jakby był kolekcję typu podstawowego.</span><span class="sxs-lookup"><span data-stu-id="a8425-334">When a derived collection is assigned to a base collection, the collection is usually serialized as if it was a collection of the base type.</span></span> <span data-ttu-id="a8425-335">Jednak jeśli typ elementu kolekcji pochodnych nie można przypisać do typu elementu podstawowego kolekcji, jest zwracany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a8425-335">However, if the item type of the derived collection cannot be assigned to the item type of the base collection, an exception is thrown.</span></span>  
  
#### <a name="type-hints-and-dictionaries"></a><span data-ttu-id="a8425-336">Wskazówki dotyczące typu i słowników</span><span class="sxs-lookup"><span data-stu-id="a8425-336">Type Hints and Dictionaries</span></span>  
 <span data-ttu-id="a8425-337">Jeśli słownik jest przypisany do <xref:System.Object>, każdy wpis kluczy i wartości w słowniku jest traktowana tak, jakby został przypisany do <xref:System.Object> i pobiera wskazówkę typu.</span><span class="sxs-lookup"><span data-stu-id="a8425-337">When a dictionary is assigned to an <xref:System.Object>, each Key and Value entry in the dictionary is treated as if it was assigned to <xref:System.Object> and gets a type hint.</span></span>  
  
 <span data-ttu-id="a8425-338">Podczas serializowania typów słownika, obiekt JSON, który zawiera elementy członkowskie "Klucz" a "Wartość" jest poza zasięgiem `alwaysEmitTypeInformation` ustawienie i zawiera tylko wskazówkę typu podczas wymagają powyższych zasad kolekcji.</span><span class="sxs-lookup"><span data-stu-id="a8425-338">When serializing dictionary types, the JSON object that contains the "Key" and "Value" members is unaffected by the `alwaysEmitTypeInformation` setting and only contains a type hint when the preceding collection rules require it.</span></span>  
  
### <a name="valid-json-key-names"></a><span data-ttu-id="a8425-339">Nazwy kluczy poprawne dane JSON</span><span class="sxs-lookup"><span data-stu-id="a8425-339">Valid JSON Key Names</span></span>  
 <span data-ttu-id="a8425-340">Nazwy kluczy serializator koduje XML, które nie są prawidłowe nazwy XML.</span><span class="sxs-lookup"><span data-stu-id="a8425-340">The serializer XML-encodes key names that are not valid XML names.</span></span> <span data-ttu-id="a8425-341">Na przykład element członkowski danych o nazwie "123" miałyby zakodowane nazwy takie jak "_x0031\__x0032\__x0033\_" ponieważ "123" jest nieprawidłową nazwą — element XML (rozpoczyna się od cyfry).</span><span class="sxs-lookup"><span data-stu-id="a8425-341">For example, a data member with the name of "123" would have an encoded name such as "_x0031\__x0032\__x0033\_" because "123" is an invalid XML element name (starts with a digit).</span></span> <span data-ttu-id="a8425-342">Podobna sytuacja mogą wynikać z niektóre zestawy znaków międzynarodowych nie jest prawidłowa w nazw XML.</span><span class="sxs-lookup"><span data-stu-id="a8425-342">A similar situation may arise with some international character sets not valid in XML names.</span></span> <span data-ttu-id="a8425-343">Aby uzyskać informacje o tej wpływa XML na przetwarzanie JSON, zobacz [mapowanie między formatami JSON i XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="a8425-343">For an explanation of this effect of XML on JSON processing, see [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a8425-344">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="a8425-344">See Also</span></span>  
 [<span data-ttu-id="a8425-345">Obsługa formatu JSON i innych formatów transferowania danych</span><span class="sxs-lookup"><span data-stu-id="a8425-345">Support for JSON and Other Data Transfer Formats</span></span>](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)
