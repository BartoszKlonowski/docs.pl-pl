---
title: Typy XML i ADO.NET w kontraktach danych
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: c2ce8461-3c15-4c41-8c81-1cb78f5b59a6
ms.openlocfilehash: 0d052c0f178c2dc6e2eb5a740faa42239fb91068
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/28/2019
ms.locfileid: "64637231"
---
# <a name="xml-and-adonet-types-in-data-contracts"></a><span data-ttu-id="7f7a2-102">Typy XML i ADO.NET w kontraktach danych</span><span class="sxs-lookup"><span data-stu-id="7f7a2-102">XML and ADO.NET Types in Data Contracts</span></span>
<span data-ttu-id="7f7a2-103">Model kontraktu danych Windows Communication Foundation (WCF) obsługuje niektóre typy, które reprezentują XML bezpośrednio.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-103">The Windows Communication Foundation (WCF) data contract model supports certain types that represent XML directly.</span></span> <span data-ttu-id="7f7a2-104">Gdy te typy są serializacji XML, serializator dokonuje zapisu zawartość XML na typy bez dalszego przetwarzania.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-104">When these types are serialized to XML, the serializer writes out the XML contents of these types without any further processing.</span></span> <span data-ttu-id="7f7a2-105">Obsługiwane typy to <xref:System.Xml.XmlElement>, tablice <xref:System.Xml.XmlNode> (, ale nie `XmlNode` wpisz sam), jak również jako typami, które implementują <xref:System.Xml.Serialization.IXmlSerializable>.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-105">Supported types are <xref:System.Xml.XmlElement>, arrays of <xref:System.Xml.XmlNode> (but not the `XmlNode` type itself), as well as types that implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span> <span data-ttu-id="7f7a2-106"><xref:System.Data.DataSet> i <xref:System.Data.DataTable> typu, a także typizowanych zestawów danych, są często używane w programowaniu bazy danych.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-106">The <xref:System.Data.DataSet> and <xref:System.Data.DataTable> type, as well as typed datasets, are commonly used in database programming.</span></span> <span data-ttu-id="7f7a2-107">Te typy implementują `IXmlSerializable` interfejsu i w związku z tym możliwy do serializacji w danych są kontraktu modelu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-107">These types implement the `IXmlSerializable` interface and are therefore serializable in the data contract model.</span></span> <span data-ttu-id="7f7a2-108">Pewne specjalne zagadnienia dotyczące tych typów są wymienione na końcu tego tematu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-108">Some special considerations for these types are listed at the end of this topic.</span></span>  
  
## <a name="xml-types"></a><span data-ttu-id="7f7a2-109">Typy XML</span><span class="sxs-lookup"><span data-stu-id="7f7a2-109">XML Types</span></span>  
  
### <a name="xml-element"></a><span data-ttu-id="7f7a2-110">Xml Element</span><span class="sxs-lookup"><span data-stu-id="7f7a2-110">Xml Element</span></span>  
 <span data-ttu-id="7f7a2-111">`XmlElement` Typ jest serializowana, za pomocą jego zawartości XML.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-111">The `XmlElement` type is serialized using its XML contents.</span></span> <span data-ttu-id="7f7a2-112">Na przykład za pomocą następującego typu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-112">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#4)]
 [!code-vb[DataContractAttribute#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#4)]  
  
 <span data-ttu-id="7f7a2-113">To jest serializowany do XML w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="7f7a2-113">This is serialized to XML as follows:</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
    <myDataMember>  
        <myElement xmlns="" myAttribute="myValue">  
            myContents  
        </myElement>  
    </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="7f7a2-114">Należy zauważyć, że element członkowski danych otoki `<myDataMember>` nadal występuje.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-114">Notice that a wrapper data member element `<myDataMember>` is still present.</span></span> <span data-ttu-id="7f7a2-115">Nie ma sposobu usunięcia tego elementu w modelu kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-115">There is no way of removing this element in the data contract model.</span></span> <span data-ttu-id="7f7a2-116">Serializatory, obsługujące ten model ( <xref:System.Runtime.Serialization.DataContractSerializer> i <xref:System.Runtime.Serialization.NetDataContractSerializer>) może emitować specjalnych atrybutów do tego elementu otoki.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-116">The serializers that handle this model (the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>) may emit special attributes into this wrapper element.</span></span> <span data-ttu-id="7f7a2-117">Te atrybuty zawierają atrybut "zero" standardowy wystąpienia schematu XML (co `XmlElement` jako `null`) i atrybutu "type" (dzięki czemu `XmlElement` ma być używany polymorphically).</span><span class="sxs-lookup"><span data-stu-id="7f7a2-117">These attributes include the standard XML Schema Instance "nil" attribute (allowing the `XmlElement` to be `null`) and the "type" attribute (allowing `XmlElement` to be used polymorphically).</span></span> <span data-ttu-id="7f7a2-118">Ponadto następujące atrybuty XML są specyficzne dla usługi WCF: "Id", "Ref", "Type" i "Assembly".</span><span class="sxs-lookup"><span data-stu-id="7f7a2-118">Also, the following XML attributes are specific to WCF: "Id", "Ref", "Type" and "Assembly".</span></span> <span data-ttu-id="7f7a2-119">Te atrybuty mogą być emitowane do obsługi przy użyciu `XmlElement` z włączonym trybem reprezentatywność wykres obiektu lub za pomocą <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-119">These attributes may be emitted to support using the `XmlElement` with the object graph preservation mode enabled, or with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="7f7a2-120">(Aby uzyskać więcej informacji o trybie konserwacji wykresu obiektu, zobacz [serializacji i deserializacji](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).)</span><span class="sxs-lookup"><span data-stu-id="7f7a2-120">(For more information about the object graph preservation mode, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).)</span></span>  
  
 <span data-ttu-id="7f7a2-121">Tablice i kolekcje `XmlElement` są dozwolone i są obsługiwane jako dowolnej tablicy lub kolekcji.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-121">Arrays or collections of `XmlElement` are allowed and are handled as any other array or collection.</span></span> <span data-ttu-id="7f7a2-122">Oznacza to, że istnieje element otoki dla całej kolekcji, a element otoki oddzielne (podobnie jak `<myDataMember>` w powyższym przykładzie) dla każdego `XmlElement` w tablicy.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-122">That is, there is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each `XmlElement` in the array.</span></span>  
  
 <span data-ttu-id="7f7a2-123">Na deserializacji `XmlElement` jest tworzony przez Deserializator z przychodzącego pliku XML.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-123">On deserialization, an `XmlElement` is created by the deserializer from the incoming XML.</span></span> <span data-ttu-id="7f7a2-124">Prawidłowego elementu nadrzędnego <xref:System.Xml.XmlDocument> odbywa się przy deserializacji.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-124">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span>  
  
 <span data-ttu-id="7f7a2-125">Upewnij się, że XML fragment to po deserializacji do `XmlElement` definiuje wszystkie prefiksy, które używa i nie zależą inne definicje prefiks z elementów nadrzędnych.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-125">Make sure that the XML fragment that is deserialized to an `XmlElement` defines all prefixes that it uses and does not rely on any prefix definitions from ancestor elements.</span></span> <span data-ttu-id="7f7a2-126">Jest to niepożądane, tylko wtedy, gdy za pomocą `DataContractSerializer` dostępu do XML w innym (non -`DataContractSerializer`) źródła.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-126">This is a concern only when using the `DataContractSerializer` to access XML from a different (non-`DataContractSerializer`) source.</span></span>  
  
 <span data-ttu-id="7f7a2-127">Gdy jest używane z `DataContractSerializer`, `XmlElement` może być przypisana polymorphically, ale tylko element członkowski danych typu <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-127">When used with the `DataContractSerializer`, the `XmlElement` may be assigned polymorphically, but only to a data member of type <xref:System.Object>.</span></span> <span data-ttu-id="7f7a2-128">Mimo że implementuje <xref:System.Collections.IEnumerable>, `XmlElement` nie można używać jako typ kolekcji, a nie można przypisać do <xref:System.Collections.IEnumerable> element członkowski danych.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-128">Even though it implements <xref:System.Collections.IEnumerable>, an `XmlElement` cannot be used as a collection type and cannot be assigned to an <xref:System.Collections.IEnumerable> data member.</span></span> <span data-ttu-id="7f7a2-129">Podobnie jak w przypadku wszystkich przypisań polimorficznych, `DataContractSerializer` emituje nazwie kontraktu danych w wynikowy kod XML — w tym przypadku jest "XmlElement" w "http://schemas.datacontract.org/2004/07/System.Xml" przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-129">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "XmlElement" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span>  
  
 <span data-ttu-id="7f7a2-130">Za pomocą `NetDataContractSerializer`, wszystkie prawidłowe przypisanie polimorficznych `XmlElement` (Aby `Object` lub `IEnumerable`) jest obsługiwana.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-130">With the `NetDataContractSerializer`, any valid polymorphic assignment of `XmlElement` (to `Object` or `IEnumerable`) is supported.</span></span>  
  
 <span data-ttu-id="7f7a2-131">Nie należy próbować użyć jednej z serializatory z typów pochodnych typu `XmlElement`na to, czy są przypisane polymorphically czy nie.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-131">Do not attempt to use either of the serializers with types derived from `XmlElement`, whether they are assigned polymorphically or not.</span></span>  
  
### <a name="array-of-xmlnode"></a><span data-ttu-id="7f7a2-132">Tablica elementów XmlNode</span><span class="sxs-lookup"><span data-stu-id="7f7a2-132">Array of XmlNode</span></span>  
 <span data-ttu-id="7f7a2-133">Przy użyciu tablic <xref:System.Xml.XmlNode> jest bardzo podobne do `XmlElement`.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-133">Using arrays of <xref:System.Xml.XmlNode> is very similar to using `XmlElement`.</span></span> <span data-ttu-id="7f7a2-134">Przy użyciu tablic `XmlNode` zapewnia większą elastyczność niż przy użyciu `XmlElement`.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-134">Using arrays of `XmlNode` gives you more flexibility than using `XmlElement`.</span></span> <span data-ttu-id="7f7a2-135">Można napisać wiele elementów wewnątrz składowej danych, które zawijania elementu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-135">You can write multiple elements inside the data member wrapping element.</span></span> <span data-ttu-id="7f7a2-136">Może również wprowadzać zawartość inna niż elementy wewnątrz składowej danych, które zawijania elementu, takiego jak komentarze XML.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-136">You can also inject content other than elements inside of the data member wrapping element, such as XML comments.</span></span> <span data-ttu-id="7f7a2-137">Na koniec można umieścić atrybutów w opakowywania element członkowski danych.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-137">Finally, you can put attributes into the wrapping data member element.</span></span> <span data-ttu-id="7f7a2-138">Można to osiągnąć przez wypełnianie tablicy `XmlNode` z określonymi pochodne klasy `XmlNode` takich jak <xref:System.Xml.XmlAttribute>, `XmlElement` lub <xref:System.Xml.XmlComment>.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-138">All this can be achieved by populating the array of `XmlNode` with specific derived classes of `XmlNode` such as <xref:System.Xml.XmlAttribute>, `XmlElement` or <xref:System.Xml.XmlComment>.</span></span> <span data-ttu-id="7f7a2-139">Na przykład za pomocą następującego typu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-139">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#5)]
 [!code-vb[DataContractAttribute#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#5)]  
  
 <span data-ttu-id="7f7a2-140">Po serializacji, wynikowy kod XML jest podobny do następującego kodu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-140">When serialized, the resulting XML is similar to the following code.</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
  <myDataMember myAttribute="myValue">  
     <!--myComment-->  
     <myElement xmlns="" myAttribute="myValue">  
 myContents  
     </myElement>  
     <myElement xmlns="" myAttribute="myValue">  
       myContents  
     </myElement>  
  </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="7f7a2-141">Należy pamiętać, że element otoki element członkowski danych `<myDataMember>` zawiera atrybut, komentarz i dwa elementy.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-141">Note that the data member wrapper element `<myDataMember>` contains an attribute, a comment, and two elements.</span></span> <span data-ttu-id="7f7a2-142">Oto cztery `XmlNode` wystąpień, które są serializowane.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-142">These are the four `XmlNode` instances that were serialized.</span></span>  
  
 <span data-ttu-id="7f7a2-143">Tablica `XmlNode` skutkuje nieprawidłowy kod XML nie może być serializowany.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-143">An array of `XmlNode` that results in invalid XML cannot be serialized.</span></span> <span data-ttu-id="7f7a2-144">Na przykład tablica dwa `XmlNode` wystąpień, w którym pierwsza z nich jest `XmlElement` , a drugi jest <xref:System.Xml.XmlAttribute> jest nieprawidłowa, ponieważ ta sekwencja nie odpowiada dowolne prawidłowe wystąpienie XML (ma miejsce, nie można dołączyć atrybut do).</span><span class="sxs-lookup"><span data-stu-id="7f7a2-144">For example, an array of two `XmlNode` instances where the first one is an `XmlElement` and the second one is an <xref:System.Xml.XmlAttribute> is invalid, because this sequence does not correspond to any valid XML instance (there is no place to attach the attribute to).</span></span>  
  
 <span data-ttu-id="7f7a2-145">Na deserializacji tablicy `XmlNode`, węzły są tworzone i wypełniane informacjami z przychodzącego pliku XML.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-145">On deserialization of an array of `XmlNode`, nodes are created and populated with information from the incoming XML.</span></span> <span data-ttu-id="7f7a2-146">Prawidłowego elementu nadrzędnego <xref:System.Xml.XmlDocument> odbywa się przy deserializacji.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-146">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span> <span data-ttu-id="7f7a2-147">Wszystkie węzły są deserializacji, w tym wszelkie atrybuty na element członkowski danych otoki, ale z wyłączeniem atrybutów umieszczone w nim przez serializatory WCF (np. atrybuty, używany do wskazania polimorficznego przypisania).</span><span class="sxs-lookup"><span data-stu-id="7f7a2-147">All nodes are deserialized, including any attributes on the wrapper data member element, but excluding the attributes placed there by the WCF serializers (such as the attributes used to indicate polymorphic assignment).</span></span> <span data-ttu-id="7f7a2-148">Ostrzeżenie o definiowaniu wszystkie prefiksy przestrzeni nazw w XML fragment, który ma zastosowanie do deserializacji tablic `XmlNode` tak samo, jak robi deserializacji `XmlElement`.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-148">The caveat about defining all namespace prefixes in the XML fragment applies to the deserialization of arrays of `XmlNode` just like it does to deserializing `XmlElement`.</span></span>  
  
 <span data-ttu-id="7f7a2-149">Jeśli serializatory z zachowania wykresu obiektu włączona, równość obiektu tylko zostaną zachowane na poziom `XmlNode` tablic, nie do poszczególnych `XmlNode` wystąpień.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-149">When using the serializers with object graph preservation turned on, object equality is only preserved on the level of `XmlNode` arrays, not individual `XmlNode` instances.</span></span>  
  
 <span data-ttu-id="7f7a2-150">Nie należy podejmować próby serializacji tablicę `XmlNode` których co najmniej jeden z węzłów ustawiono `null`.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-150">Do not attempt to serialize an array of `XmlNode` where one or more of the nodes is set to `null`.</span></span> <span data-ttu-id="7f7a2-151">Jest dozwolona dla elementu całej tablicy, aby można `null`, ale nie dla każdej osoby `XmlNode` znajdujących się w tablicy.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-151">It is permitted for the entire array member to be `null`, but not for any individual `XmlNode` contained in the array.</span></span> <span data-ttu-id="7f7a2-152">Jeśli cały element członkowski ma wartość null, element członkowski danych otoki zawiera specjalne atrybut, który wskazuje, że ma wartość null.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-152">If the entire array member is null, the wrapper data member element contains a special attribute that indicates that it is null.</span></span> <span data-ttu-id="7f7a2-153">Na deserializacji elementu członkowskiego tablicy całego staje się również o wartości null.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-153">On deserialization, the entire array member also becomes null.</span></span>  
  
 <span data-ttu-id="7f7a2-154">Tylko regularnych tablic `XmlNode` są traktowane specjalnie przez element serializujący.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-154">Only regular arrays of `XmlNode` are treated specially by the serializer.</span></span> <span data-ttu-id="7f7a2-155">Elementy członkowskie danych zadeklarowany jako inne typy kolekcji, które zawierają `XmlNode`, lub elementy członkowskie danych zadeklarowany jako tablic typów pochodnych `XmlNode`, nie jest traktowany specjalnie.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-155">Data members declared as other collection types that contain `XmlNode`, or data members declared as arrays of types derived from `XmlNode`, are not treated specially.</span></span> <span data-ttu-id="7f7a2-156">W związku z tym nie są one zazwyczaj serializacji, chyba że one również spełniać jeden z innych kryteriów dla serializacji.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-156">Thus, they are normally not serializable unless they also meet one of the other criteria for serializing.</span></span>  
  
 <span data-ttu-id="7f7a2-157">Tablice lub kolekcji tablic `XmlNode` są dozwolone.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-157">Arrays or collections of arrays of `XmlNode` are allowed.</span></span> <span data-ttu-id="7f7a2-158">Istnieje element otoki dla całej kolekcji, a element otoki oddzielne (podobnie jak `<myDataMember>` w powyższym przykładzie) dla każdej macierzy z `XmlNode` zewnętrzne tablicy lub kolekcji.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-158">There is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each array of `XmlNode` in the outer array or collection.</span></span>  
  
 <span data-ttu-id="7f7a2-159">Wypełnianie składowej danych typu <xref:System.Array> z `Object` lub `Array` z `IEnumerable` z `XmlNode` wystąpień nie powoduje składowej danych, które są traktowane jako `Array` z `XmlNode` wystąpień.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-159">Populating a data member of type <xref:System.Array> of `Object` or `Array` of `IEnumerable` with `XmlNode` instances does not result in the data member being treated as an `Array` of `XmlNode` instances.</span></span> <span data-ttu-id="7f7a2-160">Każdego elementu członkowskiego tablicy jest serializowany oddzielnie.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-160">Each array member is serialized separately.</span></span>  
  
 <span data-ttu-id="7f7a2-161">Gdy jest używane z `DataContractSerializer`, tablice `XmlNode` można przypisać polymorphically, ale tylko do składowej danych typu `Object`.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-161">When used with the `DataContractSerializer`, arrays of `XmlNode` can be assigned polymorphically, but only to a data member of type `Object`.</span></span> <span data-ttu-id="7f7a2-162">Mimo że implementuje `IEnumerable`, tablicę `XmlNode` nie można używać jako typ kolekcji, a następnie można przypisać do `IEnumerable` element członkowski danych.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-162">Even though it implements `IEnumerable`, an array of `XmlNode` cannot be used as a collection type and be assigned to an `IEnumerable` data member.</span></span> <span data-ttu-id="7f7a2-163">Podobnie jak w przypadku wszystkich przypisań polimorficznych, `DataContractSerializer` emituje nazwie kontraktu danych w wynikowy kod XML — w tym przypadku jest "ArrayOfXmlNode" w "http://schemas.datacontract.org/2004/07/System.Xml" przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-163">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "ArrayOfXmlNode" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span> <span data-ttu-id="7f7a2-164">Gdy jest używane z `NetDataContractSerializer`, wszystkie prawidłowe przypisanie `XmlNode` tablica jest obsługiwana.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-164">When used with the `NetDataContractSerializer`, any valid assignment of an `XmlNode` array is supported.</span></span>  
  
### <a name="schema-considerations"></a><span data-ttu-id="7f7a2-165">Zagadnienia dotyczące schematu</span><span class="sxs-lookup"><span data-stu-id="7f7a2-165">Schema Considerations</span></span>  
 <span data-ttu-id="7f7a2-166">Aby uzyskać szczegółowe informacje dotyczące schematu mapowania typów danych XML, zobacz [odwołanie do schematu kontraktu danych](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="7f7a2-166">For details about the schema mapping of XML types, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span> <span data-ttu-id="7f7a2-167">Ta sekcja zawiera podsumowanie przedstawienie ważnych punktów.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-167">This section provides a summary of the important points.</span></span>  
  
 <span data-ttu-id="7f7a2-168">Element członkowski danych typu `XmlElement` jest mapowany na element zdefiniowane przy użyciu następującego typu anonimowego.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-168">A data member of type `XmlElement` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType>  
   <xsd:sequence>  
      <xsd:any minOccurs="0" processContents="lax" />  
   </xsd:sequence>  
</xsd:complexType>  
```  
  
 <span data-ttu-id="7f7a2-169">Element członkowski danych z typu tablicy `XmlNode` jest mapowany na element zdefiniowane przy użyciu następującego typu anonimowego.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-169">A data member of type Array of `XmlNode` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType mixed="true">  
   <xsd:sequence>  
      <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax" />  
   </xsd:sequence>  
   <xsd:anyAttribute/>  
</xsd:complexType>  
```  
  
## <a name="types-implementing-the-ixmlserializable-interface"></a><span data-ttu-id="7f7a2-170">Implementacja interfejsu IXmlSerializable typów</span><span class="sxs-lookup"><span data-stu-id="7f7a2-170">Types Implementing the IXmlSerializable Interface</span></span>  
 <span data-ttu-id="7f7a2-171">Typami, które implementują `IXmlSerializable` interfejsu są w pełni obsługiwane przez `DataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-171">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="7f7a2-172"><xref:System.Xml.Serialization.XmlSchemaProviderAttribute> Zawsze można zastosować atrybutu do tych typów w celu kontrolowania swoich schematu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-172">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>  
  
 <span data-ttu-id="7f7a2-173">Istnieją trzy różne typy typy, które implementują `IXmlSerializable`: typy, które reprezentują arbitralnie wybrane typy zawartości, reprezentujących pojedynczy element, a starsza wersja <xref:System.Data.DataSet> typów.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-173">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>  
  
- <span data-ttu-id="7f7a2-174">Typy zawartości, użyj metody dostawcy schemat określony przez `XmlSchemaProviderAttribute` atrybutu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-174">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="7f7a2-175">Metoda nie zwraca `null`i <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> właściwości w atrybucie pozostanie ustawiony na wartość domyślną `false`.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-175">The method does not return `null`, and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="7f7a2-176">Jest to najbardziej typowe użycie `IXmlSerializable` typów.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-176">This is the most common usage of `IXmlSerializable` types.</span></span>  
  
- <span data-ttu-id="7f7a2-177">Typy elementów są używane podczas `IXmlSerializable` typu musi kontrolować własną nazwą elementu głównego.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-177">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="7f7a2-178">Aby oznaczyć typu jako typu elementu, ustaw wartość <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> właściwość <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> atrybutu `true` lub zwróć wartość null przez metodę dostawcy schematu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-178">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return null from the schema provider method.</span></span> <span data-ttu-id="7f7a2-179">Posiadanie metody dostawcy schematu jest opcjonalne dla typów elementów — można określić wartość null zamiast nazwy metody w `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-179">Having a schema provider method is optional for element types – you may specify null instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="7f7a2-180">Jednak jeśli `IsAny` jest `true` i metody dostawcy schemat jest określony, metoda musi zwracać wartość null.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-180">However, if `IsAny` is `true` and a schema provider method is specified, the method must return null.</span></span>  
  
- <span data-ttu-id="7f7a2-181">Starsza wersja <xref:System.Data.DataSet> typy są `IXmlSerializable` typy, które nie są oznaczone przez `XmlSchemaProviderAttribute` atrybutu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-181">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="7f7a2-182">Zamiast tego opierają się na <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> metody do generowania schemat.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-182">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="7f7a2-183">Ten wzorzec jest używany dla `DataSet` typu i jego typizowany zestaw danych pochodzi z klasy we wcześniejszych wersjach programu .NET Framework, ale teraz jest przestarzały i nie jest obsługiwana tylko dla starszych powodów.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-183">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="7f7a2-184">Nie zależą od tego wzorca i zawsze stosuj `XmlSchemaProviderAttribute` do Twojej `IXmlSerializable` typów.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-184">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>  
  
### <a name="ixmlserializable-content-types"></a><span data-ttu-id="7f7a2-185">Typy zawartości IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="7f7a2-185">IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="7f7a2-186">Podczas serializacji typu, który implementuje element członkowski danych `IXmlSerializable` i typu zawartości jako zdefiniowano wcześniej, serializator zapisuje element otoki dla formantu elementu członkowskiego i przekazać dane do <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-186">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="7f7a2-187"><xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> Implementacji może zapisywać żadnych XML, w tym dodawania atrybutów do element otoki.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-187">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, including adding attributes to the wrapper element.</span></span> <span data-ttu-id="7f7a2-188">Po `WriteXml` jest wykonywane, serializator zamyka element.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-188">After `WriteXml` is done, the serializer closes the element.</span></span>  
  
 <span data-ttu-id="7f7a2-189">Podczas deserializacji składowej danych typu, który implementuje `IXmlSerializable` i typ zawartości zgodnie z definicją wcześniej pozycji Deserializator odczytującego XML na element otoki dla element członkowski danych i przekazać sterowanie do <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-189">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="7f7a2-190">Metoda musi odczytać cały element, w tym tagiem początkowym i końcowym.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-190">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="7f7a2-191">Upewnij się, że Twoje `ReadXml` kod obsługuje przypadek, w której element jest pusty.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-191">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="7f7a2-192">Ponadto usługi `ReadXml` wdrożenia nie należy polegać na element otoki jest o nazwie określony sposób.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-192">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="7f7a2-193">Nazwa jest wybierany przez serializator może się różnić.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-193">The name is chosen by the serializer can vary.</span></span>  
  
 <span data-ttu-id="7f7a2-194">Dopuszcza się przypisać `IXmlSerializable` zawartości typów polymorphically, na przykład, aby dane elementy członkowskie typu <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-194">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="7f7a2-195">Jest również dozwolony w przypadku wystąpień typu to null.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-195">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="7f7a2-196">Na koniec istnieje możliwość użycia `IXmlSerializable` typów z zachowania wykresu obiektu włączone i <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-196">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="7f7a2-197">Wszystkie te funkcje wymagają serializator WCF można dołączyć niektóre atrybuty do element otoki ("zero" i "type" w przestrzeni nazw z wystąpienia schematu XML i "Id", "Ref", "Type" i "Assembly" w przestrzeni nazw specyficzne dla programu WCF).</span><span class="sxs-lookup"><span data-stu-id="7f7a2-197">All these features require the WCF serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a WCF-specific namespace).</span></span>  
  
#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="7f7a2-198">Atrybuty do zignorowania podczas implementowania ReadXml</span><span class="sxs-lookup"><span data-stu-id="7f7a2-198">Attributes to Ignore when Implementing ReadXml</span></span>  
 <span data-ttu-id="7f7a2-199">Przed przekazaniem kontroli do Twojej `ReadXml` kod, Deserializator sprawdza, czy XML element, wykrywa te atrybuty specjalne XML i działa na nich.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-199">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="7f7a2-200">Na przykład, jeśli jest "zero" `true`, wartość null jest przeprowadzona i `ReadXml` nie zostanie wywołana.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-200">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="7f7a2-201">W przypadku wykrycia polimorfizm zawartość elementu są deserializacji, tak jakby znajdowała się innego typu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-201">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="7f7a2-202">Implementacja polymorphically przypisanego typu `ReadXml` jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-202">The polymorphically assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="7f7a2-203">W każdym przypadku `ReadXml` wdrożenia powinien ignorować te atrybuty specjalne, ponieważ są one obsługiwane przez deserializacji.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-203">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>  
  
### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="7f7a2-204">Zagadnienia schematu dla typów IXmlSerializable zawartości</span><span class="sxs-lookup"><span data-stu-id="7f7a2-204">Schema Considerations for IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="7f7a2-205">Podczas eksportowania schematu `IXmlSerializable` typ zawartości, wywoływana jest metoda dostawcy schematu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-205">When exporting schema an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="7f7a2-206"><xref:System.Xml.Schema.XmlSchemaSet> Jest przekazywany do metody dostawcy schematu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-206">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="7f7a2-207">Metoda można dodać żadnych prawidłowego schematu do zestawu schematów.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-207">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="7f7a2-208">Zestaw schematów zawiera schemat, który jest już znany w czasie, gdy wystąpi eksportu schematu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-208">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="7f7a2-209">Gdy metoda dostawcy schematu musi dodać element do zestawu schematów, musisz określić w przypadku <xref:System.Xml.Schema.XmlSchema> przy użyciu odpowiedniego obszaru nazw już istnieje w zestawie.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-209">When the schema provider method must add an item to the schema set, it must determine if an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="7f7a2-210">Jeśli tak jest, metody dostawcy schemat, należy dodać nowy element do istniejącej `XmlSchema`.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-210">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="7f7a2-211">W przeciwnym razie należy utworzyć nowy `XmlSchema` wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-211">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="7f7a2-212">Jest to ważne, jeśli tablice `IXmlSerializable` typów są używane.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-212">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="7f7a2-213">Na przykład, jeśli masz `IXmlSerializable` typ, który pobiera wyeksportowany jako typu "A" w przestrzeni nazw "B", możliwe, że do czasu, wywoływana jest metoda dostawcy schematu, schemat już skonfigurowane zawiera schemat "B" pomieścić typu "ArrayOfA".</span><span class="sxs-lookup"><span data-stu-id="7f7a2-213">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>  
  
 <span data-ttu-id="7f7a2-214">Oprócz dodawania typów <xref:System.Xml.Schema.XmlSchemaSet>, metodę dostawcy schematu dla typów zawartości musi zwracać wartość inną niż null.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-214">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="7f7a2-215">Może zwracać <xref:System.Xml.XmlQualifiedName> określający nazwę typu schematu do użycia dla danego `IXmlSerializable` typu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-215">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="7f7a2-216">Ta nazwa kwalifikowana służy również jako dane kontraktu nazwy i przestrzeni nazw dla typu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-216">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="7f7a2-217">Dozwolone jest zwracany typ, który nie istnieje w schemacie zestawu natychmiast, po powrocie z metody dostawcy schematu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-217">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="7f7a2-218">Jednak oczekuje się, że po czasie wszystkie powiązane typy są eksportowane ( <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> metoda jest wywoływana dla wszystkich odpowiednich typów w <xref:System.Runtime.Serialization.XsdDataContractExporter> i <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> dostępu do właściwości), typ istnieje w zestawie schematów.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-218">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="7f7a2-219">Uzyskiwanie dostępu do `Schemas` właściwości przed wszystkimi odpowiednimi `Export` wprowadzono wywołań może spowodować <xref:System.Xml.Schema.XmlSchemaException>.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-219">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> <span data-ttu-id="7f7a2-220">Aby uzyskać więcej informacji na temat procesu eksportu, zobacz [eksportowanie schematów z klas](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span><span class="sxs-lookup"><span data-stu-id="7f7a2-220">For more information about the export process, see [Exporting Schemas from Classes](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span></span>  
  
 <span data-ttu-id="7f7a2-221">Metoda dostawcy schemat może również zwracać <xref:System.Xml.Schema.XmlSchemaType> do użycia.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-221">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="7f7a2-222">Typ może być lub może nie być anonimowy.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-222">The type may or may not be anonymous.</span></span> <span data-ttu-id="7f7a2-223">Jeśli jest anonimowe, schemat `IXmlSerializable` typu jest eksportowana jako typ anonimowy w każdym `IXmlSerializable` typ jest używany jako element członkowski danych.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-223">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="7f7a2-224">`IXmlSerializable` Typu środki, nieopłacone nazwie kontraktu danych i przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-224">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="7f7a2-225">(To jest określana zgodnie z opisem w [nazwy kontraktów danych](../../../../docs/framework/wcf/feature-details/data-contract-names.md) z tą różnicą, że <xref:System.Runtime.Serialization.DataContractAttribute> atrybutu nie można dostosować nazwę.) Jeśli nie jest anonimowe, musi być jednym z typów w `XmlSchemaSet`.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-225">(This is determined as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="7f7a2-226">Ten przypadek jest odpowiednikiem zwracanie `XmlQualifiedName` tego typu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-226">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>  
  
 <span data-ttu-id="7f7a2-227">Ponadto deklaracji element globalny jest eksportowany dla typu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-227">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="7f7a2-228">Jeśli typ nie ma <xref:System.Xml.Serialization.XmlRootAttribute> zastosowany do niego element ma taką samą nazwę i obszaru nazw kontraktu danych, a jego właściwość "nillable" ma wartość true.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-228">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is true.</span></span> <span data-ttu-id="7f7a2-229">Jedynym wyjątkiem jest przestrzeń nazw schematu ("http://www.w3.org/2001/XMLSchema") — w przypadku typu kontraktu danych w tej przestrzeni nazw, odpowiedni element globalny jest w pustej przestrzeni nazw, ponieważ jest zabroniona Dodawanie nowych elementów do przestrzeni nazw schematu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-229">The only exception to this is the schema namespace ("http://www.w3.org/2001/XMLSchema") – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="7f7a2-230">Jeśli typ ma `XmlRootAttribute` zastosowany do jego deklaracji elementu globalnego jest eksportowana za pomocą następujących: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> i <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-230">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="7f7a2-231">Ustawienia domyślne przy użyciu `XmlRootAttribute` stosowane są nazwie kontraktu danych, pustą przestrzeń nazw i "nillable" o wartości true.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-231">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being true.</span></span>  
  
 <span data-ttu-id="7f7a2-232">Te same reguły element globalny w deklaracji mają zastosowanie do zestawu danych w starszej wersji typów.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-232">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="7f7a2-233">Należy pamiętać, że `XmlRootAttribute` nie może przesłonić element globalny deklaracje dodane poprzez kod niestandardowy być dodany do `XmlSchemaSet` przy użyciu metody dostawcy schematu lub za pomocą `GetSchema` dla typów starszej wersji zestawu danych.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-233">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>  
  
### <a name="ixmlserializable-element-types"></a><span data-ttu-id="7f7a2-234">Typy elementów interfejsu IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="7f7a2-234">IXmlSerializable Element Types</span></span>  
 <span data-ttu-id="7f7a2-235">`IXmlSerializable` typy elementów mieć `IsAny` właściwością `true` lub ich dostawcy schematu, metoda zwraca `null`.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-235">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>  
  
 <span data-ttu-id="7f7a2-236">Serializacja i deserializacja typ elementu jest bardzo podobny do serializacji i deserializacji typu zawartości.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-236">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="7f7a2-237">Jednak istnieją pewne ważne różnice:</span><span class="sxs-lookup"><span data-stu-id="7f7a2-237">However, there are some important differences:</span></span>  
  
- <span data-ttu-id="7f7a2-238">`WriteXml` Implementacji oczekuje się, można zapisać dokładnie jeden element (który z kolei może zawierać wiele elementów podrzędnych).</span><span class="sxs-lookup"><span data-stu-id="7f7a2-238">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="7f7a2-239">Nie powinien być wpisywanie atrybutów poza ten pojedynczy element wielu elementów równorzędnych lub zawartość mieszana.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-239">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="7f7a2-240">Element może być pusty.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-240">The element may be empty.</span></span>  
  
- <span data-ttu-id="7f7a2-241">`ReadXml` Implementacji element otoki nie powinny do odczytu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-241">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="7f7a2-242">Oczekuje się, aby przeczytać jeden element, `WriteXml` tworzy.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-242">It is expected to read the one element that `WriteXml` produces.</span></span>  
  
- <span data-ttu-id="7f7a2-243">Podczas serializacji typu elementu regularnie (na przykład, jako element członkowski danych w kontraktu danych), serializator danych wyjściowych element otoki przed wywołaniem `WriteXml`, podobnie jak w przypadku typów zawartości.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-243">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="7f7a2-244">Jednak podczas serializacji typu elementu na najwyższym poziomie, Serializator nie zwykle wyświetla element otoki w ogóle wokół elementu, `WriteXml` zapisuje, chyba że podczas tworzenia serializator jawnie określono nazwę główną i przestrzeni nazw w `DataContractSerializer` lub `NetDataContractSerializer` konstruktorów.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-244">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace were explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> <span data-ttu-id="7f7a2-245">Aby uzyskać więcej informacji, zobacz [serializacji i deserializacji](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="7f7a2-245">For more information, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span></span>  
  
- <span data-ttu-id="7f7a2-246">Podczas serializacji typu elementu na najwyższym poziomie bez określania nazwy głównej i przestrzeni nazw w czasie tworzenia <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> i <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> zasadniczo nic nie robi i <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> wywołania `WriteXml`.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-246">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially does nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="7f7a2-247">W tym trybie obiektu poddawanego serializacji nie może mieć wartości null i nie można przypisać polymorphically.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-247">In this mode, the object being serialized cannot be null and cannot be polymorphically assigned.</span></span> <span data-ttu-id="7f7a2-248">Ponadto nie można włączyć zachowania wykresu obiektu i `NetDataContractSerializer` nie mogą być używane.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-248">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>  
  
- <span data-ttu-id="7f7a2-249">Podczas deserializacji typ elementu na najwyższym poziomie bez określania nazwy głównej i przestrzeni nazw w czasie tworzenia <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> zwraca `true` jeśli znajdzie uruchamiania dowolnego elementu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-249">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="7f7a2-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> za pomocą `verifyObjectName` parametr `true` zachowuje się w taki sam sposób jak `IsStartObject` przed faktycznie odczytu obiektu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="7f7a2-251">`ReadObject` następnie przekazuje sterowanie do `ReadXml` metody.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-251">`ReadObject` then passes control to `ReadXml` method.</span></span>  
  
 <span data-ttu-id="7f7a2-252">Schemat eksportowany dla typów elementów jest taki sam, jak w przypadku `XmlElement` wpisz zgodnie z opisem w sekcji wcześniej, z tą różnicą, że metoda dostawcy schematu można dodać dodatkowe schematu w celu <xref:System.Xml.Schema.XmlSchemaSet> podobnie jak w przypadku typów zawartości.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-252">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="7f7a2-253">Za pomocą `XmlRootAttribute` atrybut z typami elementu nie jest dozwolony, a element globalny deklaracje nigdy nie są emitowane dla tych typów.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-253">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>  
  
### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="7f7a2-254">Różnice w stosunku do elementu XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="7f7a2-254">Differences from the XmlSerializer</span></span>  
 <span data-ttu-id="7f7a2-255">`IXmlSerializable` Interfejsu i `XmlSchemaProviderAttribute` i `XmlRootAttribute` atrybuty są także zrozumiałe <xref:System.Xml.Serialization.XmlSerializer> .</span><span class="sxs-lookup"><span data-stu-id="7f7a2-255">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="7f7a2-256">Jednak istnieją pewne różnice w jaki sposób są one traktowane w modelu kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-256">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="7f7a2-257">Istotne różnice przedstawiono poniżej:</span><span class="sxs-lookup"><span data-stu-id="7f7a2-257">The important differences are summarized in the following:</span></span>  
  
- <span data-ttu-id="7f7a2-258">Metody dostawcy schematu muszą być publiczne, może być używany w `XmlSerializer`, ale nie musi być publiczna może być używany w modelu kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-258">The schema provider method must be public to be usable in the `XmlSerializer`, but does not have to be public to be usable in the data contract model.</span></span>  
  
- <span data-ttu-id="7f7a2-259">Metoda dostawcy schematu jest wywoływana, gdy `IsAny` ma wartość true w modelu kontraktu danych, ale nie z `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-259">The schema provider method is called when `IsAny` is true in the data contract model but not with the `XmlSerializer`.</span></span>  
  
- <span data-ttu-id="7f7a2-260">Gdy `XmlRootAttribute` atrybut nie jest obecny do zawartości lub typy zestawów danych w starszej wersji, `XmlSerializer` eksportuje deklaracji element globalny w pustej przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-260">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="7f7a2-261">W modelu kontraktu danych przestrzeń nazw używaną zwykle jest przestrzeń nazw kontraktu danych, zgodnie z wcześniejszym opisem.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-261">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>  
  
 <span data-ttu-id="7f7a2-262">Należy pamiętać o tych różnic, podczas tworzenia typów, które są używane w obu technologii serializacji.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-262">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>  
  
### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="7f7a2-263">Importowanie schematu interfejsu IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="7f7a2-263">Importing IXmlSerializable Schema</span></span>  
 <span data-ttu-id="7f7a2-264">Podczas importowania schematu wygenerowany na podstawie `IXmlSerializable` typów, istnieje kilka możliwości:</span><span class="sxs-lookup"><span data-stu-id="7f7a2-264">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>  
  
- <span data-ttu-id="7f7a2-265">Wygenerowany schemat może być schematu kontraktu prawidłowych danych, zgodnie z opisem w [odwołanie do schematu kontraktu danych](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="7f7a2-265">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span> <span data-ttu-id="7f7a2-266">W takim przypadku schematu, które mogą być importowane w zwykły sposób, i są generowane typy kontraktu danych regularne.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-266">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>  
  
- <span data-ttu-id="7f7a2-267">Wygenerowany schemat może nie być poprawne dane schematu kontraktu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-267">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="7f7a2-268">Na przykład metoda dostawcy schematu może wygenerować schematu, która obejmuje atrybutów XML, które nie są obsługiwane w modelu kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-268">For example, your schema provider method may generate schema that involves XML attributes which are not supported in the data contract model.</span></span> <span data-ttu-id="7f7a2-269">W takim przypadku można zaimportować schematu jako `IXmlSerializable` typów.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-269">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="7f7a2-270">Domyślnie nie jest w ten tryb importu, ale można łatwo można włączyć — na przykład za pomocą `/importXmlTypes` przełącznik wiersza polecenia, aby [narzędzia narzędzie metadanych elementu ServiceModel (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span><span class="sxs-lookup"><span data-stu-id="7f7a2-270">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="7f7a2-271">Jest to opisane szczegółowo w temacie [Importowanie schematu do generowania klasy](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="7f7a2-271">This is described in detail in the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="7f7a2-272">Należy pamiętać, że należy skontaktować się bezpośrednio z pliku XML dla wystąpień typu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-272">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="7f7a2-273">Można także rozważyć użycie innej technologii serializacji, który obsługuje szerszy zakres schematów — zobacz temat w przy użyciu `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-273">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>  
  
- <span data-ttu-id="7f7a2-274">Może zajść potrzeba ponownego użycia istniejącej `IXmlSerializable` typów serwera proxy zamiast generować nową.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-274">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="7f7a2-275">W takim przypadku funkcja przywoływane typy opisana w schemacie importowanie do tematu wygenerować typy można wskazać typ do ponownego użycia.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-275">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="7f7a2-276">Odpowiada to użyciu `/reference` Włącz svcutil.exe, który określa zestaw, który zawiera typy do ponownego użycia.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-276">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>  
  
## <a name="representing-arbitrary-xml-in-data-contracts"></a><span data-ttu-id="7f7a2-277">Reprezentuje dowolny kod XML w kontraktach danych</span><span class="sxs-lookup"><span data-stu-id="7f7a2-277">Representing Arbitrary XML in Data Contracts</span></span>  
 <span data-ttu-id="7f7a2-278">`XmlElement`, Tablica `XmlNode` i `IXmlSerializable` typy pozwala na iniekcję dowolny kod XML do modelu kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-278">The `XmlElement`, Array of `XmlNode` and `IXmlSerializable` types allow you to inject arbitrary XML into the data contract model.</span></span> <span data-ttu-id="7f7a2-279">`DataContractSerializer` i `NetDataContractSerializer` przekazać plik XML zawartości do składnika zapisywania XML w użyciu, bez wywierania wpływu w procesie.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-279">The `DataContractSerializer` and `NetDataContractSerializer` pass this XML content on to the XML writer in use, without interfering in the process.</span></span> <span data-ttu-id="7f7a2-280">Jednak autorzy XML może wymuszać pewne ograniczenia dotyczące plik XML, który zapisują.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-280">However, the XML writers may enforce certain restrictions on the XML that they write.</span></span> <span data-ttu-id="7f7a2-281">Ściślej mówiąc poniżej przedstawiono kilka przykładów ważnych:</span><span class="sxs-lookup"><span data-stu-id="7f7a2-281">Specifically, here are some important examples:</span></span>  
  
- <span data-ttu-id="7f7a2-282">Autorzy XML zazwyczaj nie zezwala na deklaracji dokumentu XML (na przykład \<? wersji xml = "1.0'? >) w trakcie wpisywania innego dokumentu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-282">The XML writers do not typically allow an XML document declaration (for example, \<?xml version=’1.0’ ?>) in the middle of writing another document.</span></span> <span data-ttu-id="7f7a2-283">Nie można wykonać pełnego dokumentu XML i serializować go jako `Array` z `XmlNode` element członkowski danych.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-283">You cannot take a full XML document and serialize it as an `Array` of `XmlNode` data member.</span></span> <span data-ttu-id="7f7a2-284">Aby to zrobić, musisz albo usuń deklaracji dokumentu lub użyć schemat kodowania, aby oznaczyć go.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-284">To do this, you have to either strip out the document declaration or use your own encoding scheme to represent it.</span></span>  
  
- <span data-ttu-id="7f7a2-285">Odrzuć wszystkie moduły zapisujące XML dostarczone z programem WCF instrukcji przetwarzania XML (\<?</span><span class="sxs-lookup"><span data-stu-id="7f7a2-285">All of the XML writers supplied with WCF reject XML processing instructions (\<?</span></span> <span data-ttu-id="7f7a2-286">…</span><span class="sxs-lookup"><span data-stu-id="7f7a2-286">…</span></span> <span data-ttu-id="7f7a2-287">? >) i zarządzania dokumentami, definicje typów (\<!</span><span class="sxs-lookup"><span data-stu-id="7f7a2-287">?>) and document type definitions (\<!</span></span> <span data-ttu-id="7f7a2-288">…</span><span class="sxs-lookup"><span data-stu-id="7f7a2-288">…</span></span> <span data-ttu-id="7f7a2-289">>), ponieważ nie są dozwolone w komunikaty protokołu SOAP.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-289">>), because they are not allowed in SOAP messages.</span></span> <span data-ttu-id="7f7a2-290">Ponownie można użyć własnego mechanizmu kodowania, aby obejść to ograniczenie.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-290">Again, you can use your own encoding mechanism to get around this restriction.</span></span> <span data-ttu-id="7f7a2-291">Jeśli należy uwzględnić je w wynikowy kod XML, można napisać niestandardowego kodera, który używa autorzy XML, które je obsługują.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-291">If you must include these in your resultant XML, you can write a custom encoder that uses XML writers that support them.</span></span>  
  
- <span data-ttu-id="7f7a2-292">Podczas implementowania `WriteXml`, należy unikać wywoływania <xref:System.Xml.XmlWriter.WriteRaw%2A> metody edytora XML.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-292">When implementing `WriteXml`, avoid calling <xref:System.Xml.XmlWriter.WriteRaw%2A> method on the XML writer.</span></span> <span data-ttu-id="7f7a2-293">Usługi WCF używa różnych kodowań XML (w tym pliku binarnego), jest bardzo trudne lub niemożliwe do użycia `WriteRaw` taki sposób, że wynik nie będzie można używać w dowolnym kodowania.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-293">WCF uses a variety of XML encodings (including binary), it is very difficult or impossible to use `WriteRaw` such that the result is usable in any encoding.</span></span>  
  
- <span data-ttu-id="7f7a2-294">Podczas implementowania `WriteXml`, należy unikać <xref:System.Xml.XmlWriter.WriteEntityRef%2A> i <xref:System.Xml.XmlWriter.WriteNmToken%2A> metody, które nie są obsługiwane w autorzy XML dostarczone z programem WCF.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-294">When implementing `WriteXml`, avoid using the <xref:System.Xml.XmlWriter.WriteEntityRef%2A> and <xref:System.Xml.XmlWriter.WriteNmToken%2A> methods that are unsupported on the XML writers supplied with WCF.</span></span>  
  
## <a name="using-dataset-typed-dataset-and-datatable"></a><span data-ttu-id="7f7a2-295">Przy użyciu zestawu danych, Typizowany zestaw danych i elementu DataTable</span><span class="sxs-lookup"><span data-stu-id="7f7a2-295">Using DataSet, Typed DataSet and DataTable</span></span>  
 <span data-ttu-id="7f7a2-296">Używanie tych typów jest w pełni obsługiwany w modelu kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-296">Using these types is fully supported in the data contract model.</span></span> <span data-ttu-id="7f7a2-297">Korzystając z tych typów, należy wziąć pod uwagę następujące kwestie:</span><span class="sxs-lookup"><span data-stu-id="7f7a2-297">When using these types, consider the following points:</span></span>  
  
- <span data-ttu-id="7f7a2-298">Schemat dla tych typów (szczególnie <xref:System.Data.DataSet> i jego typizowanych klas pochodnych) może nie być współpracujący z niektórych platform innych niż WCF lub może spowodować niską użyteczności w przypadku korzystania z tych platform.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-298">The schema for these types (especially <xref:System.Data.DataSet> and its typed derived classes) may not be interoperable with some non-WCF platforms, or may result in poor usability when used with these platforms.</span></span> <span data-ttu-id="7f7a2-299">Ponadto za pomocą `DataSet` typ może mieć wpływ na wydajność.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-299">Additionally, using the `DataSet` type may have performance implications.</span></span> <span data-ttu-id="7f7a2-300">Na koniec go może utrudnić służących do wersji aplikacji w przyszłości.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-300">Finally, it may make it more difficult for you to version your application in the future.</span></span> <span data-ttu-id="7f7a2-301">Należy rozważyć użycie typy kontraktu danych jawnie zdefiniowanych zamiast `DataSet` typy w kontraktach usługi.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-301">Consider using explicitly defined data contract types instead of `DataSet` types in your contracts.</span></span>  
  
- <span data-ttu-id="7f7a2-302">Podczas importowania `DataSet` lub `DataTable` schematu, ważne jest, aby odwoływać się do tych typów.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-302">When importing `DataSet` or `DataTable` schema, it is important to reference these types.</span></span> <span data-ttu-id="7f7a2-303">Za pomocą narzędzia wiersza polecenia Svcutil.exe, można to osiągnąć przez przekazanie nazwy zestawu System.Data.dll, aby `/reference` przełącznika.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-303">With the Svcutil.exe command-line tool, this can be accomplished by passing the System.Data.dll assembly name to the `/reference` switch.</span></span> <span data-ttu-id="7f7a2-304">W przypadku importowania danych wpisywanych schematu musi odwoływać się typ typizowany zestaw danych.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-304">If importing typed dataset schema, you must reference the typed dataset’s type.</span></span> <span data-ttu-id="7f7a2-305">Za pomocą Svcutil.exe, przekazać lokalizację zestawu typizowany zestaw danych do `/reference` przełącznika.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-305">With Svcutil.exe, pass the location of the typed dataset’s assembly to the `/reference` switch.</span></span> <span data-ttu-id="7f7a2-306">Aby uzyskać więcej informacji na temat odwołujące się do typów, zobacz [Importowanie schematu do generowania klasy](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="7f7a2-306">For more information about referencing types, see the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span></span>  
  
 <span data-ttu-id="7f7a2-307">Obsługa typizowanych zestawów danych w modelu danych umowy jest ograniczona.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-307">Support for typed DataSets in the data contract model is limited.</span></span> <span data-ttu-id="7f7a2-308">Typizowanych zestawów danych może być serializowany i deserializować i wyeksportować ich schematu.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-308">Typed DataSets can be serialized and deserialized and can export their schema.</span></span> <span data-ttu-id="7f7a2-309">Jednak kontraktu danych, import schematu nie może wygenerować nowe wpisane typy zestawów danych ze schematu, jak tylko można użyć ponownie już istniejących.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-309">However, the Data Contract schema import is unable to generate new typed DataSet types from the schema, as it can only reuse existing ones.</span></span> <span data-ttu-id="7f7a2-310">Możesz wskazać istniejące typizowany zestaw danych za pomocą `/r` Włącz Svcutil.exe.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-310">You can point to an existing typed DataSet by using the `/r` switch on Svcutil.exe.</span></span> <span data-ttu-id="7f7a2-311">Jeśli spróbujesz użyć Svcutil.exe bez `/r` przełącznika od usługi, która używa typizowany zestaw danych, alternatywnych serializatora (XmlSerializer) to opcja wybrana automatycznie.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-311">If you attempt to use a Svcutil.exe without the `/r` switch on a service that uses a typed dataset, an alternative serializer (XmlSerializer) is automatically selected.</span></span> <span data-ttu-id="7f7a2-312">Jeśli należy użyć elementu DataContractSerializer, należy wygenerować zestawy danych ze schematu można użyć poniższej procedury: generowania typizowanych typy zestawów danych (za pomocą narzędzia Xsd.exe z `/d` przełączyć się na usługę), skompilować typów, a następnie wskaż je przy użyciu `/r` Włącz Svcutil.exe.</span><span class="sxs-lookup"><span data-stu-id="7f7a2-312">If you must use the DataContractSerializer and must generate DataSets from schema, you can use the following procedure: generate the typed DataSet types (by using the Xsd.exe tool with the `/d` switch on the service), compile the types, and then point to them using the `/r` switch on Svcutil.exe.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="7f7a2-313">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="7f7a2-313">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.Serialization.IXmlSerializable>
- [<span data-ttu-id="7f7a2-314">Używanie kontraktów danych</span><span class="sxs-lookup"><span data-stu-id="7f7a2-314">Using Data Contracts</span></span>](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)
- [<span data-ttu-id="7f7a2-315">Typy obsługiwane przez serializator kontraktu danych</span><span class="sxs-lookup"><span data-stu-id="7f7a2-315">Types Supported by the Data Contract Serializer</span></span>](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)
