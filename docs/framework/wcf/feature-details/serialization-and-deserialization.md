---
title: Serializacja i deserializacja
description: Dowiedz się więcej o aparacie serializacji WCF, który tłumaczy między obiektami .NET Framework i XML, w obu kierunkach.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 3d71814c-bda7-424b-85b7-15084ff9377a
ms.openlocfilehash: 3927c17a2548a094a63ffd95ff8a3701403de281
ms.sourcegitcommit: 358a28048f36a8dca39a9fe6e6ac1f1913acadd5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 06/23/2020
ms.locfileid: "85244910"
---
# <a name="serialization-and-deserialization"></a><span data-ttu-id="3ca94-103">Serializacja i deserializacja</span><span class="sxs-lookup"><span data-stu-id="3ca94-103">Serialization and Deserialization</span></span>
<span data-ttu-id="3ca94-104">Windows Communication Foundation (WCF) zawiera nowy aparat serializacji, <xref:System.Runtime.Serialization.DataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="3ca94-104">Windows Communication Foundation (WCF) includes a new serialization engine, the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="3ca94-105"><xref:System.Runtime.Serialization.DataContractSerializer>Tłumaczy między obiektami .NET Framework i XML, w obu kierunkach.</span><span class="sxs-lookup"><span data-stu-id="3ca94-105">The <xref:System.Runtime.Serialization.DataContractSerializer> translates between .NET Framework objects and XML, in both directions.</span></span> <span data-ttu-id="3ca94-106">W tym temacie wyjaśniono, jak działa serializator.</span><span class="sxs-lookup"><span data-stu-id="3ca94-106">This topic explains how the serializer works.</span></span>  
  
 <span data-ttu-id="3ca94-107">Podczas serializacji obiektów .NET Framework, serializator zrozumie różne modele programowania serializacji, łącznie z nowym modelem *kontraktu danych* .</span><span class="sxs-lookup"><span data-stu-id="3ca94-107">When serializing .NET Framework objects, the serializer understands a variety of serialization programming models, including the new *data contract* model.</span></span> <span data-ttu-id="3ca94-108">Aby uzyskać pełną listę obsługiwanych typów, zobacz [Typy obsługiwane przez serializator kontraktu danych](types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="3ca94-108">For a full list of supported types, see [Types Supported by the Data Contract Serializer](types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="3ca94-109">Aby zapoznać się z wprowadzeniem do kontraktów danych, zobacz [Korzystanie z kontraktów danych](using-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="3ca94-109">For an introduction to data contracts, see [Using Data Contracts](using-data-contracts.md).</span></span>  
  
 <span data-ttu-id="3ca94-110">Podczas deserializacji XML, serializator używa <xref:System.Xml.XmlReader> <xref:System.Xml.XmlWriter> klas i.</span><span class="sxs-lookup"><span data-stu-id="3ca94-110">When deserializing XML, the serializer uses the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes.</span></span> <span data-ttu-id="3ca94-111">Obsługuje ona również <xref:System.Xml.XmlDictionaryReader> klasy i, <xref:System.Xml.XmlDictionaryWriter> Aby umożliwić jej tworzenie ZOPTYMALIZOWANEGO kodu XML w niektórych przypadkach, na przykład przy użyciu binarnego formatu XML WCF.</span><span class="sxs-lookup"><span data-stu-id="3ca94-111">It also supports the <xref:System.Xml.XmlDictionaryReader> and <xref:System.Xml.XmlDictionaryWriter> classes to enable it to produce optimized XML in some cases, such as when using the WCF binary XML format.</span></span>  
  
 <span data-ttu-id="3ca94-112">WCF zawiera również serializator pomocnika, <xref:System.Runtime.Serialization.NetDataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="3ca94-112">WCF also includes a companion serializer, the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="3ca94-113"><xref:System.Runtime.Serialization.NetDataContractSerializer>Jest podobna do <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> i <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> serializatorów, ponieważ również emituje .NET Framework nazw typów w ramach serializowanych danych.</span><span class="sxs-lookup"><span data-stu-id="3ca94-113">The <xref:System.Runtime.Serialization.NetDataContractSerializer> is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> serializers because it also emits .NET Framework type names as part of the serialized data.</span></span> <span data-ttu-id="3ca94-114">Jest on używany, gdy te same typy są udostępniane na serializacji i zakończenia deserializacji.</span><span class="sxs-lookup"><span data-stu-id="3ca94-114">It is used when the same types are shared on the serializing and the deserializing ends.</span></span> <span data-ttu-id="3ca94-115">Zarówno, <xref:System.Runtime.Serialization.DataContractSerializer> jak i <xref:System.Runtime.Serialization.NetDataContractSerializer> pochodna z wspólnej klasy bazowej, <xref:System.Runtime.Serialization.XmlObjectSerializer> .</span><span class="sxs-lookup"><span data-stu-id="3ca94-115">Both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Runtime.Serialization.NetDataContractSerializer> derive from a common base class, the <xref:System.Runtime.Serialization.XmlObjectSerializer>.</span></span>  
  
> [!WARNING]
> <span data-ttu-id="3ca94-116"><xref:System.Runtime.Serialization.DataContractSerializer>Serializacji ciągów zawierających znaki kontrolne o wartości szesnastkowej poniżej 20 jako jednostki XML.</span><span class="sxs-lookup"><span data-stu-id="3ca94-116">The <xref:System.Runtime.Serialization.DataContractSerializer> serializes strings containing control characters with a hexadecimal value below 20 as XML entities.</span></span> <span data-ttu-id="3ca94-117">Może to spowodować problem z klientem innym niż WCF podczas wysyłania takich danych do usługi WCF.</span><span class="sxs-lookup"><span data-stu-id="3ca94-117">This may cause a problem with a non-WCF client when sending such data to a WCF service.</span></span>  
  
## <a name="creating-a-datacontractserializer-instance"></a><span data-ttu-id="3ca94-118">Tworzenie wystąpienia DataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="3ca94-118">Creating a DataContractSerializer Instance</span></span>  
 <span data-ttu-id="3ca94-119">Konstruowanie wystąpienia <xref:System.Runtime.Serialization.DataContractSerializer> jest ważnym krokiem.</span><span class="sxs-lookup"><span data-stu-id="3ca94-119">Constructing an instance of the <xref:System.Runtime.Serialization.DataContractSerializer> is an important step.</span></span> <span data-ttu-id="3ca94-120">Po przygotowaniu nie można zmienić żadnych ustawień.</span><span class="sxs-lookup"><span data-stu-id="3ca94-120">After construction, you cannot change any of the settings.</span></span>  
  
### <a name="specifying-the-root-type"></a><span data-ttu-id="3ca94-121">Określanie typu głównego</span><span class="sxs-lookup"><span data-stu-id="3ca94-121">Specifying the Root Type</span></span>  
 <span data-ttu-id="3ca94-122">*Typ główny* to typ, z którego wystąpienia są serializowane lub deserializowane.</span><span class="sxs-lookup"><span data-stu-id="3ca94-122">The *root type* is the type of which instances are serialized or deserialized.</span></span> <span data-ttu-id="3ca94-123"><xref:System.Runtime.Serialization.DataContractSerializer>Ma wiele przeciążeń konstruktora, ale co najmniej musi być dostarczony typ główny przy użyciu `type` parametru.</span><span class="sxs-lookup"><span data-stu-id="3ca94-123">The <xref:System.Runtime.Serialization.DataContractSerializer> has many constructor overloads, but, at a minimum, a root type must be supplied using the `type` parameter.</span></span>  
  
 <span data-ttu-id="3ca94-124">Serializator utworzony dla określonego typu głównego nie może zostać użyty do serializacji (lub deserializacji) innego typu, chyba że typ pochodzi od typu głównego.</span><span class="sxs-lookup"><span data-stu-id="3ca94-124">A serializer created for a certain root type cannot be used to serialize (or deserialize) another type, unless the type is derived from the root type.</span></span> <span data-ttu-id="3ca94-125">Poniższy przykład przedstawia dwie klasy.</span><span class="sxs-lookup"><span data-stu-id="3ca94-125">The following example shows two classes.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#1)]
 [!code-vb[c_StandaloneDataContractSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#1)]  
  
 <span data-ttu-id="3ca94-126">Ten kod tworzy wystąpienie `DataContractSerializer` , które może być używane tylko do serializacji lub deserializacji wystąpień `Person` klasy.</span><span class="sxs-lookup"><span data-stu-id="3ca94-126">This code constructs an instance of the `DataContractSerializer` that can be used only to serialize or deserialize instances of the `Person` class.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#2)]
 [!code-vb[c_StandaloneDataContractSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#2)]  
  
### <a name="specifying-known-types"></a><span data-ttu-id="3ca94-127">Określanie znanych typów</span><span class="sxs-lookup"><span data-stu-id="3ca94-127">Specifying Known Types</span></span>  
 <span data-ttu-id="3ca94-128">Jeśli polimorfizm jest uwzględniany w serializowanych typach, które nie zostały jeszcze obsłużone przy użyciu <xref:System.Runtime.Serialization.KnownTypeAttribute> atrybutu lub innego mechanizmu, lista możliwych znanych typów musi zostać przeniesiona do konstruktora serializatora przy użyciu `knownTypes` parametru.</span><span class="sxs-lookup"><span data-stu-id="3ca94-128">If polymorphism is involved in the types being serialized that is not already handled using the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute or some other mechanism, a list of possible known types must be passed to the serializer’s constructor using the `knownTypes` parameter.</span></span> <span data-ttu-id="3ca94-129">Aby uzyskać więcej informacji na temat znanych typów, zobacz [znane typy kontraktu danych](data-contract-known-types.md).</span><span class="sxs-lookup"><span data-stu-id="3ca94-129">For more information about known types, see [Data Contract Known Types](data-contract-known-types.md).</span></span>  
  
 <span data-ttu-id="3ca94-130">Poniższy przykład pokazuje klasę, `LibraryPatron` , która zawiera kolekcję określonego typu, `LibraryItem` .</span><span class="sxs-lookup"><span data-stu-id="3ca94-130">The following example shows a class, `LibraryPatron`, that includes a collection of a specific type, the `LibraryItem`.</span></span> <span data-ttu-id="3ca94-131">Druga klasa definiuje `LibraryItem` Typ.</span><span class="sxs-lookup"><span data-stu-id="3ca94-131">The second class defines the `LibraryItem` type.</span></span> <span data-ttu-id="3ca94-132">Trzecia i cztery klasy ( `Book` i `Newspaper` ) dziedziczą z `LibraryItem` klasy.</span><span class="sxs-lookup"><span data-stu-id="3ca94-132">The third and four classes (`Book` and `Newspaper`) inherit from the `LibraryItem` class.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#3)]  
 [!code-vb[c_StandaloneDataContractSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#3)]  
  
 <span data-ttu-id="3ca94-133">Poniższy kod tworzy wystąpienie serializatora przy użyciu `knownTypes` parametru.</span><span class="sxs-lookup"><span data-stu-id="3ca94-133">The following code constructs an instance of the serializer using the `knownTypes` parameter.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#4)]
 [!code-vb[c_StandaloneDataContractSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#4)]  
  
### <a name="specifying-the-default-root-name-and-namespace"></a><span data-ttu-id="3ca94-134">Określanie domyślnej nazwy głównej i przestrzeni nazw</span><span class="sxs-lookup"><span data-stu-id="3ca94-134">Specifying the Default Root Name and Namespace</span></span>  
 <span data-ttu-id="3ca94-135">Zwykle gdy obiekt jest serializowany, domyślna nazwa i przestrzeń nazw zewnętrznego elementu XML są określane zgodnie z nazwą kontraktu danych i przestrzenią nazw.</span><span class="sxs-lookup"><span data-stu-id="3ca94-135">Normally, when an object is serialized, the default name and namespace of the outermost XML element are determined according to the data contract name and namespace.</span></span> <span data-ttu-id="3ca94-136">Nazwy wszystkich elementów wewnętrznych są określane na podstawie nazw składowych danych, a ich przestrzeń nazw jest przestrzenią nazw kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="3ca94-136">The names of all inner elements are determined from data member names, and their namespace is the data contract’s namespace.</span></span> <span data-ttu-id="3ca94-137">Poniższe przykładowe zestawy `Name` i `Namespace` wartości w konstruktorach <xref:System.Runtime.Serialization.DataContractAttribute> <xref:System.Runtime.Serialization.DataMemberAttribute> klas i.</span><span class="sxs-lookup"><span data-stu-id="3ca94-137">The following example sets `Name` and `Namespace` values in the constructors of the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute> classes.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#5)]
 [!code-vb[c_StandaloneDataContractSerializer#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#5)]  
  
 <span data-ttu-id="3ca94-138">Serializacja wystąpienia `Person` klasy powoduje, że kod XML jest podobny do poniższego.</span><span class="sxs-lookup"><span data-stu-id="3ca94-138">Serializing an instance of the `Person` class produces XML similar to the following.</span></span>  
  
```xml  
<PersonContract xmlns="http://schemas.contoso.com">  
  <AddressMember>  
    <StreetMember>123 Main Street</StreetMember>  
   </AddressMember>  
</PersonContract>  
```  
  
 <span data-ttu-id="3ca94-139">Można jednak dostosować domyślną nazwę i przestrzeń nazw elementu głównego, przekazując wartości `rootName` i `rootNamespace` parametrów do <xref:System.Runtime.Serialization.DataContractSerializer> konstruktora.</span><span class="sxs-lookup"><span data-stu-id="3ca94-139">However, you can customize the default name and namespace of the root element by passing the values of the `rootName` and `rootNamespace` parameters to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor.</span></span> <span data-ttu-id="3ca94-140">Należy zauważyć, że nie `rootNamespace` ma to wpływu na przestrzeń nazw zawartych elementów, które odpowiadają elementom członkowskim danych.</span><span class="sxs-lookup"><span data-stu-id="3ca94-140">Note that the `rootNamespace` does not affect the namespace of the contained elements that correspond to data members.</span></span> <span data-ttu-id="3ca94-141">Dotyczy tylko przestrzeni nazw zewnętrznego elementu.</span><span class="sxs-lookup"><span data-stu-id="3ca94-141">It affects only the namespace of the outermost element.</span></span>  
  
 <span data-ttu-id="3ca94-142">Te wartości mogą być przesyłane jako ciągi lub wystąpienia <xref:System.Xml.XmlDictionaryString> klasy w celu umożliwienia optymalizacji przy użyciu binarnego formatu XML.</span><span class="sxs-lookup"><span data-stu-id="3ca94-142">These values can be passed as strings or instances of the <xref:System.Xml.XmlDictionaryString> class to allow for their optimization using the binary XML format.</span></span>  
  
### <a name="setting-the-maximum-objects-quota"></a><span data-ttu-id="3ca94-143">Ustawianie maksymalnego limitu przydziału obiektów</span><span class="sxs-lookup"><span data-stu-id="3ca94-143">Setting the Maximum Objects Quota</span></span>  
 <span data-ttu-id="3ca94-144">Niektóre `DataContractSerializer` przeciążenia konstruktora mają `maxItemsInObjectGraph` parametr.</span><span class="sxs-lookup"><span data-stu-id="3ca94-144">Some `DataContractSerializer` constructor overloads have a `maxItemsInObjectGraph` parameter.</span></span> <span data-ttu-id="3ca94-145">Ten parametr określa maksymalną liczbę obiektów serializowanych lub deserializacji serializatora w jednym <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> wywołaniu metody.</span><span class="sxs-lookup"><span data-stu-id="3ca94-145">This parameter determines the maximum number of objects the serializer serializes or deserializes in a single <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method call.</span></span> <span data-ttu-id="3ca94-146">(Metoda zawsze odczytuje jeden obiekt główny, ale ten obiekt może mieć inne obiekty w jego składowych danych.</span><span class="sxs-lookup"><span data-stu-id="3ca94-146">(The method always reads one root object, but this object may have other objects in its data members.</span></span> <span data-ttu-id="3ca94-147">Obiekty te mogą mieć inne obiekty itd.) Wartość domyślna to 65536.</span><span class="sxs-lookup"><span data-stu-id="3ca94-147">Those objects may have other objects, and so on.) The default is 65536.</span></span> <span data-ttu-id="3ca94-148">Należy pamiętać, że podczas serializacji lub deserializacji tablic każda pozycja tablicy jest traktowana jako oddzielny obiekt.</span><span class="sxs-lookup"><span data-stu-id="3ca94-148">Note that when serializing or deserializing arrays, every array entry counts as a separate object.</span></span> <span data-ttu-id="3ca94-149">Należy również pamiętać, że niektóre obiekty mogą mieć znaczną reprezentację pamięci, więc ten limit przydziału może być niewystarczający, aby zapobiec atakom typu "odmowa usługi".</span><span class="sxs-lookup"><span data-stu-id="3ca94-149">Also, note that some objects may have a large memory representation, and so this quota alone may not be sufficient to prevent a denial of service attack.</span></span> <span data-ttu-id="3ca94-150">Aby uzyskać więcej informacji, zobacz [zagadnienia dotyczące zabezpieczeń danych](security-considerations-for-data.md).</span><span class="sxs-lookup"><span data-stu-id="3ca94-150">For more information, see [Security Considerations for Data](security-considerations-for-data.md).</span></span> <span data-ttu-id="3ca94-151">Jeśli trzeba zwiększyć ten limit przydziału poza wartością domyślną, należy to zrobić zarówno w przypadku wysyłania (serializacji), jak i otrzymywania (deserializacji) stron, ponieważ odnosi się zarówno do odczytu i zapisu danych.</span><span class="sxs-lookup"><span data-stu-id="3ca94-151">If you need to increase this quota beyond the default value, it is important to do so both on the sending (serializing) and receiving (deserializing) sides because it applies to both when reading and writing data.</span></span>  
  
### <a name="round-trips"></a><span data-ttu-id="3ca94-152">Okrągłe podróże</span><span class="sxs-lookup"><span data-stu-id="3ca94-152">Round Trips</span></span>  
 <span data-ttu-id="3ca94-153">Gdy obiekt jest deserializowany i ponownie serializowany w jednej operacji, występuje *runda* .</span><span class="sxs-lookup"><span data-stu-id="3ca94-153">A *round trip* occurs when an object is deserialized and re-serialized in one operation.</span></span> <span data-ttu-id="3ca94-154">W tym celu pochodzi z pliku XML do wystąpienia obiektu i ponownie w strumieniu XML.</span><span class="sxs-lookup"><span data-stu-id="3ca94-154">Thus, it goes from XML to an object instance, and back again into an XML stream.</span></span>  
  
 <span data-ttu-id="3ca94-155">Niektóre `DataContractSerializer` przeciążenia konstruktora mają `ignoreExtensionDataObject` parametr, który jest domyślnie ustawiony na wartość `false` .</span><span class="sxs-lookup"><span data-stu-id="3ca94-155">Some `DataContractSerializer` constructor overloads have an `ignoreExtensionDataObject` parameter, which is set to `false` by default.</span></span> <span data-ttu-id="3ca94-156">W tym trybie domyślnym dane mogą być wysyłane w formie rundy z nowszej wersji kontraktu danych za pośrednictwem starszej wersji i z powrotem do nowszej wersji bez utraty, o ile kontrakt danych implementuje <xref:System.Runtime.Serialization.IExtensibleDataObject> interfejs.</span><span class="sxs-lookup"><span data-stu-id="3ca94-156">In this default mode, data can be sent on a round trip from a newer version of a data contract through an older version and back to the newer version without loss, as long as the data contract implements the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="3ca94-157">Na przykład załóżmy, że wersja 1 `Person` kontraktu danych zawiera `Name` elementy członkowskie danych i `PhoneNumber` , a wersja 2 dodaje `Nickname` element członkowski.</span><span class="sxs-lookup"><span data-stu-id="3ca94-157">For example, suppose version 1 of the `Person` data contract contains the `Name` and `PhoneNumber` data members, and version 2 adds a `Nickname` member.</span></span> <span data-ttu-id="3ca94-158">Jeśli `IExtensibleDataObject` jest zaimplementowany, podczas wysyłania informacji z wersji 2 do wersji 1 `Nickname` dane są przechowywane, a następnie ponownie emitowane po ponownym serializacji danych; w związku z tym żadne dane nie zostaną utracone podczas rundy.</span><span class="sxs-lookup"><span data-stu-id="3ca94-158">If `IExtensibleDataObject` is implemented, when sending information from version 2 to version 1, the `Nickname` data is stored, and then re-emitted when the data is serialized again; therefore, no data is lost in the round trip.</span></span> <span data-ttu-id="3ca94-159">Aby uzyskać więcej informacji, zobacz [Kontrakty danych zgodne z przekazaniem](forward-compatible-data-contracts.md) i [przechowywanie wersji kontraktu danych](data-contract-versioning.md).</span><span class="sxs-lookup"><span data-stu-id="3ca94-159">For more information, see [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md) and [Data Contract Versioning](data-contract-versioning.md).</span></span>  
  
#### <a name="security-and-schema-validity-concerns-with-round-trips"></a><span data-ttu-id="3ca94-160">Zagadnienia dotyczące zabezpieczeń i schematów w przypadku rundy</span><span class="sxs-lookup"><span data-stu-id="3ca94-160">Security and Schema Validity Concerns with Round Trips</span></span>  
 <span data-ttu-id="3ca94-161">Obie podróże mogą mieć wpływ na bezpieczeństwo.</span><span class="sxs-lookup"><span data-stu-id="3ca94-161">Round trips may have security implications.</span></span> <span data-ttu-id="3ca94-162">Na przykład deserializacja i przechowywanie dużych ilości danych obcych może stanowić zagrożenie bezpieczeństwa.</span><span class="sxs-lookup"><span data-stu-id="3ca94-162">For example, deserializing and storing large amounts of extraneous data may be a security risk.</span></span> <span data-ttu-id="3ca94-163">Mogą wystąpić problemy z bezpieczeństwem dotyczące ponownego emitowania tych danych, które nie mają możliwości sprawdzenia, szczególnie jeśli są używane podpisy cyfrowe.</span><span class="sxs-lookup"><span data-stu-id="3ca94-163">There may be security concerns about re-emitting this data that there is no way to verify, especially if digital signatures are involved.</span></span> <span data-ttu-id="3ca94-164">Na przykład w poprzednim scenariuszu punkt końcowy w wersji 1 może podpisywać `Nickname` wartość, która zawiera złośliwe dane.</span><span class="sxs-lookup"><span data-stu-id="3ca94-164">For example, in the previous scenario, the version 1 endpoint could be signing a `Nickname` value that contains malicious data.</span></span> <span data-ttu-id="3ca94-165">Na koniec mogą wystąpić problemy z ważnością schematu: punkt końcowy może chcieć, aby zawsze emitować dane, które są ściśle zgodne z podaną umową, a nie z żadnymi dodatkowymi wartościami.</span><span class="sxs-lookup"><span data-stu-id="3ca94-165">Finally, there may be schema validity concerns: an endpoint may want to always emit data that strictly adheres to its stated contract and not any extra values.</span></span> <span data-ttu-id="3ca94-166">W poprzednim przykładzie kontrakt punktu końcowego w wersji 1 wydaje się, że emituje tylko `Name` i `PhoneNumber` i jeśli jest używana Walidacja schematu, emitowanie dodatkowej `Nickname` wartości powoduje niepowodzenie walidacji.</span><span class="sxs-lookup"><span data-stu-id="3ca94-166">In the previous example, the version 1 endpoint’s contract says that it emits only `Name` and `PhoneNumber`, and if schema validation is being used, emitting the extra `Nickname` value causes validation to fail.</span></span>  
  
#### <a name="enabling-and-disabling-round-trips"></a><span data-ttu-id="3ca94-167">Włączanie i wyłączanie rundy</span><span class="sxs-lookup"><span data-stu-id="3ca94-167">Enabling and Disabling Round Trips</span></span>  
 <span data-ttu-id="3ca94-168">Aby wyłączyć funkcję błądzenia, nie należy implementować <xref:System.Runtime.Serialization.IExtensibleDataObject> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="3ca94-168">To turn off round trips, do not implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="3ca94-169">Jeśli nie masz kontroli nad typami, ustaw parametr tak, aby `ignoreExtensionDataObject` `true` osiągnąć ten sam efekt.</span><span class="sxs-lookup"><span data-stu-id="3ca94-169">If you have no control over the types, set the `ignoreExtensionDataObject` parameter to `true` to achieve the same effect.</span></span>  
  
### <a name="object-graph-preservation"></a><span data-ttu-id="3ca94-170">Zachowywanie wykresu obiektów</span><span class="sxs-lookup"><span data-stu-id="3ca94-170">Object Graph Preservation</span></span>  
 <span data-ttu-id="3ca94-171">Zwykle serializator nie dba o tożsamość obiektu, jak w poniższym kodzie.</span><span class="sxs-lookup"><span data-stu-id="3ca94-171">Normally, the serializer does not care about object identity, as in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#6)]
 [!code-vb[c_StandaloneDataContractSerializer#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#6)]  
  
 <span data-ttu-id="3ca94-172">Poniższy kod tworzy zamówienie zakupu.</span><span class="sxs-lookup"><span data-stu-id="3ca94-172">The following code creates a purchase order.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#7)]
 [!code-vb[c_StandaloneDataContractSerializer#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#7)]  
  
 <span data-ttu-id="3ca94-173">Należy zauważyć, że `billTo` i `shipTo` pola są ustawione na to samo wystąpienie obiektu.</span><span class="sxs-lookup"><span data-stu-id="3ca94-173">Notice that `billTo` and `shipTo` fields are set to the same object instance.</span></span> <span data-ttu-id="3ca94-174">Jednak wygenerowany kod XML duplikuje informacje zduplikowane i wygląda podobnie do poniższego kodu XML.</span><span class="sxs-lookup"><span data-stu-id="3ca94-174">However, the generated XML duplicates the information duplicated, and looks similar to the following XML.</span></span>  
  
```xml  
<PurchaseOrder>  
  <billTo><street>123 Main St.</street></billTo>  
  <shipTo><street>123 Main St.</street></shipTo>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="3ca94-175">Jednak takie podejście ma następujące cechy, które mogą być niepożądane:</span><span class="sxs-lookup"><span data-stu-id="3ca94-175">However, this approach has the following characteristics, which may be undesirable:</span></span>  
  
- <span data-ttu-id="3ca94-176">Wydajność.</span><span class="sxs-lookup"><span data-stu-id="3ca94-176">Performance.</span></span> <span data-ttu-id="3ca94-177">Replikowanie danych jest niewydajne.</span><span class="sxs-lookup"><span data-stu-id="3ca94-177">Replicating data is inefficient.</span></span>  
  
- <span data-ttu-id="3ca94-178">Odwołania cykliczne.</span><span class="sxs-lookup"><span data-stu-id="3ca94-178">Circular references.</span></span> <span data-ttu-id="3ca94-179">Jeśli obiekty odnoszą się do siebie, nawet za pomocą innych obiektów, serializacja przez replikację powoduje nieskończoną pętlę.</span><span class="sxs-lookup"><span data-stu-id="3ca94-179">If objects refer to themselves, even through other objects, serializing by replication results in an infinite loop.</span></span> <span data-ttu-id="3ca94-180">(Serializator zgłasza, <xref:System.Runtime.Serialization.SerializationException> Jeśli taka sytuacja występuje).</span><span class="sxs-lookup"><span data-stu-id="3ca94-180">(The serializer throws a <xref:System.Runtime.Serialization.SerializationException> if this happens.)</span></span>  
  
- <span data-ttu-id="3ca94-181">Semantyki.</span><span class="sxs-lookup"><span data-stu-id="3ca94-181">Semantics.</span></span> <span data-ttu-id="3ca94-182">Czasami ważne jest, aby zachować fakt, że dwa odwołania są do tego samego obiektu, a nie do dwóch identycznych obiektów.</span><span class="sxs-lookup"><span data-stu-id="3ca94-182">Sometimes it is important to preserve the fact that two references are to the same object, and not to two identical objects.</span></span>  
  
 <span data-ttu-id="3ca94-183">Z tego względu niektóre `DataContractSerializer` przeciążenia konstruktora mają `preserveObjectReferences` parametr (wartość domyślna to `false` ).</span><span class="sxs-lookup"><span data-stu-id="3ca94-183">For these reasons, some `DataContractSerializer` constructor overloads have a `preserveObjectReferences` parameter (the default is `false`).</span></span> <span data-ttu-id="3ca94-184">Gdy ten parametr jest ustawiony na `true` , jest to specjalna metoda kodowania odwołań do obiektów, która jest używana tylko przez program WCF.</span><span class="sxs-lookup"><span data-stu-id="3ca94-184">When this parameter is set to `true`, a special method of encoding object references, which only WCF understands, is used.</span></span> <span data-ttu-id="3ca94-185">Po ustawieniu na `true` , przykładowy kod XML jest teraz podobny do poniższego.</span><span class="sxs-lookup"><span data-stu-id="3ca94-185">When set to `true`, the XML code example now resembles the following.</span></span>  
  
```xml  
<PurchaseOrder ser:id="1">  
  <billTo ser:id="2"><street ser:id="3">123 Main St.</street></billTo>  
  <shipTo ser:ref="2"/>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="3ca94-186">Przestrzeń nazw "ser" odwołuje się do przestrzeni nazw serializacji standardowej, `http://schemas.microsoft.com/2003/10/Serialization/` .</span><span class="sxs-lookup"><span data-stu-id="3ca94-186">The "ser" namespace refers to the standard serialization namespace, `http://schemas.microsoft.com/2003/10/Serialization/`.</span></span> <span data-ttu-id="3ca94-187">Każdy element danych jest serializowany tylko raz i ma określony numer IDENTYFIKACYJNy, a kolejne użycie powoduje odwołanie do już zserializowanych danych.</span><span class="sxs-lookup"><span data-stu-id="3ca94-187">Each piece of data is serialized only once and given an ID number, and subsequent uses result in a reference to the already serialized data.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="3ca94-188">Jeśli w kontrakcie danych są obecne atrybuty "ID" i "ref" `XMLElement` , atrybut "ref" jest uznawany, a atrybut "ID" jest ignorowany.</span><span class="sxs-lookup"><span data-stu-id="3ca94-188">If both "id" and "ref" attributes are present in the data contract `XMLElement`, then the "ref" attribute is honored and the "id" attribute is ignored.</span></span>  
  
 <span data-ttu-id="3ca94-189">Ważne jest zrozumienie ograniczeń tego trybu:</span><span class="sxs-lookup"><span data-stu-id="3ca94-189">It is important to understand the limitations of this mode:</span></span>  
  
- <span data-ttu-id="3ca94-190">KOD XML `DataContractSerializer` tworzony z `preserveObjectReferences` ustawioną na `true` nie jest współdziałany z innymi technologiami i można uzyskać do niego dostęp tylko przy użyciu innego `DataContractSerializer` wystąpienia, a także `preserveObjectReferences` ustawić wartość `true` .</span><span class="sxs-lookup"><span data-stu-id="3ca94-190">The XML the `DataContractSerializer` produces with `preserveObjectReferences` set to `true` is not interoperable with any other technologies, and can be accessed only by another `DataContractSerializer` instance, also with `preserveObjectReferences` set to `true`.</span></span>  
  
- <span data-ttu-id="3ca94-191">Brak obsługi metadanych (schematu) dla tej funkcji.</span><span class="sxs-lookup"><span data-stu-id="3ca94-191">There is no metadata (schema) support for this feature.</span></span> <span data-ttu-id="3ca94-192">Tworzony schemat jest prawidłowy tylko dla przypadku, gdy `preserveObjectReferences` jest ustawiony na `false` .</span><span class="sxs-lookup"><span data-stu-id="3ca94-192">The schema that is produced is valid only for the case when `preserveObjectReferences` is set to `false`.</span></span>  
  
- <span data-ttu-id="3ca94-193">Ta funkcja może spowodować wolniejsze działanie serializacji i deserializacji.</span><span class="sxs-lookup"><span data-stu-id="3ca94-193">This feature may cause the serialization and deserialization process to run slower.</span></span> <span data-ttu-id="3ca94-194">Chociaż dane nie muszą być replikowane, w tym trybie należy wykonać dodatkowe porównania obiektów.</span><span class="sxs-lookup"><span data-stu-id="3ca94-194">Although data does not have to be replicated, extra object comparisons must be performed in this mode.</span></span>  
  
> [!CAUTION]
> <span data-ttu-id="3ca94-195">Gdy `preserveObjectReferences` tryb jest włączony, jest szczególnie ważne, aby ustawić wartość w `maxItemsInObjectGraph` prawidłowym limicie przydziału.</span><span class="sxs-lookup"><span data-stu-id="3ca94-195">When the `preserveObjectReferences` mode is enabled, it is especially important to set the `maxItemsInObjectGraph` value to the correct quota.</span></span> <span data-ttu-id="3ca94-196">Ze względu na sposób obsługi tablic w tym trybie, osoba atakująca może łatwo utworzyć małą złośliwą wiadomość, która powoduje, że duże użycie pamięci jest ograniczone tylko przez `maxItemsInObjectGraph` przydział.</span><span class="sxs-lookup"><span data-stu-id="3ca94-196">Due to the way arrays are handled in this mode, it is easy for an attacker to construct a small malicious message that results in large memory consumption limited only by the `maxItemsInObjectGraph` quota.</span></span>  
  
### <a name="specifying-a-data-contract-surrogate"></a><span data-ttu-id="3ca94-197">Określanie surogatu kontraktu danych</span><span class="sxs-lookup"><span data-stu-id="3ca94-197">Specifying a Data Contract Surrogate</span></span>  
 <span data-ttu-id="3ca94-198">Niektóre `DataContractSerializer` przeciążenia konstruktora mają `dataContractSurrogate` parametr, który może być ustawiony na `null` .</span><span class="sxs-lookup"><span data-stu-id="3ca94-198">Some `DataContractSerializer` constructor overloads have a `dataContractSurrogate` parameter, which may be set to `null`.</span></span> <span data-ttu-id="3ca94-199">W przeciwnym razie można użyć jej do określenia *surogatu kontraktu danych*, który jest typem, który implementuje <xref:System.Runtime.Serialization.IDataContractSurrogate> interfejs.</span><span class="sxs-lookup"><span data-stu-id="3ca94-199">Otherwise, you can use it to specify a *data contract surrogate*, which is a type that implements the <xref:System.Runtime.Serialization.IDataContractSurrogate> interface.</span></span> <span data-ttu-id="3ca94-200">Następnie można użyć interfejsu do dostosowania procesu serializacji i deserializacji.</span><span class="sxs-lookup"><span data-stu-id="3ca94-200">You can then use the interface to customize the serialization and deserialization process.</span></span> <span data-ttu-id="3ca94-201">Aby uzyskać więcej informacji, zobacz [surogaty kontraktu danych](../extending/data-contract-surrogates.md).</span><span class="sxs-lookup"><span data-stu-id="3ca94-201">For more information, see [Data Contract Surrogates](../extending/data-contract-surrogates.md).</span></span>  
  
## <a name="serialization"></a><span data-ttu-id="3ca94-202">Serializacja</span><span class="sxs-lookup"><span data-stu-id="3ca94-202">Serialization</span></span>  
 <span data-ttu-id="3ca94-203">Poniższe informacje dotyczą każdej klasy, która dziedziczy z <xref:System.Runtime.Serialization.XmlObjectSerializer> , łącznie z <xref:System.Runtime.Serialization.DataContractSerializer> <xref:System.Runtime.Serialization.NetDataContractSerializer> klasami i.</span><span class="sxs-lookup"><span data-stu-id="3ca94-203">The following information applies to any class that inherits from the <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer> classes.</span></span>  
  
### <a name="simple-serialization"></a><span data-ttu-id="3ca94-204">Prosta Serializacja</span><span class="sxs-lookup"><span data-stu-id="3ca94-204">Simple Serialization</span></span>  
 <span data-ttu-id="3ca94-205">Najbardziej podstawowym sposobem serializacji obiektu jest przekazanie go do <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="3ca94-205">The most basic way to serialize an object is to pass it to the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> method.</span></span> <span data-ttu-id="3ca94-206">Istnieją trzy przeciążenia, jeden z nich do zapisu w <xref:System.IO.Stream> , a <xref:System.Xml.XmlWriter> lub <xref:System.Xml.XmlDictionaryWriter> .</span><span class="sxs-lookup"><span data-stu-id="3ca94-206">There are three overloads, one each for writing to a <xref:System.IO.Stream>, an <xref:System.Xml.XmlWriter>, or an <xref:System.Xml.XmlDictionaryWriter>.</span></span> <span data-ttu-id="3ca94-207">W przypadku <xref:System.IO.Stream> przeciążenia dane wyjściowe są XML w kodowaniu UTF-8.</span><span class="sxs-lookup"><span data-stu-id="3ca94-207">With the <xref:System.IO.Stream> overload, the output is XML in the UTF-8 encoding.</span></span> <span data-ttu-id="3ca94-208">W przypadku <xref:System.Xml.XmlDictionaryWriter> przeciążenia, serializator optymalizuje dane wyjściowe dla binarnego kodu XML.</span><span class="sxs-lookup"><span data-stu-id="3ca94-208">With the <xref:System.Xml.XmlDictionaryWriter> overload, the serializer optimizes its output for binary XML.</span></span>  
  
 <span data-ttu-id="3ca94-209">W przypadku korzystania z <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> metody serializator używa domyślnej nazwy i przestrzeni nazw dla elementu otoki i zapisuje go wraz z zawartością (zobacz poprzednią sekcję "Określanie domyślnej nazwy głównej i przestrzeni nazw").</span><span class="sxs-lookup"><span data-stu-id="3ca94-209">When using the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> method, the serializer uses the default name and namespace for the wrapper element and writes it out along with the contents (see the previous "Specifying the Default Root Name and Namespace" section).</span></span>  
  
 <span data-ttu-id="3ca94-210">Poniższy przykład ilustruje pisanie przy użyciu <xref:System.Xml.XmlDictionaryWriter> .</span><span class="sxs-lookup"><span data-stu-id="3ca94-210">The following example demonstrates writing with an <xref:System.Xml.XmlDictionaryWriter>.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#8)]
 [!code-vb[c_StandaloneDataContractSerializer#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#8)]  
  
 <span data-ttu-id="3ca94-211">Spowoduje to utworzenie kodu XML podobnego do poniższego.</span><span class="sxs-lookup"><span data-stu-id="3ca94-211">This produces XML similar to the following.</span></span>  
  
```xml  
<Person>  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</Person>  
```  
  
### <a name="step-by-step-serialization"></a><span data-ttu-id="3ca94-212">Serializacja krok po kroku</span><span class="sxs-lookup"><span data-stu-id="3ca94-212">Step-By-Step Serialization</span></span>  
 <span data-ttu-id="3ca94-213">Użyj <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> metod, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> , i, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> Aby zapisać element końcowy, zapisać zawartość obiektu i zamknąć odpowiednio element otoki.</span><span class="sxs-lookup"><span data-stu-id="3ca94-213">Use the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A>, and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> methods to write the end element, write the object contents, and close the wrapper element, respectively.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="3ca94-214">Nie ma żadnych <xref:System.IO.Stream> przeciążeń tych metod.</span><span class="sxs-lookup"><span data-stu-id="3ca94-214">There are no <xref:System.IO.Stream> overloads of these methods.</span></span>  
  
 <span data-ttu-id="3ca94-215">Ta Serializacja krok po kroku ma dwa typowe zastosowania.</span><span class="sxs-lookup"><span data-stu-id="3ca94-215">This step-by-step serialization has two common uses.</span></span> <span data-ttu-id="3ca94-216">Jednym z nich jest wstawianie zawartości, takiej jak atrybuty lub komentarze między `WriteStartObject` i `WriteObjectContent` , jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="3ca94-216">One is to insert contents such as attributes or comments between `WriteStartObject` and `WriteObjectContent`,  as shown in the following example.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#9)]
 [!code-vb[c_StandaloneDataContractSerializer#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#9)]  
  
 <span data-ttu-id="3ca94-217">Spowoduje to utworzenie kodu XML podobnego do poniższego.</span><span class="sxs-lookup"><span data-stu-id="3ca94-217">This produces XML similar to the following.</span></span>  
  
```xml  
<Person serializedBy="myCode">  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</Person>  
```  
  
 <span data-ttu-id="3ca94-218">Innym typowym zastosowaniem jest unikanie używania <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> i <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> całości, a także tworzenie własnego elementu otoki niestandardowej (lub nawet pomijanie tworzenia otoki), jak pokazano w poniższym kodzie.</span><span class="sxs-lookup"><span data-stu-id="3ca94-218">Another common use is to avoid using <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> entirely, and to write your own custom wrapper element (or even skip writing a wrapper altogether), as shown in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#10)]
 [!code-vb[c_StandaloneDataContractSerializer#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#10)]  
  
 <span data-ttu-id="3ca94-219">Spowoduje to utworzenie kodu XML podobnego do poniższego.</span><span class="sxs-lookup"><span data-stu-id="3ca94-219">This produces XML similar to the following.</span></span>  
  
```xml  
<MyCustomWrapper>  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</MyCustomWrapper>  
```  
  
> [!NOTE]
> <span data-ttu-id="3ca94-220">Użycie serializacji krok po kroku może spowodować, że w schemacie nieprawidłowy kod XML.</span><span class="sxs-lookup"><span data-stu-id="3ca94-220">Using step-by-step serialization may result in schema-invalid XML.</span></span>  
  
## <a name="deserialization"></a><span data-ttu-id="3ca94-221">Deserializacji</span><span class="sxs-lookup"><span data-stu-id="3ca94-221">Deserialization</span></span>  
 <span data-ttu-id="3ca94-222">Poniższe informacje dotyczą każdej klasy, która dziedziczy z <xref:System.Runtime.Serialization.XmlObjectSerializer> , łącznie z <xref:System.Runtime.Serialization.DataContractSerializer> <xref:System.Runtime.Serialization.NetDataContractSerializer> klasami i.</span><span class="sxs-lookup"><span data-stu-id="3ca94-222">The following information applies to any class that inherits from the <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer> classes.</span></span>  
  
 <span data-ttu-id="3ca94-223">Najbardziej podstawowym sposobem deserializacji obiektu jest wywołanie jednego z <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> przeciążeń metody.</span><span class="sxs-lookup"><span data-stu-id="3ca94-223">The most basic way to deserialize an object is to call one of the <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method overloads.</span></span> <span data-ttu-id="3ca94-224">Istnieją trzy przeciążenia, jeden z nich do odczytu z <xref:System.Xml.XmlDictionaryReader> , a `XmlReader` lub `Stream` .</span><span class="sxs-lookup"><span data-stu-id="3ca94-224">There are three overloads, one each for reading with a <xref:System.Xml.XmlDictionaryReader>, an `XmlReader`, or a `Stream`.</span></span> <span data-ttu-id="3ca94-225">Należy zauważyć, że `Stream` Przeciążenie tworzy tekst <xref:System.Xml.XmlDictionaryReader> , który nie jest chroniony przez żadne przydziały i powinien być używany tylko do odczytywania zaufanych danych.</span><span class="sxs-lookup"><span data-stu-id="3ca94-225">Note that the `Stream` overload creates a textual <xref:System.Xml.XmlDictionaryReader> that is not protected by any quotas, and should be used only to read trusted data.</span></span>  
  
 <span data-ttu-id="3ca94-226">Należy również zauważyć, że obiekt `ReadObject` zwracany przez metodę musi być rzutowany na odpowiedni typ.</span><span class="sxs-lookup"><span data-stu-id="3ca94-226">Also note that the object the `ReadObject` method returns must be cast to the appropriate type.</span></span>  
  
 <span data-ttu-id="3ca94-227">Poniższy kod tworzy wystąpienie <xref:System.Runtime.Serialization.DataContractSerializer> i a <xref:System.Xml.XmlDictionaryReader> , a następnie deserializacji `Person` wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="3ca94-227">The following code constructs an instance of the <xref:System.Runtime.Serialization.DataContractSerializer> and an <xref:System.Xml.XmlDictionaryReader>, then deserializes a `Person` instance.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#11)]
 [!code-vb[c_StandaloneDataContractSerializer#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#11)]  
  
 <span data-ttu-id="3ca94-228">Przed wywołaniem <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> metody należy umieścić obiekt odczytujący XML na elemencie otoki lub w węźle nienależącym do zawartości, który poprzedza element otoki.</span><span class="sxs-lookup"><span data-stu-id="3ca94-228">Before calling the <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method, position the XML reader on the wrapper element or on a non-content node that precedes the wrapper element.</span></span> <span data-ttu-id="3ca94-229">Można to zrobić przez wywołanie <xref:System.Xml.XmlReader.Read%2A> metody <xref:System.Xml.XmlReader> lub jej pochodne i przetestowanie <xref:System.Xml.XmlReader.NodeType%2A> , jak pokazano w poniższym kodzie.</span><span class="sxs-lookup"><span data-stu-id="3ca94-229">You can do this by calling the <xref:System.Xml.XmlReader.Read%2A> method of the <xref:System.Xml.XmlReader> or its derivation, and testing the <xref:System.Xml.XmlReader.NodeType%2A>, as shown in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#12](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#12)]
 [!code-vb[c_StandaloneDataContractSerializer#12](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#12)]  
  
 <span data-ttu-id="3ca94-230">Należy pamiętać, że atrybuty tego elementu otoki można odczytać przed przekazaniem czytnika do programu `ReadObject` .</span><span class="sxs-lookup"><span data-stu-id="3ca94-230">Note that you can read attributes on this wrapper element before handing the reader to `ReadObject`.</span></span>  
  
 <span data-ttu-id="3ca94-231">W przypadku użycia jednego z prostych `ReadObject` przeciążeń, Deserializator szuka domyślnej nazwy i przestrzeni nazw w elemencie otoki (zobacz poprzednią sekcję "Określanie domyślnej nazwy głównej i przestrzeni nazw") i zgłasza wyjątek, jeśli odnajdzie nieznany element.</span><span class="sxs-lookup"><span data-stu-id="3ca94-231">When using one of the simple `ReadObject` overloads, the deserializer looks for the default name and namespace on the wrapper element (see the preceding section, "Specifying the Default Root Name and Namespace") and throws an exception if it finds an unknown element.</span></span> <span data-ttu-id="3ca94-232">W poprzednim przykładzie `<Person>` oczekiwany jest element otoki.</span><span class="sxs-lookup"><span data-stu-id="3ca94-232">In the preceding example, the `<Person>` wrapper element is expected.</span></span> <span data-ttu-id="3ca94-233"><xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A>Metoda jest wywoływana w celu sprawdzenia, czy czytnik jest umieszczony na elemencie o nazwie zgodnie z oczekiwaniami.</span><span class="sxs-lookup"><span data-stu-id="3ca94-233">The <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> method is called to verify that the reader is positioned on an element that is named as expected.</span></span>  
  
 <span data-ttu-id="3ca94-234">Istnieje możliwość wyłączenia tego sprawdzania nazwy elementu otoki; Niektóre przeciążenia `ReadObject` metody przyjmują parametr logiczny `verifyObjectName` , który jest domyślnie ustawiony na wartość `true` .</span><span class="sxs-lookup"><span data-stu-id="3ca94-234">There is a way to disable this wrapper element name check; some overloads of the `ReadObject` method take the Boolean parameter `verifyObjectName`, which is set to `true` by default.</span></span> <span data-ttu-id="3ca94-235">Gdy jest ustawiona na `false` , nazwa i przestrzeń nazw elementu otoki jest ignorowana.</span><span class="sxs-lookup"><span data-stu-id="3ca94-235">When set to `false`, the name and namespace of the wrapper element is ignored.</span></span> <span data-ttu-id="3ca94-236">Jest to przydatne w przypadku odczytywania kodu XML, który został zapisany przy użyciu opisanego wcześniej mechanizmu serializacji krok po kroku.</span><span class="sxs-lookup"><span data-stu-id="3ca94-236">This is useful for reading XML that was written using the step-by-step serialization mechanism described previously.</span></span>  
  
## <a name="using-the-netdatacontractserializer"></a><span data-ttu-id="3ca94-237">Korzystanie z NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="3ca94-237">Using the NetDataContractSerializer</span></span>  
 <span data-ttu-id="3ca94-238">Główną różnicą między `DataContractSerializer` i <xref:System.Runtime.Serialization.NetDataContractSerializer> jest to, że program `DataContractSerializer` używa nazw kontraktów danych, podczas gdy dane `NetDataContractSerializer` wyjściowe pełnią .NET Framework zestawu i typów nazw w serializowanym kodzie XML.</span><span class="sxs-lookup"><span data-stu-id="3ca94-238">The primary difference between the `DataContractSerializer` and the <xref:System.Runtime.Serialization.NetDataContractSerializer> is that the `DataContractSerializer` uses data contract names, whereas the `NetDataContractSerializer` outputs full .NET Framework assembly and type names in the serialized XML.</span></span> <span data-ttu-id="3ca94-239">Oznacza to, że dokładnie te same typy muszą być współdzielone między punktami końcowymi serializacji i deserializacji.</span><span class="sxs-lookup"><span data-stu-id="3ca94-239">This means that the exact same types must be shared between the serialization and deserialization endpoints.</span></span> <span data-ttu-id="3ca94-240">Oznacza to, że mechanizm znanych typów nie jest wymagany w przypadku, gdy `NetDataContractSerializer` dokładne typy do deserializacji są zawsze znane.</span><span class="sxs-lookup"><span data-stu-id="3ca94-240">This means that the known types mechanism is not required with the `NetDataContractSerializer` because the exact types to be deserialized are always known.</span></span>  
  
 <span data-ttu-id="3ca94-241">Może jednak wystąpić kilka problemów:</span><span class="sxs-lookup"><span data-stu-id="3ca94-241">However, several problems can occur:</span></span>  
  
- <span data-ttu-id="3ca94-242">Zabezpieczenia.</span><span class="sxs-lookup"><span data-stu-id="3ca94-242">Security.</span></span> <span data-ttu-id="3ca94-243">Zostanie załadowany dowolny typ znaleziony w deserializowanym kodzie XML.</span><span class="sxs-lookup"><span data-stu-id="3ca94-243">Any type found in the XML being deserialized is loaded.</span></span> <span data-ttu-id="3ca94-244">Może to być wykorzystane w celu wymuszenia załadowania złośliwych typów.</span><span class="sxs-lookup"><span data-stu-id="3ca94-244">This can be exploited to force the loading of malicious types.</span></span> <span data-ttu-id="3ca94-245">Za pomocą `NetDataContractSerializer` niezaufanych danych należy wykonać tylko wtedy, gdy jest używany *spinacz serializacji* (przy użyciu <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> właściwości lub konstruktora).</span><span class="sxs-lookup"><span data-stu-id="3ca94-245">Using the `NetDataContractSerializer` with untrusted data should be done only if a *Serialization Binder* is used (using the <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> property or constructor parameter).</span></span> <span data-ttu-id="3ca94-246">Spinacz zezwala na ładowanie tylko bezpiecznych typów.</span><span class="sxs-lookup"><span data-stu-id="3ca94-246">The binder permits only safe types to be loaded.</span></span> <span data-ttu-id="3ca94-247">Mechanizm segregatora jest identyczny z typem, który jest <xref:System.Runtime.Serialization> używany w przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="3ca94-247">The Binder mechanism is identical to the one that types in the <xref:System.Runtime.Serialization> namespace use.</span></span>  
  
- <span data-ttu-id="3ca94-248">Przechowywanie wersji.</span><span class="sxs-lookup"><span data-stu-id="3ca94-248">Versioning.</span></span> <span data-ttu-id="3ca94-249">Używanie typów pełnych i nazw zestawów w kodzie XML poważnie ogranicza sposób obsługi wersji.</span><span class="sxs-lookup"><span data-stu-id="3ca94-249">Using full type and assembly names in the XML severely restricts how types can be versioned.</span></span> <span data-ttu-id="3ca94-250">Nie można zmienić następujących danych: nazwy typów, przestrzenie nazw, nazwy zestawów i wersje zestawu.</span><span class="sxs-lookup"><span data-stu-id="3ca94-250">The following cannot be changed: type names, namespaces, assembly names, and assembly versions.</span></span> <span data-ttu-id="3ca94-251">Ustawienie <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> właściwości lub konstruktora <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple> zamiast wartości domyślnej <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Full> zezwala na zmiany wersji zestawu, ale nie dla typów parametrów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="3ca94-251">Setting the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property or constructor parameter to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple> instead of the default value of <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Full> allows for assembly version changes, but not for generic parameter types.</span></span>  
  
- <span data-ttu-id="3ca94-252">Współdziałanie.</span><span class="sxs-lookup"><span data-stu-id="3ca94-252">Interoperability.</span></span> <span data-ttu-id="3ca94-253">Ponieważ typ .NET Framework i nazwy zestawów są zawarte w pliku XML, platformy inne niż .NET Framework nie mogą uzyskać dostępu do danych wyjściowych.</span><span class="sxs-lookup"><span data-stu-id="3ca94-253">Because .NET Framework type and assembly names are included in the XML, platforms other than the .NET Framework cannot access the resulting data.</span></span>  
  
- <span data-ttu-id="3ca94-254">Wydajność.</span><span class="sxs-lookup"><span data-stu-id="3ca94-254">Performance.</span></span> <span data-ttu-id="3ca94-255">Wpisywanie nazw typów i zestawów znacząco zwiększa rozmiar wynikowego kodu XML.</span><span class="sxs-lookup"><span data-stu-id="3ca94-255">Writing out the type and assembly names significantly increases the size of the resulting XML.</span></span>  
  
 <span data-ttu-id="3ca94-256">Ten mechanizm jest podobny do serializacji binarnej lub SOAP używanej przez .NET Framework komunikacji zdalnej (w tym, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> a <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> ).</span><span class="sxs-lookup"><span data-stu-id="3ca94-256">This mechanism is similar to binary or SOAP serialization used by .NET Framework remoting (specifically, the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>).</span></span>  
  
 <span data-ttu-id="3ca94-257">Korzystanie z programu `NetDataContractSerializer` jest podobne do użycia `DataContractSerializer` , z następującymi różnicami:</span><span class="sxs-lookup"><span data-stu-id="3ca94-257">Using the `NetDataContractSerializer` is similar to using the `DataContractSerializer`, with the following differences:</span></span>  
  
- <span data-ttu-id="3ca94-258">Konstruktory nie wymagają określenia typu głównego.</span><span class="sxs-lookup"><span data-stu-id="3ca94-258">The constructors do not require you to specify a root type.</span></span> <span data-ttu-id="3ca94-259">Można serializować dowolnego typu z tym samym wystąpieniem `NetDataContractSerializer` .</span><span class="sxs-lookup"><span data-stu-id="3ca94-259">You can serialize any type with the same instance of the `NetDataContractSerializer`.</span></span>  
  
- <span data-ttu-id="3ca94-260">Konstruktory nie akceptują listy znanych typów.</span><span class="sxs-lookup"><span data-stu-id="3ca94-260">The constructors do not accept a list of known types.</span></span> <span data-ttu-id="3ca94-261">Mechanizm znanych typów jest zbędny, jeśli nazwy typów są serializowane do kodu XML.</span><span class="sxs-lookup"><span data-stu-id="3ca94-261">The known types mechanism is unnecessary if type names are serialized into the XML.</span></span>  
  
- <span data-ttu-id="3ca94-262">Konstruktory nie akceptują surogatu kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="3ca94-262">The constructors do not accept a data contract surrogate.</span></span> <span data-ttu-id="3ca94-263">Zamiast tego akceptują <xref:System.Runtime.Serialization.ISurrogateSelector> parametr o nazwie `surrogateSelector` (który mapuje do <xref:System.Runtime.Serialization.NetDataContractSerializer.SurrogateSelector%2A> Właściwości).</span><span class="sxs-lookup"><span data-stu-id="3ca94-263">Instead, they accept an <xref:System.Runtime.Serialization.ISurrogateSelector> parameter called `surrogateSelector` (which maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.SurrogateSelector%2A> property).</span></span> <span data-ttu-id="3ca94-264">Jest to starszy mechanizm zastępczy.</span><span class="sxs-lookup"><span data-stu-id="3ca94-264">This is a legacy surrogate mechanism.</span></span>  
  
- <span data-ttu-id="3ca94-265">Konstruktory akceptują parametr wywoływany przez `assemblyFormat` <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> Mapowanie do <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="3ca94-265">The constructors accept a parameter called `assemblyFormat` of the <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> that maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property.</span></span> <span data-ttu-id="3ca94-266">Jak wspomniano wcześniej, może to służyć do ulepszania możliwości obsługi wersji programu szeregującego.</span><span class="sxs-lookup"><span data-stu-id="3ca94-266">As discussed previously, this can be used to enhance the versioning capabilities of the serializer.</span></span> <span data-ttu-id="3ca94-267">Jest to taka sama jak <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> w przypadku serializacji binarnej lub SOAP.</span><span class="sxs-lookup"><span data-stu-id="3ca94-267">This is identical to the <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> mechanism in binary or SOAP serialization.</span></span>  
  
- <span data-ttu-id="3ca94-268">Konstruktory akceptują <xref:System.Runtime.Serialization.StreamingContext> parametr o nazwie `context` , który jest mapowany na <xref:System.Runtime.Serialization.NetDataContractSerializer.Context%2A> Właściwość.</span><span class="sxs-lookup"><span data-stu-id="3ca94-268">The constructors accept a <xref:System.Runtime.Serialization.StreamingContext> parameter called `context` that maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.Context%2A> property.</span></span> <span data-ttu-id="3ca94-269">Możesz użyć tego do przekazania informacji do typów, które są serializowane.</span><span class="sxs-lookup"><span data-stu-id="3ca94-269">You can use this to pass information into types being serialized.</span></span> <span data-ttu-id="3ca94-270">To użycie jest takie samo jak w przypadku <xref:System.Runtime.Serialization.StreamingContext> mechanizmu używanego w innych <xref:System.Runtime.Serialization> klasach.</span><span class="sxs-lookup"><span data-stu-id="3ca94-270">This usage is identical to that of the <xref:System.Runtime.Serialization.StreamingContext> mechanism used in other <xref:System.Runtime.Serialization> classes.</span></span>  
  
- <span data-ttu-id="3ca94-271"><xref:System.Runtime.Serialization.NetDataContractSerializer.Serialize%2A>Metody i <xref:System.Runtime.Serialization.NetDataContractSerializer.Deserialize%2A> są aliasami dla <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> metod i <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> .</span><span class="sxs-lookup"><span data-stu-id="3ca94-271">The <xref:System.Runtime.Serialization.NetDataContractSerializer.Serialize%2A> and <xref:System.Runtime.Serialization.NetDataContractSerializer.Deserialize%2A> methods are aliases for the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> methods.</span></span> <span data-ttu-id="3ca94-272">Istnieją one, aby zapewnić bardziej spójny model programowania z binarną lub serializacji SOAP.</span><span class="sxs-lookup"><span data-stu-id="3ca94-272">These exist to provide a more consistent programming model with binary or SOAP serialization.</span></span>  
  
 <span data-ttu-id="3ca94-273">Aby uzyskać więcej informacji o tych funkcjach, zobacz [Serializacja binarna](../../../standard/serialization/binary-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="3ca94-273">For more information about these features, see [Binary Serialization](../../../standard/serialization/binary-serialization.md).</span></span>  
  
 <span data-ttu-id="3ca94-274">Formaty XML, których `NetDataContractSerializer` `DataContractSerializer` użycie i nie są zwykle zgodne.</span><span class="sxs-lookup"><span data-stu-id="3ca94-274">The XML formats that the `NetDataContractSerializer` and the `DataContractSerializer` use are normally not compatible.</span></span> <span data-ttu-id="3ca94-275">Oznacza to, że próba serializacji z jednym z tych serializacji i deserializacji z drugim nie jest obsługiwanym scenariuszem.</span><span class="sxs-lookup"><span data-stu-id="3ca94-275">That is, attempting to serialize with one of these serializers and deserialize with the other is not a supported scenario.</span></span>  
  
 <span data-ttu-id="3ca94-276">Należy również pamiętać, że program `NetDataContractSerializer` nie wyprowadza pełnego typu .NET Framework i nazwy zestawu dla każdego węzła na grafie obiektów.</span><span class="sxs-lookup"><span data-stu-id="3ca94-276">Also, note that the `NetDataContractSerializer` does not output the full .NET Framework type and assembly name for each node in the object graph.</span></span> <span data-ttu-id="3ca94-277">Dane te są wyprowadzane tylko wtedy, gdy są niejednoznaczne.</span><span class="sxs-lookup"><span data-stu-id="3ca94-277">It outputs that information only where it is ambiguous.</span></span> <span data-ttu-id="3ca94-278">Oznacza to, że jest ona wyprowadzana na poziomie obiektu głównego i dla każdego polimorficznego przypadku.</span><span class="sxs-lookup"><span data-stu-id="3ca94-278">That is, it outputs at the root object level and for any polymorphic cases.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3ca94-279">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="3ca94-279">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Runtime.Serialization.NetDataContractSerializer>
- <xref:System.Runtime.Serialization.XmlObjectSerializer>
- [<span data-ttu-id="3ca94-280">Serializacja binarna</span><span class="sxs-lookup"><span data-stu-id="3ca94-280">Binary Serialization</span></span>](../../../standard/serialization/binary-serialization.md)
- [<span data-ttu-id="3ca94-281">Typy obsługiwane przez serializator kontraktu danych</span><span class="sxs-lookup"><span data-stu-id="3ca94-281">Types Supported by the Data Contract Serializer</span></span>](types-supported-by-the-data-contract-serializer.md)
