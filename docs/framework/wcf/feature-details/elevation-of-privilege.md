---
title: Podniesienie uprawnień
ms.date: 03/30/2017
helpviewer_keywords:
- elevation of privilege [WCF]
- security [WCF], elevation of privilege
ms.assetid: 146e1c66-2a76-4ed3-98a5-fd77851a06d9
ms.openlocfilehash: 8838b139efa20bc796fc21567cc6fc9ee8691eee
ms.sourcegitcommit: 17ee6605e01ef32506f8fdc686954244ba6911de
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 11/21/2019
ms.locfileid: "74283248"
---
# <a name="elevation-of-privilege"></a><span data-ttu-id="8977f-102">Podniesienie uprawnień</span><span class="sxs-lookup"><span data-stu-id="8977f-102">Elevation of Privilege</span></span>
<span data-ttu-id="8977f-103">*Podniesienie* uprawnień w wyniku udzielenia uprawnień autoryzacji osoby atakującej poza wstępnie udzielonym.</span><span class="sxs-lookup"><span data-stu-id="8977f-103">*Elevation of privilege* results from giving an attacker authorization permissions beyond those initially granted.</span></span> <span data-ttu-id="8977f-104">Na przykład osoba atakująca z zestawem uprawnień "tylko do odczytu" w dowolnej postaci podnosi poziom w taki sposób, aby obejmował "Odczyt i zapis".</span><span class="sxs-lookup"><span data-stu-id="8977f-104">For example, an attacker with a privilege set of "read only" permissions somehow elevates the set to include "read and write."</span></span>  
  
## <a name="trusted-sts-should-sign-saml-token-claims"></a><span data-ttu-id="8977f-105">Zaufane usługi STS powinny podpisywać oświadczenia tokenów SAML</span><span class="sxs-lookup"><span data-stu-id="8977f-105">Trusted STS Should Sign SAML Token Claims</span></span>  
 <span data-ttu-id="8977f-106">Token potwierdzeń zabezpieczeń (SAML) jest ogólnym tokenem XML, który jest domyślnym typem dla wystawionych tokenów.</span><span class="sxs-lookup"><span data-stu-id="8977f-106">A Security Assertions Markup Language (SAML) token is a generic XML token that is the default type for issued tokens.</span></span> <span data-ttu-id="8977f-107">Token SAML może być skonstruowany przez usługę tokenu zabezpieczającego (STS), którą usługa sieci Web jest zaufana w typowej wymianie.</span><span class="sxs-lookup"><span data-stu-id="8977f-107">A SAML token can be constructed by a Security Token Service (STS) that the end Web service trusts in a typical exchange.</span></span> <span data-ttu-id="8977f-108">Tokeny SAML zawierają oświadczenia w instrukcjach.</span><span class="sxs-lookup"><span data-stu-id="8977f-108">SAML tokens contain claims in statements.</span></span> <span data-ttu-id="8977f-109">Osoba atakująca może skopiować oświadczenia z prawidłowego tokenu, utworzyć nowy token SAML i podpisać go innym wystawcą.</span><span class="sxs-lookup"><span data-stu-id="8977f-109">An attacker may copy the claims from a valid token, create a new SAML token, and sign it with a different issuer.</span></span> <span data-ttu-id="8977f-110">Celem jest określenie, czy serwer sprawdza poprawność wystawców i, jeśli nie, użyje luki w celu skonstruowania tokenów SAML, które zezwalają na uprawnienia poza tymi, które są przeznaczone dla zaufanej usługi STS.</span><span class="sxs-lookup"><span data-stu-id="8977f-110">The intent is to determine whether the server is validating issuers and, if not, utilize the weakness to construct SAML tokens that allow privileges beyond those intended by a trusted STS.</span></span>  
  
 <span data-ttu-id="8977f-111">Klasa <xref:System.IdentityModel.Tokens.SamlAssertion> weryfikuje podpis cyfrowy zawarty w tokenie SAML, a domyślna <xref:System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator> wymaga podpisania tokenów SAML przy użyciu certyfikatu X. 509, który jest prawidłowy, gdy <xref:System.ServiceModel.Security.IssuedTokenServiceCredential.CertificateValidationMode%2A> klasy <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> jest ustawiona na <xref:System.ServiceModel.Security.X509CertificateValidationMode.ChainTrust>.</span><span class="sxs-lookup"><span data-stu-id="8977f-111">The <xref:System.IdentityModel.Tokens.SamlAssertion> class verifies the digital signature contained within a SAML token, and the default <xref:System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator> requires that SAML tokens be signed by an X.509 certificate that is valid when the <xref:System.ServiceModel.Security.IssuedTokenServiceCredential.CertificateValidationMode%2A> of the <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> class is set to <xref:System.ServiceModel.Security.X509CertificateValidationMode.ChainTrust>.</span></span> <span data-ttu-id="8977f-112">Tryb `ChainTrust` jest niewystarczający, aby określić, czy Wystawca tokenu SAML jest zaufany.</span><span class="sxs-lookup"><span data-stu-id="8977f-112">`ChainTrust` mode alone is insufficient to determine whether the issuer of the SAML token is trusted.</span></span> <span data-ttu-id="8977f-113">Usługi, które wymagają bardziej szczegółowego modelu zaufania, mogą użyć zasad autoryzacji i wymuszania do sprawdzania wystawcy zestawów roszczeń utworzonych przy użyciu uwierzytelniania wystawionego tokenu lub użyć ustawień weryfikacji X. 509 w <xref:System.ServiceModel.Security.IssuedTokenServiceCredential>, aby ograniczyć zestaw dozwolonych certyfikatów podpisywania.</span><span class="sxs-lookup"><span data-stu-id="8977f-113">Services that require a more granular trust model can either use authorization and enforcement policies to check the issuer of the claim sets produced by issued token authentication or use the X.509 validation settings on <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> to restrict the set of allowed signing certificates.</span></span> <span data-ttu-id="8977f-114">Aby uzyskać więcej informacji, zobacz [Zarządzanie oświadczeniami i autoryzacją za pomocą modelu tożsamości](../../../../docs/framework/wcf/feature-details/managing-claims-and-authorization-with-the-identity-model.md) oraz [Federacji i wystawionych tokenów](../../../../docs/framework/wcf/feature-details/federation-and-issued-tokens.md).</span><span class="sxs-lookup"><span data-stu-id="8977f-114">For more information, see [Managing Claims and Authorization with the Identity Model](../../../../docs/framework/wcf/feature-details/managing-claims-and-authorization-with-the-identity-model.md) and [Federation and Issued Tokens](../../../../docs/framework/wcf/feature-details/federation-and-issued-tokens.md).</span></span>  
  
## <a name="switching-identity-without-a-security-context"></a><span data-ttu-id="8977f-115">Przełączanie tożsamości bez kontekstu zabezpieczeń</span><span class="sxs-lookup"><span data-stu-id="8977f-115">Switching Identity Without a Security Context</span></span>  
 <span data-ttu-id="8977f-116">Poniższe zasady dotyczą tylko programu WinFX.</span><span class="sxs-lookup"><span data-stu-id="8977f-116">The following applies only to WinFX.</span></span>  
  
 <span data-ttu-id="8977f-117">W przypadku ustanowienia połączenia między klientem a serwerem tożsamość klienta nie zmienia się, z wyjątkiem sytuacji, gdy jest otwarty klient WCF, jeśli spełnione są wszystkie następujące warunki:</span><span class="sxs-lookup"><span data-stu-id="8977f-117">When a connection is established between a client and server, the identity of the client does not change, except in one situation: after the WCF client is opened, if all of the following conditions are true:</span></span>  
  
- <span data-ttu-id="8977f-118">Procedury ustanawiania kontekstu zabezpieczeń (przy użyciu sesji zabezpieczeń transportu lub sesji zabezpieczeń komunikatów) są przełączane (<xref:System.ServiceModel.NonDualMessageSecurityOverHttp.EstablishSecurityContext%2A> właściwość jest ustawiana na `false` w przypadku zabezpieczenia komunikatów lub transport nie może ustanowić sesji zabezpieczeń w przypadku bezpieczeństwa transportowego.</span><span class="sxs-lookup"><span data-stu-id="8977f-118">The procedures to establish a security context (using a transport security session or message security session) is switched off (<xref:System.ServiceModel.NonDualMessageSecurityOverHttp.EstablishSecurityContext%2A> property is set to `false` in case of message security or transport not capable of establishing security sessions is used in transport security case.</span></span> <span data-ttu-id="8977f-119">HTTPS to jeden przykład takiego transportu).</span><span class="sxs-lookup"><span data-stu-id="8977f-119">HTTPS is one example of such transport).</span></span>  
  
- <span data-ttu-id="8977f-120">Używasz uwierzytelniania systemu Windows.</span><span class="sxs-lookup"><span data-stu-id="8977f-120">You are using Windows authentication.</span></span>  
  
- <span data-ttu-id="8977f-121">Nie ustawiasz jawnie poświadczenia.</span><span class="sxs-lookup"><span data-stu-id="8977f-121">You do not explicitly set the credential.</span></span>  
  
- <span data-ttu-id="8977f-122">Wywołujesz usługę w ramach personifikowanego kontekstu zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="8977f-122">You are calling the service under the impersonated security context.</span></span>  
  
 <span data-ttu-id="8977f-123">Jeśli te warunki są spełnione, tożsamość użyta do uwierzytelnienia klienta w usłudze może ulec zmianie (może nie być to personifikowana tożsamość, ale tożsamość procesu) po otwarciu klienta programu WCF.</span><span class="sxs-lookup"><span data-stu-id="8977f-123">If these conditions are true, the identity used to authenticate the client to the service might change (it might not be the impersonated identity but the process identity instead) after the WCF client is opened.</span></span> <span data-ttu-id="8977f-124">Dzieje się tak, ponieważ poświadczenia systemu Windows używane do uwierzytelniania klienta w usłudze są przesyłane wraz z każdym komunikatem, a poświadczenia używane do uwierzytelniania są uzyskiwane z tożsamości systemu Windows bieżącego wątku.</span><span class="sxs-lookup"><span data-stu-id="8977f-124">This occurs because the Windows credential used to authenticate the client to the service is transmitted with every message, and the credential used for authentication is obtained from the current thread's Windows identity.</span></span> <span data-ttu-id="8977f-125">Jeśli tożsamość systemu Windows bieżącego wątku ulegnie zmianie (na przykład przez personifikację innego obiektu wywołującego), poświadczenie dołączone do wiadomości i użyte do uwierzytelnienia klienta w usłudze również może ulec zmianie.</span><span class="sxs-lookup"><span data-stu-id="8977f-125">If the Windows identity of the current thread changes (for example, by impersonating a different caller), the credential that is attached to the message and used to authenticate the client to the service might also change.</span></span>  
  
 <span data-ttu-id="8977f-126">Jeśli chcesz mieć deterministyczne zachowanie podczas korzystania z uwierzytelniania systemu Windows razem z personifikacją, musisz jawnie ustawić poświadczenia systemu Windows lub ustanowić kontekst zabezpieczeń z usługą.</span><span class="sxs-lookup"><span data-stu-id="8977f-126">If you want to have deterministic behavior when using Windows authentication together with impersonation you need to explicitly set the Windows credential or you need to establish a security context with the service.</span></span> <span data-ttu-id="8977f-127">W tym celu należy użyć sesji zabezpieczeń wiadomości lub sesji zabezpieczeń transportu.</span><span class="sxs-lookup"><span data-stu-id="8977f-127">To do this, use a message security session or a transport security session.</span></span> <span data-ttu-id="8977f-128">Na przykład transport net. TCP może zapewnić sesję zabezpieczeń transportu.</span><span class="sxs-lookup"><span data-stu-id="8977f-128">For example, the net.tcp transport can provide a transport security session.</span></span> <span data-ttu-id="8977f-129">Ponadto podczas wywoływania usługi należy używać tylko synchronicznej wersji operacji klienta.</span><span class="sxs-lookup"><span data-stu-id="8977f-129">Additionally, you must use only a synchronous version of client operations when calling the service.</span></span> <span data-ttu-id="8977f-130">W przypadku ustanowienia kontekstu zabezpieczeń wiadomości nie powinno być konieczne pozostawienie połączenia z usługą dłużej niż skonfigurowany okres odnawiania sesji, ponieważ tożsamość może być również zmieniana podczas procesu odnawiania sesji.</span><span class="sxs-lookup"><span data-stu-id="8977f-130">If you establish a message security context, you should not keep the connection to the service open longer than the configured session renewal period, because the identity can also change during the session renewal process.</span></span>  
  
### <a name="credentials-capture"></a><span data-ttu-id="8977f-131">Przechwytywanie poświadczeń</span><span class="sxs-lookup"><span data-stu-id="8977f-131">Credentials Capture</span></span>  
 <span data-ttu-id="8977f-132">Poniższe zasady dotyczą .NET Framework 3,5 i kolejnych wersji.</span><span class="sxs-lookup"><span data-stu-id="8977f-132">The following applies to .NET Framework 3.5, and subsequent versions.</span></span>  
  
 <span data-ttu-id="8977f-133">Poświadczenia używane przez klienta lub usługę są oparte na bieżącym wątku kontekstu.</span><span class="sxs-lookup"><span data-stu-id="8977f-133">Credentials used by the client or the service are based on the current context thread.</span></span> <span data-ttu-id="8977f-134">Poświadczenia są uzyskiwane, gdy wywoływana jest metoda `Open` (lub `BeginOpen`, dla wywołań asynchronicznych) klienta lub usługi.</span><span class="sxs-lookup"><span data-stu-id="8977f-134">The credentials are obtained when the `Open` method (or `BeginOpen`, for asynchronous calls) of the client or service is called.</span></span> <span data-ttu-id="8977f-135">Dla klas <xref:System.ServiceModel.ServiceHost> i <xref:System.ServiceModel.ClientBase%601> metody `Open` i `BeginOpen` dziedziczą z metod <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> i <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> klasy <xref:System.ServiceModel.Channels.CommunicationObject>.</span><span class="sxs-lookup"><span data-stu-id="8977f-135">For both the <xref:System.ServiceModel.ServiceHost> and <xref:System.ServiceModel.ClientBase%601> classes, the `Open` and `BeginOpen` methods inherit from the <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> and <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> methods of the <xref:System.ServiceModel.Channels.CommunicationObject> class.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="8977f-136">W przypadku korzystania z metody `BeginOpen` przechwycone poświadczenia nie mogą być poświadczeniami procesu wywołującego metodę.</span><span class="sxs-lookup"><span data-stu-id="8977f-136">When using the `BeginOpen` method, the credentials captured cannot be guaranteed to be the credentials of the process that calls the method.</span></span>  
  
## <a name="token-caches-allow-replay-using-obsolete-data"></a><span data-ttu-id="8977f-137">Pamięć podręczna tokenów zezwala na powtarzanie przy użyciu przestarzałych danych</span><span class="sxs-lookup"><span data-stu-id="8977f-137">Token Caches Allow Replay Using Obsolete Data</span></span>  
 <span data-ttu-id="8977f-138">Usługa WCF używa funkcji `LogonUser` urzędu zabezpieczeń lokalnych (LSA) do uwierzytelniania użytkowników według nazwy użytkownika i hasła.</span><span class="sxs-lookup"><span data-stu-id="8977f-138">WCF uses the local security authority (LSA) `LogonUser` function to authenticate users by user name and password.</span></span> <span data-ttu-id="8977f-139">Ponieważ funkcja logowania jest kosztowną operacją, WCF pozwala na buforowanie tokenów reprezentujących użytkowników uwierzytelnionych w celu zwiększenia wydajności.</span><span class="sxs-lookup"><span data-stu-id="8977f-139">Because the logon function is a costly operation, WCF allows you to cache tokens that represent authenticated users to increase performance.</span></span> <span data-ttu-id="8977f-140">Mechanizm buforowania zapisuje wyniki `LogonUser` do kolejnych użycia.</span><span class="sxs-lookup"><span data-stu-id="8977f-140">The caching mechanism saves the results from `LogonUser` for subsequent uses.</span></span> <span data-ttu-id="8977f-141">Ten mechanizm jest domyślnie wyłączony; Aby ją włączyć, należy ustawić właściwość <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CacheLogonTokens%2A> na `true`lub użyć atrybutu `cacheLogonTokens` [\<userNameAuthentication >](../../../../docs/framework/configure-apps/file-schema/wcf/usernameauthentication.md).</span><span class="sxs-lookup"><span data-stu-id="8977f-141">This mechanism is disabled by default; to enable it, set the <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CacheLogonTokens%2A> property to `true`, or use the `cacheLogonTokens` attribute of the [\<userNameAuthentication>](../../../../docs/framework/configure-apps/file-schema/wcf/usernameauthentication.md).</span></span>  
  
 <span data-ttu-id="8977f-142">Można ustawić czas wygaśnięcia (TTL) dla buforowanych tokenów przez ustawienie właściwości <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CachedLogonTokenLifetime%2A> na <xref:System.TimeSpan>lub użyć atrybutu `cachedLogonTokenLifetime` elementu `userNameAuthentication`; wartość domyślna to 15 minut.</span><span class="sxs-lookup"><span data-stu-id="8977f-142">You can set a Time to Live (TTL) for the cached tokens by setting the <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CachedLogonTokenLifetime%2A> property to a <xref:System.TimeSpan>, or use the `cachedLogonTokenLifetime` attribute of the `userNameAuthentication` element; the default is 15 minutes.</span></span> <span data-ttu-id="8977f-143">Należy pamiętać, że gdy token jest buforowany, każdy klient, który przedstawia taką samą nazwę użytkownika i hasło, może używać tokenu, nawet jeśli konto użytkownika zostanie usunięte z systemu Windows lub zmieniono jego hasło.</span><span class="sxs-lookup"><span data-stu-id="8977f-143">Note that while a token is cached, any client that presents the same user name and password can use the token, even if the user account is deleted from Windows or if its password has been changed.</span></span> <span data-ttu-id="8977f-144">Do momentu wygaśnięcia czasu wygaśnięcia i usunięcia tokenu z pamięci podręcznej program WCF zezwoli użytkownikowi (prawdopodobnie złośliwemu) na uwierzytelnienie.</span><span class="sxs-lookup"><span data-stu-id="8977f-144">Until the TTL expires and the token is removed from the cache, WCF allows the (possibly malicious) user to authenticate.</span></span>  
  
 <span data-ttu-id="8977f-145">Aby rozwiązać ten problem: Zmniejsz okno ataków, ustawiając wartość `cachedLogonTokenLifetime` na najkrótszy czas na potrzeby użytkowników.</span><span class="sxs-lookup"><span data-stu-id="8977f-145">To mitigate this: Decrease the attack window by setting the `cachedLogonTokenLifetime` value to the shortest time span your users need.</span></span>  
  
## <a name="issued-token-authorization-expiration-reset-to-large-value"></a><span data-ttu-id="8977f-146">Autoryzacja wystawionego tokenu: Resetowanie czasu wygaśnięcia do wartości dużej</span><span class="sxs-lookup"><span data-stu-id="8977f-146">Issued Token Authorization: Expiration Reset to Large Value</span></span>  
 <span data-ttu-id="8977f-147">W pewnych warunkach Właściwość <xref:System.IdentityModel.Policy.AuthorizationContext.ExpirationTime%2A> <xref:System.IdentityModel.Policy.AuthorizationContext> może być ustawiona na nieoczekiwaną większą wartość (<xref:System.DateTime.MaxValue> wartości pola pomniejszonej o jeden dzień lub 20 grudnia 9999).</span><span class="sxs-lookup"><span data-stu-id="8977f-147">Under certain conditions, the <xref:System.IdentityModel.Policy.AuthorizationContext.ExpirationTime%2A> property of the <xref:System.IdentityModel.Policy.AuthorizationContext> may be set to an unexpectedly larger value (the <xref:System.DateTime.MaxValue> field value minus one day, or December 20, 9999).</span></span>  
  
 <span data-ttu-id="8977f-148">Dzieje się tak w przypadku używania <xref:System.ServiceModel.WSFederationHttpBinding> i wszelkich powiązań dostarczonych przez system, które mają wystawiony token jako typ poświadczeń klienta.</span><span class="sxs-lookup"><span data-stu-id="8977f-148">This occurs when using the <xref:System.ServiceModel.WSFederationHttpBinding> and any of the system-provided bindings that have an issued token as the client credential type.</span></span>  
  
 <span data-ttu-id="8977f-149">Występuje to również podczas tworzenia powiązań niestandardowych przy użyciu jednej z następujących metod:</span><span class="sxs-lookup"><span data-stu-id="8977f-149">This also occurs when you create custom bindings by using one of the following methods:</span></span>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForCertificateBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForSslBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenOverTransportBindingElement%2A>  
  
 <span data-ttu-id="8977f-150">Aby temu zapobiec, zasady autoryzacji muszą sprawdzać akcję i czas wygaśnięcia poszczególnych zasad autoryzacji.</span><span class="sxs-lookup"><span data-stu-id="8977f-150">To mitigate this, the authorization policy must check the action and the expiration time of each authorization policy.</span></span>  
  
## <a name="the-service-uses-a-different-certificate-than-the-client-intended"></a><span data-ttu-id="8977f-151">Usługa używa innego certyfikatu niż zamierzony klient</span><span class="sxs-lookup"><span data-stu-id="8977f-151">The Service Uses a Different Certificate Than the Client Intended</span></span>  
 <span data-ttu-id="8977f-152">W pewnych warunkach klient może cyfrowo podpisać komunikat przy użyciu certyfikatu X. 509, a usługa pobiera inny certyfikat niż przewidziany.</span><span class="sxs-lookup"><span data-stu-id="8977f-152">Under certain conditions, a client can digitally sign a message with an X.509 certificate and have the service retrieve a different certificate than the intended one.</span></span>  
  
 <span data-ttu-id="8977f-153">Może się to zdarzyć w następujących okolicznościach:</span><span class="sxs-lookup"><span data-stu-id="8977f-153">This can occur under the following circumstances:</span></span>  
  
- <span data-ttu-id="8977f-154">Klient cyfrowo podpisuje komunikat przy użyciu certyfikatu X. 509 i nie dołącza certyfikatu X. 509 do wiadomości, ale nie tylko odwołuje się do certyfikatu przy użyciu identyfikatora klucza podmiotu.</span><span class="sxs-lookup"><span data-stu-id="8977f-154">The client digitally signs a message using an X.509 certificate and does not attach the X.509 certificate to the message, but rather just references the certificate using its subject key identifier.</span></span>  
  
- <span data-ttu-id="8977f-155">Komputer usługi zawiera dwa lub więcej certyfikatów z tym samym kluczem publicznym, ale zawierają różne informacje.</span><span class="sxs-lookup"><span data-stu-id="8977f-155">The service's computer contains two or more certificates with the same public key, but they contain different information.</span></span>  
  
- <span data-ttu-id="8977f-156">Usługa pobiera certyfikat odpowiadający identyfikatorowi klucza podmiotu, ale nie jest to klient, którego zamierza użyć.</span><span class="sxs-lookup"><span data-stu-id="8977f-156">The service retrieves a certificate that matches the subject key identifier, but it is not the one the client intended to use.</span></span> <span data-ttu-id="8977f-157">Gdy usługa WCF odbiera komunikat i weryfikuje podpis, usługa WCF mapuje informacje w niezamierzonym certyfikacie X. 509 do zestawu oświadczeń, które są różne i mogą być podniesione z poziomu klienta.</span><span class="sxs-lookup"><span data-stu-id="8977f-157">When WCF receives the message and verifies the signature, WCF maps the information in the unintended X.509 certificate to a set of claims that are different and potentially elevated from what the client expected.</span></span>  
  
 <span data-ttu-id="8977f-158">Aby rozwiązać ten problem, należy odwołać się do certyfikatu X. 509 w inny sposób, na przykład przy użyciu <xref:System.ServiceModel.Security.Tokens.X509KeyIdentifierClauseType.IssuerSerial>.</span><span class="sxs-lookup"><span data-stu-id="8977f-158">To mitigate this, reference the X.509 certificate another way, such as using <xref:System.ServiceModel.Security.Tokens.X509KeyIdentifierClauseType.IssuerSerial>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8977f-159">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="8977f-159">See also</span></span>

- [<span data-ttu-id="8977f-160">Zagadnienia dotyczące bezpieczeństwa</span><span class="sxs-lookup"><span data-stu-id="8977f-160">Security Considerations</span></span>](../../../../docs/framework/wcf/feature-details/security-considerations-in-wcf.md)
- [<span data-ttu-id="8977f-161">Ujawnianie informacji</span><span class="sxs-lookup"><span data-stu-id="8977f-161">Information Disclosure</span></span>](../../../../docs/framework/wcf/feature-details/information-disclosure.md)
- [<span data-ttu-id="8977f-162">Odmowa usługi</span><span class="sxs-lookup"><span data-stu-id="8977f-162">Denial of Service</span></span>](../../../../docs/framework/wcf/feature-details/denial-of-service.md)
- [<span data-ttu-id="8977f-163">Ataki oparte na metodzie powtórzeń</span><span class="sxs-lookup"><span data-stu-id="8977f-163">Replay Attacks</span></span>](../../../../docs/framework/wcf/feature-details/replay-attacks.md)
- [<span data-ttu-id="8977f-164">Manipulowanie</span><span class="sxs-lookup"><span data-stu-id="8977f-164">Tampering</span></span>](../../../../docs/framework/wcf/feature-details/tampering.md)
- [<span data-ttu-id="8977f-165">Nieobsługiwane scenariusze</span><span class="sxs-lookup"><span data-stu-id="8977f-165">Unsupported Scenarios</span></span>](../../../../docs/framework/wcf/feature-details/unsupported-scenarios.md)
