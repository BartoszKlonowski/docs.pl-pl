---
title: Podniesienie uprawnień
ms.date: 03/30/2017
helpviewer_keywords:
- elevation of privilege [WCF]
- security [WCF], elevation of privilege
ms.assetid: 146e1c66-2a76-4ed3-98a5-fd77851a06d9
ms.openlocfilehash: fd5829d2dbb1853bf65f1f6e402b918137bd59e3
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/08/2019
ms.locfileid: "59099992"
---
# <a name="elevation-of-privilege"></a><span data-ttu-id="16f65-102">Podniesienie uprawnień</span><span class="sxs-lookup"><span data-stu-id="16f65-102">Elevation of Privilege</span></span>
<span data-ttu-id="16f65-103">*Podniesienie uprawnień* powstały na skutek zapewniając autoryzacji osoba atakująca uprawnień poza tymi początkowo udzielone.</span><span class="sxs-lookup"><span data-stu-id="16f65-103">*Elevation of privilege* results from giving an attacker authorization permissions beyond those initially granted.</span></span> <span data-ttu-id="16f65-104">Na przykład osoba atakująca z zestawem uprawnień uprawnienia "tylko do odczytu" jakiś sposób podnosi poziom uprawnień zestawu do uwzględnienia "odczytu i zapisu."</span><span class="sxs-lookup"><span data-stu-id="16f65-104">For example, an attacker with a privilege set of "read only" permissions somehow elevates the set to include "read and write."</span></span>  
  
## <a name="trusted-sts-should-sign-saml-token-claims"></a><span data-ttu-id="16f65-105">Zaufana Usługa STS Utwórz oświadczeń tokenu SAML</span><span class="sxs-lookup"><span data-stu-id="16f65-105">Trusted STS Should Sign SAML Token Claims</span></span>  
 <span data-ttu-id="16f65-106">Token potwierdzenia języka SAML (Security Markup) jest ogólny token XML, który jest domyślnym typem wystawianych tokenów.</span><span class="sxs-lookup"><span data-stu-id="16f65-106">A Security Assertions Markup Language (SAML) token is a generic XML token that is the default type for issued tokens.</span></span> <span data-ttu-id="16f65-107">SAML token można konstruować przez Usługa tokenu zabezpieczającego (STS) uznającego końcowych usługi sieci Web w typowej programu exchange.</span><span class="sxs-lookup"><span data-stu-id="16f65-107">A SAML token can be constructed by a Security Token Service (STS) that the end Web service trusts in a typical exchange.</span></span> <span data-ttu-id="16f65-108">Tokeny SAML zawierają oświadczenia w instrukcjach.</span><span class="sxs-lookup"><span data-stu-id="16f65-108">SAML tokens contain claims in statements.</span></span> <span data-ttu-id="16f65-109">Osoba atakująca może skopiować oświadczenia z prawidłowym tokenem, Utwórz nowy token SAML i podpisać ją przy użyciu różnych wystawcy.</span><span class="sxs-lookup"><span data-stu-id="16f65-109">An attacker may copy the claims from a valid token, create a new SAML token, and sign it with a different issuer.</span></span> <span data-ttu-id="16f65-110">Celem jest określić, czy serwer jest sprawdzania poprawności wystawcy, a jeśli nie, korzystanie z słabość do konstruowania tokeny SAML, zezwalających na uprawnienia poza te zamierzony przez usługę STS zaufanych.</span><span class="sxs-lookup"><span data-stu-id="16f65-110">The intent is to determine whether the server is validating issuers and, if not, utilize the weakness to construct SAML tokens that allow privileges beyond those intended by a trusted STS.</span></span>  
  
 <span data-ttu-id="16f65-111"><xref:System.IdentityModel.Tokens.SamlAssertion> Klasy weryfikuje podpis cyfrowy zawartych w tokenie języka SAML i domyślnego <xref:System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator> wymaga podpisania tokeny SAML, certyfikat X.509, który jest nieprawidłowy, gdy <xref:System.ServiceModel.Security.IssuedTokenServiceCredential.CertificateValidationMode%2A> z <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> klasy jest ustawiona na <xref:System.ServiceModel.Security.X509CertificateValidationMode.ChainTrust>.</span><span class="sxs-lookup"><span data-stu-id="16f65-111">The <xref:System.IdentityModel.Tokens.SamlAssertion> class verifies the digital signature contained within a SAML token, and the default <xref:System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator> requires that SAML tokens be signed by an X.509 certificate that is valid when the <xref:System.ServiceModel.Security.IssuedTokenServiceCredential.CertificateValidationMode%2A> of the <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> class is set to <xref:System.ServiceModel.Security.X509CertificateValidationMode.ChainTrust>.</span></span> `ChainTrust` <span data-ttu-id="16f65-112">Tryb samego jest za mała, aby ustalić, czy wystawca SAML token jest zaufany.</span><span class="sxs-lookup"><span data-stu-id="16f65-112">mode alone is insufficient to determine whether the issuer of the SAML token is trusted.</span></span> <span data-ttu-id="16f65-113">Usługi, które wymagają bardziej szczegółowy model zaufania można albo użyć autoryzacji i wymuszanie zasad do sprawdzanych wystawcy zestawów oświadczeń produkowane przez uwierzytelnianie przy użyciu tokenów wystawionych lub ustawienia weryfikacji X.509 na <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> ograniczyć zestaw dozwolone certyfikaty podpisywania.</span><span class="sxs-lookup"><span data-stu-id="16f65-113">Services that require a more granular trust model can either use authorization and enforcement policies to check the issuer of the claim sets produced by issued token authentication or use the X.509 validation settings on <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> to restrict the set of allowed signing certificates.</span></span> <span data-ttu-id="16f65-114">Aby uzyskać więcej informacji, zobacz [Zarządzanie oświadczeniami i autoryzacją za pomocą modelu tożsamości](../../../../docs/framework/wcf/feature-details/managing-claims-and-authorization-with-the-identity-model.md) i [Federacja i wystawione tokeny](../../../../docs/framework/wcf/feature-details/federation-and-issued-tokens.md).</span><span class="sxs-lookup"><span data-stu-id="16f65-114">For more information, see [Managing Claims and Authorization with the Identity Model](../../../../docs/framework/wcf/feature-details/managing-claims-and-authorization-with-the-identity-model.md) and [Federation and Issued Tokens](../../../../docs/framework/wcf/feature-details/federation-and-issued-tokens.md).</span></span>  
  
## <a name="switching-identity-without-a-security-context"></a><span data-ttu-id="16f65-115">Przełączanie tożsamości bez kontekstu zabezpieczeń</span><span class="sxs-lookup"><span data-stu-id="16f65-115">Switching Identity Without a Security Context</span></span>  
 <span data-ttu-id="16f65-116">Następujące ma zastosowanie tylko do [!INCLUDE[vstecwinfx](../../../../includes/vstecwinfx-md.md)].</span><span class="sxs-lookup"><span data-stu-id="16f65-116">The following applies only to [!INCLUDE[vstecwinfx](../../../../includes/vstecwinfx-md.md)].</span></span>  
  
 <span data-ttu-id="16f65-117">Po nawiązaniu połączenia między klientem i serwerem oraz tożsamości klienta nie zmienia się, z wyjątkiem sytuacji: po otwarciu klienta WCF, jeśli spełnione są wszystkie następujące warunki:</span><span class="sxs-lookup"><span data-stu-id="16f65-117">When a connection is established between a client and server, the identity of the client does not change, except in one situation: after the WCF client is opened, if all of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="16f65-118">Procedury ustanawiania kontekstu zabezpieczeń (przy użyciu zabezpieczeń transport, sesji lub sesji zabezpieczeń wiadomości) jest wyłączany (<xref:System.ServiceModel.NonDualMessageSecurityOverHttp.EstablishSecurityContext%2A> właściwość jest ustawiona na `false` przypadku zabezpieczenia wiadomości lub niezdolnych do ustanawiania zabezpieczeń transportu sesje są używane w przypadku zabezpieczeń transportu.</span><span class="sxs-lookup"><span data-stu-id="16f65-118">The procedures to establish a security context (using a transport security session or message security session) is switched off (<xref:System.ServiceModel.NonDualMessageSecurityOverHttp.EstablishSecurityContext%2A> property is set to `false` in case of message security or transport not capable of establishing security sessions is used in transport security case.</span></span> <span data-ttu-id="16f65-119">Protokół HTTPS jest przykładem takiego transportu).</span><span class="sxs-lookup"><span data-stu-id="16f65-119">HTTPS is one example of such transport).</span></span>  
  
-   <span data-ttu-id="16f65-120">Korzystasz z uwierzytelniania Windows.</span><span class="sxs-lookup"><span data-stu-id="16f65-120">You are using Windows authentication.</span></span>  
  
-   <span data-ttu-id="16f65-121">Nie używaj jawne poświadczenia.</span><span class="sxs-lookup"><span data-stu-id="16f65-121">You do not explicitly set the credential.</span></span>  
  
-   <span data-ttu-id="16f65-122">Wywołujesz usługi w obszarze spersonifikowanym kontekście zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="16f65-122">You are calling the service under the impersonated security context.</span></span>  
  
 <span data-ttu-id="16f65-123">Jeśli te warunki są spełnione, to tożsamość używana do uwierzytelniania klienta do usługi mogą ulec zmianie (może nie być personifikowanej tożsamości, ale tożsamość procesu zamiast) po otwarciu klienta platformy WCF.</span><span class="sxs-lookup"><span data-stu-id="16f65-123">If these conditions are true, the identity used to authenticate the client to the service might change (it might not be the impersonated identity but the process identity instead) after the WCF client is opened.</span></span> <span data-ttu-id="16f65-124">Dzieje się tak, ponieważ poświadczenia Windows używane do uwierzytelniania klienta do usługi są przesyłane za pomocą każdej wiadomości i poświadczeń używanych do uwierzytelniania są uzyskiwane z bieżącego wątku Windows tożsamości.</span><span class="sxs-lookup"><span data-stu-id="16f65-124">This occurs because the Windows credential used to authenticate the client to the service is transmitted with every message, and the credential used for authentication is obtained from the current thread's Windows identity.</span></span> <span data-ttu-id="16f65-125">Jeśli zmieni tożsamość Windows bieżącego wątku (na przykład, Personifikując inny obiekt wywołujący), poświadczeń, który jest dołączony do wiadomości i używany do uwierzytelniania klienta do usługi także mogą ulec zmianie.</span><span class="sxs-lookup"><span data-stu-id="16f65-125">If the Windows identity of the current thread changes (for example, by impersonating a different caller), the credential that is attached to the message and used to authenticate the client to the service might also change.</span></span>  
  
 <span data-ttu-id="16f65-126">Jeśli chcesz mieć deterministyczne zachowanie podczas korzystania z uwierzytelniania Windows wraz z personifikacji należy jawnie ustawić poświadczenia Windows, lub należy ustanowić kontekstu zabezpieczeń w usłudze.</span><span class="sxs-lookup"><span data-stu-id="16f65-126">If you want to have deterministic behavior when using Windows authentication together with impersonation you need to explicitly set the Windows credential or you need to establish a security context with the service.</span></span> <span data-ttu-id="16f65-127">Aby to zrobić, należy użyć sesji zabezpieczeń wiadomości lub sesja zabezpieczeń transportu.</span><span class="sxs-lookup"><span data-stu-id="16f65-127">To do this, use a message security session or a transport security session.</span></span> <span data-ttu-id="16f65-128">Na przykład transportu net.tcp, może zapewnić sesji zabezpieczeń transportu.</span><span class="sxs-lookup"><span data-stu-id="16f65-128">For example, the net.tcp transport can provide a transport security session.</span></span> <span data-ttu-id="16f65-129">Ponadto podczas wywoływania usługi należy użyć synchroniczna wersja operacji klienta.</span><span class="sxs-lookup"><span data-stu-id="16f65-129">Additionally, you must use only a synchronous version of client operations when calling the service.</span></span> <span data-ttu-id="16f65-130">Jeśli ustanowisz kontekstu zabezpieczeń wiadomości, nie Zachowaj połączenie z usługą Otwórz dłuższy niż okres odnawiania skonfigurowanych sesji, ponieważ tożsamość można również zmienić w procesie odnawiania sesji.</span><span class="sxs-lookup"><span data-stu-id="16f65-130">If you establish a message security context, you should not keep the connection to the service open longer than the configured session renewal period, because the identity can also change during the session renewal process.</span></span>  
  
### <a name="credentials-capture"></a><span data-ttu-id="16f65-131">Przechwycenie poświadczeń</span><span class="sxs-lookup"><span data-stu-id="16f65-131">Credentials Capture</span></span>  
 <span data-ttu-id="16f65-132">Poniższe uwagi dotyczą [!INCLUDE[netfx35_long](../../../../includes/netfx35-long-md.md)]i późniejszych wersjach.</span><span class="sxs-lookup"><span data-stu-id="16f65-132">The following applies to [!INCLUDE[netfx35_long](../../../../includes/netfx35-long-md.md)], and subsequent versions.</span></span>  
  
 <span data-ttu-id="16f65-133">Poświadczenia używane przez klienta lub usługi zależą od bieżącego wątku kontekstu.</span><span class="sxs-lookup"><span data-stu-id="16f65-133">Credentials used by the client or the service are based on the current context thread.</span></span> <span data-ttu-id="16f65-134">Poświadczenia są uzyskiwane podczas `Open` — metoda (lub `BeginOpen`, na wywołania asynchroniczne) klienta lub usługi jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="16f65-134">The credentials are obtained when the `Open` method (or `BeginOpen`, for asynchronous calls) of the client or service is called.</span></span> <span data-ttu-id="16f65-135">Dla obu <xref:System.ServiceModel.ServiceHost> i <xref:System.ServiceModel.ClientBase%601> klas, `Open` i `BeginOpen` metody dziedziczyć <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> i <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> metody <xref:System.ServiceModel.Channels.CommunicationObject> klasy.</span><span class="sxs-lookup"><span data-stu-id="16f65-135">For both the <xref:System.ServiceModel.ServiceHost> and <xref:System.ServiceModel.ClientBase%601> classes, the `Open` and `BeginOpen` methods inherit from the <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> and <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> methods of the <xref:System.ServiceModel.Channels.CommunicationObject> class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="16f65-136">Korzystając z `BeginOpen` metody, nie można zagwarantować poświadczenia przechwytywane do poświadczenia procesu, który wywołuje metodę.</span><span class="sxs-lookup"><span data-stu-id="16f65-136">When using the `BeginOpen` method, the credentials captured cannot be guaranteed to be the credentials of the process that calls the method.</span></span>  
  
## <a name="token-caches-allow-replay-using-obsolete-data"></a><span data-ttu-id="16f65-137">Pamięci podręczne tokenu umożliwia powtarzanie przy użyciu przestarzałe dane</span><span class="sxs-lookup"><span data-stu-id="16f65-137">Token Caches Allow Replay Using Obsolete Data</span></span>  
 <span data-ttu-id="16f65-138">Urząd zabezpieczeń lokalnych (LSA) korzysta z usługi WCF `LogonUser` funkcję, aby uwierzytelniać użytkowników według nazwy użytkownika i hasło.</span><span class="sxs-lookup"><span data-stu-id="16f65-138">WCF uses the local security authority (LSA) `LogonUser` function to authenticate users by user name and password.</span></span> <span data-ttu-id="16f65-139">Ponieważ funkcja logowania jest kosztowna operacja, WCF umożliwia do pamięci podręcznej tokenów, które reprezentują uwierzytelnionych użytkowników, co pozwoli zwiększyć wydajność.</span><span class="sxs-lookup"><span data-stu-id="16f65-139">Because the logon function is a costly operation, WCF allows you to cache tokens that represent authenticated users to increase performance.</span></span> <span data-ttu-id="16f65-140">Mechanizm buforowania zapisuje wyniki z `LogonUser` do późniejszego wykorzystania.</span><span class="sxs-lookup"><span data-stu-id="16f65-140">The caching mechanism saves the results from `LogonUser` for subsequent uses.</span></span> <span data-ttu-id="16f65-141">Ten mechanizm jest domyślnie wyłączona; Aby ją włączyć, ustaw <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CacheLogonTokens%2A> właściwości `true`, lub użyj `cacheLogonTokens` atrybutu [ \<userNameAuthentication >](../../../../docs/framework/configure-apps/file-schema/wcf/usernameauthentication.md).</span><span class="sxs-lookup"><span data-stu-id="16f65-141">This mechanism is disabled by default; to enable it, set the <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CacheLogonTokens%2A> property to `true`, or use the `cacheLogonTokens` attribute of the [\<userNameAuthentication>](../../../../docs/framework/configure-apps/file-schema/wcf/usernameauthentication.md).</span></span>  
  
 <span data-ttu-id="16f65-142">Można ustawić czas wygaśnięcia (TTL) dla pamięci podręcznej tokeny, ustawiając <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CachedLogonTokenLifetime%2A> właściwości <xref:System.TimeSpan>, lub użyj `cachedLogonTokenLifetime` atrybutu `userNameAuthentication` element; wartość domyślna to 15 minut.</span><span class="sxs-lookup"><span data-stu-id="16f65-142">You can set a Time to Live (TTL) for the cached tokens by setting the <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CachedLogonTokenLifetime%2A> property to a <xref:System.TimeSpan>, or use the `cachedLogonTokenLifetime` attribute of the `userNameAuthentication` element; the default is 15 minutes.</span></span> <span data-ttu-id="16f65-143">Pamiętaj, że gdy token są buforowane, każdy klient, który przedstawia informacje o tej samej nazwy użytkownika i hasła można używać tokenu, nawet, jeśli konto użytkownika zostanie usunięte z Windows lub zmieniono jego hasło.</span><span class="sxs-lookup"><span data-stu-id="16f65-143">Note that while a token is cached, any client that presents the same user name and password can use the token, even if the user account is deleted from Windows or if its password has been changed.</span></span> <span data-ttu-id="16f65-144">Do momentu wygaśnięcia i token zostanie usunięty z pamięci podręcznej, WCF umożliwia uwierzytelnienia użytkownika (potencjalnie złośliwego).</span><span class="sxs-lookup"><span data-stu-id="16f65-144">Until the TTL expires and the token is removed from the cache, WCF allows the (possibly malicious) user to authenticate.</span></span>  
  
 <span data-ttu-id="16f65-145">Aby rozwiązać ten problem: Zmniejsz okna ataku, ustawiając `cachedLogonTokenLifetime` wartość przez jak najkrótszy czas span Twoich potrzeb użytkowników.</span><span class="sxs-lookup"><span data-stu-id="16f65-145">To mitigate this: Decrease the attack window by setting the `cachedLogonTokenLifetime` value to the shortest time span your users need.</span></span>  
  
## <a name="issued-token-authorization-expiration-reset-to-large-value"></a><span data-ttu-id="16f65-146">Wystawiony Token autoryzacji: Resetowanie wygaśnięcia duża wartość</span><span class="sxs-lookup"><span data-stu-id="16f65-146">Issued Token Authorization: Expiration Reset to Large Value</span></span>  
 <span data-ttu-id="16f65-147">Pod pewnymi warunkami <xref:System.IdentityModel.Policy.AuthorizationContext.ExpirationTime%2A> właściwość <xref:System.IdentityModel.Policy.AuthorizationContext> może być ustawiona na wartość nieoczekiwanie większe ( <xref:System.DateTime.MaxValue> pola wartości, minus jeden dzień lub 20 grudnia 9999).</span><span class="sxs-lookup"><span data-stu-id="16f65-147">Under certain conditions, the <xref:System.IdentityModel.Policy.AuthorizationContext.ExpirationTime%2A> property of the <xref:System.IdentityModel.Policy.AuthorizationContext> may be set to an unexpectedly larger value (the <xref:System.DateTime.MaxValue> field value minus one day, or December 20, 9999).</span></span>  
  
 <span data-ttu-id="16f65-148">Ten problem wystąpi w przypadku korzystania z <xref:System.ServiceModel.WSFederationHttpBinding> i żadnego powiązania dostarczane przez system, które mają wystawiony token, którego typ poświadczeń.</span><span class="sxs-lookup"><span data-stu-id="16f65-148">This occurs when using the <xref:System.ServiceModel.WSFederationHttpBinding> and any of the system-provided bindings that have an issued token as the client credential type.</span></span>  
  
 <span data-ttu-id="16f65-149">Dzieje się tak również podczas tworzenia powiązań niestandardowych przy użyciu jednej z następujących metod:</span><span class="sxs-lookup"><span data-stu-id="16f65-149">This also occurs when you create custom bindings by using one of the following methods:</span></span>  
  
-   <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenBindingElement%2A>  
  
-   <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForCertificateBindingElement%2A>  
  
-   <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForSslBindingElement%2A>  
  
-   <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenOverTransportBindingElement%2A>  
  
 <span data-ttu-id="16f65-150">Aby rozwiązać ten problem, zasady autoryzacji sprawdzić akcji i czas wygaśnięcia poszczególnych zasad autoryzacji.</span><span class="sxs-lookup"><span data-stu-id="16f65-150">To mitigate this, the authorization policy must check the action and the expiration time of each authorization policy.</span></span>  
  
## <a name="the-service-uses-a-different-certificate-than-the-client-intended"></a><span data-ttu-id="16f65-151">Usługa używa innego certyfikatu niż zamierzano klienta</span><span class="sxs-lookup"><span data-stu-id="16f65-151">The Service Uses a Different Certificate Than the Client Intended</span></span>  
 <span data-ttu-id="16f65-152">Pod pewnymi warunkami klienta można cyfrowego podpisywania wiadomości za pomocą certyfikatu X.509 i usługa pobieranie certyfikatu innego niż zamierzony.</span><span class="sxs-lookup"><span data-stu-id="16f65-152">Under certain conditions, a client can digitally sign a message with an X.509 certificate and have the service retrieve a different certificate than the intended one.</span></span>  
  
 <span data-ttu-id="16f65-153">Taka sytuacja może wystąpić w następujących okolicznościach:</span><span class="sxs-lookup"><span data-stu-id="16f65-153">This can occur under the following circumstances:</span></span>  
  
-   <span data-ttu-id="16f65-154">Klient podpisuje cyfrowo komunikat przy użyciu certyfikatu X.509 nie dołączy certyfikatu X.509 do wiadomości, a zamiast po prostu odwołuje się do certyfikatu, używając swojego identyfikatora klucza podmiotu.</span><span class="sxs-lookup"><span data-stu-id="16f65-154">The client digitally signs a message using an X.509 certificate and does not attach the X.509 certificate to the message, but rather just references the certificate using its subject key identifier.</span></span>  
  
-   <span data-ttu-id="16f65-155">Komputer z usługą zawiera co najmniej dwóch certyfikatów przy użyciu tego samego klucza publicznego, ale mogą zawierać różne informacje.</span><span class="sxs-lookup"><span data-stu-id="16f65-155">The service's computer contains two or more certificates with the same public key, but they contain different information.</span></span>  
  
-   <span data-ttu-id="16f65-156">Usługa pobiera certyfikat, który pasuje do identyfikatora klucza podmiotu, ale nie jest ten, który klient jest przeznaczony do użycia.</span><span class="sxs-lookup"><span data-stu-id="16f65-156">The service retrieves a certificate that matches the subject key identifier, but it is not the one the client intended to use.</span></span> <span data-ttu-id="16f65-157">Gdy WCF odbiera komunikat i weryfikuje podpis, WCF mapuje informacje zawarte w niezamierzony certyfikatu X.509 do zestawu oświadczeń, które są różne i potencjalnie z podwyższonym poziomem uprawnień z oczekiwaniami klienta.</span><span class="sxs-lookup"><span data-stu-id="16f65-157">When WCF receives the message and verifies the signature, WCF maps the information in the unintended X.509 certificate to a set of claims that are different and potentially elevated from what the client expected.</span></span>  
  
 <span data-ttu-id="16f65-158">Aby temu zaradzić, odwołanie X.509 certyfikatu inny sposób, na przykład za pomocą <xref:System.ServiceModel.Security.Tokens.X509KeyIdentifierClauseType.IssuerSerial>.</span><span class="sxs-lookup"><span data-stu-id="16f65-158">To mitigate this, reference the X.509 certificate another way, such as using <xref:System.ServiceModel.Security.Tokens.X509KeyIdentifierClauseType.IssuerSerial>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="16f65-159">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="16f65-159">See also</span></span>

- [<span data-ttu-id="16f65-160">Zagadnienia dotyczące zabezpieczeń</span><span class="sxs-lookup"><span data-stu-id="16f65-160">Security Considerations</span></span>](../../../../docs/framework/wcf/feature-details/security-considerations-in-wcf.md)
- [<span data-ttu-id="16f65-161">Ujawnianie informacji</span><span class="sxs-lookup"><span data-stu-id="16f65-161">Information Disclosure</span></span>](../../../../docs/framework/wcf/feature-details/information-disclosure.md)
- [<span data-ttu-id="16f65-162">Odmowa usługi</span><span class="sxs-lookup"><span data-stu-id="16f65-162">Denial of Service</span></span>](../../../../docs/framework/wcf/feature-details/denial-of-service.md)
- [<span data-ttu-id="16f65-163">Ataki oparte na metodzie powtórzeń</span><span class="sxs-lookup"><span data-stu-id="16f65-163">Replay Attacks</span></span>](../../../../docs/framework/wcf/feature-details/replay-attacks.md)
- [<span data-ttu-id="16f65-164">Manipulowanie</span><span class="sxs-lookup"><span data-stu-id="16f65-164">Tampering</span></span>](../../../../docs/framework/wcf/feature-details/tampering.md)
- [<span data-ttu-id="16f65-165">Nieobsługiwane scenariusze</span><span class="sxs-lookup"><span data-stu-id="16f65-165">Unsupported Scenarios</span></span>](../../../../docs/framework/wcf/feature-details/unsupported-scenarios.md)
