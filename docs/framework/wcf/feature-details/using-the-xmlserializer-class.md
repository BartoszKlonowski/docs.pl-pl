---
title: Używanie klasy XmlSerializer
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- XmlSerializer [WCF], using
ms.assetid: c680602d-39d3-44f1-bf22-8e6654ad5069
ms.openlocfilehash: 29ce9b165c3823d7d06008431294f67716ccf8e1
ms.sourcegitcommit: 0be8a279af6d8a43e03141e349d3efd5d35f8767
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/18/2019
ms.locfileid: "59105446"
---
# <a name="using-the-xmlserializer-class"></a><span data-ttu-id="a2fb4-102">Używanie klasy XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="a2fb4-102">Using the XmlSerializer Class</span></span>
<span data-ttu-id="a2fb4-103">Windows Communication Foundation (WCF) można użyć dwóch technologii serializacji w różnych, aby przekształcać dane w aplikacji do formatu XML, które są przesyłane między klientami i usług, w procesie zwanym serializacji.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-103">Windows Communication Foundation (WCF) can use two different serialization technologies to turn the data in your application into XML that is transmitted between clients and services, a process called serialization.</span></span>  
  
## <a name="datacontractserializer-as-the-default"></a><span data-ttu-id="a2fb4-104">DataContractSerializer jako domyślny</span><span class="sxs-lookup"><span data-stu-id="a2fb4-104">DataContractSerializer as the Default</span></span>  
 <span data-ttu-id="a2fb4-105">Domyślnie używa WCF <xref:System.Runtime.Serialization.DataContractSerializer> klasy do serializacji typów danych.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-105">By default WCF uses the <xref:System.Runtime.Serialization.DataContractSerializer> class to serialize data types.</span></span> <span data-ttu-id="a2fb4-106">Przez ten serializator obsługuje następujące typy:</span><span class="sxs-lookup"><span data-stu-id="a2fb4-106">This serializer supports the following types:</span></span>  
  
-   <span data-ttu-id="a2fb4-107">Typy pierwotne (na przykład liczby całkowite, ciągi i bajtów tablice), a także niektóre typy specjalne, takie jak <xref:System.Xml.XmlElement> i <xref:System.DateTime>, które są traktowane jako elementów podstawowych.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-107">Primitive types (for example, integers, strings, and byte arrays), as well as some special types, such as <xref:System.Xml.XmlElement> and <xref:System.DateTime>, which are treated as primitives.</span></span>  
  
-   <span data-ttu-id="a2fb4-108">Typy kontraktów danych (typy oznaczone <xref:System.Runtime.Serialization.DataContractAttribute> atrybutu).</span><span class="sxs-lookup"><span data-stu-id="a2fb4-108">Data contract types (types marked with the <xref:System.Runtime.Serialization.DataContractAttribute> attribute).</span></span>  
  
-   <span data-ttu-id="a2fb4-109">Typy oznaczone <xref:System.SerializableAttribute> atrybut, który zawierają typami, które implementują <xref:System.Runtime.Serialization.ISerializable> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-109">Types marked with the <xref:System.SerializableAttribute> attribute, which include types that implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span>  
  
-   <span data-ttu-id="a2fb4-110">Typami, które implementują <xref:System.Xml.Serialization.IXmlSerializable> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-110">Types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>  
  
-   <span data-ttu-id="a2fb4-111">Wiele typowych kolekcji typów, które obejmują wiele typów kolekcji ogólnej.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-111">Many common collection types, which include many generic collection types.</span></span>  
  
 <span data-ttu-id="a2fb4-112">Wiele [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] typów można podzielić na dwie ostatnie kategorie i dlatego są możliwe do serializacji.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-112">Many [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] types fall into the latter two categories and are thus serializable.</span></span> <span data-ttu-id="a2fb4-113">Tablice typów możliwych do serializacji są również możliwe do serializacji.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-113">Arrays of serializable types are also serializable.</span></span> <span data-ttu-id="a2fb4-114">Aby uzyskać pełną listę, zobacz [Określanie transferu danych w kontraktach usług](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="a2fb4-114">For a complete list, see [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).</span></span>  
  
 <span data-ttu-id="a2fb4-115"><xref:System.Runtime.Serialization.DataContractSerializer>, Używana wraz z danymi typy kontraktu, jest zalecanym sposobem pisania nowych usług WCF.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-115">The <xref:System.Runtime.Serialization.DataContractSerializer>, used together with data contract types, is the recommended way to write new WCF services.</span></span> <span data-ttu-id="a2fb4-116">Aby uzyskać więcej informacji, zobacz [za pomocą kontraktów danych](../../../../docs/framework/wcf/feature-details/using-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="a2fb4-116">For more information, see [Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md).</span></span>  
  
## <a name="when-to-use-the-xmlserializer-class"></a><span data-ttu-id="a2fb4-117">Kiedy należy używać klasy XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="a2fb4-117">When to Use the XmlSerializer Class</span></span>  
 <span data-ttu-id="a2fb4-118">Obsługuje również WCF <xref:System.Xml.Serialization.XmlSerializer> klasy.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-118">WCF also supports the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="a2fb4-119"><xref:System.Xml.Serialization.XmlSerializer> Klasy nie jest unikatowy dla usługi WCF.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-119">The <xref:System.Xml.Serialization.XmlSerializer> class is not unique to WCF.</span></span> <span data-ttu-id="a2fb4-120">Serializacja tego samego aparatu, który jest [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] użycia usług sieci Web.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-120">It is the same serialization engine that [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] Web services use.</span></span> <span data-ttu-id="a2fb4-121"><xref:System.Xml.Serialization.XmlSerializer> Klasa obsługuje znacznie mniejszą niż zestaw typów niż <xref:System.Runtime.Serialization.DataContractSerializer> klasy, ale zapewnia większą kontrolę nad wynikowy kod XML i obsługuje znacznie więcej język definicji schematu XML (XSD) standardowa.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-121">The <xref:System.Xml.Serialization.XmlSerializer> class supports a much narrower set of types than the <xref:System.Runtime.Serialization.DataContractSerializer> class, but allows much more control over the resulting XML and supports much more of the XML Schema definition language (XSD) standard.</span></span> <span data-ttu-id="a2fb4-122">Ponadto nie wymaga żadnych deklaratywne atrybuty typów możliwych do serializacji.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-122">It also does not require any declarative attributes on the serializable types.</span></span> <span data-ttu-id="a2fb4-123">Aby uzyskać więcej informacji, zobacz temat serializacji XML w [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] dokumentacji.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-123">For more information, see the XML Serialization topic in the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] documentation.</span></span> <span data-ttu-id="a2fb4-124"><xref:System.Xml.Serialization.XmlSerializer> Klasa nie obsługuje typy kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-124">The <xref:System.Xml.Serialization.XmlSerializer> class does not support data contract types.</span></span>  
  
 <span data-ttu-id="a2fb4-125">Korzystając z Svcutil.exe lub **Dodaj odwołanie do usługi** funkcji w programie Visual Studio do generowania kodu klienta dla usługi innych firm oraz do schematów innych firm, odpowiedni element serializujący została wybrana automatycznie.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-125">When using Svcutil.exe or the **Add Service Reference** feature in Visual Studio to generate client code for a third-party service, or to access a third-party schema, an appropriate serializer is automatically selected for you.</span></span> <span data-ttu-id="a2fb4-126">Jeśli schemat nie jest zgodny z <xref:System.Runtime.Serialization.DataContractSerializer>, <xref:System.Xml.Serialization.XmlSerializer> jest zaznaczone.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-126">If the schema is not compatible with the <xref:System.Runtime.Serialization.DataContractSerializer>, the <xref:System.Xml.Serialization.XmlSerializer> is selected.</span></span>  
  
## <a name="manually-switching-to-the-xmlserializer"></a><span data-ttu-id="a2fb4-127">Ręczne przełączanie się do elementu XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="a2fb4-127">Manually Switching to the XmlSerializer</span></span>  
 <span data-ttu-id="a2fb4-128">Czasami może być konieczne ręcznie przełączysz się do <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-128">At times, you may have to manually switch to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="a2fb4-129">Dzieje się tak, na przykład w następujących przypadkach:</span><span class="sxs-lookup"><span data-stu-id="a2fb4-129">This happens, for example, in the following cases:</span></span>  
  
-   <span data-ttu-id="a2fb4-130">Podczas migracji aplikacji z [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] usług sieci Web WCF, może zajść potrzeba ponownego użycia istniejącej, <xref:System.Xml.Serialization.XmlSerializer>— typy kontraktów zgodnych typów, zamiast tworzyć nowe dane.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-130">When migrating an application from [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] Web services to WCF, you may want to reuse existing, <xref:System.Xml.Serialization.XmlSerializer>-compatible types instead of creating new data contract types.</span></span>  
  
-   <span data-ttu-id="a2fb4-131">Gdy precyzyjną kontrolę nad tym XML, który pojawia się w wiadomościach jest ważne, ale dokument usługi sieci Web Services Description Language (WSDL) nie jest dostępny, na przykład podczas tworzenia usługi przy użyciu typów, które mają się pewnych standardowych, opublikowanych schematu to nie jest zgodna z elementu DataContractSerializer.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-131">When precise control over the XML that appears in messages is important, but a Web Services Description Language (WSDL) document is not available, for example, when creating a service with types that have to comply to a certain standardized, published schema that is not compatible with the DataContractSerializer.</span></span>  
  
-   <span data-ttu-id="a2fb4-132">Podczas tworzenia usługi, które są zgodne ze standardem starszych kodowaniem SOAP.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-132">When creating services that follow the legacy SOAP Encoding standard.</span></span>  
  
 <span data-ttu-id="a2fb4-133">W tych i innych przypadkach, można ręcznie przełączysz się do <xref:System.Xml.Serialization.XmlSerializer> klasy, stosując `XmlSerializerFormatAttribute` atrybutu do swojej usługi, jak pokazano w poniższym kodzie.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-133">In these and other cases, you can manually switch to the <xref:System.Xml.Serialization.XmlSerializer> class by applying the `XmlSerializerFormatAttribute` attribute to your service, as shown in the following code.</span></span>  
  
 [!code-csharp[c_XmlSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#1)]
 [!code-vb[c_XmlSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#1)]  
  
## <a name="security-considerations"></a><span data-ttu-id="a2fb4-134">Zagadnienia dotyczące zabezpieczeń</span><span class="sxs-lookup"><span data-stu-id="a2fb4-134">Security Considerations</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a2fb4-135">Koniecznie należy zachować ostrożność podczas przełączania aparatów serializacji.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-135">It is important to be careful when switching serialization engines.</span></span> <span data-ttu-id="a2fb4-136">Ten sam typ może wykonywać serializację do pliku XML inaczej w zależności od serializator używany.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-136">The same type can serialize to XML differently depending on the serializer being used.</span></span> <span data-ttu-id="a2fb4-137">Korzystając z przypadkiem niewłaściwy serializator, może być ujawnieniu informacji z typu, który nie ma konieczności ujawnienia.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-137">If you accidentally use the wrong serializer, you might be disclosing information from the type that you did not intend to disclose.</span></span>  
  
 <span data-ttu-id="a2fb4-138">Na przykład <xref:System.Runtime.Serialization.DataContractSerializer> klasy serializuje tylko składowe oznaczone za pomocą <xref:System.Runtime.Serialization.DataMemberAttribute> atrybutu podczas serializacji typy kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-138">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> class only serializes members marked with the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute when serializing data contract types.</span></span> <span data-ttu-id="a2fb4-139"><xref:System.Xml.Serialization.XmlSerializer> Klasy serializuje żadnego publicznego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-139">The <xref:System.Xml.Serialization.XmlSerializer> class serializes any public member.</span></span> <span data-ttu-id="a2fb4-140">Zobacz typ w poniższym kodzie.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-140">See the type in the following code.</span></span>  
  
 [!code-csharp[c_XmlSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#2)]
 [!code-vb[c_XmlSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#2)]  
  
 <span data-ttu-id="a2fb4-141">Jeśli typ jest nieodwracalnie używany w kontrakcie usługi gdzie <xref:System.Xml.Serialization.XmlSerializer> wybrano klasy `creditCardNumber` elementu członkowskiego jest serializowana, który prawdopodobnie nie jest przeznaczony.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-141">If the type is inadvertently used in a service contract where the <xref:System.Xml.Serialization.XmlSerializer> class is selected, the `creditCardNumber` member is serialized, which is probably not intended.</span></span>  
  
 <span data-ttu-id="a2fb4-142">Mimo że <xref:System.Runtime.Serialization.DataContractSerializer> klasy jest ustawieniem domyślnym, możesz jawnie wybrać go dla usługi (mimo że to nigdy nie powinno być wymagane), stosując <xref:System.ServiceModel.DataContractFormatAttribute> atrybutu typu kontraktu usługi.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-142">Even though the <xref:System.Runtime.Serialization.DataContractSerializer> class is the default, you can explicitly select it for your service (although doing this should never be required) by applying the <xref:System.ServiceModel.DataContractFormatAttribute> attribute to the service contract type.</span></span>  
  
 <span data-ttu-id="a2fb4-143">Serializator używany przez usługę jest integralną częścią kontraktu i nie można zmienić, wybierając inne powiązanie lub zmieniając innych ustawień konfiguracyjnych.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-143">The serializer used for the service is an integral part of the contract and cannot be changed by selecting a different binding or by changing other configuration settings.</span></span>  
  
 <span data-ttu-id="a2fb4-144">Inne ważne zagadnienia dotyczące bezpieczeństwa dotyczą <xref:System.Xml.Serialization.XmlSerializer> klasy.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-144">Other important security considerations apply to the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="a2fb4-145">Po pierwsze, zdecydowanie zaleca się że każda aplikacja usługi WCF, używa <xref:System.Xml.Serialization.XmlSerializer> klasy jest podpisany za pomocą klucza, które są chronione przed ujawnieniem.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-145">First, it is strongly recommended that any WCF application that uses the <xref:System.Xml.Serialization.XmlSerializer> class is signed with a key that is safeguarded from disclosure.</span></span> <span data-ttu-id="a2fb4-146">To zalecenie dotyczy zarówno podczas ręcznego przełączenia do <xref:System.Xml.Serialization.XmlSerializer> jest wykonywane i kiedy przełącznik automatyczne jest wykonywane (przez Svcutil.exe, Dodaj odwołanie do usługi lub podobnego narzędzia).</span><span class="sxs-lookup"><span data-stu-id="a2fb4-146">This recommendation applies both when a manual switch to the <xref:System.Xml.Serialization.XmlSerializer> is performed and when an automatic switch is performed (by Svcutil.exe, Add Service Reference, or a similar tool).</span></span> <span data-ttu-id="a2fb4-147">Jest to spowodowane <xref:System.Xml.Serialization.XmlSerializer> mechanizm serializacji obsługuje ładowanie *wstępnie wygenerowane zestawy serializacji* tak długo, jak są one podpisane za pomocą tego samego klucza, co aplikacja.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-147">This is because the <xref:System.Xml.Serialization.XmlSerializer> serialization engine supports the loading of *pre-generated serialization assemblies* as long as they are signed with the same key as the application.</span></span> <span data-ttu-id="a2fb4-148">Niepodpisana aplikacja nie jest całkowicie chroniony, z możliwością złośliwemu zestawowi pasującą do oczekiwanej nazwy zestawu wstępnie wygenerowanego serializacji, są umieszczane w folderze aplikacji lub w globalnej pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-148">An unsigned application is completely unprotected from the possibility of a malicious assembly matching the expected name of the pre-generated serialization assembly being placed in the application folder or the global assembly cache.</span></span> <span data-ttu-id="a2fb4-149">Oczywiście osoba atakująca musi najpierw uzyskać dostęp do zapisu do jednej z tych dwóch lokalizacjach próby tej akcji.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-149">Of course, an attacker must first gain write access to one of these two locations to attempt this action.</span></span>  
  
 <span data-ttu-id="a2fb4-150">Istnieje zawsze wtedy, gdy używasz innego zagrożenia <xref:System.Xml.Serialization.XmlSerializer> powiązany jest dostęp do zapisu do folderu tymczasowego systemu.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-150">Another threat that exists whenever you use <xref:System.Xml.Serialization.XmlSerializer> is related to write access to the system temporary folder.</span></span> <span data-ttu-id="a2fb4-151"><xref:System.Xml.Serialization.XmlSerializer> Mechanizm serializacji tworzenia i tymczasowego *zestawy serializacji* w tym folderze.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-151">The <xref:System.Xml.Serialization.XmlSerializer> serialization engine creates and uses temporary *serialization assemblies* in this folder.</span></span> <span data-ttu-id="a2fb4-152">Należy pamiętać, że żaden proces z dostępem do zapisu do folderu tymczasowego może zastąpić te zestawy serializacji złośliwego kodu.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-152">You should be aware that any process with write access to the temporary folder may overwrite these serialization assemblies with malicious code.</span></span>  
  
## <a name="rules-for-xmlserializer-support"></a><span data-ttu-id="a2fb4-153">Obsługuje reguły dla elementu XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="a2fb4-153">Rules for XmlSerializer support</span></span>  
 <span data-ttu-id="a2fb4-154">Nie można zastosować bezpośrednio <xref:System.Xml.Serialization.XmlSerializer>-niezgodne atrybuty kontrakt operacji parametrów lub zwracanych wartości.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-154">You cannot directly apply <xref:System.Xml.Serialization.XmlSerializer>-compatible attributes to contract operation parameters or return values.</span></span> <span data-ttu-id="a2fb4-155">Jednak one mogą być stosowane do wpisane wiadomości (części treści kontraktu komunikatu,) jak pokazano w poniższym kodzie.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-155">However, they can be applied to typed messages (message contract body parts), as shown in the following code.</span></span>  
  
 [!code-csharp[c_XmlSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#3)]
 [!code-vb[c_XmlSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#3)]  
  
 <span data-ttu-id="a2fb4-156">Gdy jest stosowany do elementów członkowskich wpisany komunikat, te atrybuty zastąpić właściwości, które powodują konflikt w atrybutach wpisany komunikat.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-156">When applied to typed message members, these attributes override properties that conflict on the typed message attributes.</span></span> <span data-ttu-id="a2fb4-157">Na przykład w poniższym kodzie `ElementName` zastępuje `Name`.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-157">For example, in the following code, `ElementName` overrides `Name`.</span></span>  
  
 [!code-csharp[c_XmlSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#4)]
 [!code-vb[c_XmlSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#4)]  
  
 <span data-ttu-id="a2fb4-158"><xref:System.ServiceModel.MessageHeaderArrayAttribute> Atrybut nie jest obsługiwany w przypadku korzystania z <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-158">The <xref:System.ServiceModel.MessageHeaderArrayAttribute> attribute is not supported when using the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a2fb4-159">W tym przypadku <xref:System.Xml.Serialization.XmlSerializer> zgłasza następujący wyjątek, który jest wydane przed WCF: "Element zadeklarowany na najwyższym poziomie schematu nie może mieć `maxOccurs` > 1.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-159">In this case, the <xref:System.Xml.Serialization.XmlSerializer> throws the following exception, which is released prior to WCF: "An element declared at the top level of a schema cannot have `maxOccurs` > 1.</span></span> <span data-ttu-id="a2fb4-160">Dostarcz element otoki, aby uzyskać więcej, korzystając z `XmlArray` lub `XmlArrayItem` zamiast `XmlElementAttribute`, lub używając stylu parametru Wrapped. "</span><span class="sxs-lookup"><span data-stu-id="a2fb4-160">Provide a wrapper element for 'more' by using `XmlArray` or `XmlArrayItem` instead of `XmlElementAttribute`, or by using the Wrapped parameter style."</span></span>  
>   
>  <span data-ttu-id="a2fb4-161">Jeśli wystąpi wyjątek od tej zasady należy zbadać, czy w takiej sytuacji.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-161">If you receive such an exception, investigate whether this situation applies.</span></span>  
  
 <span data-ttu-id="a2fb4-162">Usługi WCF nie obsługuje <xref:System.Xml.Serialization.SoapIncludeAttribute> i <xref:System.Xml.Serialization.XmlIncludeAttribute> umów dotyczących atrybutów w kontrakty komunikatów i operacji; użyj <xref:System.Runtime.Serialization.KnownTypeAttribute> zamiast tego atrybutu.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-162">WCF does not support the <xref:System.Xml.Serialization.SoapIncludeAttribute> and <xref:System.Xml.Serialization.XmlIncludeAttribute> attributes in message contracts and operation contracts; use the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute instead.</span></span>  
  
## <a name="types-that-implement-the-ixmlserializable-interface"></a><span data-ttu-id="a2fb4-163">Typy implementujące interfejs IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="a2fb4-163">Types that Implement the IXmlSerializable Interface</span></span>  
 <span data-ttu-id="a2fb4-164">Typami, które implementują `IXmlSerializable` interfejsu są w pełni obsługiwane przez `DataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-164">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="a2fb4-165"><xref:System.Xml.Serialization.XmlSchemaProviderAttribute> Zawsze można zastosować atrybutu do tych typów w celu kontrolowania swoich schematu.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-165">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="a2fb4-166">Jeśli są serializacji polimorficzne typy należy zastosować <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> do typu, aby zapewnić poprawny typ jest serializowana.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-166">If you are serializing polymorphic types you must apply the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> to the type to ensure the correct type is serialized.</span></span>  
  
 <span data-ttu-id="a2fb4-167">Istnieją trzy różne typy typy, które implementują `IXmlSerializable`: typy, które reprezentują arbitralnie wybrane typy zawartości, reprezentujących pojedynczy element, a starsza wersja <xref:System.Data.DataSet> typów.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-167">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>  
  
-   <span data-ttu-id="a2fb4-168">Typy zawartości, użyj metody dostawcy schemat określony przez `XmlSchemaProviderAttribute` atrybutu.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-168">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="a2fb4-169">Metoda nie zwraca `null` i <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> właściwości w atrybucie pozostanie ustawiony na wartość domyślną `false`.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-169">The method does not return `null` and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="a2fb4-170">Jest to najbardziej typowe użycie `IXmlSerializable` typów.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-170">This is the most common usage of `IXmlSerializable` types.</span></span>  
  
-   <span data-ttu-id="a2fb4-171">Typy elementów są używane podczas `IXmlSerializable` typu musi kontrolować własną nazwą elementu głównego.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-171">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="a2fb4-172">Aby oznaczyć typu jako typu elementu, ustaw wartość <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> właściwość <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> atrybutu `true` lub je zwracają `null` z metody dostawcy schematu.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-172">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return `null` from the schema provider method.</span></span> <span data-ttu-id="a2fb4-173">Posiadanie metody dostawcy schematu jest opcjonalne dla typów elementów — użytkownik może określić `null` zamiast nazwy metody w `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-173">Having a schema provider method is optional for element types – you may specify `null` instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="a2fb4-174">Jednak jeśli `IsAny` jest `true` i metody dostawcy schemat jest określony, metoda musi zwracać `null`.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-174">However, if `IsAny` is `true` and a schema provider method is specified, the method must return `null`.</span></span>  
  
-   <span data-ttu-id="a2fb4-175">Starsza wersja <xref:System.Data.DataSet> typy są `IXmlSerializable` typy, które nie są oznaczone przez `XmlSchemaProviderAttribute` atrybutu.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-175">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="a2fb4-176">Zamiast tego opierają się na <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> metody do generowania schemat.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-176">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="a2fb4-177">Ten wzorzec jest używany dla `DataSet` typu i jego typizowany zestaw danych pochodzi z klasy we wcześniejszych wersjach programu .NET Framework, ale teraz jest przestarzały i nie jest obsługiwana tylko dla starszych powodów.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-177">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="a2fb4-178">Nie zależą od tego wzorca i zawsze stosuj `XmlSchemaProviderAttribute` do Twojej `IXmlSerializable` typów.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-178">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>  
  
### <a name="ixmlserializable-content-types"></a><span data-ttu-id="a2fb4-179">Typy zawartości IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="a2fb4-179">IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="a2fb4-180">Podczas serializacji typu, który implementuje element członkowski danych `IXmlSerializable` jest typ zawartości zdefiniowany wcześniej serializator zapisuje element otoki dla składowej danych i przekazuje kontrolę <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-180">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="a2fb4-181"><xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> Implementacji może zapisywać żadnych XML, który obejmuje dodawanie atrybutów do elementu otoki.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-181">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, which includes adding attributes to the wrapper element.</span></span> <span data-ttu-id="a2fb4-182">Po `WriteXml` jest wykonywane, serializator zamyka element.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-182">After `WriteXml` is done, the serializer closes the element.</span></span>  
  
 <span data-ttu-id="a2fb4-183">Podczas deserializacji składowej danych typu, który implementuje `IXmlSerializable` jest typ zawartości zdefiniowany wcześniej, Deserializator umieszcza odczytującego XML element otoki dla składowej danych i przekazuje kontrolę <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-183">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="a2fb4-184">Metoda musi odczytać cały element, w tym tagiem początkowym i końcowym.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-184">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="a2fb4-185">Upewnij się, że Twoje `ReadXml` kod obsługuje przypadek, w której element jest pusty.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-185">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="a2fb4-186">Ponadto usługi `ReadXml` wdrożenia nie należy polegać na element otoki jest o nazwie określony sposób.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-186">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="a2fb4-187">Nazwa jest wybierany przez serializator może się różnić.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-187">The name is chosen by the serializer can vary.</span></span>  
  
 <span data-ttu-id="a2fb4-188">Dopuszcza się przypisać `IXmlSerializable` zawartości typów polymorphically, na przykład, aby dane elementy członkowskie typu <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-188">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="a2fb4-189">Jest również dozwolony w przypadku wystąpień typu to null.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-189">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="a2fb4-190">Na koniec istnieje możliwość użycia `IXmlSerializable` typów z zachowania wykresu obiektu włączone i <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-190">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="a2fb4-191">Wszystkie te funkcje wymagają serializator WCF można dołączyć niektóre atrybuty do element otoki ("zero" i "type" w przestrzeni nazw z wystąpienia schematu XML i "Id", "Ref", "Type" i "Assembly" w przestrzeni nazw specyficzne dla programu WCF).</span><span class="sxs-lookup"><span data-stu-id="a2fb4-191">All these features require the WCF serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a WCF-specific namespace).</span></span>  
  
#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="a2fb4-192">Atrybuty do zignorowania podczas implementowania ReadXml</span><span class="sxs-lookup"><span data-stu-id="a2fb4-192">Attributes to Ignore when Implementing ReadXml</span></span>  
 <span data-ttu-id="a2fb4-193">Przed przekazaniem kontroli do Twojej `ReadXml` kod, Deserializator sprawdza, czy XML element, wykrywa te atrybuty specjalne XML i działa na nich.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-193">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="a2fb4-194">Na przykład, jeśli jest "zero" `true`, wartość null jest przeprowadzona i `ReadXml` nie zostanie wywołana.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-194">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="a2fb4-195">W przypadku wykrycia polimorfizm zawartość elementu są deserializacji, tak jakby znajdowała się innego typu.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-195">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="a2fb4-196">Implementacja typu polymorphically przypisane `ReadXml` jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-196">The polymorphically-assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="a2fb4-197">W każdym przypadku `ReadXml` wdrożenia powinien ignorować te atrybuty specjalne, ponieważ są one obsługiwane przez deserializacji.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-197">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>  
  
### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="a2fb4-198">Zagadnienia schematu dla typów IXmlSerializable zawartości</span><span class="sxs-lookup"><span data-stu-id="a2fb4-198">Schema Considerations for IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="a2fb4-199">Podczas eksportowania schematu i `IXmlSerializable` typ zawartości, wywoływana jest metoda dostawcy schematu.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-199">When exporting schema and an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="a2fb4-200"><xref:System.Xml.Schema.XmlSchemaSet> Jest przekazywany do metody dostawcy schematu.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-200">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="a2fb4-201">Metoda można dodać żadnych prawidłowego schematu do zestawu schematów.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-201">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="a2fb4-202">Zestaw schematów zawiera schemat, który jest już znany w czasie, gdy wystąpi eksportu schematu.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-202">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="a2fb4-203">Gdy metoda dostawcy schematu musi dodać element do zestawu schematów, należy określić czy <xref:System.Xml.Schema.XmlSchema> przy użyciu odpowiedniego obszaru nazw już istnieje w zestawie.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-203">When the schema provider method must add an item to the schema set, it must determine whether an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="a2fb4-204">Jeśli tak jest, metody dostawcy schemat, należy dodać nowy element do istniejącej `XmlSchema`.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-204">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="a2fb4-205">W przeciwnym razie należy utworzyć nowy `XmlSchema` wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-205">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="a2fb4-206">Jest to ważne, jeśli tablice `IXmlSerializable` typów są używane.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-206">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="a2fb4-207">Na przykład, jeśli masz `IXmlSerializable` typ, który pobiera wyeksportowany jako typu "A" w przestrzeni nazw "B", możliwe, że do czasu, wywoływana jest metoda dostawcy schematu, schemat już skonfigurowane zawiera schemat "B" pomieścić typu "ArrayOfA".</span><span class="sxs-lookup"><span data-stu-id="a2fb4-207">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>  
  
 <span data-ttu-id="a2fb4-208">Oprócz dodawania typów <xref:System.Xml.Schema.XmlSchemaSet>, metodę dostawcy schematu dla typów zawartości musi zwracać wartość inną niż null.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-208">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="a2fb4-209">Może zwracać <xref:System.Xml.XmlQualifiedName> określający nazwę typu schematu do użycia dla danego `IXmlSerializable` typu.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-209">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="a2fb4-210">Ta nazwa kwalifikowana służy również jako dane kontraktu nazwy i przestrzeni nazw dla typu.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-210">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="a2fb4-211">Dozwolone jest zwracany typ, który nie istnieje w schemacie zestawu natychmiast, po powrocie z metody dostawcy schematu.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-211">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="a2fb4-212">Jednak oczekuje się, że po czasie wszystkie powiązane typy są eksportowane ( <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> metoda jest wywoływana dla wszystkich odpowiednich typów w <xref:System.Runtime.Serialization.XsdDataContractExporter> i <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> dostępu do właściwości), typ istnieje w zestawie schematów.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-212">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="a2fb4-213">Uzyskiwanie dostępu do `Schemas` właściwości przed wszystkimi odpowiednimi `Export` wprowadzono wywołań może spowodować <xref:System.Xml.Schema.XmlSchemaException>.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-213">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> <span data-ttu-id="a2fb4-214">Aby uzyskać więcej informacji na temat procesu eksportu, zobacz [eksportowanie schematów z klas](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span><span class="sxs-lookup"><span data-stu-id="a2fb4-214">For more information about the export process, see [Exporting Schemas from Classes](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span></span>  
  
 <span data-ttu-id="a2fb4-215">Metoda dostawcy schemat może również zwracać <xref:System.Xml.Schema.XmlSchemaType> do użycia.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-215">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="a2fb4-216">Typ może być lub może nie być anonimowy.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-216">The type may or may not be anonymous.</span></span> <span data-ttu-id="a2fb4-217">Jeśli jest anonimowe, schemat `IXmlSerializable` typu jest eksportowana jako typ anonimowy w każdym `IXmlSerializable` typ jest używany jako element członkowski danych.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-217">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="a2fb4-218">`IXmlSerializable` Typu środki, nieopłacone nazwie kontraktu danych i przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-218">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="a2fb4-219">(To jest określana zgodnie z opisem w [nazwy kontraktów danych](../../../../docs/framework/wcf/feature-details/data-contract-names.md) z tą różnicą, że <xref:System.Runtime.Serialization.DataContractAttribute> atrybutu nie można dostosować nazwę.) Jeśli nie jest anonimowe, musi być jednym z typów w `XmlSchemaSet`.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-219">(This is determined as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="a2fb4-220">Ten przypadek jest odpowiednikiem zwracanie `XmlQualifiedName` tego typu.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-220">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>  
  
 <span data-ttu-id="a2fb4-221">Ponadto deklaracji element globalny jest eksportowany dla typu.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-221">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="a2fb4-222">Jeśli typ nie ma <xref:System.Xml.Serialization.XmlRootAttribute> zastosowany do niego element ma taką samą nazwę i obszaru nazw kontraktu danych, a jego właściwość "nillable" ma `true`.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-222">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is `true`.</span></span> <span data-ttu-id="a2fb4-223">Jedynym wyjątkiem jest przestrzeń nazw schematu (`http://www.w3.org/2001/XMLSchema`) — w przypadku typu kontraktu danych w tej przestrzeni nazw, odpowiedni element globalny jest w pustej przestrzeni nazw, ponieważ jest zabroniona Dodawanie nowych elementów do przestrzeni nazw schematu.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-223">The only exception to this is the schema namespace (`http://www.w3.org/2001/XMLSchema`) – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="a2fb4-224">Jeśli typ ma `XmlRootAttribute` zastosowany do jego deklaracji elementu globalnego jest eksportowana za pomocą następujących: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> i <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-224">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="a2fb4-225">Ustawienia domyślne przy użyciu `XmlRootAttribute` stosowane są nazwie kontraktu danych, pustą przestrzeń nazw, a jest "nillable" `true`.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-225">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being `true`.</span></span>  
  
 <span data-ttu-id="a2fb4-226">Te same reguły element globalny w deklaracji mają zastosowanie do zestawu danych w starszej wersji typów.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-226">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="a2fb4-227">Należy pamiętać, że `XmlRootAttribute` nie może przesłonić element globalny deklaracje dodane poprzez kod niestandardowy być dodany do `XmlSchemaSet` przy użyciu metody dostawcy schematu lub za pomocą `GetSchema` dla typów starszej wersji zestawu danych.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-227">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>  
  
### <a name="ixmlserializable-element-types"></a><span data-ttu-id="a2fb4-228">Typy elementów interfejsu IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="a2fb4-228">IXmlSerializable Element Types</span></span>  
 <span data-ttu-id="a2fb4-229">`IXmlSerializable` typy elementów mieć `IsAny` właściwością `true` lub ich dostawcy schematu, metoda zwraca `null`.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-229">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>  
  
 <span data-ttu-id="a2fb4-230">Serializacja i deserializacja typ elementu jest bardzo podobny do serializacji i deserializacji typu zawartości.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-230">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="a2fb4-231">Jednak istnieją pewne ważne różnice:</span><span class="sxs-lookup"><span data-stu-id="a2fb4-231">However, there are some important differences:</span></span>  
  
-   <span data-ttu-id="a2fb4-232">`WriteXml` Implementacji oczekuje się, można zapisać dokładnie jeden element (który z kolei może zawierać wiele elementów podrzędnych).</span><span class="sxs-lookup"><span data-stu-id="a2fb4-232">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="a2fb4-233">Nie powinien być wpisywanie atrybutów poza ten pojedynczy element wielu elementów równorzędnych lub zawartość mieszana.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-233">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="a2fb4-234">Element może być pusty.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-234">The element may be empty.</span></span>  
  
-   <span data-ttu-id="a2fb4-235">`ReadXml` Implementacji element otoki nie powinny do odczytu.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-235">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="a2fb4-236">Oczekuje się, aby przeczytać jeden element, `WriteXml` tworzy.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-236">It is expected to read the one element that `WriteXml` produces.</span></span>  
  
-   <span data-ttu-id="a2fb4-237">Podczas serializacji typu elementu regularnie (na przykład, jako element członkowski danych w kontraktu danych), serializator danych wyjściowych element otoki przed wywołaniem `WriteXml`, podobnie jak w przypadku typów zawartości.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-237">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="a2fb4-238">Jednak podczas serializacji typu elementu na najwyższym poziomie, Serializator nie zwykle wyświetla element otoki w ogóle wokół elementu, `WriteXml` zapisuje, chyba że nazwę główną i przestrzeni nazw są jawnie określone podczas tworzenia serializatora w `DataContractSerializer` lub `NetDataContractSerializer` konstruktorów.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-238">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace are explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> <span data-ttu-id="a2fb4-239">Aby uzyskać więcej informacji, zobacz [serializacji i deserializacji](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="a2fb4-239">For more information, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span></span>  
  
-   <span data-ttu-id="a2fb4-240">Podczas serializacji typu elementu na najwyższym poziomie bez określania nazwy głównej i przestrzeni nazw w czasie tworzenia <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> i <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> zasadniczo nic nie rób i <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> wywołania `WriteXml`.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-240">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially do nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="a2fb4-241">W tym trybie nie może być obiektu poddawanego serializacji `null` i nie można przypisać polymorphically.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-241">In this mode, the object being serialized cannot be `null` and cannot be polymorphically assigned.</span></span> <span data-ttu-id="a2fb4-242">Ponadto nie można włączyć zachowania wykresu obiektu i `NetDataContractSerializer` nie mogą być używane.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-242">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>  
  
-   <span data-ttu-id="a2fb4-243">Podczas deserializacji typ elementu na najwyższym poziomie bez określania nazwy głównej i przestrzeni nazw w czasie tworzenia <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> zwraca `true` jeśli znajdzie uruchamiania dowolnego elementu.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-243">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="a2fb4-244"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> za pomocą `verifyObjectName` parametr `true` zachowuje się w taki sam sposób jak `IsStartObject` przed faktycznie odczytu obiektu.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-244"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="a2fb4-245">`ReadObject` następnie przekazuje sterowanie do `ReadXml` metody.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-245">`ReadObject` then passes control to `ReadXml` method.</span></span>  
  
 <span data-ttu-id="a2fb4-246">Schemat eksportowany dla typów elementów jest taki sam, jak w przypadku `XmlElement` wpisz zgodnie z opisem w sekcji wcześniej, z tą różnicą, że metoda dostawcy schematu można dodać dodatkowe schematu w celu <xref:System.Xml.Schema.XmlSchemaSet> podobnie jak w przypadku typów zawartości.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-246">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="a2fb4-247">Za pomocą `XmlRootAttribute` atrybut z typami elementu nie jest dozwolony, a element globalny deklaracje nigdy nie są emitowane dla tych typów.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-247">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>  
  
### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="a2fb4-248">Różnice w stosunku do elementu XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="a2fb4-248">Differences from the XmlSerializer</span></span>  
 <span data-ttu-id="a2fb4-249">`IXmlSerializable` Interfejsu i `XmlSchemaProviderAttribute` i `XmlRootAttribute` atrybuty są także zrozumiałe <xref:System.Xml.Serialization.XmlSerializer> .</span><span class="sxs-lookup"><span data-stu-id="a2fb4-249">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="a2fb4-250">Jednak istnieją pewne różnice w jaki sposób są one traktowane w modelu kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-250">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="a2fb4-251">Istotne różnice przedstawiono na poniższej liście:</span><span class="sxs-lookup"><span data-stu-id="a2fb4-251">The important differences are summarized in the following list:</span></span>  
  
-   <span data-ttu-id="a2fb4-252">Metody dostawcy schematu muszą być publiczne, które zostaną użyte w `XmlSerializer`, ale nie musi być publiczne, które zostaną użyte w modelu kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-252">The schema provider method must be public to be used in the `XmlSerializer`, but does not have to be public to be used in the data contract model.</span></span>  
  
-   <span data-ttu-id="a2fb4-253">Metoda dostawcy schematu jest wywoływana, gdy `IsAny` jest `true` w modelu kontraktu danych, ale nie z `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-253">The schema provider method is called when `IsAny` is `true` in the data contract model but not with the `XmlSerializer`.</span></span>  
  
-   <span data-ttu-id="a2fb4-254">Gdy `XmlRootAttribute` atrybut nie jest obecny do zawartości lub typy zestawów danych w starszej wersji, `XmlSerializer` eksportuje deklaracji element globalny w pustej przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-254">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="a2fb4-255">W modelu kontraktu danych przestrzeń nazw używaną zwykle jest przestrzeń nazw kontraktu danych, zgodnie z wcześniejszym opisem.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-255">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>  
  
 <span data-ttu-id="a2fb4-256">Należy pamiętać o tych różnic, podczas tworzenia typów, które są używane w obu technologii serializacji.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-256">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>  
  
### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="a2fb4-257">Importowanie schematu interfejsu IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="a2fb4-257">Importing IXmlSerializable Schema</span></span>  
 <span data-ttu-id="a2fb4-258">Podczas importowania schematu wygenerowany na podstawie `IXmlSerializable` typów, istnieje kilka możliwości:</span><span class="sxs-lookup"><span data-stu-id="a2fb4-258">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>  
  
-   <span data-ttu-id="a2fb4-259">Wygenerowany schemat może być schematu kontraktu prawidłowych danych, zgodnie z opisem w [odwołanie do schematu kontraktu danych](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="a2fb4-259">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span> <span data-ttu-id="a2fb4-260">W takim przypadku schematu, które mogą być importowane w zwykły sposób, i są generowane typy kontraktu danych regularne.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-260">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>  
  
-   <span data-ttu-id="a2fb4-261">Wygenerowany schemat może nie być poprawne dane schematu kontraktu.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-261">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="a2fb4-262">Na przykład metoda dostawcy schematu może wygenerować schematu, która obejmuje atrybutów XML, które nie są obsługiwane w modelu kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-262">For example, your schema provider method may generate schema that involves XML attributes that are not supported in the data contract model.</span></span> <span data-ttu-id="a2fb4-263">W takim przypadku można zaimportować schematu jako `IXmlSerializable` typów.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-263">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="a2fb4-264">Domyślnie nie jest w ten tryb importu, ale można łatwo można włączyć — na przykład za pomocą `/importXmlTypes` przełącznik wiersza polecenia, aby [narzędzia narzędzie metadanych elementu ServiceModel (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span><span class="sxs-lookup"><span data-stu-id="a2fb4-264">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="a2fb4-265">Jest to opisane szczegółowo w temacie [Importowanie schematu do generowania klasy](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="a2fb4-265">This is described in detail in the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="a2fb4-266">Należy pamiętać, że należy skontaktować się bezpośrednio z pliku XML dla wystąpień typu.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-266">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="a2fb4-267">Można także rozważyć użycie innej technologii serializacji, który obsługuje szerszy zakres schematów — zobacz temat w przy użyciu `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-267">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>  
  
-   <span data-ttu-id="a2fb4-268">Może zajść potrzeba ponownego użycia istniejącej `IXmlSerializable` typów serwera proxy zamiast generować nową.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-268">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="a2fb4-269">W takim przypadku funkcja przywoływane typy opisana w schemacie importowanie do tematu wygenerować typy można wskazać typ do ponownego użycia.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-269">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="a2fb4-270">Odpowiada to użyciu `/reference` Włącz svcutil.exe, który określa zestaw, który zawiera typy do ponownego użycia.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-270">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>  
  
### <a name="xmlserializer-legacy-behavior"></a><span data-ttu-id="a2fb4-271">Zachowanie elementu XmlSerializer starszej wersji</span><span class="sxs-lookup"><span data-stu-id="a2fb4-271">XmlSerializer Legacy Behavior</span></span>  
 <span data-ttu-id="a2fb4-272">W .NET Framework 4.0 i starszych elementu XmlSerializer wygenerowane zestawy serializacji tymczasowych przez napisanie kodu języka C# do pliku.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-272">In the .NET Framework 4.0 and earlier, the XmlSerializer generated temporary serialization assemblies by writing C# code to a file.</span></span> <span data-ttu-id="a2fb4-273">Plik został następnie kompilowane do zestawu.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-273">The file was then compiled into an assembly.</span></span>  <span data-ttu-id="a2fb4-274">To zachowanie ma niektórych niepożądanych skutków, takich jak spowalnianiu czas uruchamiania dla serializatora.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-274">This behavior had some undesirable consequences like slowing the startup time for the serializer.</span></span> <span data-ttu-id="a2fb4-275">W programie .NET Framework 4.5 to zachowanie została zmieniona na generowanie zestawów bez konieczności użycia kompilatora.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-275">In .NET Framework 4.5, this behavior was changed to generate the assemblies without requiring use of the compiler.</span></span> <span data-ttu-id="a2fb4-276">Niektórzy deweloperzy mogą chcieć wyświetlić wygenerowany kod C#.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-276">Some developers may wish to see the generated C# code.</span></span> <span data-ttu-id="a2fb4-277">Możesz określić to starsze zachowanie za pomocą następującej konfiguracji:</span><span class="sxs-lookup"><span data-stu-id="a2fb4-277">You can specify to use this legacy behavior by the following configuration:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<configuration>  
  <system.xml.serialization>  
    <xmlSerializer tempFilesLocation='e:\temp\XmlSerializerBug' useLegacySerializerGeneration="true" />  
  </system.xml.serialization>  
  <system.diagnostics>  
    <switches>  
      <add name="XmlSerialization.Compilation" value="1" />  
    </switches>  
  </system.diagnostics>  
</configuration>  
```  
  
 <span data-ttu-id="a2fb4-278">Jeśli napotkasz problemy ze zgodnością, takich jak `XmlSerializer` kończy się niepowodzeniem do serializacji klasę pochodną z możliwością zmiany nowych niepublicznych, możesz przełączyć się ponownie do `XMLSerializer` starsze zachowanie za pomocą następującej konfiguracji:</span><span class="sxs-lookup"><span data-stu-id="a2fb4-278">If you run into compatibility issues,  such as the `XmlSerializer` failing to serialize a derived class with a non-public new override, you can switch back to the  `XMLSerializer` legacy behavior by using the following configuration:</span></span>  
  
```xml  
<configuration>  
<appSettings>   
<add key="System:Xml:Serialization:UseLegacySerializerGeneration" value="true" />  
               </appSettings>  
</configuration>  
```  
  
 <span data-ttu-id="a2fb4-279">Jako alternatywę do powyższych konfiguracji można użyć następującej konfiguracji na komputerze z systemem .NET Framework 4.5 lub nowszej wersji:</span><span class="sxs-lookup"><span data-stu-id="a2fb4-279">As an alternative to the above configuration, you can use the following configuration on a machine running .NET Framework 4.5 or later version:</span></span>  
  
```xml  
<configuration>  
<system.xml.serialization>  
<xmlSerializer useLegacySerializerGeneration="true"/>  
</system.xml.serialization>  
</configuration>  
```  
  
> [!NOTE]
>  <span data-ttu-id="a2fb4-280">`<xmlSerializer useLegacySerializerGeneration="true"/>` Przełącznika działa tylko na komputerze z systemem .NET Framework 4.5 lub nowszej wersji.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-280">The `<xmlSerializer useLegacySerializerGeneration="true"/>` switch only works on a machine running .NET Framework 4.5 or later version.</span></span> <span data-ttu-id="a2fb4-281">Powyższe `appSettings` podejście działa we wszystkich wersjach systemu .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="a2fb4-281">The above `appSettings` approach works on all .NET Framework versions.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a2fb4-282">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="a2fb4-282">See also</span></span>

- <xref:System.ServiceModel.DataContractFormatAttribute>
- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.Serialization.XmlSerializer>
- <xref:System.ServiceModel.MessageHeaderArrayAttribute>
- [<span data-ttu-id="a2fb4-283">Określanie transferu danych w kontraktach usług</span><span class="sxs-lookup"><span data-stu-id="a2fb4-283">Specifying Data Transfer in Service Contracts</span></span>](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)
- [<span data-ttu-id="a2fb4-284">Używanie kontraktów danych</span><span class="sxs-lookup"><span data-stu-id="a2fb4-284">Using Data Contracts</span></span>](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)
- [<span data-ttu-id="a2fb4-285">Instrukcje: Poprawę czasu uruchamiania programu WCF klienta aplikacji przy użyciu elementu XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="a2fb4-285">How to: Improve the Startup Time of WCF Client Applications using the XmlSerializer</span></span>](../../../../docs/framework/wcf/feature-details/startup-time-of-wcf-client-applications-using-the-xmlserializer.md)
