---
title: Przechowywanie wersji usługi
ms.date: 03/30/2017
ms.assetid: 37575ead-d820-4a67-8059-da11a2ab48e2
ms.openlocfilehash: 6b72558be4a367505ff18f10406785bc21fddd2c
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/28/2019
ms.locfileid: "64606002"
---
# <a name="service-versioning"></a><span data-ttu-id="3d71f-102">Przechowywanie wersji usługi</span><span class="sxs-lookup"><span data-stu-id="3d71f-102">Service Versioning</span></span>
<span data-ttu-id="3d71f-103">Po początkowym wdrożeniu i potencjalnie kilka razy w okresie ich istnienia usługi (i punktów końcowych, które udostępniają) może być konieczne zostanie zmieniony z różnych powodów, takich jak zmieniających się potrzeb biznesowych, wymagań dotyczących technologii informacji, lub inne rozwiązania problemy.</span><span class="sxs-lookup"><span data-stu-id="3d71f-103">After initial deployment, and potentially several times during their lifetime, services (and the endpoints they expose) may need to be changed for a variety of reasons, such as changing business needs, information technology requirements, or to address other issues.</span></span> <span data-ttu-id="3d71f-104">Każda zmiana wprowadza nową wersję usługi.</span><span class="sxs-lookup"><span data-stu-id="3d71f-104">Each change introduces a new version of the service.</span></span> <span data-ttu-id="3d71f-105">W tym temacie wyjaśniono, jak należy wziąć pod uwagę przechowywanie wersji w Windows Communication Foundation (WCF).</span><span class="sxs-lookup"><span data-stu-id="3d71f-105">This topic explains how to consider versioning in Windows Communication Foundation (WCF).</span></span>  
  
## <a name="four-categories-of-service-changes"></a><span data-ttu-id="3d71f-106">Cztery kategorie zmianami w usłudze</span><span class="sxs-lookup"><span data-stu-id="3d71f-106">Four Categories of Service Changes</span></span>  
 <span data-ttu-id="3d71f-107">Zmiany usług, które mogą być wymagane, można podzielić na cztery kategorie:</span><span class="sxs-lookup"><span data-stu-id="3d71f-107">The changes to services that may be required can be classified into four categories:</span></span>  
  
- <span data-ttu-id="3d71f-108">Zmiany umowy: Na przykład operacji, które mogą być dodawane lub element danych w komunikacie może być dodane lub zmienione.</span><span class="sxs-lookup"><span data-stu-id="3d71f-108">Contract changes: For example, an operation might be added, or a data element in a message might be added or changed.</span></span>  
  
- <span data-ttu-id="3d71f-109">Zmian adresów: Na przykład usługa zostaje przeniesiony do innej lokalizacji, gdzie punkty końcowe mają nowe adresy.</span><span class="sxs-lookup"><span data-stu-id="3d71f-109">Address changes: For example, a service moves to a different location where endpoints have new addresses.</span></span>  
  
- <span data-ttu-id="3d71f-110">Powiązanie zmiany: Na przykład zmienia mechanizmu zabezpieczeń lub zmienić jego ustawienia.</span><span class="sxs-lookup"><span data-stu-id="3d71f-110">Binding changes: For example, a security mechanism changes or its settings change.</span></span>  
  
- <span data-ttu-id="3d71f-111">Zmiany w implementacji: Na przykład, gdy implementację metody wewnętrznego zmiany.</span><span class="sxs-lookup"><span data-stu-id="3d71f-111">Implementation changes: For example, when an internal method implementation changes.</span></span>  
  
 <span data-ttu-id="3d71f-112">Niektóre z tych zmian są nazywane "złamanie", a inne są "nierozdzielające."</span><span class="sxs-lookup"><span data-stu-id="3d71f-112">Some of these changes are called "breaking" and others are "nonbreaking."</span></span> <span data-ttu-id="3d71f-113">Zmiana jest *nierozdzielający* Jeśli wszystkie komunikaty, które mogłyby zostały przetworzone pomyślnie w poprzedniej wersji pomyślnie przetworzonych w nowej wersji.</span><span class="sxs-lookup"><span data-stu-id="3d71f-113">A change is *nonbreaking* if all messages that would have been processed successfully in the previous version are processed successfully in the new version.</span></span> <span data-ttu-id="3d71f-114">Każda zmiana, który nie spełnia warunku jest *istotne* zmiany.</span><span class="sxs-lookup"><span data-stu-id="3d71f-114">Any change that does not meet that criterion is a *breaking* change.</span></span>  
  
## <a name="service-orientation-and-versioning"></a><span data-ttu-id="3d71f-115">Orientacja usługi i przechowywania wersji</span><span class="sxs-lookup"><span data-stu-id="3d71f-115">Service Orientation and Versioning</span></span>  
 <span data-ttu-id="3d71f-116">Jedną z założenia orientacji usługi to usług i klientów autonomicznego (lub niezależnych).</span><span class="sxs-lookup"><span data-stu-id="3d71f-116">One of the tenets of service orientation is that services and clients are autonomous (or independent).</span></span> <span data-ttu-id="3d71f-117">Między innymi oznacza to, że deweloperzy usług nie można zakładać, kontrolowania lub nawet wiedzieć o wszystkich klientów usługi.</span><span class="sxs-lookup"><span data-stu-id="3d71f-117">Among other things, this implies that service developers cannot assume that they control or even know about all service clients.</span></span> <span data-ttu-id="3d71f-118">Pozwala to wyeliminować możliwość ponownego kompilowania lub wdrażania wszystkich klientów w przypadku wersji zmiany usługi.</span><span class="sxs-lookup"><span data-stu-id="3d71f-118">This eliminates the option of rebuilding and redeploying all clients when a service changes versions.</span></span> <span data-ttu-id="3d71f-119">W tym temacie przyjęto założenie, usługa działa zgodnie z tym główną i dlatego musi być zmienione lub "kontrolą wersji", niezależnie od swoich klientów.</span><span class="sxs-lookup"><span data-stu-id="3d71f-119">This topic assumes the service adheres to this tenet and therefore must be changed or "versioned" independent of its clients.</span></span>  
  
 <span data-ttu-id="3d71f-120">W przypadkach, gdy jest nieoczekiwany i nie można uniknąć istotnej zmiany mogą wybrać aplikację Ignoruj ten główną i wymagają, aby klienci można odbudować i ponownego wdrożenia nowej wersji usługi.</span><span class="sxs-lookup"><span data-stu-id="3d71f-120">In cases where a breaking change is unexpected and cannot be avoided, an application may choose to ignore this tenet and require that clients be rebuilt and redeployed with a new version of the service.</span></span>  
  
## <a name="contract-versioning"></a><span data-ttu-id="3d71f-121">Przechowywanie wersji kontraktów</span><span class="sxs-lookup"><span data-stu-id="3d71f-121">Contract Versioning</span></span>  
 <span data-ttu-id="3d71f-122">Kontrakty używany przez klienta musi być taka sama jak kontraktu używanego przez usługę; tylko muszą być zgodne.</span><span class="sxs-lookup"><span data-stu-id="3d71f-122">Contracts used by a client do not need to be the same as the contract used by the service; they need only to be compatible.</span></span>  
  
 <span data-ttu-id="3d71f-123">Dla kontraktów usług zgodności można dodawać nowe operacje oznacza, że udostępniane przez usługę, ale istniejące operacje nie może być usunięte lub zmienione semantycznie.</span><span class="sxs-lookup"><span data-stu-id="3d71f-123">For service contracts, compatibility means new operations exposed by the service can be added but existing operations cannot be removed or changed semantically.</span></span>  
  
 <span data-ttu-id="3d71f-124">W przypadku kontraktów danych zgodność oznacza nowego typu schematu, który można dodać definicji, ale w istotne sposoby nie można zmienić istniejące definicje typu schematu.</span><span class="sxs-lookup"><span data-stu-id="3d71f-124">For data contracts, compatibility means new schema type definitions can be added but existing schema type definitions cannot be changed in breaking ways.</span></span> <span data-ttu-id="3d71f-125">Istotne zmiany może obejmować usunięcie elementów członkowskich danych lub incompatibly zmianie jego typu danych.</span><span class="sxs-lookup"><span data-stu-id="3d71f-125">Breaking changes might include removing data members or changing their data type incompatibly.</span></span> <span data-ttu-id="3d71f-126">Ta funkcja umożliwia usłudze niektóre latitude podczas zmieniania wersji swoich umów bez przerywania klientów.</span><span class="sxs-lookup"><span data-stu-id="3d71f-126">This feature allows the service some latitude in changing the version of its contracts without breaking clients.</span></span> <span data-ttu-id="3d71f-127">W dwóch następnych sekcjach opisano nieprzerywającymi działania aplikacji i istotne zmiany, które może przyjąć dane usług WCF i umowy o świadczenie usług.</span><span class="sxs-lookup"><span data-stu-id="3d71f-127">The next two sections explain nonbreaking and breaking changes that can be made to WCF data and service contracts.</span></span>  
  
## <a name="data-contract-versioning"></a><span data-ttu-id="3d71f-128">Przechowywanie wersji kontraktów danych</span><span class="sxs-lookup"><span data-stu-id="3d71f-128">Data Contract Versioning</span></span>  
 <span data-ttu-id="3d71f-129">W tej sekcji omówiono zarządzanie wersjami danych, korzystając z <xref:System.Runtime.Serialization.DataContractSerializer> i <xref:System.Runtime.Serialization.DataContractAttribute> klasy.</span><span class="sxs-lookup"><span data-stu-id="3d71f-129">This section deals with data versioning when using the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.DataContractAttribute> classes.</span></span>  
  
### <a name="strict-versioning"></a><span data-ttu-id="3d71f-130">Przechowywanie wersji Strict</span><span class="sxs-lookup"><span data-stu-id="3d71f-130">Strict Versioning</span></span>  
 <span data-ttu-id="3d71f-131">W wielu scenariuszach podczas zmiany wersji jest to problem dla deweloperów usługi ma kontrolę nad klientów i w związku z tym nie może wprowadzać założeń dotyczących jak będzie reagować na zmiany w komunikacie lub schemat XML.</span><span class="sxs-lookup"><span data-stu-id="3d71f-131">In many scenarios when changing versions is an issue, the service developer does not have control over the clients and therefore cannot make assumptions about how they would react to changes in the message XML or schema.</span></span> <span data-ttu-id="3d71f-132">W takich przypadkach musisz gwarantować, że nowe wiadomości zostanie przeprowadzona Weryfikacja względem schematu stare dwóch powodów:</span><span class="sxs-lookup"><span data-stu-id="3d71f-132">In these cases, you must guarantee that the new messages will validate against the old schema, for two reasons:</span></span>  
  
- <span data-ttu-id="3d71f-133">Starych klientów opracowano przy założeniu, że schemat nie ulegnie zmianie.</span><span class="sxs-lookup"><span data-stu-id="3d71f-133">The old clients were developed with the assumption that the schema will not change.</span></span> <span data-ttu-id="3d71f-134">One może zakończyć się niepowodzeniem do przetwarzania komunikatów, które nigdy nie zostały zaprojektowane dla.</span><span class="sxs-lookup"><span data-stu-id="3d71f-134">They may fail to process messages that they were never designed for.</span></span>  
  
- <span data-ttu-id="3d71f-135">Stary klientów mogą wykonać sprawdzanie poprawności schematu rzeczywiste względem schematu stare przed próbą nawet przetwarzania komunikatów.</span><span class="sxs-lookup"><span data-stu-id="3d71f-135">The old clients may perform actual schema validation against the old schema before even attempting to process the messages.</span></span>  
  
 <span data-ttu-id="3d71f-136">W takich scenariuszach zaleca traktować istniejących kontraktów danych jako niezmienialny i tworzenie nowych, unikatowych XML kwalifikowane nazwy.</span><span class="sxs-lookup"><span data-stu-id="3d71f-136">The recommended approach in such scenarios is to treat existing data contracts as immutable and create new ones with unique XML qualified names.</span></span> <span data-ttu-id="3d71f-137">Deweloper usługi będzie następnie dodać nowych metod do istniejącej umowy serwisowej lub tworzenie nowego kontraktu usługi przy użyciu metody, które używają nowego kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="3d71f-137">The service developer would then either add new methods to an existing service contract or create a new service contract with methods that use the new data contract.</span></span>  
  
 <span data-ttu-id="3d71f-138">Często będzie przypadek, który deweloper usługi musi zapisać niektóre logiki biznesowej, które należy uruchomić we wszystkich wersjach kontraktu danych oraz kod specyficzny dla wersji business dla każdej wersji kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="3d71f-138">It will often be the case that a service developer needs to write some business logic that should run within all versions of a data contract plus version-specific business code for each version of the data contract.</span></span> <span data-ttu-id="3d71f-139">Dodatku na końcu tego tematu opisano, jak interfejsów można spełnić te wymagania.</span><span class="sxs-lookup"><span data-stu-id="3d71f-139">The appendix at the end of this topic explains how interfaces can be used to satisfy this need.</span></span>  
  
### <a name="lax-versioning"></a><span data-ttu-id="3d71f-140">Przechowywanie wersji łagodnymi</span><span class="sxs-lookup"><span data-stu-id="3d71f-140">Lax Versioning</span></span>  
 <span data-ttu-id="3d71f-141">W wielu inne scenariusze dla deweloperów usługi można zapewnić przy założeniu, że dodawanie elementu członkowskiego nowy, opcjonalny kontraktu danych nie spowoduje uszkodzenie istniejących klientów.</span><span class="sxs-lookup"><span data-stu-id="3d71f-141">In many other scenarios, the service developer can make the assumption that adding a new, optional member to the data contract will not break existing clients.</span></span> <span data-ttu-id="3d71f-142">Wymaga to deweloper usługi zbadać, czy istniejący klienci nie wykonuje sprawdzanie poprawności schematu i że Ignoruj ich elementy członkowskie danych nieznany.</span><span class="sxs-lookup"><span data-stu-id="3d71f-142">This requires the service developer to investigate whether existing clients are not performing schema validation and that they ignore unknown data members.</span></span> <span data-ttu-id="3d71f-143">W tych scenariuszach jest to możliwe, należy korzystać z funkcji kontraktu danych do dodawania nowych elementów członkowskich w sposób nieprzerywającymi działania aplikacji.</span><span class="sxs-lookup"><span data-stu-id="3d71f-143">In these scenarios, it is possible to take advantage of data contract features for adding new members in a nonbreaking way.</span></span> <span data-ttu-id="3d71f-144">Dla deweloperów usługi ułatwia to założenie bez obaw, jeśli funkcje kontraktu danych pod kątem przechowywania wersji zostały już użyte w pierwszej wersji usługi.</span><span class="sxs-lookup"><span data-stu-id="3d71f-144">The service developer can make this assumption with confidence if the data contract features for versioning were already used for the first version of the service.</span></span>  
  
 <span data-ttu-id="3d71f-145">Usługi WCF, usług sieci Web ASP.NET i wiele innych sieci Web usługi pomocy technicznej stosy *łagodnymi versioning*: oznacza to, mogą nie zgłaszać wyjątków dla nowych członków nieznany danych odebranych danych.</span><span class="sxs-lookup"><span data-stu-id="3d71f-145">WCF, ASP.NET Web Services, and many other Web service stacks support *lax versioning*: that is, they do not throw exceptions for new unknown data members in received data.</span></span>  
  
 <span data-ttu-id="3d71f-146">To proste przez pomyłkę podejrzewać, że dodawanie nowego elementu członkowskiego nie będę powodować istniejących klientów.</span><span class="sxs-lookup"><span data-stu-id="3d71f-146">It is easy to mistakenly believe that adding a new member will not break existing clients.</span></span> <span data-ttu-id="3d71f-147">Jeśli nie wiesz, że wszyscy klienci mogą obsługiwać łagodnymi przechowywania wersji, zaleca się użyć wskazówki wersji strict i traktować dane umów jako niezmienialny.</span><span class="sxs-lookup"><span data-stu-id="3d71f-147">If you are unsure that all clients can handle lax versioning, the recommendation is to use the strict versioning guidelines and treat data contracts as immutable.</span></span>  
  
 <span data-ttu-id="3d71f-148">Aby uzyskać szczegółowe wskazówki dotyczące łagodnymi i ograniczeniami przechowywanie wersji kontraktów danych, zobacz [najlepsze rozwiązania: Przechowywanie wersji kontraktów danych](../../../docs/framework/wcf/best-practices-data-contract-versioning.md).</span><span class="sxs-lookup"><span data-stu-id="3d71f-148">For detailed guidelines for both lax and strict versioning of data contracts, see [Best Practices: Data Contract Versioning](../../../docs/framework/wcf/best-practices-data-contract-versioning.md).</span></span>  
  
### <a name="distinguishing-between-data-contract-and-net-types"></a><span data-ttu-id="3d71f-149">Rozróżniania kontraktu danych i typów .NET</span><span class="sxs-lookup"><span data-stu-id="3d71f-149">Distinguishing Between Data Contract and .NET Types</span></span>  
 <span data-ttu-id="3d71f-150">.NET klasy lub struktury może być przekazywany jako kontraktu danych, stosując <xref:System.Runtime.Serialization.DataContractAttribute> do klasy atrybutu.</span><span class="sxs-lookup"><span data-stu-id="3d71f-150">A .NET class or structure can be projected as a data contract by applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to the class.</span></span> <span data-ttu-id="3d71f-151">Typ architektury .NET i jej prognozy kontraktu danych to dwa odrębne jest ważna.</span><span class="sxs-lookup"><span data-stu-id="3d71f-151">The .NET type and its data contract projections are two distinct matters.</span></span> <span data-ttu-id="3d71f-152">Istnieje możliwość mają różne typy .NET o tej samej projekcji kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="3d71f-152">It is possible to have multiple .NET types with the same data contract projection.</span></span> <span data-ttu-id="3d71f-153">Różnica ta jest szczególnie przydatna w umożliwia zmianę typu .NET, przy zachowaniu umowy prognozowanych danych, w tym samym zachowuje zgodność z istniejącymi klientami, nawet w sensie ograniczeniami Word.</span><span class="sxs-lookup"><span data-stu-id="3d71f-153">This distinction is especially useful in allowing you to change the .NET type while maintaining the projected data contract, thereby maintaining compatibility with existing clients even in the strict sense of the word.</span></span> <span data-ttu-id="3d71f-154">Istnieją dwie rzeczy, które należy zawsze zachować wykonywania tego rozróżnienia między kontraktu danych i typ .NET:</span><span class="sxs-lookup"><span data-stu-id="3d71f-154">There are two things you should always do to maintain this distinction between .NET type and data contract:</span></span>  
  
- <span data-ttu-id="3d71f-155">Określ <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> i <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>.</span><span class="sxs-lookup"><span data-stu-id="3d71f-155">Specify a <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> and <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>.</span></span> <span data-ttu-id="3d71f-156">Należy zawsze podać nazwę i przestrzeń nazw usługi kontraktu danych, aby zapobiec nazwę danego typu .NET i przestrzeni nazw przed przypadkowym w kontrakcie.</span><span class="sxs-lookup"><span data-stu-id="3d71f-156">You should always specify the name and namespace of your data contract to prevent your .NET type’s name and namespace from being exposed in the contract.</span></span> <span data-ttu-id="3d71f-157">Dzięki temu, jeśli później zdecydujesz się zmienić z obszaru nazw .NET lub wpisz nazwę, kontrakt usługi danych pozostaje taki sam.</span><span class="sxs-lookup"><span data-stu-id="3d71f-157">This way, if you decide later to change the .NET namespace or type name, your data contract remains the same.</span></span>  
  
- <span data-ttu-id="3d71f-158">Określ <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>.</span><span class="sxs-lookup"><span data-stu-id="3d71f-158">Specify <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>.</span></span> <span data-ttu-id="3d71f-159">Należy zawsze podać nazwę usługi składowych danych, aby uniemożliwić spowodują ujawnienie w kontrakcie nazwę użytkownika platformy .NET.</span><span class="sxs-lookup"><span data-stu-id="3d71f-159">You should always specify the name of your data members to prevent your .NET member name from being exposed in the contract.</span></span> <span data-ttu-id="3d71f-160">Dzięki temu, jeśli później zdecydujesz się zmienić nazwę elementu członkowskiego .NET, usługi kontraktu danych pozostaje taki sam.</span><span class="sxs-lookup"><span data-stu-id="3d71f-160">This way, if you decide later to change the .NET name of the member, your data contract remains the same.</span></span>  
  
### <a name="changing-or-removing-members"></a><span data-ttu-id="3d71f-161">Zmienianie lub usuwanie członków</span><span class="sxs-lookup"><span data-stu-id="3d71f-161">Changing or Removing Members</span></span>  
 <span data-ttu-id="3d71f-162">Zmienianie nazwy lub typu danych elementu członkowskiego lub usuwanie elementów członkowskich danych jest istotną zmianę, nawet wtedy, gdy łagodnymi versioning jest dozwolone.</span><span class="sxs-lookup"><span data-stu-id="3d71f-162">Changing the name or data type of a member, or removing data members is a breaking change even if lax versioning is allowed.</span></span> <span data-ttu-id="3d71f-163">Jeśli jest to konieczne, należy utworzyć nowego kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="3d71f-163">If this is necessary, create a new data contract.</span></span>  
  
 <span data-ttu-id="3d71f-164">W przypadku zgodności usługi o wysokiej ważności, może wziąć pod uwagę ignorowanie nieużywanych danych członków w kodzie i pozostawić bez zmian.</span><span class="sxs-lookup"><span data-stu-id="3d71f-164">If service compatibility is of high importance, you might consider ignoring unused data members in your code and leave them in place.</span></span> <span data-ttu-id="3d71f-165">Jeśli są dzielenie element członkowski danych do wielu członków, można rozważyć opuszczania istniejącego elementu członkowskiego w miejscu jako właściwość może wykonać wymagane rozdzielenie i ponowne agregacji w przypadku klientów niskiego poziomu (liczba klientów, które nie zostały uaktualnione do najnowszej wersji).</span><span class="sxs-lookup"><span data-stu-id="3d71f-165">If you are splitting up a data member into multiple members, you might consider leaving the existing member in place as a property that can perform the required splitting and re-aggregation for down-level clients (clients that are not upgraded to the latest version).</span></span>  
  
 <span data-ttu-id="3d71f-166">Podobnie zmiany nazwy lub przestrzeni nazw kontraktu danych są istotne zmiany.</span><span class="sxs-lookup"><span data-stu-id="3d71f-166">Similarly, changes to the data contract’s name or namespace are breaking changes.</span></span>  
  
### <a name="round-trips-of-unknown-data"></a><span data-ttu-id="3d71f-167">Rund nieznane dane</span><span class="sxs-lookup"><span data-stu-id="3d71f-167">Round-Trips of Unknown Data</span></span>  
 <span data-ttu-id="3d71f-168">W niektórych scenariuszach istnieje potrzeba "obustronne" Nieznany dane pochodzące z danych elementy członkowskie dodane w nowej wersji.</span><span class="sxs-lookup"><span data-stu-id="3d71f-168">In some scenarios, there is a need to "round-trip" unknown data that comes from members added in a new version.</span></span> <span data-ttu-id="3d71f-169">Na przykład "versionNew" usługa wysyła dane za pomocą niektórych nowo dodane elementy członkowskie do klienta "versionOld".</span><span class="sxs-lookup"><span data-stu-id="3d71f-169">For example, a "versionNew" service sends data with some newly added members to a "versionOld" client.</span></span> <span data-ttu-id="3d71f-170">Klient ignoruje nowo dodanych elementów członkowskich, podczas przetwarzania komunikatu, ale umożliwia ponowne wysłanie tych samych danych, w tym nowo dodanych elementów członkowskich, wróć do usługi versionNew.</span><span class="sxs-lookup"><span data-stu-id="3d71f-170">The client ignores the newly added members when processing the message, but it resends that same data, including the newly added members, back to the versionNew service.</span></span> <span data-ttu-id="3d71f-171">Typowy scenariusz, w tym jest aktualizacji danych, gdzie dane są pobierane z usługi, zmienione i zwrócony.</span><span class="sxs-lookup"><span data-stu-id="3d71f-171">The typical scenario for this is data updates where data is retrieved from the service, changed, and returned.</span></span>  
  
 <span data-ttu-id="3d71f-172">Aby włączyć Pełna zgodnooć wersji dla określonego typu, musi implementować typ <xref:System.Runtime.Serialization.IExtensibleDataObject> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="3d71f-172">To enable round-tripping for a particular type, the type must implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="3d71f-173">Interfejs zawiera jedną właściwość <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> zwracającego <xref:System.Runtime.Serialization.ExtensionDataObject> typu.</span><span class="sxs-lookup"><span data-stu-id="3d71f-173">The interface contains one property, <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> that returns the <xref:System.Runtime.Serialization.ExtensionDataObject> type.</span></span> <span data-ttu-id="3d71f-174">Właściwość jest używana do przechowywania wszelkich danych z przyszłych wersji kontraktu danych, który jest nieznany do bieżącej wersji.</span><span class="sxs-lookup"><span data-stu-id="3d71f-174">The property is used to store any data from future versions of the data contract that is unknown to the current version.</span></span> <span data-ttu-id="3d71f-175">Dane te są nieprzezroczyste dla klienta, ale w przypadku wystąpienia jest serializowana, zawartość <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> właściwości są zapisywane z użyciem usług rest danych kontraktu składowych danych.</span><span class="sxs-lookup"><span data-stu-id="3d71f-175">This data is opaque to the client, but when the instance is serialized, the content of the <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> property is written with the rest of the data contract members' data.</span></span>  
  
 <span data-ttu-id="3d71f-176">Zalecane jest, czy wszystkich typów implementować ten interfejs w celu uwzględnienia nowych i nieznany przyszłych członków.</span><span class="sxs-lookup"><span data-stu-id="3d71f-176">It is recommended that all your types implement this interface to accommodate new and unknown future members.</span></span>  
  
### <a name="data-contract-libraries"></a><span data-ttu-id="3d71f-177">Biblioteki kontraktu danych</span><span class="sxs-lookup"><span data-stu-id="3d71f-177">Data Contract Libraries</span></span>  
 <span data-ttu-id="3d71f-178">Może to być bibliotek kontraktów danych, gdy kontrakt jest opublikowana w centralnym repozytorium i konsultantów usługi i typ wdrożenia i udostępnić kontraktów danych z tego repozytorium.</span><span class="sxs-lookup"><span data-stu-id="3d71f-178">There may be libraries of data contracts where a contract is published to a central repository, and service and type implementers implement and expose data contracts from that repository.</span></span> <span data-ttu-id="3d71f-179">W takim przypadku gdy opublikujesz umowy dotyczącej danych do repozytorium masz żadnej kontroli nad tym kto tworzy typy, które ją implementują.</span><span class="sxs-lookup"><span data-stu-id="3d71f-179">In that case, when you publish a data contract to the repository, you have no control over who creates types that implement it.</span></span> <span data-ttu-id="3d71f-180">W związku z tym, nie można zmodyfikować umowy po opublikowaniu, renderowanie na efektywne niezmienne.</span><span class="sxs-lookup"><span data-stu-id="3d71f-180">Thus, you cannot modify the contract once it is published, rendering it effectively immutable.</span></span>  
  
### <a name="when-using-the-xmlserializer"></a><span data-ttu-id="3d71f-181">Przy użyciu elementu XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="3d71f-181">When Using the XmlSerializer</span></span>  
 <span data-ttu-id="3d71f-182">Te same zasady przechowywania wersji stosowane podczas korzystania z <xref:System.Xml.Serialization.XmlSerializer> klasy.</span><span class="sxs-lookup"><span data-stu-id="3d71f-182">The same versioning principles apply when using the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="3d71f-183">Gdy wymagana jest ścisłym przechowywania wersji, Traktuj kontraktów danych jako niezmienialny i tworzenie nowych kontraktów danych przy użyciu nazwy kwalifikowanej, unikatową nowych wersji.</span><span class="sxs-lookup"><span data-stu-id="3d71f-183">When strict versioning is required, treat data contracts as immutable and create new data contracts with unique, qualified names for the new versions.</span></span> <span data-ttu-id="3d71f-184">Gdy masz pewność, że łagodnymi przechowywanie wersji może służyć, mogą dodawać nowych członków do serializacji w nowych wersji, ale nie zmieniać lub Usuń istniejących elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="3d71f-184">When you are sure that lax versioning can be used, you can add new serializable members in new versions but not change or remove existing members.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d71f-185"><xref:System.Xml.Serialization.XmlSerializer> Używa <xref:System.Xml.Serialization.XmlAnyElementAttribute> i <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> atrybuty do obsługi Pełna zgodnooć wersji nieznany danych.</span><span class="sxs-lookup"><span data-stu-id="3d71f-185">The <xref:System.Xml.Serialization.XmlSerializer> uses the <xref:System.Xml.Serialization.XmlAnyElementAttribute> and <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> attributes to support round-tripping of unknown data.</span></span>  
  
## <a name="message-contract-versioning"></a><span data-ttu-id="3d71f-186">Przechowywanie wersji kontraktów komunikatu</span><span class="sxs-lookup"><span data-stu-id="3d71f-186">Message Contract Versioning</span></span>  
 <span data-ttu-id="3d71f-187">Wytyczne dotyczące przechowywanie wersji kontraktów komunikatu są bardzo podobne do przechowywanie wersji kontraktów danych.</span><span class="sxs-lookup"><span data-stu-id="3d71f-187">The guidelines for message contract versioning are very similar to versioning data contracts.</span></span> <span data-ttu-id="3d71f-188">Jeśli wymagana jest ścisłym przechowywania wersji, należy nie zmienić Twoje treści wiadomości, ale zamiast tego utworzyć nowego kontraktu komunikatu, unikatową nazwą kwalifikowaną.</span><span class="sxs-lookup"><span data-stu-id="3d71f-188">If strict versioning is required, you should not change your message body but instead create a new message contract with a unique qualified name.</span></span> <span data-ttu-id="3d71f-189">Jeśli znasz służy łagodnymi przechowywania wersji, możesz dodać nowe części treści wiadomości, ale nie zmienić lub usunąć istniejące.</span><span class="sxs-lookup"><span data-stu-id="3d71f-189">If you know that you can use lax versioning, you can add new message body parts but not change or remove existing ones.</span></span> <span data-ttu-id="3d71f-190">Te wskazówki dotyczą zarówno na komputerze i opakowane kontrakty komunikatów.</span><span class="sxs-lookup"><span data-stu-id="3d71f-190">This guidance applies both to bare and wrapped message contracts.</span></span>  
  
 <span data-ttu-id="3d71f-191">Zawsze można dodawać nagłówki wiadomości, nawet jeśli strict wersji jest używany.</span><span class="sxs-lookup"><span data-stu-id="3d71f-191">Message headers can always be added, even if strict versioning is in use.</span></span> <span data-ttu-id="3d71f-192">Flaga MustUnderstand może mieć wpływ na przechowywanie wersji.</span><span class="sxs-lookup"><span data-stu-id="3d71f-192">The MustUnderstand flag may affect versioning.</span></span> <span data-ttu-id="3d71f-193">Ogólnie rzecz biorąc model przechowywania wersji dla nagłówków w programie WCF jest, jak opisano w specyfikacji protokołu SOAP.</span><span class="sxs-lookup"><span data-stu-id="3d71f-193">In general, the versioning model for headers in WCF is as described in the SOAP specification.</span></span>  
  
## <a name="service-contract-versioning"></a><span data-ttu-id="3d71f-194">Przechowywanie wersji kontraktów usług</span><span class="sxs-lookup"><span data-stu-id="3d71f-194">Service Contract Versioning</span></span>  
 <span data-ttu-id="3d71f-195">Podobnie jak przechowywanie wersji kontraktów danych, przechowywanie wersji kontraktów usługi obejmuje również dodawanie, zmienianie i usuwanie operacji.</span><span class="sxs-lookup"><span data-stu-id="3d71f-195">Similar to data contract versioning, service contract versioning also involves adding, changing, and removing operations.</span></span>  
  
### <a name="specifying-name-namespace-and-action"></a><span data-ttu-id="3d71f-196">Określanie nazwy, Namespace i akcji</span><span class="sxs-lookup"><span data-stu-id="3d71f-196">Specifying Name, Namespace, and Action</span></span>  
 <span data-ttu-id="3d71f-197">Domyślnie nazwa kontraktu usługi jest nazwą interfejsu.</span><span class="sxs-lookup"><span data-stu-id="3d71f-197">By default, the name of a service contract is the name of the interface.</span></span> <span data-ttu-id="3d71f-198">Jego domyślnej przestrzeni nazw "http://tempuri.org", i akcji każdej operacji "http://tempuri.org/contractname/methodname".</span><span class="sxs-lookup"><span data-stu-id="3d71f-198">Its default namespace is "http://tempuri.org", and each operation’s action is "http://tempuri.org/contractname/methodname".</span></span> <span data-ttu-id="3d71f-199">Zalecane jest, że jawnie określisz nazwę i przestrzeń nazw dla kontraktu usługi i akcję dla każdej operacji należy unikać "http://tempuri.org" i uniemożliwić nazwy interfejsu i metoda spowodują ujawnienie w kontrakcie usługi.</span><span class="sxs-lookup"><span data-stu-id="3d71f-199">It is recommended that you explicitly specify a name and namespace for the service contract, and an action for each operation to avoid using "http://tempuri.org" and to prevent interface and method names from being exposed in the service’s contract.</span></span>  
  
### <a name="adding-parameters-and-operations"></a><span data-ttu-id="3d71f-200">Dodawanie parametrów i operacje</span><span class="sxs-lookup"><span data-stu-id="3d71f-200">Adding Parameters and Operations</span></span>  
 <span data-ttu-id="3d71f-201">Dodawanie operacji usług udostępnianych przez usługę jest nierozdzielający zmiany, ponieważ istniejący klienci nie muszą być zajmującym się te nowe operacje.</span><span class="sxs-lookup"><span data-stu-id="3d71f-201">Adding service operations exposed by the service is a nonbreaking change because existing clients need not be concerned about those new operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d71f-202">Dodawanie operacji do kontraktu dwustronnego wywołania zwrotnego jest zmianą przerywającą.</span><span class="sxs-lookup"><span data-stu-id="3d71f-202">Adding operations to a duplex callback contract is a breaking change.</span></span>  
  
### <a name="changing-operation-parameter-or-return-types"></a><span data-ttu-id="3d71f-203">Zmiana parametru operacji lub typów zwracanych</span><span class="sxs-lookup"><span data-stu-id="3d71f-203">Changing Operation Parameter or Return Types</span></span>  
 <span data-ttu-id="3d71f-204">Zmiana parametr lub zwracane typy ogólnie jest istotną zmianę, chyba, że nowy typ implementuje ten sam kontrakt danych implementowana przez typ stary.</span><span class="sxs-lookup"><span data-stu-id="3d71f-204">Changing parameter or return types generally is a breaking change unless the new type implements the same data contract implemented by the old type.</span></span> <span data-ttu-id="3d71f-205">Aby wprowadzić zmiany, Dodaj nową operację do umowy serwisowej lub zdefiniowanie nowego kontraktu usługi.</span><span class="sxs-lookup"><span data-stu-id="3d71f-205">To make such a change, add a new operation to the service contract or define a new service contract.</span></span>  
  
### <a name="removing-operations"></a><span data-ttu-id="3d71f-206">Operacje usuwania</span><span class="sxs-lookup"><span data-stu-id="3d71f-206">Removing Operations</span></span>  
 <span data-ttu-id="3d71f-207">Usuwanie operacji jest również istotną zmianę.</span><span class="sxs-lookup"><span data-stu-id="3d71f-207">Removing operations is also a breaking change.</span></span> <span data-ttu-id="3d71f-208">Aby wprowadzić zmiany, zdefiniowanie nowego kontraktu usługi i ujawnisz go na nowy punkt końcowy.</span><span class="sxs-lookup"><span data-stu-id="3d71f-208">To make such a change, define a new service contract and expose it on a new endpoint.</span></span>  
  
### <a name="fault-contracts"></a><span data-ttu-id="3d71f-209">Kontrakty błędów</span><span class="sxs-lookup"><span data-stu-id="3d71f-209">Fault Contracts</span></span>  
 <span data-ttu-id="3d71f-210"><xref:System.ServiceModel.FaultContractAttribute> Atrybut umożliwia deweloperom kontraktu usługi, podaj informacje o błędach, które mogą być zwracane z operacji kontraktu.</span><span class="sxs-lookup"><span data-stu-id="3d71f-210">The <xref:System.ServiceModel.FaultContractAttribute> attribute enables a service contract developer to specify information about faults that can be returned from the contract's operations.</span></span>  
  
 <span data-ttu-id="3d71f-211">Lista błędów, które opisano w kontrakcie usługi nie jest uważany za wyczerpujący.</span><span class="sxs-lookup"><span data-stu-id="3d71f-211">The list of faults described in a service's contract is not considered exhaustive.</span></span> <span data-ttu-id="3d71f-212">W dowolnym momencie operacja może zwrócić błędy, które nie zostały opisane w zmiana kontraktu.</span><span class="sxs-lookup"><span data-stu-id="3d71f-212">At any time, an operation may return faults that are not described in its contract.</span></span> <span data-ttu-id="3d71f-213">W związku z tym zmiana zestawu błędów opisanych w umowie nie jest uważany za istotne.</span><span class="sxs-lookup"><span data-stu-id="3d71f-213">Therefore changing the set of faults described in the contract is not considered breaking.</span></span> <span data-ttu-id="3d71f-214">Na przykład dodać do umowy przy użyciu nowych odporności <xref:System.ServiceModel.FaultContractAttribute> lub usunięcie istniejącej usterki z umowy.</span><span class="sxs-lookup"><span data-stu-id="3d71f-214">For example, adding a new fault to the contract using the <xref:System.ServiceModel.FaultContractAttribute> or removing an existing fault from the contract.</span></span>  
  
### <a name="service-contract-libraries"></a><span data-ttu-id="3d71f-215">Biblioteki kontraktu usługi</span><span class="sxs-lookup"><span data-stu-id="3d71f-215">Service Contract Libraries</span></span>  
 <span data-ttu-id="3d71f-216">Organizacje mogą mieć bibliotek zamówień, gdy kontrakt jest opublikowana w centralnym repozytorium i konsultantów usługi wdrożenie umów z tego repozytorium.</span><span class="sxs-lookup"><span data-stu-id="3d71f-216">Organizations may have libraries of contracts where a contract is published to a central repository and service implementers implement contracts from that repository.</span></span> <span data-ttu-id="3d71f-217">W tym przypadku gdy opublikujesz umowy serwisowej do repozytorium masz żadnej kontroli nad tym kto tworzy usług, które ją implementują.</span><span class="sxs-lookup"><span data-stu-id="3d71f-217">In this case, when you publish a service contract to the repository you have no control over who creates services that implement it.</span></span> <span data-ttu-id="3d71f-218">W związku z tym nie możesz modyfikować kontraktu usługi, po opublikowaniu renderowaniem go skutecznie niezmienne.</span><span class="sxs-lookup"><span data-stu-id="3d71f-218">Therefore, you cannot modify the service contract once published, rendering it effectively immutable.</span></span> <span data-ttu-id="3d71f-219">Usługi WCF obsługuje dziedziczenie kontraktów, która może służyć do tworzenia nowego kontraktu, który rozszerza istniejących umów.</span><span class="sxs-lookup"><span data-stu-id="3d71f-219">WCF supports contract inheritance, which can be used to create a new contract that extends existing contracts.</span></span> <span data-ttu-id="3d71f-220">Aby użyć tej funkcji, zdefiniuj nowy interfejs kontraktu usługi, która dziedziczy interfejs starego kontraktu usługi, a następnie dodaj metody nowego interfejsu.</span><span class="sxs-lookup"><span data-stu-id="3d71f-220">To use this feature, define a new service contract interface that inherits from the old service contract interface, then add methods to the new interface.</span></span> <span data-ttu-id="3d71f-221">Następnie zmienić usługa, która implementuje ten kontrakt starego wdrożenia nowego kontraktu i zmieniać definicji punktu końcowego "versionOld", aby użyć nowego kontraktu.</span><span class="sxs-lookup"><span data-stu-id="3d71f-221">You then change the service that implements the old contract to implement the new contract and change the "versionOld" endpoint definition to use the new contract.</span></span> <span data-ttu-id="3d71f-222">Dla klientów "versionOld" punktu końcowego będą nadal wyświetlane jako uwidaczniającą kontraktu "versionOld"; dla klientów "versionNew" punktu końcowego pojawi się do udostępnienia kontraktu "versionNew".</span><span class="sxs-lookup"><span data-stu-id="3d71f-222">To "versionOld" clients, the endpoint will continue to appear as exposing the "versionOld" contract; to "versionNew" clients, the endpoint will appear to expose the "versionNew" contract.</span></span>  
  
## <a name="address-and-binding-versioning"></a><span data-ttu-id="3d71f-223">Adres i powiązanie przechowywania wersji</span><span class="sxs-lookup"><span data-stu-id="3d71f-223">Address and Binding Versioning</span></span>  
 <span data-ttu-id="3d71f-224">Zmiany adresu punktu końcowego i powiązania są istotne zmiany, chyba, że klienci są w stanie dynamicznie odnajdywania nowy adres punktu końcowego lub powiązania.</span><span class="sxs-lookup"><span data-stu-id="3d71f-224">Changes to endpoint address and binding are breaking changes unless clients are capable of dynamically discovering the new endpoint address or binding.</span></span> <span data-ttu-id="3d71f-225">Jeden mechanizm implementowania ta funkcja jest za pomocą rejestru Universal opis odnajdywania i integracja (UDDI) i wzorzec wywołania UDDI, gdzie klient próbuje nawiązać połączenia z punktem końcowym i, w przypadku awarii zapytanie UDDI dobrze znane Rejestr bieżący punkt końcowy metadanych.</span><span class="sxs-lookup"><span data-stu-id="3d71f-225">One mechanism for implementing this capability is by using a Universal Discovery Description and Integration (UDDI) registry and the UDDI Invocation Pattern where a client attempts to communicate with an endpoint and, upon failure, queries a well-known UDDI registry for the current endpoint metadata.</span></span> <span data-ttu-id="3d71f-226">Klient używa następnie adres i powiązanie z tych metadanych do komunikowania się z punktem końcowym.</span><span class="sxs-lookup"><span data-stu-id="3d71f-226">The client then uses the address and binding from this metadata to communicate with the endpoint.</span></span> <span data-ttu-id="3d71f-227">Jeśli ta komunikacja zakończy się powodzeniem, klient buforuje informacje dotyczące adresów i powiązania do użycia w przyszłości.</span><span class="sxs-lookup"><span data-stu-id="3d71f-227">If this communication succeeds, the client caches the address and binding information for future use.</span></span>  
  
## <a name="routing-service-and-versioning"></a><span data-ttu-id="3d71f-228">Usługa routingu oraz zarządzanie ich wersjami</span><span class="sxs-lookup"><span data-stu-id="3d71f-228">Routing Service and Versioning</span></span>  
 <span data-ttu-id="3d71f-229">Jeśli zmiany wprowadzone do usługi są istotne zmiany i muszą mieć co najmniej dwóch różnych wersjach usługi uruchomionej jednocześnie służy usługa routingu WCF do przesyłania wiadomości do wystąpienia odpowiednią usługę.</span><span class="sxs-lookup"><span data-stu-id="3d71f-229">If the changes made to a service are breaking changes and you need to have two or more different versions of a service running simultaneously you can use the WCF Routing Service to route messages to the appropriate service instance.</span></span> <span data-ttu-id="3d71f-230">Usługa routingu WCF używa routingu opartego na zawartości, innymi słowy, używa informacji w wiadomości, aby określić miejsce do rozsyłania wiadomości.</span><span class="sxs-lookup"><span data-stu-id="3d71f-230">The WCF Routing Service uses content-based routing, in other words, it uses information within the message to determine where to route the message.</span></span> <span data-ttu-id="3d71f-231">Aby uzyskać więcej informacji na temat usługi routingu WCF, zobacz [usługa routingu](../../../docs/framework/wcf/feature-details/routing-service.md).</span><span class="sxs-lookup"><span data-stu-id="3d71f-231">For more information about the WCF Routing Service see [Routing Service](../../../docs/framework/wcf/feature-details/routing-service.md).</span></span> <span data-ttu-id="3d71f-232">Aby uzyskać przykład sposobu użycia usługi routingu WCF pod kątem przechowywania wersji usługi, zobacz [How to: Przechowywanie wersji usługi](../../../docs/framework/wcf/feature-details/how-to-service-versioning.md).</span><span class="sxs-lookup"><span data-stu-id="3d71f-232">For an example of how to use the WCF Routing Service for service versioning see [How To: Service Versioning](../../../docs/framework/wcf/feature-details/how-to-service-versioning.md).</span></span>  
  
## <a name="appendix"></a><span data-ttu-id="3d71f-233">Dodatek</span><span class="sxs-lookup"><span data-stu-id="3d71f-233">Appendix</span></span>  
 <span data-ttu-id="3d71f-234">Wskazówki wersji kontraktu ogólne dane razie strict versioning jest traktować kontraktów danych jako niezmienialny i tworzenie nowych, gdy są wymagane zmiany.</span><span class="sxs-lookup"><span data-stu-id="3d71f-234">The general data contract versioning guidance when strict versioning is needed is to treat data contracts as immutable and create new ones when changes are required.</span></span> <span data-ttu-id="3d71f-235">Nowa klasa musi zostać utworzona dla każdego nowego kontraktu danych, tak wymagany jest mechanizm pozwala uniknąć uruchomić istniejący kod, który został napisany pod względem stare dane kontraktu klasy i ponowne zapisywanie adresów pod względem nowej klasy kontraktu danych.</span><span class="sxs-lookup"><span data-stu-id="3d71f-235">A new class needs to be created for each new data contract, so a mechanism is needed to avoid having to take existing code that was written in terms of the old data contract class and rewrite it in terms of the new data contract class.</span></span>  
  
 <span data-ttu-id="3d71f-236">Jeden taki mechanizm jest zdefiniowanie członków każdej umowy danych oraz pisania kodu wewnętrznej implementacji pod względem interfejsów, a nie klasy kontraktu danych, które implementują interfejsy za pomocą interfejsów.</span><span class="sxs-lookup"><span data-stu-id="3d71f-236">One such mechanism is to use interfaces to define the members of each data contract and write internal implementation code in terms of the interfaces rather than the data contract classes that implement the interfaces.</span></span> <span data-ttu-id="3d71f-237">W poniższym kodzie dla wersji 1 usługi pokazano `IPurchaseOrderV1` interfejsu i `PurchaseOrderV1`:</span><span class="sxs-lookup"><span data-stu-id="3d71f-237">The following code for version 1 of a service shows an `IPurchaseOrderV1` interface and a `PurchaseOrderV1`:</span></span>  
  
```  
public interface IPurchaseOrderV1  
{  
    string OrderId { get; set; }  
    string CustomerId { get; set; }  
}  
  
[DataContract(  
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2005/10/PurchaseOrder")]  
public class PurchaseOrderV1 : IPurchaseOrderV1  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
}  
```  
  
 <span data-ttu-id="3d71f-238">Podczas operacji kontraktu usługi powinny być zapisane w `PurchaseOrderV1`, logiki biznesowej rzeczywiste byłaby w kategoriach `IPurchaseOrderV1`.</span><span class="sxs-lookup"><span data-stu-id="3d71f-238">While the service contract’s operations would be written in terms of `PurchaseOrderV1`, the actual business logic would be in terms of `IPurchaseOrderV1`.</span></span> <span data-ttu-id="3d71f-239">Następnie, w wersji 2 będzie istnieć nową `IPurchaseOrderV2` interfejsu i nową `PurchaseOrderV2` klasy, jak pokazano w poniższym kodzie:</span><span class="sxs-lookup"><span data-stu-id="3d71f-239">Then, in version 2, there would be a new `IPurchaseOrderV2` interface and a new `PurchaseOrderV2` class as shown in the following code:</span></span>  
  
```  
public interface IPurchaseOrderV2  
{  
    DateTime OrderDate { get; set; }  
}

[DataContract(   
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2006/02/PurchaseOrder")]  
public class PurchaseOrderV2 : IPurchaseOrderV1, IPurchaseOrderV2  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
    [DataMember(...)]  
    public DateTime OrderDate { ... }  
}  
```  
  
 <span data-ttu-id="3d71f-240">Kontrakt usługi zostałaby zaktualizowana w celu uwzględnienia nowych operacji, które są zapisywane w `PurchaseOrderV2`.</span><span class="sxs-lookup"><span data-stu-id="3d71f-240">The service contract would be updated to include new operations that are written in terms of `PurchaseOrderV2`.</span></span> <span data-ttu-id="3d71f-241">Istniejącej logiki biznesowej, zapisane pod względem `IPurchaseOrderV1` będzie w dalszym ciągu działać w przypadku `PurchaseOrderV2` i nowej logiki biznesowej, który wymaga `OrderDate` właściwości powinny być zapisane w `IPurchaseOrderV2`.</span><span class="sxs-lookup"><span data-stu-id="3d71f-241">Existing business logic written in terms of `IPurchaseOrderV1` would continue to work for `PurchaseOrderV2` and new business logic that needs the `OrderDate` property would be written in terms of `IPurchaseOrderV2`.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3d71f-242">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="3d71f-242">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Runtime.Serialization.DataContractAttribute>
- <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A>
- <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A>
- <xref:System.Runtime.Serialization.IExtensibleDataObject>
- <xref:System.Runtime.Serialization.ExtensionDataObject>
- <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A>
- <xref:System.Xml.Serialization.XmlSerializer>
- [<span data-ttu-id="3d71f-243">Równoważność kontraktów danych</span><span class="sxs-lookup"><span data-stu-id="3d71f-243">Data Contract Equivalence</span></span>](../../../docs/framework/wcf/feature-details/data-contract-equivalence.md)
- [<span data-ttu-id="3d71f-244">Wywołania zwrotne serializacji z tolerancją dla wersji</span><span class="sxs-lookup"><span data-stu-id="3d71f-244">Version-Tolerant Serialization Callbacks</span></span>](../../../docs/framework/wcf/feature-details/version-tolerant-serialization-callbacks.md)
