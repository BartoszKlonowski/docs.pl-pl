---
title: Inicjalizacja z opóźnieniem
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lazy initialization in .NET, introduction
ms.assetid: 56b4ae5c-4745-44ff-ad78-ffe4fcde6b9b
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: ce217e2ed8e542ad0f7122970655aa32a353f51a
ms.sourcegitcommit: 0be8a279af6d8a43e03141e349d3efd5d35f8767
ms.translationtype: HT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/18/2019
ms.locfileid: "59182302"
---
# <a name="lazy-initialization"></a><span data-ttu-id="aa6b2-102">Inicjalizacja z opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="aa6b2-102">Lazy Initialization</span></span>
<span data-ttu-id="aa6b2-103">*Inicjalizacja z opóźnieniem* obiektu oznacza, że jego utworzenia jest odroczone do czasu jej pierwszym użyciu.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-103">*Lazy initialization* of an object means that its creation is deferred until it is first used.</span></span> <span data-ttu-id="aa6b2-104">(W tym temacie warunki *inicjowania z opóźnieniem* i *wystąpienia z opóźnieniem* oznaczają to samo.) Inicjalizacja z opóźnieniem służy głównie do zwiększenia wydajności, należy unikać marnotrawstwa obliczeń i zmniejszyć wymagania dotyczące pamięci programu.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-104">(For this topic, the terms *lazy initialization* and *lazy instantiation* are synonymous.) Lazy initialization is primarily used to improve performance, avoid wasteful computation, and reduce program memory requirements.</span></span> <span data-ttu-id="aa6b2-105">Poniżej przedstawiono najbardziej typowych scenariuszy:</span><span class="sxs-lookup"><span data-stu-id="aa6b2-105">These are the most common scenarios:</span></span>  
  
-   <span data-ttu-id="aa6b2-106">Gdy ma obiekt, który jest kosztowne, a program nie może używać.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-106">When you have an object that is expensive to create, and the program might not use it.</span></span> <span data-ttu-id="aa6b2-107">Na przykład załóżmy, że masz w pamięci `Customer` obiekt, który ma `Orders` właściwość, która zawiera dużą tablicę liczb `Order` obiekty, które zainicjowana, wymaga połączenia z bazą danych.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-107">For example, assume that you have in memory a `Customer` object that has an `Orders` property that contains a large array of `Order` objects that, to be initialized, requires a database connection.</span></span> <span data-ttu-id="aa6b2-108">Jeśli użytkownik nigdy nie prosi do wyświetlania zamówień lub użyć danych w obliczeń, następnie nie ma powodu ją utworzyć za pomocą pamięci systemowej lub cykli obliczeniowych.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-108">If the user never asks to display the Orders or use the data in a computation, then there is no reason to use system memory or computing cycles to create it.</span></span> <span data-ttu-id="aa6b2-109">Za pomocą `Lazy<Orders>` do deklarowania `Orders` obiektu inicjowania z opóźnieniem, możesz uniknąć marnowania zasobów systemowych, jeśli obiekt nie jest używany.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-109">By using `Lazy<Orders>` to declare the `Orders` object for lazy initialization, you can avoid wasting system resources when the object is not used.</span></span>  
  
-   <span data-ttu-id="aa6b2-110">Gdy obiekt, która jest kosztowna utworzyć i mają być odroczone jej tworzenia, aż po innych kosztowne operacje zostały zakończone.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-110">When you have an object that is expensive to create, and you want to defer its creation until after other expensive operations have been completed.</span></span> <span data-ttu-id="aa6b2-111">Załóżmy na przykład, czy program ładuje kilka wystąpień obiektu po jego uruchomieniu, ale tylko niektóre z nich wymagane jest od razu.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-111">For example, assume that your program loads several object instances when it starts, but only some of them are required immediately.</span></span> <span data-ttu-id="aa6b2-112">Aby zwiększyć wydajność uruchamiania programów, należy Opóźnienie inicjowania obiektów, które nie są wymagane, dopóki nie zostały utworzone wymagane obiekty.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-112">You can improve the startup performance of the program by deferring initialization of the objects that are not required until the required objects have been created.</span></span>  
  
 <span data-ttu-id="aa6b2-113">Mimo że można napisać własny kod, aby wykonać inicjowania z opóźnieniem, firma Microsoft zaleca użycie <xref:System.Lazy%601> zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-113">Although you can write your own code to perform lazy initialization, we recommend that you use <xref:System.Lazy%601> instead.</span></span> <span data-ttu-id="aa6b2-114"><xref:System.Lazy%601> oraz jego powiązanych typów również obsługuje bezpieczeństwo wątków i zasady propagacji wyjątku spójne.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-114"><xref:System.Lazy%601> and its related types also support thread-safety and provide a consistent exception propagation policy.</span></span>  
  
 <span data-ttu-id="aa6b2-115">W poniższej tabeli wymieniono typy, które zapewnia .NET Framework w wersji 4, umożliwiające inicjowanie z opóźnieniem w różnych scenariuszach.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-115">The following table lists the types that the .NET Framework version 4 provides to enable lazy initialization in different scenarios.</span></span>  
  
|<span data-ttu-id="aa6b2-116">Typ</span><span class="sxs-lookup"><span data-stu-id="aa6b2-116">Type</span></span>|<span data-ttu-id="aa6b2-117">Opis</span><span class="sxs-lookup"><span data-stu-id="aa6b2-117">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601>|<span data-ttu-id="aa6b2-118">Klasa otoki, która zapewnia semantykę, inicjowania z opóźnieniem dla biblioteki klas lub typ zdefiniowany przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-118">A wrapper class that provides lazy initialization semantics for any class library or user-defined type.</span></span>|  
|<xref:System.Threading.ThreadLocal%601>|<span data-ttu-id="aa6b2-119">Przypomina <xref:System.Lazy%601> z tą różnicą, że zapewnia semantykę inicjowania z opóźnieniem na podstawie lokalnej wątku.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-119">Resembles <xref:System.Lazy%601> except that it provides lazy initialization semantics on a thread-local basis.</span></span> <span data-ttu-id="aa6b2-120">Każdy wątek ma dostęp do jego własnej unikatowe wartości.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-120">Every thread has access to its own unique value.</span></span>|  
|<xref:System.Threading.LazyInitializer>|<span data-ttu-id="aa6b2-121">Zapewnia zaawansowane `static` (`Shared` w języku Visual Basic) metody incjalizacji obiektów bez konieczności klasy.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-121">Provides advanced `static` (`Shared` in Visual Basic) methods for lazy initialization of objects without the overhead of a class.</span></span>|  
  
## <a name="basic-lazy-initialization"></a><span data-ttu-id="aa6b2-122">Podstawowe inicjowania z opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="aa6b2-122">Basic Lazy Initialization</span></span>  
 <span data-ttu-id="aa6b2-123">Do zdefiniowania z opóźnieniem zainicjowany typem, na przykład `MyType`, użyj `Lazy<MyType>` (`Lazy(Of MyType)` w języku Visual Basic), jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-123">To define a lazy-initialized type, for example, `MyType`, use `Lazy<MyType>` (`Lazy(Of MyType)` in Visual Basic), as shown in the following example.</span></span> <span data-ttu-id="aa6b2-124">Jeśli delegowanie nie jest przekazywany w <xref:System.Lazy%601> opakowany typ konstruktora, jest tworzona przy użyciu <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> podczas pierwszego otwarcia właściwości value.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-124">If no delegate is passed in the <xref:System.Lazy%601> constructor, the wrapped type is created by using <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> when the value property is first accessed.</span></span> <span data-ttu-id="aa6b2-125">Jeśli typ nie ma domyślnego konstruktora, zwracany jest wyjątek czasu wykonywania.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-125">If the type does not have a default constructor, a run-time exception is thrown.</span></span>  
  
 <span data-ttu-id="aa6b2-126">W poniższym przykładzie przyjęto założenie, że `Orders` to klasa, która zawiera tablicę `Order` obiekty są pobierane z bazy danych.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-126">In the following example, assume that `Orders` is a class that contains an array of `Order` objects retrieved from a database.</span></span> <span data-ttu-id="aa6b2-127">A `Customer` obiekt zawiera wystąpienie `Orders`, ale w zależności od działań użytkownika, danych z `Orders` obiekt nie może być wymagane.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-127">A `Customer` object contains an instance of `Orders`, but depending on user actions, the data from the `Orders` object might not be required.</span></span>  
  
 [!code-csharp[Lazy#1](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#1)]
 [!code-vb[Lazy#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#1)]  
  
 <span data-ttu-id="aa6b2-128">Można również przekazać delegata w <xref:System.Lazy%601> Konstruktor, który wywołuje konstruktora określonego przeciążenia opakowanej typu w czasie tworzenia i wykonać pozostałe kroki inicjowania, które są wymagane, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-128">You can also pass a delegate in the <xref:System.Lazy%601> constructor that invokes a specific constructor overload on the wrapped type at creation time, and perform any other initialization steps that are required, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#2](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#2)]
 [!code-vb[Lazy#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#2)]  
  
 <span data-ttu-id="aa6b2-129">Po utworzeniu obiektu z opóźnieniem, żadne wystąpienie elementu `Orders` jest tworzony, dopóki <xref:System.Lazy%601.Value%2A> właściwości zmiennej z opóźnieniem odbywa się po raz pierwszy.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-129">After the Lazy object is created, no instance of `Orders` is created until the <xref:System.Lazy%601.Value%2A> property of the Lazy variable is accessed for the first time.</span></span> <span data-ttu-id="aa6b2-130">Na pierwszym dostępie opakowany typ jest utworzony i zwracane, a także przechowywane, aby uzyskać dostęp do wszystkich przyszłych.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-130">On first access, the wrapped type is created and returned, and stored for any future access.</span></span>  
  
 [!code-csharp[Lazy#3](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#3)]
 [!code-vb[Lazy#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#3)]  
  
 <span data-ttu-id="aa6b2-131">A <xref:System.Lazy%601> zawsze zwraca ten sam obiekt lub wartość, która została zainicjowana przy użyciu.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-131">A <xref:System.Lazy%601> object always returns the same object or value that it was initialized with.</span></span> <span data-ttu-id="aa6b2-132">W związku z tym <xref:System.Lazy%601.Value%2A> właściwość jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-132">Therefore, the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="aa6b2-133">Jeśli <xref:System.Lazy%601.Value%2A> zapisuje odwołanie do typu, nie można przypisać nowy obiekt do niego.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-133">If <xref:System.Lazy%601.Value%2A> stores a reference type, you cannot assign a new object to it.</span></span> <span data-ttu-id="aa6b2-134">(Jednak można zmienić wartość można ustawić pola publiczne i właściwości.) Jeśli <xref:System.Lazy%601.Value%2A> zapisuje wartość typu, nie można zmodyfikować jego wartości.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-134">(However, you can change the value of its settable public fields and properties.) If <xref:System.Lazy%601.Value%2A> stores a value type, you cannot modify its value.</span></span> <span data-ttu-id="aa6b2-135">Niemniej jednak można utworzyć nową zmienną za pomocą wywołania konstruktora zmiennej ponownie przy użyciu nowe argumenty.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-135">Nevertheless, you can create a new variable by invoking the variable constructor again by using new arguments.</span></span>  
  
 [!code-csharp[Lazy#4](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#4)]
 [!code-vb[Lazy#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#4)]  
  
 <span data-ttu-id="aa6b2-136">Nowe wystąpienie z opóźnieniem, tak jak wcześniej, nie tworzy wystąpienia `Orders` do momentu jego <xref:System.Lazy%601.Value%2A> najpierw dostęp do właściwości.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-136">The new lazy instance, like the earlier one, does not instantiate `Orders` until its <xref:System.Lazy%601.Value%2A> property is first accessed.</span></span>  
  
### <a name="thread-safe-initialization"></a><span data-ttu-id="aa6b2-137">Wątkowo inicjowanie</span><span class="sxs-lookup"><span data-stu-id="aa6b2-137">Thread-Safe Initialization</span></span>  
 <span data-ttu-id="aa6b2-138">Domyślnie <xref:System.Lazy%601> obiekty są odporne na wątki.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-138">By default, <xref:System.Lazy%601> objects are thread-safe.</span></span> <span data-ttu-id="aa6b2-139">Oznacza to, jeśli Konstruktor nie określa rodzaj bezpieczeństwo wątków <xref:System.Lazy%601> tworzy obiekty są odporne na wątki.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-139">That is, if the constructor does not specify the kind of thread safety, the <xref:System.Lazy%601> objects it creates are thread-safe.</span></span> <span data-ttu-id="aa6b2-140">W scenariuszach wielowątkowych, pierwszym wątkiem w celu uzyskania dostępu do <xref:System.Lazy%601.Value%2A> właściwość obsługujące wielowątkowość <xref:System.Lazy%601> obiektu inicjuje go dla wszystkich kolejnych dostępy do we wszystkich wątkach i wszystkie wątki udostępnianie tych samych danych.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-140">In multi-threaded scenarios, the first thread to access the <xref:System.Lazy%601.Value%2A> property of a thread-safe <xref:System.Lazy%601> object initializes it for all subsequent accesses on all threads, and all threads share the same data.</span></span> <span data-ttu-id="aa6b2-141">Dlatego nie ma znaczenia, który wątek inicjuje obiekt i sytuacje wyścigu sygnalizują poważnych problemów.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-141">Therefore, it does not matter which thread initializes the object, and race conditions are benign.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aa6b2-142">Ten spójności w warunkach błędu można rozszerzyć za pomocą pamięci podręcznej wyjątek.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-142">You can extend this consistency to error conditions by using exception caching.</span></span> <span data-ttu-id="aa6b2-143">Aby uzyskać więcej informacji, zobacz następną sekcję, [wyjątków w obiektów z opóźnieniem](../../../docs/framework/performance/lazy-initialization.md#ExceptionsInLazyObjects).</span><span class="sxs-lookup"><span data-stu-id="aa6b2-143">For more information, see the next section, [Exceptions in Lazy Objects](../../../docs/framework/performance/lazy-initialization.md#ExceptionsInLazyObjects).</span></span>  
  
 <span data-ttu-id="aa6b2-144">Poniższy przykład pokazuje, że takie same `Lazy<int>` wystąpienie ma taką samą wartość dla trzech oddzielnych wątkach.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-144">The following example shows that the same `Lazy<int>` instance has the same value for three separate threads.</span></span>  
  
 [!code-csharp[Lazy#8](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#8)]
 [!code-vb[Lazy#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#8)]  
  
 <span data-ttu-id="aa6b2-145">Jeśli wymagane są osobne dane dla każdego wątku, należy użyć <xref:System.Threading.ThreadLocal%601> typ, zgodnie z opisem w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-145">If you require separate data on each thread, use the <xref:System.Threading.ThreadLocal%601> type, as described later in this topic.</span></span>  
  
 <span data-ttu-id="aa6b2-146">Niektóre <xref:System.Lazy%601> konstruktorów mają parametrem logicznym o nazwie `isThreadSafe` używany do określenia czy <xref:System.Lazy%601.Value%2A> właściwości będą uzyskiwać dostęp z wielu wątków.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-146">Some <xref:System.Lazy%601> constructors have a Boolean parameter named `isThreadSafe` that is used to specify whether the <xref:System.Lazy%601.Value%2A> property will be accessed from multiple threads.</span></span> <span data-ttu-id="aa6b2-147">Jeśli planujesz dostęp do właściwości z tylko jednego wątku, Przekaż `false` korzyści skromną wydajności.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-147">If you intend to access the property from just one thread, pass in `false` to obtain a modest performance benefit.</span></span> <span data-ttu-id="aa6b2-148">Jeśli planujesz dostęp do właściwości z wielu wątków, Przekaż `true` nakazać <xref:System.Lazy%601> wystąpienia poprawnie obsługuje sytuacje wyścigu, w których jeden wątek zgłasza wyjątek w czasie inicjowania.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-148">If you intend to access the property from multiple threads, pass in `true` to instruct the <xref:System.Lazy%601> instance to correctly handle race conditions in which one thread throws an exception at initialization time.</span></span>  
  
 <span data-ttu-id="aa6b2-149">Niektóre <xref:System.Lazy%601> mają konstruktory <xref:System.Threading.LazyThreadSafetyMode> parametr o nazwie `mode`.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-149">Some <xref:System.Lazy%601> constructors have a <xref:System.Threading.LazyThreadSafetyMode> parameter named `mode`.</span></span> <span data-ttu-id="aa6b2-150">Te konstruktory zapewniają tryb awaryjny wątku dodatkowe.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-150">These constructors provide an additional thread safety mode.</span></span> <span data-ttu-id="aa6b2-151">W poniższej tabeli przedstawiono, jak bezpieczeństwo wątku <xref:System.Lazy%601> obiektu jest zależna od parametry konstruktora, które określają bezpieczeństwo wątkowe.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-151">The following table shows how the thread safety of a <xref:System.Lazy%601> object is affected by constructor parameters that specify thread safety.</span></span> <span data-ttu-id="aa6b2-152">Każdy Konstruktor ma co najwyżej jeden taki parametr.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-152">Each constructor has at most one such parameter.</span></span>  
  
|<span data-ttu-id="aa6b2-153">Bezpieczeństwo wątków obiektu</span><span class="sxs-lookup"><span data-stu-id="aa6b2-153">Thread safety of the object</span></span>|<span data-ttu-id="aa6b2-154">`LazyThreadSafetyMode` `mode` Parametr</span><span class="sxs-lookup"><span data-stu-id="aa6b2-154">`LazyThreadSafetyMode` `mode` parameter</span></span>|<span data-ttu-id="aa6b2-155">Wartość logiczna `isThreadSafe` parametru</span><span class="sxs-lookup"><span data-stu-id="aa6b2-155">Boolean `isThreadSafe` parameter</span></span>|<span data-ttu-id="aa6b2-156">Brak parametrów bezpieczeństwa wątków</span><span class="sxs-lookup"><span data-stu-id="aa6b2-156">No thread safety parameters</span></span>|  
|---------------------------------|---------------------------------------------|--------------------------------------|---------------------------------|  
|<span data-ttu-id="aa6b2-157">W pełni wątkowo; tylko jeden wątek jednocześnie próbuje zainicjować wartości.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-157">Fully thread-safe; only one thread at a time tries to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|<span data-ttu-id="aa6b2-158">Tak.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-158">Yes.</span></span>|  
|<span data-ttu-id="aa6b2-159">Nie metodą o bezpiecznych wątkach.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-159">Not thread-safe.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|<span data-ttu-id="aa6b2-160">Nie dotyczy.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-160">Not applicable.</span></span>|  
|<span data-ttu-id="aa6b2-161">W pełni wątkowo; Wyścig wątków do inicjacji wartości.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-161">Fully thread-safe; threads race to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|<span data-ttu-id="aa6b2-162">Nie dotyczy.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-162">Not applicable.</span></span>|<span data-ttu-id="aa6b2-163">Nie dotyczy.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-163">Not applicable.</span></span>|  
  
 <span data-ttu-id="aa6b2-164">Jak widać w tabeli, określając <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> dla `mode` parametru jest taka sama jak określanie `true` dla `isThreadSafe` parametru i określając <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> jest taka sama jak określanie `false`.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-164">As the table shows, specifying <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> for the `mode` parameter is the same as specifying `true` for the `isThreadSafe` parameter, and specifying <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> is the same as specifying `false`.</span></span>  
  
 <span data-ttu-id="aa6b2-165">Określanie <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> zezwala na wiele wątków próbuje zainicjować <xref:System.Lazy%601> wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-165">Specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> allows multiple threads to attempt to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="aa6b2-166">Tylko jeden wątek może wygrać Wyścig, a inne wątki otrzymują wartość, która została zainicjowana przez wątek się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-166">Only one thread can win this race, and all the other threads receive the value that was initialized by the successful thread.</span></span> <span data-ttu-id="aa6b2-167">Jeśli w wątku, jest zgłaszany wyjątek podczas inicjowania, wątek nie otrzymuje wartość ustawioną przy użyciu pomyślne wątku.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-167">If an exception is thrown on a thread during initialization, that thread does not receive the value set by the successful thread.</span></span> <span data-ttu-id="aa6b2-168">Wyjątki nie są buforowane, dlatego kolejna próba uzyskania dostępu <xref:System.Lazy%601.Value%2A> właściwość może doprowadzić do prawidłowego zainicjowania.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-168">Exceptions are not cached, so a subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property can result in successful initialization.</span></span> <span data-ttu-id="aa6b2-169">To różni się od sposobu wyjątki są traktowane w innych trybach, który jest opisany w poniższej sekcji.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-169">This differs from the way exceptions are treated in other modes, which is described in the following section.</span></span> <span data-ttu-id="aa6b2-170">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.LazyThreadSafetyMode> wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-170">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
<a name="ExceptionsInLazyObjects"></a>   
## <a name="exceptions-in-lazy-objects"></a><span data-ttu-id="aa6b2-171">Wyjątki w obiektów z opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="aa6b2-171">Exceptions in Lazy Objects</span></span>  
 <span data-ttu-id="aa6b2-172">Jak wspomniano wcześniej, <xref:System.Lazy%601> zawsze zwraca ten sam obiekt lub wartość, która została zainicjowana, i w związku z tym <xref:System.Lazy%601.Value%2A> właściwość jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-172">As stated earlier, a <xref:System.Lazy%601> object always returns the same object or value that it was initialized with, and therefore the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="aa6b2-173">Po włączeniu buforowania wyjątek, wyjątek zachowanie rozszerzają to niezmienności.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-173">If you enable exception caching, this immutability also extends to exception behavior.</span></span> <span data-ttu-id="aa6b2-174">Jeśli obiekt inicjowany z opóźnieniem jest włączone buforowanie wyjątek i zgłasza wyjątek z jego metody inicjującej podczas <xref:System.Lazy%601.Value%2A> najpierw dostęp do właściwości, ten sam wyjątek jest zgłaszany w każdej kolejnej próby dostępu do <xref:System.Lazy%601.Value%2A> właściwości .</span><span class="sxs-lookup"><span data-stu-id="aa6b2-174">If a lazy-initialized object has exception caching enabled and throws an exception from its initialization method when the <xref:System.Lazy%601.Value%2A> property is first accessed, that same exception is thrown on every subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property.</span></span> <span data-ttu-id="aa6b2-175">Innymi słowy, Konstruktor opakowany typ nigdy nie zostanie ponownie wywołana, nawet w scenariuszach wielowątkowych.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-175">In other words, the constructor of the wrapped type is never re-invoked, even in multithreaded scenarios.</span></span> <span data-ttu-id="aa6b2-176">W związku z tym <xref:System.Lazy%601> obiektu nie można zgłosić wyjątek na jednym dostępu i zwraca wartości na kolejny dostęp.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-176">Therefore, the <xref:System.Lazy%601> object cannot throw an exception on one access and return a value on a subsequent access.</span></span>  
  
 <span data-ttu-id="aa6b2-177">Wyjątek jest włączone buforowanie przy użyciu jednej <xref:System.Lazy%601?displayProperty=nameWithType> konstruktora przyjmującego metodę inicjalizacji (`valueFactory` parametru), na przykład jest włączona, gdy używasz `Lazy(T)(Func(T))`konstruktora.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-177">Exception caching is enabled when you use any <xref:System.Lazy%601?displayProperty=nameWithType> constructor that takes an initialization method (`valueFactory` parameter); for example, it is enabled when you use the `Lazy(T)(Func(T))`constructor.</span></span> <span data-ttu-id="aa6b2-178">Jeśli Konstruktor przyjmuje liczbę również <xref:System.Threading.LazyThreadSafetyMode> wartość (`mode` parametru), określ <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> lub <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-178">If the constructor also takes a <xref:System.Threading.LazyThreadSafetyMode> value (`mode` parameter), specify <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> or <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aa6b2-179">Określanie metody inicjującej umożliwia wyjątek buforowania dla tych dwóch trybów.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-179">Specifying an initialization method enables exception caching for these two modes.</span></span> <span data-ttu-id="aa6b2-180">Metoda inicjująca może być bardzo proste.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-180">The initialization method can be very simple.</span></span> <span data-ttu-id="aa6b2-181">Na przykład może wywołać konstruktora domyślnego dla `T`: `new Lazy<Contents>(() => new Contents(), mode)` w języku C# lub `New Lazy(Of Contents)(Function() New Contents())` w języku Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-181">For example, it might call the default constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic.</span></span> <span data-ttu-id="aa6b2-182">Jeśli używasz <xref:System.Lazy%601?displayProperty=nameWithType> Konstruktor, który nie określa metodę inicjalizacji, wyjątki wyrzucane przez domyślny konstruktor dla `T` nie są buforowane.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-182">If you use a <xref:System.Lazy%601?displayProperty=nameWithType> constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for `T` are not cached.</span></span> <span data-ttu-id="aa6b2-183">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.LazyThreadSafetyMode> wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-183">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aa6b2-184">Jeśli tworzysz <xref:System.Lazy%601> obiekt z `isThreadSafe` parametr konstruktora równa `false` lub `mode` parametr konstruktora równa <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, musi mieć dostęp <xref:System.Lazy%601> obiektu z jednego wątku lub podać własne Synchronizacja.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-184">If you create a <xref:System.Lazy%601> object with the `isThreadSafe` constructor parameter set to `false` or the `mode` constructor parameter set to <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, you must access the <xref:System.Lazy%601> object from a single thread or provide your own synchronization.</span></span> <span data-ttu-id="aa6b2-185">Dotyczy to wszystkich aspektów obiektu, w tym usługi pamięć podręczna wyjątek.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-185">This applies to all aspects of the object, including exception caching.</span></span>  
  
 <span data-ttu-id="aa6b2-186">Jak wspomniano w poprzedniej sekcji <xref:System.Lazy%601> obiekty utworzone przez określenie <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> inaczej traktują wyjątków.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-186">As noted in the previous section, <xref:System.Lazy%601> objects created by specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> treat exceptions differently.</span></span> <span data-ttu-id="aa6b2-187">Za pomocą <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, mogą konkurować wiele wątków, aby zainicjować <xref:System.Lazy%601> wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-187">With <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, multiple threads can compete to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="aa6b2-188">W tym przypadku wyjątki nie są buforowane i próbuje uzyskać dostęp do <xref:System.Lazy%601.Value%2A> właściwości można kontynuować przed pomyślnym zakończeniem inicjowania.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-188">In this case, exceptions are not cached, and attempts to access the <xref:System.Lazy%601.Value%2A> property can continue until initialization is successful.</span></span>  
  
 <span data-ttu-id="aa6b2-189">Poniższa tabela zawiera podsumowanie sposobu <xref:System.Lazy%601> konstruktory kontrolowanie buforowania wyjątku.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-189">The following table summarizes the way the <xref:System.Lazy%601> constructors control exception caching.</span></span>  
  
|<span data-ttu-id="aa6b2-190">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="aa6b2-190">Constructor</span></span>|<span data-ttu-id="aa6b2-191">Tryb awaryjny wątku</span><span class="sxs-lookup"><span data-stu-id="aa6b2-191">Thread safety mode</span></span>|<span data-ttu-id="aa6b2-192">Używa metody inicjującej</span><span class="sxs-lookup"><span data-stu-id="aa6b2-192">Uses initialization method</span></span>|<span data-ttu-id="aa6b2-193">Wyjątki są buforowane.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-193">Exceptions are cached</span></span>|  
|-----------------|------------------------|--------------------------------|---------------------------|  
|<span data-ttu-id="aa6b2-194">Lazy(T)()</span><span class="sxs-lookup"><span data-stu-id="aa6b2-194">Lazy(T)()</span></span>|<span data-ttu-id="aa6b2-195">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="aa6b2-195">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="aa6b2-196">Nie</span><span class="sxs-lookup"><span data-stu-id="aa6b2-196">No</span></span>|<span data-ttu-id="aa6b2-197">Nie</span><span class="sxs-lookup"><span data-stu-id="aa6b2-197">No</span></span>|  
|<span data-ttu-id="aa6b2-198">Lazy(T)(FUNC(T))</span><span class="sxs-lookup"><span data-stu-id="aa6b2-198">Lazy(T)(Func(T))</span></span>|<span data-ttu-id="aa6b2-199">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="aa6b2-199">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="aa6b2-200">Tak</span><span class="sxs-lookup"><span data-stu-id="aa6b2-200">Yes</span></span>|<span data-ttu-id="aa6b2-201">Tak</span><span class="sxs-lookup"><span data-stu-id="aa6b2-201">Yes</span></span>|  
|<span data-ttu-id="aa6b2-202">Lazy(T)(Boolean)</span><span class="sxs-lookup"><span data-stu-id="aa6b2-202">Lazy(T)(Boolean)</span></span>|<span data-ttu-id="aa6b2-203">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) lub `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="aa6b2-203">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="aa6b2-204">Nie</span><span class="sxs-lookup"><span data-stu-id="aa6b2-204">No</span></span>|<span data-ttu-id="aa6b2-205">Nie</span><span class="sxs-lookup"><span data-stu-id="aa6b2-205">No</span></span>|  
|<span data-ttu-id="aa6b2-206">Lazy(T)(FUNC(T), atrybut typu wartość logiczna)</span><span class="sxs-lookup"><span data-stu-id="aa6b2-206">Lazy(T)(Func(T), Boolean)</span></span>|<span data-ttu-id="aa6b2-207">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) lub `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="aa6b2-207">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="aa6b2-208">Tak</span><span class="sxs-lookup"><span data-stu-id="aa6b2-208">Yes</span></span>|<span data-ttu-id="aa6b2-209">Yes</span><span class="sxs-lookup"><span data-stu-id="aa6b2-209">Yes</span></span>|  
|<span data-ttu-id="aa6b2-210">Lazy(T)(LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="aa6b2-210">Lazy(T)(LazyThreadSafetyMode)</span></span>|<span data-ttu-id="aa6b2-211">Określone przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="aa6b2-211">User-specified</span></span>|<span data-ttu-id="aa6b2-212">Nie</span><span class="sxs-lookup"><span data-stu-id="aa6b2-212">No</span></span>|<span data-ttu-id="aa6b2-213">Nie</span><span class="sxs-lookup"><span data-stu-id="aa6b2-213">No</span></span>|  
|<span data-ttu-id="aa6b2-214">Lazy(T)(Func(T), LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="aa6b2-214">Lazy(T)(Func(T), LazyThreadSafetyMode)</span></span>|<span data-ttu-id="aa6b2-215">Określone przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="aa6b2-215">User-specified</span></span>|<span data-ttu-id="aa6b2-216">Tak</span><span class="sxs-lookup"><span data-stu-id="aa6b2-216">Yes</span></span>|<span data-ttu-id="aa6b2-217">Nie, gdy użytkownik poda <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; w przeciwnym razie tak.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-217">No if user specifies <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; otherwise, yes.</span></span>|  
  
## <a name="implementing-a-lazy-initialized-property"></a><span data-ttu-id="aa6b2-218">Implementowanie właściwości inicjowany z opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="aa6b2-218">Implementing a Lazy-Initialized Property</span></span>  
 <span data-ttu-id="aa6b2-219">Aby zaimplementować właściwości publicznej przy użyciu inicjowania z opóźnieniem, zdefiniuj do pola pomocniczego właściwości jako <xref:System.Lazy%601>i zwróć <xref:System.Lazy%601.Value%2A> właściwość `get` metody dostępu właściwości.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-219">To implement a public property by using lazy initialization, define the backing field of the property as a <xref:System.Lazy%601>, and return the <xref:System.Lazy%601.Value%2A> property from the `get` accessor of the property.</span></span>  
  
 [!code-csharp[Lazy#5](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#5)]
 [!code-vb[Lazy#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#5)]  
  
 <span data-ttu-id="aa6b2-220"><xref:System.Lazy%601.Value%2A> Właściwość jest tylko do odczytu; w związku z tym, nie ma właściwość, która udostępniła je `set` metody dostępu.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-220">The <xref:System.Lazy%601.Value%2A> property is read-only; therefore, the property that exposes it has no `set` accessor.</span></span> <span data-ttu-id="aa6b2-221">Jeśli potrzebujesz właściwości odczytu/zapisu, wspierane przez <xref:System.Lazy%601> obiektu `set` dostępu należy utworzyć nowy <xref:System.Lazy%601> obiektu i przypisz je do magazynu zapasowego.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-221">If you require a read/write property backed by a <xref:System.Lazy%601> object, the `set` accessor must create a new <xref:System.Lazy%601> object and assign it to the backing store.</span></span> <span data-ttu-id="aa6b2-222">`set` Dostępu należy utworzyć wyrażenie lambda, które zwraca nową wartość właściwości, który został przekazany do `set` metody dostępu i przekazać to wyrażenie lambda do konstruktora dla nowego <xref:System.Lazy%601> obiektu.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-222">The `set` accessor must create a lambda expression that returns the new property value that was passed to the `set` accessor, and pass that lambda expression to the constructor for the new <xref:System.Lazy%601> object.</span></span> <span data-ttu-id="aa6b2-223">Następny dostęp <xref:System.Lazy%601.Value%2A> właściwość spowoduje, że inicjowania nowego <xref:System.Lazy%601>i jego <xref:System.Lazy%601.Value%2A> właściwości po tej dacie zwróci nową wartość, która została przypisana do właściwości.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-223">The next access of the <xref:System.Lazy%601.Value%2A> property will cause initialization of the new <xref:System.Lazy%601>, and its <xref:System.Lazy%601.Value%2A> property will thereafter return the new value that was assigned to the property.</span></span> <span data-ttu-id="aa6b2-224">Przyczyna to zawiłe rozmieszczenie jest zachowanie wielowątkowość ochronę wbudowaną <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-224">The reason for this convoluted arrangement is to preserve the multithreading protections built into <xref:System.Lazy%601>.</span></span> <span data-ttu-id="aa6b2-225">W przeciwnym razie Akcesory właściwości musiałaby pierwszą wartość zwrócona przez obiekt w pamięci podręcznej <xref:System.Lazy%601.Value%2A> właściwości i modyfikować tylko wartość w pamięci podręcznej i trzeba napisać własny kod metodą o bezpiecznych wątkach, aby to zrobić.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-225">Otherwise, the property accessors would have to cache the first value returned by the <xref:System.Lazy%601.Value%2A> property and only modify the cached value, and you would have to write your own thread-safe code to do that.</span></span> <span data-ttu-id="aa6b2-226">Ze względu na dodatkowe inicjalizacje, wymagane przez właściwości odczytu/zapisu, wspierane przez <xref:System.Lazy%601> obiektu wydajności nie może być akceptowalne.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-226">Because of the additional initializations required by a read/write property backed by a <xref:System.Lazy%601> object, the performance might not be acceptable.</span></span> <span data-ttu-id="aa6b2-227">Ponadto w zależności od konkretnego scenariusza dodatkowe koordynacji może być konieczne w celu uniknięcia wyścigu między metody ustawiające i metod pobierających.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-227">Furthermore, depending on the specific scenario, additional coordination might be required to avoid race conditions between setters and getters.</span></span>  
  
## <a name="thread-local-lazy-initialization"></a><span data-ttu-id="aa6b2-228">Inicjalizacja z opóźnieniem Thread-Local</span><span class="sxs-lookup"><span data-stu-id="aa6b2-228">Thread-Local Lazy Initialization</span></span>  
 <span data-ttu-id="aa6b2-229">W niektórych scenariuszach wielowątkowych można nadać każdy wątek prywatnych danych.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-229">In some multithreaded scenarios, you might want to give each thread its own private data.</span></span> <span data-ttu-id="aa6b2-230">Takie dane są nazywane *wątków lokalnych danych*.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-230">Such data is called *thread-local data*.</span></span> <span data-ttu-id="aa6b2-231">W .NET Framework w wersji 3.5 i starszych, można zastosować `ThreadStatic` atrybutu ze zmienną statycznej charakteryzowanych lokalnej wątku.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-231">In the .NET Framework version 3.5 and earlier, you could apply the `ThreadStatic` attribute to a static variable to make it thread-local.</span></span> <span data-ttu-id="aa6b2-232">Jednak przy użyciu `ThreadStatic` atrybut może prowadzić do powstawania błędów.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-232">However, using the `ThreadStatic` attribute can lead to subtle errors.</span></span> <span data-ttu-id="aa6b2-233">Na przykład instrukcje inicjowania nawet podstawowe spowoduje, że zmienną można zainicjować tylko na pierwszym wątkiem, który uzyskuje dostęp do niego, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-233">For example, even basic initialization statements will cause the variable to be initialized only on the first thread that accesses it, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#6](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#6)]
 [!code-vb[Lazy#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#6)]  
  
 <span data-ttu-id="aa6b2-234">W innych wątkach zmienna zostaną zainicjowane przy użyciu wartości domyślnej (zero).</span><span class="sxs-lookup"><span data-stu-id="aa6b2-234">On all other threads, the variable will be initialized by using its default value (zero).</span></span> <span data-ttu-id="aa6b2-235">Jako alternatywę w .NET Framework w wersji 4, możesz użyć <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> typ, aby utworzyć zmienną oparta na wystąpieniach, lokalnej wątku, który jest inicjowany we wszystkich wątkach, <xref:System.Action%601> delegat, który należy podać.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-235">As an alternative in the .NET Framework version 4, you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> type to create an instance-based, thread-local variable that is initialized on all threads by the <xref:System.Action%601> delegate that you provide.</span></span> <span data-ttu-id="aa6b2-236">W poniższym przykładzie wszystkie wątki dostęp `counter` zostanie wyświetlona jego wartość początkową jako 1.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-236">In the following example, all threads that access `counter` will see its starting value as 1.</span></span>  
  
 [!code-csharp[Lazy#7](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#7)]
 [!code-vb[Lazy#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#7)]  
  
 <span data-ttu-id="aa6b2-237"><xref:System.Threading.ThreadLocal%601> opakowuje jego obiekt w podobny sposób jak <xref:System.Lazy%601>, za pomocą tych podstawowych różnic:</span><span class="sxs-lookup"><span data-stu-id="aa6b2-237"><xref:System.Threading.ThreadLocal%601> wraps its object in much the same way as <xref:System.Lazy%601>, with these essential differences:</span></span>  
  
-   <span data-ttu-id="aa6b2-238">Każdy wątek inicjuje zmienną lokalną wątku, przy użyciu własnych danych prywatnego, który nie jest dostępny z innych wątków.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-238">Each thread initializes the thread-local variable by using its own private data that is not accessible from other threads.</span></span>  
  
-   <span data-ttu-id="aa6b2-239"><xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> Właściwość jest odczytu / zapisu i dowolną liczbę razy może być modyfikowany.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-239">The <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> property is read-write, and can be modified any number of times.</span></span> <span data-ttu-id="aa6b2-240">Może to wpłynąć na Propagacja wyjątków, na przykład jeden `get` operacji może zgłosić wyjątek, ale następny może zostać pomyślnie zainicjowany wartość.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-240">This can affect exception propagation, for example, one `get` operation can raise an exception but the next one can successfully initialize the value.</span></span>  
  
-   <span data-ttu-id="aa6b2-241">Jeśli nie podano żadnych delegata inicjowania, <xref:System.Threading.ThreadLocal%601> zainicjuje jego typ opakowany przy użyciu wartości domyślnej typu.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-241">If no initialization delegate is provided, <xref:System.Threading.ThreadLocal%601> will initialize its wrapped type by using the default value of the type.</span></span> <span data-ttu-id="aa6b2-242">W tym zakresie <xref:System.Threading.ThreadLocal%601> jest spójna z <xref:System.ThreadStaticAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-242">In this regard, <xref:System.Threading.ThreadLocal%601> is consistent with the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
 <span data-ttu-id="aa6b2-243">W poniższym przykładzie pokazano, że każdy wątek, uzyskuje dostęp do `ThreadLocal<int>` wystąpienie zyskuje własną unikatową kopię danych.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-243">The following example demonstrates that every thread that accesses the `ThreadLocal<int>` instance gets its own unique copy of the data.</span></span>  
  
 [!code-csharp[Lazy#9](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#9)]
 [!code-vb[Lazy#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#9)]  
  
## <a name="thread-local-variables-in-parallelfor-and-foreach"></a><span data-ttu-id="aa6b2-244">Thread-Local zmiennych Parallel.For i ForEach</span><span class="sxs-lookup"><span data-stu-id="aa6b2-244">Thread-Local Variables in Parallel.For and ForEach</span></span>  
 <span data-ttu-id="aa6b2-245">Kiedy używasz <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> metody lub <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metody do wykonywania iteracji źródeł danych w sposób równoległy, możesz użyć przeciążenia, które ma wbudowaną obsługę danych lokalnej wątku.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-245">When you use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method or <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to iterate over data sources in parallel, you can use the overloads that have built-in support for thread-local data.</span></span> <span data-ttu-id="aa6b2-246">W tych metodach umiejscowienie wątku jest realizowane za pośrednictwem lokalnego delegatów do tworzenia, dostęp i wyczyścić dane.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-246">In these methods, the thread-locality is achieved by using local delegates to create, access, and clean up the data.</span></span> <span data-ttu-id="aa6b2-247">Aby uzyskać więcej informacji, zobacz [jak: Zapisywanie pętli Parallel.For ze zmiennymi lokalnymi wątku](../../../docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) i [jak: Zapisywanie pętli Parallel.ForEach ze zmiennymi lokalnymi partycji](../../../docs/standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="aa6b2-247">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](../../../docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Partition-Local Variables](../../../docs/standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span></span>  
  
## <a name="using-lazy-initialization-for-low-overhead-scenarios"></a><span data-ttu-id="aa6b2-248">Przy użyciu inicjowania z opóźnieniem dla scenariuszy małym obciążeniem</span><span class="sxs-lookup"><span data-stu-id="aa6b2-248">Using Lazy Initialization for Low-Overhead Scenarios</span></span>  
 <span data-ttu-id="aa6b2-249">W scenariuszach, w którym trzeba z opóźnieniem zainicjować dużą liczbę obiektów, można zdecydować o zawijania każdego obiektu w <xref:System.Lazy%601> wymaga zbyt dużej ilości pamięci lub zbyt wiele zasobów obliczeniowych.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-249">In scenarios where you have to lazy-initialize a large number of objects, you might decide that wrapping each object in a <xref:System.Lazy%601> requires too much memory or too many computing resources.</span></span> <span data-ttu-id="aa6b2-250">Lub możesz mieć rygorystyczne wymagania dotyczące sposobu incjalizacji jest widoczna.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-250">Or, you might have stringent requirements about how lazy initialization is exposed.</span></span> <span data-ttu-id="aa6b2-251">W takich przypadkach można użyć `static` (`Shared` w języku Visual Basic) metody <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> klasy z opóźnieniem inicjalizacji każdego obiektu bez opakowującego aplikacje dostępnego w wystąpieniu <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-251">In such cases, you can use the `static` (`Shared` in Visual Basic) methods of the <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> class to lazy-initialize each object without wrapping it in an instance of <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="aa6b2-252">W poniższym przykładzie przyjęto założenie, że, zamiast zawijania cały `Orders` obiektu w jednym <xref:System.Lazy%601> obiektu jest inicjowany z opóźnieniem osoba `Order` obiektów tylko wtedy, gdy są one wymagane.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-252">In the following example, assume that, instead of wrapping an entire `Orders` object in one <xref:System.Lazy%601> object, you have lazy-initialized individual `Order` objects only if they are required.</span></span>  
  
 [!code-csharp[Lazy#10](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#10)]
 [!code-vb[Lazy#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#10)]  
  
 <span data-ttu-id="aa6b2-253">W tym przykładzie należy zauważyć, że procedura inicjowania została wywołana w każdej iteracji pętli.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-253">In this example, notice that the initialization procedure is invoked on every iteration of the loop.</span></span> <span data-ttu-id="aa6b2-254">W scenariuszach wielowątkowych pierwszym wątku do wywołania procedury inicjowania jest ten, którego wartość jest widoczna dla wszystkich wątków.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-254">In multi-threaded scenarios, the first thread to invoke the initialization procedure is the one whose value is seen by all threads.</span></span> <span data-ttu-id="aa6b2-255">Nowsze wątków także wywoływać procedury inicjowania, ale jego wyniki nie są używane.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-255">Later threads also invoke the initialization procedure, but their results are not used.</span></span> <span data-ttu-id="aa6b2-256">Jeśli tego rodzaju potencjalnych sytuacji wyścigu nie jest dopuszczalne, użyj przeciążenia <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> która przyjmuje argument logiczny i obiekt synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="aa6b2-256">If this kind of potential race condition is not acceptable, use the overload of <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> that takes a Boolean argument and a synchronization object.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="aa6b2-257">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="aa6b2-257">See also</span></span>

- [<span data-ttu-id="aa6b2-258">Zarządzana wątkowość — podstawy</span><span class="sxs-lookup"><span data-stu-id="aa6b2-258">Managed Threading Basics</span></span>](../../../docs/standard/threading/managed-threading-basics.md)
- [<span data-ttu-id="aa6b2-259">Wątki i wątkowość</span><span class="sxs-lookup"><span data-stu-id="aa6b2-259">Threads and Threading</span></span>](../../../docs/standard/threading/threads-and-threading.md)
- [<span data-ttu-id="aa6b2-260">Biblioteka zadań równoległych (TPL)</span><span class="sxs-lookup"><span data-stu-id="aa6b2-260">Task Parallel Library (TPL)</span></span>](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)
- [<span data-ttu-id="aa6b2-261">Instrukcje: Wykonywanie Incjalizacji obiektów</span><span class="sxs-lookup"><span data-stu-id="aa6b2-261">How to: Perform Lazy Initialization of Objects</span></span>](../../../docs/framework/performance/how-to-perform-lazy-initialization-of-objects.md)
