---
title: Inicjalizacja z opóźnieniem
description: Poznaj inicjalizację z opóźnieniem w programie .NET, poprawę wydajności, która oznacza, że tworzenie obiektu jest odroczone do momentu pierwszego użycia obiektu.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lazy initialization in .NET, introduction
ms.assetid: 56b4ae5c-4745-44ff-ad78-ffe4fcde6b9b
ms.openlocfilehash: 6cbda2bd45f2cdc5085ca30af878824069fb019a
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 11/26/2020
ms.locfileid: "96242178"
---
# <a name="lazy-initialization"></a><span data-ttu-id="9c718-103">Inicjalizacja z opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="9c718-103">Lazy Initialization</span></span>

<span data-ttu-id="9c718-104">*Inicjalizacja z opóźnieniem* obiektu oznacza, że jego tworzenie jest odroczone do czasu jego pierwszego użycia.</span><span class="sxs-lookup"><span data-stu-id="9c718-104">*Lazy initialization* of an object means that its creation is deferred until it is first used.</span></span> <span data-ttu-id="9c718-105">(W tym temacie warunki *inicjalizacji z opóźnieniem* i *utworzenia wystąpienia z opóźnieniem* są równoznaczne). Inicjalizacja z opóźnieniem służy głównie do poprawy wydajności, unikania obliczeń wasteful i zmniejszania wymagań dotyczących pamięci programu.</span><span class="sxs-lookup"><span data-stu-id="9c718-105">(For this topic, the terms *lazy initialization* and *lazy instantiation* are synonymous.) Lazy initialization is primarily used to improve performance, avoid wasteful computation, and reduce program memory requirements.</span></span> <span data-ttu-id="9c718-106">Są to najczęstsze scenariusze:</span><span class="sxs-lookup"><span data-stu-id="9c718-106">These are the most common scenarios:</span></span>  
  
- <span data-ttu-id="9c718-107">Gdy masz obiekt, który jest kosztowny do utworzenia i program może go nie używać.</span><span class="sxs-lookup"><span data-stu-id="9c718-107">When you have an object that is expensive to create, and the program might not use it.</span></span> <span data-ttu-id="9c718-108">Załóżmy na przykład, że masz w pamięci `Customer` obiekt, który ma `Orders` Właściwość, która zawiera dużą tablicę `Order` obiektów, która ma zostać zainicjowana, wymaga połączenia z bazą danych.</span><span class="sxs-lookup"><span data-stu-id="9c718-108">For example, assume that you have in memory a `Customer` object that has an `Orders` property that contains a large array of `Order` objects that, to be initialized, requires a database connection.</span></span> <span data-ttu-id="9c718-109">Jeśli użytkownik nigdy nie monituje o wyświetlenie zamówień lub użycie danych w obliczeniach, nie istnieje powód, aby użyć pamięci systemowej lub cykle obliczeniowe do jego utworzenia.</span><span class="sxs-lookup"><span data-stu-id="9c718-109">If the user never asks to display the Orders or use the data in a computation, then there is no reason to use system memory or computing cycles to create it.</span></span> <span data-ttu-id="9c718-110">Za pomocą `Lazy<Orders>` do deklarowania `Orders` obiektu do inicjowania z opóźnieniem można uniknąć marnowania zasobów systemowych, gdy obiekt nie jest używany.</span><span class="sxs-lookup"><span data-stu-id="9c718-110">By using `Lazy<Orders>` to declare the `Orders` object for lazy initialization, you can avoid wasting system resources when the object is not used.</span></span>  
  
- <span data-ttu-id="9c718-111">Gdy masz obiekt, który jest kosztowny do utworzenia, i chcesz odroczyć jego tworzenie do momentu ukończenia innych kosztownych operacji.</span><span class="sxs-lookup"><span data-stu-id="9c718-111">When you have an object that is expensive to create, and you want to defer its creation until after other expensive operations have been completed.</span></span> <span data-ttu-id="9c718-112">Załóżmy na przykład, że program ładuje kilka wystąpień obiektów podczas uruchamiania, ale tylko niektóre z nich są wymagane od razu.</span><span class="sxs-lookup"><span data-stu-id="9c718-112">For example, assume that your program loads several object instances when it starts, but only some of them are required immediately.</span></span> <span data-ttu-id="9c718-113">Wydajność uruchamiania programu można poprawić, odwołując inicjalizację obiektów, które nie są wymagane do momentu utworzenia wymaganych obiektów.</span><span class="sxs-lookup"><span data-stu-id="9c718-113">You can improve the startup performance of the program by deferring initialization of the objects that are not required until the required objects have been created.</span></span>  
  
 <span data-ttu-id="9c718-114">Chociaż można napisać własny kod w celu wykonania inicjalizacji z opóźnieniem, zalecamy użycie <xref:System.Lazy%601> zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="9c718-114">Although you can write your own code to perform lazy initialization, we recommend that you use <xref:System.Lazy%601> instead.</span></span> <span data-ttu-id="9c718-115"><xref:System.Lazy%601> i powiązane typy obsługują również bezpieczeństwo wątków i zapewniają zasady propagacji spójnych wyjątków.</span><span class="sxs-lookup"><span data-stu-id="9c718-115"><xref:System.Lazy%601> and its related types also support thread-safety and provide a consistent exception propagation policy.</span></span>  
  
 <span data-ttu-id="9c718-116">Poniższa tabela zawiera listę typów, które zawiera .NET Framework w wersji 4, aby włączyć inicjalizację z opóźnieniem w różnych scenariuszach.</span><span class="sxs-lookup"><span data-stu-id="9c718-116">The following table lists the types that the .NET Framework version 4 provides to enable lazy initialization in different scenarios.</span></span>  
  
|<span data-ttu-id="9c718-117">Typ</span><span class="sxs-lookup"><span data-stu-id="9c718-117">Type</span></span>|<span data-ttu-id="9c718-118">Opis</span><span class="sxs-lookup"><span data-stu-id="9c718-118">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601>|<span data-ttu-id="9c718-119">Klasa otoki, która zapewnia semantykę inicjacji z opóźnieniem dla każdej biblioteki klas lub typu zdefiniowanego przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="9c718-119">A wrapper class that provides lazy initialization semantics for any class library or user-defined type.</span></span>|  
|<xref:System.Threading.ThreadLocal%601>|<span data-ttu-id="9c718-120">Przypomina <xref:System.Lazy%601> z tą różnicą, że zapewnia semantykę inicjacji z opóźnieniem w zależności od wątku.</span><span class="sxs-lookup"><span data-stu-id="9c718-120">Resembles <xref:System.Lazy%601> except that it provides lazy initialization semantics on a thread-local basis.</span></span> <span data-ttu-id="9c718-121">Każdy wątek ma dostęp do własnej unikatowej wartości.</span><span class="sxs-lookup"><span data-stu-id="9c718-121">Every thread has access to its own unique value.</span></span>|  
|<xref:System.Threading.LazyInitializer>|<span data-ttu-id="9c718-122">Zapewnia zaawansowane `static` `Shared` metody inicjacji obiektów (w Visual Basic) w odniesieniu do opóźnionej inicjalizacji obiektu bez nakładu pracy klasy.</span><span class="sxs-lookup"><span data-stu-id="9c718-122">Provides advanced `static` (`Shared` in Visual Basic) methods for lazy initialization of objects without the overhead of a class.</span></span>|  
  
## <a name="basic-lazy-initialization"></a><span data-ttu-id="9c718-123">Podstawowa Inicjalizacja z opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="9c718-123">Basic Lazy Initialization</span></span>  

 <span data-ttu-id="9c718-124">Aby zdefiniować typ inicjowania z opóźnieniem, na przykład, `MyType` Użyj `Lazy<MyType>` ( `Lazy(Of MyType)` w Visual Basic), jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="9c718-124">To define a lazy-initialized type, for example, `MyType`, use `Lazy<MyType>` (`Lazy(Of MyType)` in Visual Basic), as shown in the following example.</span></span> <span data-ttu-id="9c718-125">Jeśli w konstruktorze nie zostanie przesłany delegat <xref:System.Lazy%601> , opakowany typ jest tworzony przy użyciu, <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> gdy zostanie uzyskany pierwszy raz.</span><span class="sxs-lookup"><span data-stu-id="9c718-125">If no delegate is passed in the <xref:System.Lazy%601> constructor, the wrapped type is created by using <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> when the value property is first accessed.</span></span> <span data-ttu-id="9c718-126">Jeśli typ nie ma konstruktora bez parametrów, zgłaszany jest wyjątek czasu wykonywania.</span><span class="sxs-lookup"><span data-stu-id="9c718-126">If the type does not have a parameterless constructor, a run-time exception is thrown.</span></span>  
  
 <span data-ttu-id="9c718-127">W poniższym przykładzie Załóżmy, że `Orders` jest klasą zawierającą tablicę `Order` obiektów pobranych z bazy danych.</span><span class="sxs-lookup"><span data-stu-id="9c718-127">In the following example, assume that `Orders` is a class that contains an array of `Order` objects retrieved from a database.</span></span> <span data-ttu-id="9c718-128">`Customer`Obiekt zawiera wystąpienie `Orders` , ale w zależności od akcji użytkownika, dane z `Orders` obiektu mogą nie być wymagane.</span><span class="sxs-lookup"><span data-stu-id="9c718-128">A `Customer` object contains an instance of `Orders`, but depending on user actions, the data from the `Orders` object might not be required.</span></span>  
  
 [!code-csharp[Lazy#1](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#1)]
 [!code-vb[Lazy#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#1)]  
  
 <span data-ttu-id="9c718-129">Można również przekazać delegata w <xref:System.Lazy%601> konstruktorze, który wywołuje określone przeciążenie konstruktora dla opakowanego typu podczas tworzenia, i wykonać wszelkie inne wymagane kroki inicjowania, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="9c718-129">You can also pass a delegate in the <xref:System.Lazy%601> constructor that invokes a specific constructor overload on the wrapped type at creation time, and perform any other initialization steps that are required, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#2](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#2)]
 [!code-vb[Lazy#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#2)]  
  
 <span data-ttu-id="9c718-130">Po utworzeniu obiektu z opóźnieniem żadne wystąpienie elementu nie `Orders` zostanie utworzone do momentu uzyskania <xref:System.Lazy%601.Value%2A> dostępu do właściwości zmiennej opóźnionej po raz pierwszy.</span><span class="sxs-lookup"><span data-stu-id="9c718-130">After the Lazy object is created, no instance of `Orders` is created until the <xref:System.Lazy%601.Value%2A> property of the Lazy variable is accessed for the first time.</span></span> <span data-ttu-id="9c718-131">Przy pierwszym dostępie opakowany typ jest tworzony i zwracany i przechowywany dla dowolnego przyszłego dostępu.</span><span class="sxs-lookup"><span data-stu-id="9c718-131">On first access, the wrapped type is created and returned, and stored for any future access.</span></span>  
  
 [!code-csharp[Lazy#3](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#3)]
 [!code-vb[Lazy#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#3)]  
  
 <span data-ttu-id="9c718-132"><xref:System.Lazy%601>Obiekt zawsze zwraca ten sam obiekt lub wartość, z którą została zainicjowana.</span><span class="sxs-lookup"><span data-stu-id="9c718-132">A <xref:System.Lazy%601> object always returns the same object or value that it was initialized with.</span></span> <span data-ttu-id="9c718-133">W związku z tym <xref:System.Lazy%601.Value%2A> Właściwość jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="9c718-133">Therefore, the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="9c718-134">W przypadku <xref:System.Lazy%601.Value%2A> przechowywania typu referencyjnego nie można przypisać do niego nowego obiektu.</span><span class="sxs-lookup"><span data-stu-id="9c718-134">If <xref:System.Lazy%601.Value%2A> stores a reference type, you cannot assign a new object to it.</span></span> <span data-ttu-id="9c718-135">(Można jednak zmienić wartość jego pól publicznych i właściwości.). W przypadku <xref:System.Lazy%601.Value%2A> przechowywania typu wartości nie można zmodyfikować jego wartości.</span><span class="sxs-lookup"><span data-stu-id="9c718-135">(However, you can change the value of its settable public fields and properties.) If <xref:System.Lazy%601.Value%2A> stores a value type, you cannot modify its value.</span></span> <span data-ttu-id="9c718-136">Niemniej jednak można utworzyć nową zmienną, wywołując Konstruktor zmiennej ponownie przy użyciu nowych argumentów.</span><span class="sxs-lookup"><span data-stu-id="9c718-136">Nevertheless, you can create a new variable by invoking the variable constructor again by using new arguments.</span></span>  
  
 [!code-csharp[Lazy#4](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#4)]
 [!code-vb[Lazy#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#4)]  
  
 <span data-ttu-id="9c718-137">Nowe wystąpienie z opóźnieniem, takie jak wcześniejszy, nie tworzy wystąpienia `Orders` przed <xref:System.Lazy%601.Value%2A> pierwszym uzyskaniem dostępu do jego właściwości.</span><span class="sxs-lookup"><span data-stu-id="9c718-137">The new lazy instance, like the earlier one, does not instantiate `Orders` until its <xref:System.Lazy%601.Value%2A> property is first accessed.</span></span>  
  
### <a name="thread-safe-initialization"></a><span data-ttu-id="9c718-138">Inicjalizacja Thread-Safe</span><span class="sxs-lookup"><span data-stu-id="9c718-138">Thread-Safe Initialization</span></span>  

 <span data-ttu-id="9c718-139">Domyślnie <xref:System.Lazy%601> obiekty są bezpieczne wątkowo.</span><span class="sxs-lookup"><span data-stu-id="9c718-139">By default, <xref:System.Lazy%601> objects are thread-safe.</span></span> <span data-ttu-id="9c718-140">Oznacza to, że jeśli Konstruktor nie określi rodzaju bezpieczeństwa wątków, <xref:System.Lazy%601> tworzone obiekty są bezpieczne wątkowo.</span><span class="sxs-lookup"><span data-stu-id="9c718-140">That is, if the constructor does not specify the kind of thread safety, the <xref:System.Lazy%601> objects it creates are thread-safe.</span></span> <span data-ttu-id="9c718-141">W scenariuszach wielowątkowych pierwszy wątek uzyskuje dostęp do <xref:System.Lazy%601.Value%2A> właściwości obiektu bezpiecznego wątkowo <xref:System.Lazy%601> inicjuje go dla wszystkich kolejnych operacji dostępu we wszystkich wątkach, a wszystkie wątki współużytkują te same dane.</span><span class="sxs-lookup"><span data-stu-id="9c718-141">In multi-threaded scenarios, the first thread to access the <xref:System.Lazy%601.Value%2A> property of a thread-safe <xref:System.Lazy%601> object initializes it for all subsequent accesses on all threads, and all threads share the same data.</span></span> <span data-ttu-id="9c718-142">W związku z tym nie ma znaczenia, który wątek inicjuje obiekt, a warunki wyścigu są niegroźne.</span><span class="sxs-lookup"><span data-stu-id="9c718-142">Therefore, it does not matter which thread initializes the object, and race conditions are benign.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9c718-143">Tę spójność można zwiększyć do warunków błędów przy użyciu buforowania wyjątków.</span><span class="sxs-lookup"><span data-stu-id="9c718-143">You can extend this consistency to error conditions by using exception caching.</span></span> <span data-ttu-id="9c718-144">Aby uzyskać więcej informacji, zobacz następną sekcję [wyjątki w odniesieniu do obiektów z opóźnieniem](lazy-initialization.md#ExceptionsInLazyObjects).</span><span class="sxs-lookup"><span data-stu-id="9c718-144">For more information, see the next section, [Exceptions in Lazy Objects](lazy-initialization.md#ExceptionsInLazyObjects).</span></span>  
  
 <span data-ttu-id="9c718-145">Poniższy przykład pokazuje, że to samo `Lazy<int>` wystąpienie ma tę samą wartość dla trzech oddzielnych wątków.</span><span class="sxs-lookup"><span data-stu-id="9c718-145">The following example shows that the same `Lazy<int>` instance has the same value for three separate threads.</span></span>  
  
 [!code-csharp[Lazy#8](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#8)]
 [!code-vb[Lazy#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#8)]  
  
 <span data-ttu-id="9c718-146">Jeśli wymagane są osobne dane w każdym wątku, użyj <xref:System.Threading.ThreadLocal%601> typu, zgodnie z opisem w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="9c718-146">If you require separate data on each thread, use the <xref:System.Threading.ThreadLocal%601> type, as described later in this topic.</span></span>  
  
 <span data-ttu-id="9c718-147">Niektóre <xref:System.Lazy%601> konstruktory mają parametr logiczny o nazwie `isThreadSafe` , który służy do określenia, czy <xref:System.Lazy%601.Value%2A> Właściwość będzie dostępna z wielu wątków.</span><span class="sxs-lookup"><span data-stu-id="9c718-147">Some <xref:System.Lazy%601> constructors have a Boolean parameter named `isThreadSafe` that is used to specify whether the <xref:System.Lazy%601.Value%2A> property will be accessed from multiple threads.</span></span> <span data-ttu-id="9c718-148">Jeśli zamierzasz uzyskać dostęp do właściwości z tylko jednego wątku, Przekaż, `false` Aby uzyskać nieznacznie korzyść wydajności.</span><span class="sxs-lookup"><span data-stu-id="9c718-148">If you intend to access the property from just one thread, pass in `false` to obtain a modest performance benefit.</span></span> <span data-ttu-id="9c718-149">Jeśli zamierzasz uzyskać dostęp do właściwości z wielu wątków, Przekaż, `true` aby poinstruować <xref:System.Lazy%601> wystąpienie o prawidłowym obsłudze warunków wyścigu, w których jeden wątek zgłasza wyjątek w czasie inicjacji.</span><span class="sxs-lookup"><span data-stu-id="9c718-149">If you intend to access the property from multiple threads, pass in `true` to instruct the <xref:System.Lazy%601> instance to correctly handle race conditions in which one thread throws an exception at initialization time.</span></span>  
  
 <span data-ttu-id="9c718-150">Niektóre <xref:System.Lazy%601> konstruktory mają <xref:System.Threading.LazyThreadSafetyMode> parametr o nazwie `mode` .</span><span class="sxs-lookup"><span data-stu-id="9c718-150">Some <xref:System.Lazy%601> constructors have a <xref:System.Threading.LazyThreadSafetyMode> parameter named `mode`.</span></span> <span data-ttu-id="9c718-151">Konstruktory te zapewniają dodatkowy tryb zabezpieczeń wątków.</span><span class="sxs-lookup"><span data-stu-id="9c718-151">These constructors provide an additional thread safety mode.</span></span> <span data-ttu-id="9c718-152">W poniższej tabeli przedstawiono, w jaki sposób bezpieczeństwo wątku <xref:System.Lazy%601> obiektu ma wpływ na parametry konstruktora, które określają bezpieczeństwo wątku.</span><span class="sxs-lookup"><span data-stu-id="9c718-152">The following table shows how the thread safety of a <xref:System.Lazy%601> object is affected by constructor parameters that specify thread safety.</span></span> <span data-ttu-id="9c718-153">Każdy Konstruktor ma co najwyżej jeden taki parametr.</span><span class="sxs-lookup"><span data-stu-id="9c718-153">Each constructor has at most one such parameter.</span></span>  
  
|<span data-ttu-id="9c718-154">Bezpieczeństwo wątku obiektu</span><span class="sxs-lookup"><span data-stu-id="9c718-154">Thread safety of the object</span></span>|<span data-ttu-id="9c718-155">`LazyThreadSafetyMode``mode`parametr</span><span class="sxs-lookup"><span data-stu-id="9c718-155">`LazyThreadSafetyMode` `mode` parameter</span></span>|<span data-ttu-id="9c718-156">`isThreadSafe`Parametr logiczny</span><span class="sxs-lookup"><span data-stu-id="9c718-156">Boolean `isThreadSafe` parameter</span></span>|<span data-ttu-id="9c718-157">Brak parametrów zabezpieczeń wątku</span><span class="sxs-lookup"><span data-stu-id="9c718-157">No thread safety parameters</span></span>|  
|---------------------------------|---------------------------------------------|--------------------------------------|---------------------------------|  
|<span data-ttu-id="9c718-158">W pełni bezpieczny wątkowo; tylko jeden wątek w czasie próbuje zainicjować wartość.</span><span class="sxs-lookup"><span data-stu-id="9c718-158">Fully thread-safe; only one thread at a time tries to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|<span data-ttu-id="9c718-159">Tak.</span><span class="sxs-lookup"><span data-stu-id="9c718-159">Yes.</span></span>|  
|<span data-ttu-id="9c718-160">Nie jest bezpieczny dla wątków.</span><span class="sxs-lookup"><span data-stu-id="9c718-160">Not thread-safe.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|<span data-ttu-id="9c718-161">Nie dotyczy.</span><span class="sxs-lookup"><span data-stu-id="9c718-161">Not applicable.</span></span>|  
|<span data-ttu-id="9c718-162">W pełni bezpieczny wątkowo; możliwość zainicjowania wartości przez rasę wątków.</span><span class="sxs-lookup"><span data-stu-id="9c718-162">Fully thread-safe; threads race to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|<span data-ttu-id="9c718-163">Nie dotyczy.</span><span class="sxs-lookup"><span data-stu-id="9c718-163">Not applicable.</span></span>|<span data-ttu-id="9c718-164">Nie dotyczy.</span><span class="sxs-lookup"><span data-stu-id="9c718-164">Not applicable.</span></span>|  
  
 <span data-ttu-id="9c718-165">Jak tabela pokazuje, określanie <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> dla `mode` parametru jest taka sama jak określenie `true` `isThreadSafe` parametru, i określenie <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> jest taka sama jak określanie `false` .</span><span class="sxs-lookup"><span data-stu-id="9c718-165">As the table shows, specifying <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> for the `mode` parameter is the same as specifying `true` for the `isThreadSafe` parameter, and specifying <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> is the same as specifying `false`.</span></span>  
  
 <span data-ttu-id="9c718-166">Określenie <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> zezwala wielu wątkom na próbę zainicjowania <xref:System.Lazy%601> wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="9c718-166">Specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> allows multiple threads to attempt to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="9c718-167">Tylko jeden wątek może wygrać ten wyścigu, a wszystkie pozostałe wątki odbierają wartość, która została zainicjowana przez wątek zakończony powodzeniem.</span><span class="sxs-lookup"><span data-stu-id="9c718-167">Only one thread can win this race, and all the other threads receive the value that was initialized by the successful thread.</span></span> <span data-ttu-id="9c718-168">Jeśli wyjątek jest zgłaszany w wątku podczas inicjowania, ten wątek nie otrzymuje wartości ustawionej przez wątek zakończony powodzeniem.</span><span class="sxs-lookup"><span data-stu-id="9c718-168">If an exception is thrown on a thread during initialization, that thread does not receive the value set by the successful thread.</span></span> <span data-ttu-id="9c718-169">Wyjątki nie są buforowane, dlatego kolejna próba uzyskania dostępu do <xref:System.Lazy%601.Value%2A> właściwości może skutkować pomyślnym zainicjowaniem.</span><span class="sxs-lookup"><span data-stu-id="9c718-169">Exceptions are not cached, so a subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property can result in successful initialization.</span></span> <span data-ttu-id="9c718-170">Różni się to od sposobu traktowania wyjątków w innych trybach, które opisano w następnej sekcji.</span><span class="sxs-lookup"><span data-stu-id="9c718-170">This differs from the way exceptions are treated in other modes, which is described in the following section.</span></span> <span data-ttu-id="9c718-171">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.LazyThreadSafetyMode> Wyliczenie.</span><span class="sxs-lookup"><span data-stu-id="9c718-171">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
<a name="ExceptionsInLazyObjects"></a>

## <a name="exceptions-in-lazy-objects"></a><span data-ttu-id="9c718-172">Wyjątki w obiektach z opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="9c718-172">Exceptions in Lazy Objects</span></span>  

 <span data-ttu-id="9c718-173">Jak wspomniano wcześniej, <xref:System.Lazy%601> obiekt zawsze zwraca ten sam obiekt lub wartość, która została zainicjowana, i w związku z tym <xref:System.Lazy%601.Value%2A> Właściwość jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="9c718-173">As stated earlier, a <xref:System.Lazy%601> object always returns the same object or value that it was initialized with, and therefore the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="9c718-174">W przypadku włączenia buforowania wyjątków ten niezmienności również rozszerza na zachowanie wyjątków.</span><span class="sxs-lookup"><span data-stu-id="9c718-174">If you enable exception caching, this immutability also extends to exception behavior.</span></span> <span data-ttu-id="9c718-175">Jeśli obiekt zainicjowany z opóźnieniem ma włączone buforowanie wyjątków i zgłasza wyjątek z metody inicjującej podczas <xref:System.Lazy%601.Value%2A> pierwszego dostępu do właściwości, ten sam wyjątek jest zgłaszany przy każdej kolejnej próbie uzyskania dostępu do <xref:System.Lazy%601.Value%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9c718-175">If a lazy-initialized object has exception caching enabled and throws an exception from its initialization method when the <xref:System.Lazy%601.Value%2A> property is first accessed, that same exception is thrown on every subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property.</span></span> <span data-ttu-id="9c718-176">Innymi słowy, Konstruktor opakowanego typu nigdy nie jest ponownie wywoływany, nawet w scenariuszach wielowątkowych.</span><span class="sxs-lookup"><span data-stu-id="9c718-176">In other words, the constructor of the wrapped type is never re-invoked, even in multithreaded scenarios.</span></span> <span data-ttu-id="9c718-177">W związku z tym <xref:System.Lazy%601> obiekt nie może zgłosić wyjątku dla jednego dostępu i zwrócić wartości w kolejnym dostępie.</span><span class="sxs-lookup"><span data-stu-id="9c718-177">Therefore, the <xref:System.Lazy%601> object cannot throw an exception on one access and return a value on a subsequent access.</span></span>  
  
 <span data-ttu-id="9c718-178">Buforowanie wyjątków jest włączane w przypadku użycia dowolnego <xref:System.Lazy%601?displayProperty=nameWithType> konstruktora, który przyjmuje metodę inicjującą ( `valueFactory` parametr); na przykład jest on włączony w przypadku użycia `Lazy(T)(Func(T))` konstruktora.</span><span class="sxs-lookup"><span data-stu-id="9c718-178">Exception caching is enabled when you use any <xref:System.Lazy%601?displayProperty=nameWithType> constructor that takes an initialization method (`valueFactory` parameter); for example, it is enabled when you use the `Lazy(T)(Func(T))`constructor.</span></span> <span data-ttu-id="9c718-179">Jeśli Konstruktor pobiera również <xref:System.Threading.LazyThreadSafetyMode> wartość ( `mode` parametr), określ <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> lub <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="9c718-179">If the constructor also takes a <xref:System.Threading.LazyThreadSafetyMode> value (`mode` parameter), specify <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> or <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9c718-180">Określenie metody inicjującej umożliwia buforowanie wyjątków dla tych dwóch trybów.</span><span class="sxs-lookup"><span data-stu-id="9c718-180">Specifying an initialization method enables exception caching for these two modes.</span></span> <span data-ttu-id="9c718-181">Metoda inicjacji może być bardzo prosta.</span><span class="sxs-lookup"><span data-stu-id="9c718-181">The initialization method can be very simple.</span></span> <span data-ttu-id="9c718-182">Na przykład może wywołać konstruktora bez parametrów dla `T` : `new Lazy<Contents>(() => new Contents(), mode)` w języku C# lub `New Lazy(Of Contents)(Function() New Contents())` w Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="9c718-182">For example, it might call the parameterless constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic.</span></span> <span data-ttu-id="9c718-183">Jeśli używasz <xref:System.Lazy%601?displayProperty=nameWithType> konstruktora, który nie określa metody inicjacji, wyjątki, które są zgłaszane przez konstruktora bez parametrów dla `T` nie są buforowane.</span><span class="sxs-lookup"><span data-stu-id="9c718-183">If you use a <xref:System.Lazy%601?displayProperty=nameWithType> constructor that does not specify an initialization method, exceptions that are thrown by the parameterless constructor for `T` are not cached.</span></span> <span data-ttu-id="9c718-184">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.LazyThreadSafetyMode> Wyliczenie.</span><span class="sxs-lookup"><span data-stu-id="9c718-184">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9c718-185">Jeśli utworzysz <xref:System.Lazy%601> obiekt z `isThreadSafe` parametrem konstruktora ustawionym na `false` lub `mode` parametrem konstruktora ustawionym na <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> , musisz uzyskać dostęp do <xref:System.Lazy%601> obiektu z pojedynczego wątku lub podać własną synchronizację.</span><span class="sxs-lookup"><span data-stu-id="9c718-185">If you create a <xref:System.Lazy%601> object with the `isThreadSafe` constructor parameter set to `false` or the `mode` constructor parameter set to <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, you must access the <xref:System.Lazy%601> object from a single thread or provide your own synchronization.</span></span> <span data-ttu-id="9c718-186">Dotyczy to wszystkich aspektów obiektu, w tym buforowania wyjątków.</span><span class="sxs-lookup"><span data-stu-id="9c718-186">This applies to all aspects of the object, including exception caching.</span></span>  
  
 <span data-ttu-id="9c718-187">Jak wskazano w poprzedniej sekcji, <xref:System.Lazy%601> obiekty utworzone przez określanie <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> wyjątków traktują się inaczej.</span><span class="sxs-lookup"><span data-stu-id="9c718-187">As noted in the previous section, <xref:System.Lazy%601> objects created by specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> treat exceptions differently.</span></span> <span data-ttu-id="9c718-188">W przypadku <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly> wielu wątków może konkurować, aby zainicjować <xref:System.Lazy%601> wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="9c718-188">With <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, multiple threads can compete to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="9c718-189">W takim przypadku wyjątki nie są buforowane, a próby uzyskania dostępu do <xref:System.Lazy%601.Value%2A> właściwości mogą być kontynuowane do momentu pomyślnego inicjalizacji.</span><span class="sxs-lookup"><span data-stu-id="9c718-189">In this case, exceptions are not cached, and attempts to access the <xref:System.Lazy%601.Value%2A> property can continue until initialization is successful.</span></span>  
  
 <span data-ttu-id="9c718-190">Poniższa tabela zawiera podsumowanie sposobu, w jaki <xref:System.Lazy%601> konstruktory kontrolują buforowanie wyjątków.</span><span class="sxs-lookup"><span data-stu-id="9c718-190">The following table summarizes the way the <xref:System.Lazy%601> constructors control exception caching.</span></span>  
  
|<span data-ttu-id="9c718-191">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="9c718-191">Constructor</span></span>|<span data-ttu-id="9c718-192">Tryb bezpieczny wątku</span><span class="sxs-lookup"><span data-stu-id="9c718-192">Thread safety mode</span></span>|<span data-ttu-id="9c718-193">Używa metody inicjującej</span><span class="sxs-lookup"><span data-stu-id="9c718-193">Uses initialization method</span></span>|<span data-ttu-id="9c718-194">Wyjątki są buforowane</span><span class="sxs-lookup"><span data-stu-id="9c718-194">Exceptions are cached</span></span>|  
|-----------------|------------------------|--------------------------------|---------------------------|  
|<span data-ttu-id="9c718-195">Opóźnione (T) ()</span><span class="sxs-lookup"><span data-stu-id="9c718-195">Lazy(T)()</span></span>|<span data-ttu-id="9c718-196">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="9c718-196">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="9c718-197">Nie</span><span class="sxs-lookup"><span data-stu-id="9c718-197">No</span></span>|<span data-ttu-id="9c718-198">Nie</span><span class="sxs-lookup"><span data-stu-id="9c718-198">No</span></span>|  
|<span data-ttu-id="9c718-199">Opóźniony (T) (Func (T))</span><span class="sxs-lookup"><span data-stu-id="9c718-199">Lazy(T)(Func(T))</span></span>|<span data-ttu-id="9c718-200">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="9c718-200">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="9c718-201">Tak</span><span class="sxs-lookup"><span data-stu-id="9c718-201">Yes</span></span>|<span data-ttu-id="9c718-202">Tak</span><span class="sxs-lookup"><span data-stu-id="9c718-202">Yes</span></span>|  
|<span data-ttu-id="9c718-203">Opóźniony (T) (wartość logiczna)</span><span class="sxs-lookup"><span data-stu-id="9c718-203">Lazy(T)(Boolean)</span></span>|<span data-ttu-id="9c718-204">`True` ( <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication> ) lub `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="9c718-204">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="9c718-205">Nie</span><span class="sxs-lookup"><span data-stu-id="9c718-205">No</span></span>|<span data-ttu-id="9c718-206">Nie</span><span class="sxs-lookup"><span data-stu-id="9c718-206">No</span></span>|  
|<span data-ttu-id="9c718-207">Opóźniony (T) (Func (T), wartość logiczna)</span><span class="sxs-lookup"><span data-stu-id="9c718-207">Lazy(T)(Func(T), Boolean)</span></span>|<span data-ttu-id="9c718-208">`True` ( <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication> ) lub `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="9c718-208">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="9c718-209">Tak</span><span class="sxs-lookup"><span data-stu-id="9c718-209">Yes</span></span>|<span data-ttu-id="9c718-210">Tak</span><span class="sxs-lookup"><span data-stu-id="9c718-210">Yes</span></span>|  
|<span data-ttu-id="9c718-211">Opóźnione (T) (LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="9c718-211">Lazy(T)(LazyThreadSafetyMode)</span></span>|<span data-ttu-id="9c718-212">Określony przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="9c718-212">User-specified</span></span>|<span data-ttu-id="9c718-213">Nie</span><span class="sxs-lookup"><span data-stu-id="9c718-213">No</span></span>|<span data-ttu-id="9c718-214">Nie</span><span class="sxs-lookup"><span data-stu-id="9c718-214">No</span></span>|  
|<span data-ttu-id="9c718-215">Opóźniony (T) (Func (T), LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="9c718-215">Lazy(T)(Func(T), LazyThreadSafetyMode)</span></span>|<span data-ttu-id="9c718-216">Określony przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="9c718-216">User-specified</span></span>|<span data-ttu-id="9c718-217">Tak</span><span class="sxs-lookup"><span data-stu-id="9c718-217">Yes</span></span>|<span data-ttu-id="9c718-218">Nie, jeśli użytkownik określi <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly> ; w przeciwnym razie, tak.</span><span class="sxs-lookup"><span data-stu-id="9c718-218">No if user specifies <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; otherwise, yes.</span></span>|  
  
## <a name="implementing-a-lazy-initialized-property"></a><span data-ttu-id="9c718-219">Implementowanie właściwości Lazy-Initialized</span><span class="sxs-lookup"><span data-stu-id="9c718-219">Implementing a Lazy-Initialized Property</span></span>  

 <span data-ttu-id="9c718-220">Aby zaimplementować Właściwość publiczną przy użyciu inicjowania z opóźnieniem, Zdefiniuj pole zapasowe właściwości jako <xref:System.Lazy%601> i zwróć <xref:System.Lazy%601.Value%2A> Właściwość z `get` metody dostępu do właściwości.</span><span class="sxs-lookup"><span data-stu-id="9c718-220">To implement a public property by using lazy initialization, define the backing field of the property as a <xref:System.Lazy%601>, and return the <xref:System.Lazy%601.Value%2A> property from the `get` accessor of the property.</span></span>  
  
 [!code-csharp[Lazy#5](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#5)]
 [!code-vb[Lazy#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#5)]  
  
 <span data-ttu-id="9c718-221"><xref:System.Lazy%601.Value%2A>Właściwość jest tylko do odczytu; w związku z tym właściwość, która ujawnia ją, nie ma `set` metody dostępu.</span><span class="sxs-lookup"><span data-stu-id="9c718-221">The <xref:System.Lazy%601.Value%2A> property is read-only; therefore, the property that exposes it has no `set` accessor.</span></span> <span data-ttu-id="9c718-222">Jeśli wymagana jest właściwość odczytu/zapisu dla <xref:System.Lazy%601> obiektu, `set` metoda dostępu musi utworzyć nowy <xref:System.Lazy%601> obiekt i przypisać go do magazynu zapasowego.</span><span class="sxs-lookup"><span data-stu-id="9c718-222">If you require a read/write property backed by a <xref:System.Lazy%601> object, the `set` accessor must create a new <xref:System.Lazy%601> object and assign it to the backing store.</span></span> <span data-ttu-id="9c718-223">`set`Metoda dostępu musi utworzyć wyrażenie lambda zwracające nową wartość właściwości, która została przekazana do `set` metody dostępu, i przekazać do konstruktora wyrażenie lambda dla nowego <xref:System.Lazy%601> obiektu.</span><span class="sxs-lookup"><span data-stu-id="9c718-223">The `set` accessor must create a lambda expression that returns the new property value that was passed to the `set` accessor, and pass that lambda expression to the constructor for the new <xref:System.Lazy%601> object.</span></span> <span data-ttu-id="9c718-224">Następny dostęp do <xref:System.Lazy%601.Value%2A> właściwości spowoduje zainicjowanie nowej <xref:System.Lazy%601> , a jej <xref:System.Lazy%601.Value%2A> właściwość zwróci nową wartość, która została przypisana do właściwości.</span><span class="sxs-lookup"><span data-stu-id="9c718-224">The next access of the <xref:System.Lazy%601.Value%2A> property will cause initialization of the new <xref:System.Lazy%601>, and its <xref:System.Lazy%601.Value%2A> property will thereafter return the new value that was assigned to the property.</span></span> <span data-ttu-id="9c718-225">Przyczyną tego rozmieszczenia zawiłe jest zachowanie ochrony wielowątkowości wbudowanej <xref:System.Lazy%601> .</span><span class="sxs-lookup"><span data-stu-id="9c718-225">The reason for this convoluted arrangement is to preserve the multithreading protections built into <xref:System.Lazy%601>.</span></span> <span data-ttu-id="9c718-226">W przeciwnym razie metody dostępu do właściwości będą musiały buforować pierwszą wartość zwróconą przez <xref:System.Lazy%601.Value%2A> Właściwość i modyfikować tylko buforowaną wartość i należy napisać własny kod bezpieczny dla wątków, aby to zrobić.</span><span class="sxs-lookup"><span data-stu-id="9c718-226">Otherwise, the property accessors would have to cache the first value returned by the <xref:System.Lazy%601.Value%2A> property and only modify the cached value, and you would have to write your own thread-safe code to do that.</span></span> <span data-ttu-id="9c718-227">Ze względu na dodatkowe inicjalizacje wymagane przez właściwość odczytu/zapisu, które są obsługiwane przez <xref:System.Lazy%601> obiekt, wydajność może nie być akceptowalna.</span><span class="sxs-lookup"><span data-stu-id="9c718-227">Because of the additional initializations required by a read/write property backed by a <xref:System.Lazy%601> object, the performance might not be acceptable.</span></span> <span data-ttu-id="9c718-228">Ponadto w zależności od konkretnego scenariusza może być wymagana dodatkowa koordynacja, aby uniknąć sytuacji wyścigu między metodami tworzenia i pobierania.</span><span class="sxs-lookup"><span data-stu-id="9c718-228">Furthermore, depending on the specific scenario, additional coordination might be required to avoid race conditions between setters and getters.</span></span>  
  
## <a name="thread-local-lazy-initialization"></a><span data-ttu-id="9c718-229">Thread-Local inicjowania z opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="9c718-229">Thread-Local Lazy Initialization</span></span>  

 <span data-ttu-id="9c718-230">W niektórych scenariuszach wielowątkowych można przydzielić każdemu wątkowi swoje prywatne dane.</span><span class="sxs-lookup"><span data-stu-id="9c718-230">In some multithreaded scenarios, you might want to give each thread its own private data.</span></span> <span data-ttu-id="9c718-231">Takie dane są nazywane *danymi lokalnymi wątku*.</span><span class="sxs-lookup"><span data-stu-id="9c718-231">Such data is called *thread-local data*.</span></span> <span data-ttu-id="9c718-232">W .NET Framework w wersji 3,5 i starszych można zastosować `ThreadStatic` atrybut do zmiennej statycznej w celu ustawienia jej jako wątku lokalnego.</span><span class="sxs-lookup"><span data-stu-id="9c718-232">In the .NET Framework version 3.5 and earlier, you could apply the `ThreadStatic` attribute to a static variable to make it thread-local.</span></span> <span data-ttu-id="9c718-233">Jednak użycie `ThreadStatic` atrybutu może prowadzić do delikatnych błędów.</span><span class="sxs-lookup"><span data-stu-id="9c718-233">However, using the `ThreadStatic` attribute can lead to subtle errors.</span></span> <span data-ttu-id="9c718-234">Na przykład nawet podstawowe instrukcje inicjowania spowodują, że zmienna zostanie zainicjowana tylko na pierwszym wątku, który uzyskuje do niego dostęp, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="9c718-234">For example, even basic initialization statements will cause the variable to be initialized only on the first thread that accesses it, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#6](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#6)]
 [!code-vb[Lazy#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#6)]  
  
 <span data-ttu-id="9c718-235">We wszystkich innych wątkach zmienna zostanie zainicjowana przy użyciu wartości domyślnej (zero).</span><span class="sxs-lookup"><span data-stu-id="9c718-235">On all other threads, the variable will be initialized by using its default value (zero).</span></span> <span data-ttu-id="9c718-236">Alternatywnie w .NET Framework w wersji 4, można użyć <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> typu, aby utworzyć zmienną lokalną wątku, która jest inicjowana we wszystkich wątkach przez podaną <xref:System.Action%601> delegata.</span><span class="sxs-lookup"><span data-stu-id="9c718-236">As an alternative in the .NET Framework version 4, you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> type to create an instance-based, thread-local variable that is initialized on all threads by the <xref:System.Action%601> delegate that you provide.</span></span> <span data-ttu-id="9c718-237">W poniższym przykładzie wszystkie wątki, do których uzyskuje dostęp, `counter` będą widzieć wartość początkową 1.</span><span class="sxs-lookup"><span data-stu-id="9c718-237">In the following example, all threads that access `counter` will see its starting value as 1.</span></span>  
  
 [!code-csharp[Lazy#7](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#7)]
 [!code-vb[Lazy#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#7)]  
  
 <span data-ttu-id="9c718-238"><xref:System.Threading.ThreadLocal%601> Zawija swój obiekt w taki sam sposób jak w przypadku <xref:System.Lazy%601> następujących zasadniczych różnic:</span><span class="sxs-lookup"><span data-stu-id="9c718-238"><xref:System.Threading.ThreadLocal%601> wraps its object in much the same way as <xref:System.Lazy%601>, with these essential differences:</span></span>  
  
- <span data-ttu-id="9c718-239">Każdy wątek inicjuje zmienną lokalną wątku przy użyciu własnych danych prywatnych, które nie są dostępne z innych wątków.</span><span class="sxs-lookup"><span data-stu-id="9c718-239">Each thread initializes the thread-local variable by using its own private data that is not accessible from other threads.</span></span>  
  
- <span data-ttu-id="9c718-240"><xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType>Właściwość jest do odczytu i zapisu i może być modyfikowana dowolną liczbę razy.</span><span class="sxs-lookup"><span data-stu-id="9c718-240">The <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> property is read-write, and can be modified any number of times.</span></span> <span data-ttu-id="9c718-241">Może to mieć wpływ na propagację wyjątku, na przykład jedna `get` operacja może zgłosić wyjątek, ale następny z nich może pomyślnie zainicjować wartość.</span><span class="sxs-lookup"><span data-stu-id="9c718-241">This can affect exception propagation, for example, one `get` operation can raise an exception but the next one can successfully initialize the value.</span></span>  
  
- <span data-ttu-id="9c718-242">Jeśli nie podano delegata inicjalizacji, <xref:System.Threading.ThreadLocal%601> program zainicjuje swój opakowany typ przy użyciu wartości domyślnej typu.</span><span class="sxs-lookup"><span data-stu-id="9c718-242">If no initialization delegate is provided, <xref:System.Threading.ThreadLocal%601> will initialize its wrapped type by using the default value of the type.</span></span> <span data-ttu-id="9c718-243">W tym przypadku <xref:System.Threading.ThreadLocal%601> jest spójny z <xref:System.ThreadStaticAttribute> atrybutem.</span><span class="sxs-lookup"><span data-stu-id="9c718-243">In this regard, <xref:System.Threading.ThreadLocal%601> is consistent with the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
 <span data-ttu-id="9c718-244">Poniższy przykład pokazuje, że każdy wątek, który uzyskuje dostęp do `ThreadLocal<int>` wystąpienia, pobiera własną unikatową kopię danych.</span><span class="sxs-lookup"><span data-stu-id="9c718-244">The following example demonstrates that every thread that accesses the `ThreadLocal<int>` instance gets its own unique copy of the data.</span></span>  
  
 [!code-csharp[Lazy#9](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#9)]
 [!code-vb[Lazy#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#9)]  
  
## <a name="thread-local-variables-in-parallelfor-and-foreach"></a><span data-ttu-id="9c718-245">Thread-Local zmiennych równolegle. dla i ForEach</span><span class="sxs-lookup"><span data-stu-id="9c718-245">Thread-Local Variables in Parallel.For and ForEach</span></span>  

 <span data-ttu-id="9c718-246">W przypadku użycia <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> metody lub <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metody do iteracji równolegle ze źródłami danych można użyć przeciążenia, które mają wbudowaną obsługę danych wątku lokalnego.</span><span class="sxs-lookup"><span data-stu-id="9c718-246">When you use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method or <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to iterate over data sources in parallel, you can use the overloads that have built-in support for thread-local data.</span></span> <span data-ttu-id="9c718-247">W tych metodach można uzyskać dostęp do zasobów lokalnych przy użyciu lokalnych delegatów do tworzenia, uzyskiwania dostępu i czyszczenia danych.</span><span class="sxs-lookup"><span data-stu-id="9c718-247">In these methods, the thread-locality is achieved by using local delegates to create, access, and clean up the data.</span></span> <span data-ttu-id="9c718-248">Aby uzyskać więcej informacji, zobacz [How to: Write a Parallel. for — pętla with Thread-Local zmienne](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) i [instrukcje: pisanie pętli Parallel. Foreach ze zmiennymi Partition-Local](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="9c718-248">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Partition-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span></span>  
  
## <a name="using-lazy-initialization-for-low-overhead-scenarios"></a><span data-ttu-id="9c718-249">Używanie inicjowania z opóźnieniem dla scenariuszy Low-Overhead</span><span class="sxs-lookup"><span data-stu-id="9c718-249">Using Lazy Initialization for Low-Overhead Scenarios</span></span>  

 <span data-ttu-id="9c718-250">W scenariuszach, w których konieczne jest zainicjowanie dużej liczby obiektów z opóźnieniem, można zdecydować, że opakowanie każdego obiektu w <xref:System.Lazy%601> wymaga zbyt dużej ilości pamięci lub zbyt wielu zasobów obliczeniowych.</span><span class="sxs-lookup"><span data-stu-id="9c718-250">In scenarios where you have to lazy-initialize a large number of objects, you might decide that wrapping each object in a <xref:System.Lazy%601> requires too much memory or too many computing resources.</span></span> <span data-ttu-id="9c718-251">Można też mieć rygorystyczne wymagania dotyczące sposobu, w jaki jest ujawniane Inicjowanie z opóźnieniem.</span><span class="sxs-lookup"><span data-stu-id="9c718-251">Or, you might have stringent requirements about how lazy initialization is exposed.</span></span> <span data-ttu-id="9c718-252">W takich przypadkach można użyć `static` `Shared` metod (w Visual Basic) <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> klasy do opóźnionego inicjowania każdego obiektu bez zawijania go w wystąpieniu <xref:System.Lazy%601> .</span><span class="sxs-lookup"><span data-stu-id="9c718-252">In such cases, you can use the `static` (`Shared` in Visual Basic) methods of the <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> class to lazy-initialize each object without wrapping it in an instance of <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="9c718-253">W poniższym przykładzie Załóżmy, że zamiast zawijać cały `Orders` obiekt w jednym <xref:System.Lazy%601> obiekcie, są inicjowane z opóźnieniem pojedyncze `Order` obiekty tylko wtedy, gdy są wymagane.</span><span class="sxs-lookup"><span data-stu-id="9c718-253">In the following example, assume that, instead of wrapping an entire `Orders` object in one <xref:System.Lazy%601> object, you have lazy-initialized individual `Order` objects only if they are required.</span></span>  
  
 [!code-csharp[Lazy#10](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#10)]
 [!code-vb[Lazy#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#10)]  
  
 <span data-ttu-id="9c718-254">W tym przykładzie należy zauważyć, że procedura inicjacji jest wywoływana na każdej iteracji pętli.</span><span class="sxs-lookup"><span data-stu-id="9c718-254">In this example, notice that the initialization procedure is invoked on every iteration of the loop.</span></span> <span data-ttu-id="9c718-255">W scenariuszach wielowątkowych pierwszy wątek do wywołania procedury inicjowania jest taki, którego wartość jest widoczna dla wszystkich wątków.</span><span class="sxs-lookup"><span data-stu-id="9c718-255">In multi-threaded scenarios, the first thread to invoke the initialization procedure is the one whose value is seen by all threads.</span></span> <span data-ttu-id="9c718-256">Późniejsze wątki również wywołują procedurę inicjowania, ale ich wyniki nie są używane.</span><span class="sxs-lookup"><span data-stu-id="9c718-256">Later threads also invoke the initialization procedure, but their results are not used.</span></span> <span data-ttu-id="9c718-257">Jeśli ten rodzaj potencjalnego warunku wyścigu nie jest akceptowalny, Użyj przeciążenia, <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> które przyjmuje argument logiczny i obiekt synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="9c718-257">If this kind of potential race condition is not acceptable, use the overload of <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> that takes a Boolean argument and a synchronization object.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9c718-258">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="9c718-258">See also</span></span>

- [<span data-ttu-id="9c718-259">Zarządzana wątkowość — podstawy</span><span class="sxs-lookup"><span data-stu-id="9c718-259">Managed Threading Basics</span></span>](../../standard/threading/managed-threading-basics.md)
- [<span data-ttu-id="9c718-260">Wątki i wątkowość</span><span class="sxs-lookup"><span data-stu-id="9c718-260">Threads and Threading</span></span>](../../standard/threading/threads-and-threading.md)
- [<span data-ttu-id="9c718-261">Biblioteka zadań równoległych (TPL)</span><span class="sxs-lookup"><span data-stu-id="9c718-261">Task Parallel Library (TPL)</span></span>](../../standard/parallel-programming/task-parallel-library-tpl.md)
- [<span data-ttu-id="9c718-262">Instrukcje: wykonywanie inicjalizacji obiektów z opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="9c718-262">How to: Perform Lazy Initialization of Objects</span></span>](how-to-perform-lazy-initialization-of-objects.md)
