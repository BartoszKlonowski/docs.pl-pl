---
title: Inicjalizacja z opóźnieniem
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lazy initialization in .NET, introduction
ms.assetid: 56b4ae5c-4745-44ff-ad78-ffe4fcde6b9b
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: a826121a7f22d1db7287171c5add28e5fcd690cc
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 05/04/2018
ms.locfileid: "33398030"
---
# <a name="lazy-initialization"></a><span data-ttu-id="f66b9-102">Inicjalizacja z opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="f66b9-102">Lazy Initialization</span></span>
<span data-ttu-id="f66b9-103">*Inicjalizacja z opóźnieniem* obiektu oznacza, że jej tworzenia została odroczona aż najpierw jest używany.</span><span class="sxs-lookup"><span data-stu-id="f66b9-103">*Lazy initialization* of an object means that its creation is deferred until it is first used.</span></span> <span data-ttu-id="f66b9-104">(W tym temacie warunki *incjalizacji* i *opóźnieniem wystąpienia* to samo.) Inicjalizacja z opóźnieniem służy głównie w celu zwiększenia wydajności, uniknąć niepotrzebne obliczeń i zmniejszyć wymagania dotyczące pamięci programu.</span><span class="sxs-lookup"><span data-stu-id="f66b9-104">(For this topic, the terms *lazy initialization* and *lazy instantiation* are synonymous.) Lazy initialization is primarily used to improve performance, avoid wasteful computation, and reduce program memory requirements.</span></span> <span data-ttu-id="f66b9-105">Są to najbardziej typowych scenariuszy:</span><span class="sxs-lookup"><span data-stu-id="f66b9-105">These are the most common scenarios:</span></span>  
  
-   <span data-ttu-id="f66b9-106">Gdy został wybrany obiekt, który jest kosztowne, a program nie może używać.</span><span class="sxs-lookup"><span data-stu-id="f66b9-106">When you have an object that is expensive to create, and the program might not use it.</span></span> <span data-ttu-id="f66b9-107">Załóżmy na przykład, że masz w pamięci `Customer` obiektu, który ma `Orders` właściwość, która zawiera dużą tablicę `Order` obiekty, które, aby można było zainicjować wymaga połączenia z bazą danych.</span><span class="sxs-lookup"><span data-stu-id="f66b9-107">For example, assume that you have in memory a `Customer` object that has an `Orders` property that contains a large array of `Order` objects that, to be initialized, requires a database connection.</span></span> <span data-ttu-id="f66b9-108">Jeśli użytkownik nigdy nie żąda umożliwia wyświetlanie zamówień lub użyć danych w obliczeniach, to nie ma żadnych powód użycia pamięci lub obliczeniowych cykle go utworzyć.</span><span class="sxs-lookup"><span data-stu-id="f66b9-108">If the user never asks to display the Orders or use the data in a computation, then there is no reason to use system memory or computing cycles to create it.</span></span> <span data-ttu-id="f66b9-109">Za pomocą `Lazy<Orders>` Aby zadeklarować `Orders` obiekt do inicjowania z opóźnieniem, możesz uniknąć traci zasobów systemowych, jeśli obiekt nie jest używany.</span><span class="sxs-lookup"><span data-stu-id="f66b9-109">By using `Lazy<Orders>` to declare the `Orders` object for lazy initialization, you can avoid wasting system resources when the object is not used.</span></span>  
  
-   <span data-ttu-id="f66b9-110">Gdy został wybrany obiekt, który jest kosztowne i chcesz odroczenie jego tworzenia, aż do zakończenia inne kosztowne operacje.</span><span class="sxs-lookup"><span data-stu-id="f66b9-110">When you have an object that is expensive to create, and you want to defer its creation until after other expensive operations have been completed.</span></span> <span data-ttu-id="f66b9-111">Załóżmy na przykład, że program ładuje kilka wystąpień obiektu podczas uruchamiania, ale tylko niektóre z nich są wymagane natychmiast.</span><span class="sxs-lookup"><span data-stu-id="f66b9-111">For example, assume that your program loads several object instances when it starts, but only some of them are required immediately.</span></span> <span data-ttu-id="f66b9-112">Aby zwiększyć wydajność uruchamiania programów, należy odkładanie Inicjowanie obiektów, które nie są wymagane do czasu utworzenia wymaganych obiektów.</span><span class="sxs-lookup"><span data-stu-id="f66b9-112">You can improve the startup performance of the program by deferring initialization of the objects that are not required until the required objects have been created.</span></span>  
  
 <span data-ttu-id="f66b9-113">Mimo że można napisać własny kod do wykonania inicjowania z opóźnieniem, zaleca się używanie <xref:System.Lazy%601> zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="f66b9-113">Although you can write your own code to perform lazy initialization, we recommend that you use <xref:System.Lazy%601> instead.</span></span> <span data-ttu-id="f66b9-114"><xref:System.Lazy%601> oraz jego powiązanych typów również obsługuje bezpieczeństwo wątków i zasad propagacji spójne wyjątku.</span><span class="sxs-lookup"><span data-stu-id="f66b9-114"><xref:System.Lazy%601> and its related types also support thread-safety and provide a consistent exception propagation policy.</span></span>  
  
 <span data-ttu-id="f66b9-115">Poniższa tabela zawiera listę typów, które .NET Framework w wersji 4 udostępnia umożliwiające Inicjalizacja z opóźnieniem w różnych scenariuszy.</span><span class="sxs-lookup"><span data-stu-id="f66b9-115">The following table lists the types that the .NET Framework version 4 provides to enable lazy initialization in different scenarios.</span></span>  
  
|<span data-ttu-id="f66b9-116">Typ</span><span class="sxs-lookup"><span data-stu-id="f66b9-116">Type</span></span>|<span data-ttu-id="f66b9-117">Opis</span><span class="sxs-lookup"><span data-stu-id="f66b9-117">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601>|<span data-ttu-id="f66b9-118">Klasa otoki, która zapewnia semantyki Inicjalizacja z opóźnieniem biblioteki klas lub typ zdefiniowany przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="f66b9-118">A wrapper class that provides lazy initialization semantics for any class library or user-defined type.</span></span>|  
|<xref:System.Threading.ThreadLocal%601>|<span data-ttu-id="f66b9-119">Podobny <xref:System.Lazy%601> z tym, że zapewnia semantyki Inicjalizacja z opóźnieniem na zasadzie lokalnej wątku.</span><span class="sxs-lookup"><span data-stu-id="f66b9-119">Resembles <xref:System.Lazy%601> except that it provides lazy initialization semantics on a thread-local basis.</span></span> <span data-ttu-id="f66b9-120">Każdy wątek ma dostęp do własnej unikatowe wartości.</span><span class="sxs-lookup"><span data-stu-id="f66b9-120">Every thread has access to its own unique value.</span></span>|  
|<xref:System.Threading.LazyInitializer>|<span data-ttu-id="f66b9-121">Udostępnia zaawansowane `static` (`Shared` w języku Visual Basic) metody incjalizacji obiektów bez nakładów związanych z klasą.</span><span class="sxs-lookup"><span data-stu-id="f66b9-121">Provides advanced `static` (`Shared` in Visual Basic) methods for lazy initialization of objects without the overhead of a class.</span></span>|  
  
## <a name="basic-lazy-initialization"></a><span data-ttu-id="f66b9-122">Inicjalizacja z opóźnieniem podstawowe</span><span class="sxs-lookup"><span data-stu-id="f66b9-122">Basic Lazy Initialization</span></span>  
 <span data-ttu-id="f66b9-123">Aby zdefiniować opóźnieniem zainicjowany typem, na przykład `MyType`, użyj `Lazy<MyType>` (`Lazy(Of MyType)` w języku Visual Basic), jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="f66b9-123">To define a lazy-initialized type, for example, `MyType`, use `Lazy<MyType>` (`Lazy(Of MyType)` in Visual Basic), as shown in the following example.</span></span> <span data-ttu-id="f66b9-124">Jeśli delegat nie jest przekazywany w <xref:System.Lazy%601> opakowanej typu konstruktora, jest tworzona przy użyciu <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> kiedy najpierw dostępu do właściwości value.</span><span class="sxs-lookup"><span data-stu-id="f66b9-124">If no delegate is passed in the <xref:System.Lazy%601> constructor, the wrapped type is created by using <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> when the value property is first accessed.</span></span> <span data-ttu-id="f66b9-125">Jeśli typ nie ma domyślnego konstruktora, zwracany jest wyjątek czasu wykonywania.</span><span class="sxs-lookup"><span data-stu-id="f66b9-125">If the type does not have a default constructor, a run-time exception is thrown.</span></span>  
  
 <span data-ttu-id="f66b9-126">W poniższym przykładzie przyjęto założenie, że `Orders` jest klasa, która zawiera tablicę `Order` obiekt pobrany z bazy danych.</span><span class="sxs-lookup"><span data-stu-id="f66b9-126">In the following example, assume that `Orders` is a class that contains an array of `Order` objects retrieved from a database.</span></span> <span data-ttu-id="f66b9-127">A `Customer` obiekt zawiera wystąpienie `Orders`, ale w zależności od działań użytkownika, danych z `Orders` obiekt nie może być wymagane.</span><span class="sxs-lookup"><span data-stu-id="f66b9-127">A `Customer` object contains an instance of `Orders`, but depending on user actions, the data from the `Orders` object might not be required.</span></span>  
  
 [!code-csharp[Lazy#1](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#1)]
 [!code-vb[Lazy#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#1)]  
  
 <span data-ttu-id="f66b9-128">Można również przekazać delegata w <xref:System.Lazy%601> Konstruktor, który wywołuje konstruktor określonego przeciążenia opakowanej typu w czasie tworzenia i wykonaj pozostałe kroki inicjowania, które są wymagane, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="f66b9-128">You can also pass a delegate in the <xref:System.Lazy%601> constructor that invokes a specific constructor overload on the wrapped type at creation time, and perform any other initialization steps that are required, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#2](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#2)]
 [!code-vb[Lazy#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#2)]  
  
 <span data-ttu-id="f66b9-129">Po utworzeniu obiektu opóźnieniem, żadne wystąpienie elementu `Orders` jest tworzony, dopóki <xref:System.Lazy%601.Value%2A> właściwość opóźnieniem zmiennej jest dostępny po raz pierwszy.</span><span class="sxs-lookup"><span data-stu-id="f66b9-129">After the Lazy object is created, no instance of `Orders` is created until the <xref:System.Lazy%601.Value%2A> property of the Lazy variable is accessed for the first time.</span></span> <span data-ttu-id="f66b9-130">Na pierwszym dostępie opakowanej typu jest utworzony i zwracane, a następnie przechowywane dla przyszłych dostęp.</span><span class="sxs-lookup"><span data-stu-id="f66b9-130">On first access, the wrapped type is created and returned, and stored for any future access.</span></span>  
  
 [!code-csharp[Lazy#3](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#3)]
 [!code-vb[Lazy#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#3)]  
  
 <span data-ttu-id="f66b9-131">A <xref:System.Lazy%601> obiektu zawsze zwraca tego samego obiektu lub wartości, który został zainicjowany.</span><span class="sxs-lookup"><span data-stu-id="f66b9-131">A <xref:System.Lazy%601> object always returns the same object or value that it was initialized with.</span></span> <span data-ttu-id="f66b9-132">W związku z tym <xref:System.Lazy%601.Value%2A> właściwość jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="f66b9-132">Therefore, the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="f66b9-133">Jeśli <xref:System.Lazy%601.Value%2A> typ zapisuje odwołanie, nie można przypisać nowy obiekt do niego.</span><span class="sxs-lookup"><span data-stu-id="f66b9-133">If <xref:System.Lazy%601.Value%2A> stores a reference type, you cannot assign a new object to it.</span></span> <span data-ttu-id="f66b9-134">(Jednak można zmienić wartość można ustawić pola publiczne i właściwości.) Jeśli <xref:System.Lazy%601.Value%2A> zapisuje wartość typ, nie można zmodyfikować jego wartości.</span><span class="sxs-lookup"><span data-stu-id="f66b9-134">(However, you can change the value of its settable public fields and properties.) If <xref:System.Lazy%601.Value%2A> stores a value type, you cannot modify its value.</span></span> <span data-ttu-id="f66b9-135">Niemniej jednak można utworzyć nową zmienną za pomocą zmiennej konstruktora ponownie przy użyciu nowych argumentów.</span><span class="sxs-lookup"><span data-stu-id="f66b9-135">Nevertheless, you can create a new variable by invoking the variable constructor again by using new arguments.</span></span>  
  
 [!code-csharp[Lazy#4](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#4)]
 [!code-vb[Lazy#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#4)]  
  
 <span data-ttu-id="f66b9-136">Nowe wystąpienie opóźnieniem, tak jak wcześniej, nie tworzy wystąpienia `Orders` do momentu jego <xref:System.Lazy%601.Value%2A> najpierw dostępu do właściwości.</span><span class="sxs-lookup"><span data-stu-id="f66b9-136">The new lazy instance, like the earlier one, does not instantiate `Orders` until its <xref:System.Lazy%601.Value%2A> property is first accessed.</span></span>  
  
### <a name="thread-safe-initialization"></a><span data-ttu-id="f66b9-137">Inicjowanie obsługujące wielowątkowość</span><span class="sxs-lookup"><span data-stu-id="f66b9-137">Thread-Safe Initialization</span></span>  
 <span data-ttu-id="f66b9-138">Domyślnie <xref:System.Lazy%601> obiekty są wątkowo.</span><span class="sxs-lookup"><span data-stu-id="f66b9-138">By default, <xref:System.Lazy%601> objects are thread-safe.</span></span> <span data-ttu-id="f66b9-139">Oznacza to, gdy Konstruktor nie został określony rodzaj bezpieczeństwo wątków <xref:System.Lazy%601> tworzy obiekty są wątkowo.</span><span class="sxs-lookup"><span data-stu-id="f66b9-139">That is, if the constructor does not specify the kind of thread safety, the <xref:System.Lazy%601> objects it creates are thread-safe.</span></span> <span data-ttu-id="f66b9-140">W scenariuszach wielowątkowych pierwszym wątkiem dostępu do <xref:System.Lazy%601.Value%2A> właściwości obsługującej wielowątkowość <xref:System.Lazy%601> obiektu inicjowane dla wszystkich kolejnych dostęp na wszystkie wątki i wszystkie wątki udostępnianie tych samych danych.</span><span class="sxs-lookup"><span data-stu-id="f66b9-140">In multi-threaded scenarios, the first thread to access the <xref:System.Lazy%601.Value%2A> property of a thread-safe <xref:System.Lazy%601> object initializes it for all subsequent accesses on all threads, and all threads share the same data.</span></span> <span data-ttu-id="f66b9-141">W związku z tym nie ma znaczenia, który wątek inicjuje obiekt i niegroźne są warunki wyścigu.</span><span class="sxs-lookup"><span data-stu-id="f66b9-141">Therefore, it does not matter which thread initializes the object, and race conditions are benign.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f66b9-142">Ten zgodność warunki błędów można rozszerzyć przy użyciu buforowania wyjątek.</span><span class="sxs-lookup"><span data-stu-id="f66b9-142">You can extend this consistency to error conditions by using exception caching.</span></span> <span data-ttu-id="f66b9-143">Aby uzyskać więcej informacji, zobacz następną sekcję, [wyjątków w obiektach opóźnieniem](../../../docs/framework/performance/lazy-initialization.md#ExceptionsInLazyObjects).</span><span class="sxs-lookup"><span data-stu-id="f66b9-143">For more information, see the next section, [Exceptions in Lazy Objects](../../../docs/framework/performance/lazy-initialization.md#ExceptionsInLazyObjects).</span></span>  
  
 <span data-ttu-id="f66b9-144">W poniższym przykładzie pokazano, że takie same `Lazy<int>` wystąpienie ma taką samą wartość dla trzech oddzielnych wątkach.</span><span class="sxs-lookup"><span data-stu-id="f66b9-144">The following example shows that the same `Lazy<int>` instance has the same value for three separate threads.</span></span>  
  
 [!code-csharp[Lazy#8](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#8)]
 [!code-vb[Lazy#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#8)]  
  
 <span data-ttu-id="f66b9-145">Jeśli potrzebujesz oddzielnych danych na każdy wątek, użyj <xref:System.Threading.ThreadLocal%601> typ, zgodnie z opisem w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="f66b9-145">If you require separate data on each thread, use the <xref:System.Threading.ThreadLocal%601> type, as described later in this topic.</span></span>  
  
 <span data-ttu-id="f66b9-146">Niektóre <xref:System.Lazy%601> konstruktorów mieć parametrów typu Boolean o nazwie `isThreadSafe` używany do określenia czy <xref:System.Lazy%601.Value%2A> właściwość będą mieli dostęp wiele wątków.</span><span class="sxs-lookup"><span data-stu-id="f66b9-146">Some <xref:System.Lazy%601> constructors have a Boolean parameter named `isThreadSafe` that is used to specify whether the <xref:System.Lazy%601.Value%2A> property will be accessed from multiple threads.</span></span> <span data-ttu-id="f66b9-147">Jeśli planujesz dostęp do właściwości z tylko jednego wątku, Przekaż `false` korzyści niewielkie wydajności.</span><span class="sxs-lookup"><span data-stu-id="f66b9-147">If you intend to access the property from just one thread, pass in `false` to obtain a modest performance benefit.</span></span> <span data-ttu-id="f66b9-148">Jeśli planujesz dostęp do właściwości wiele wątków, Przekaż `true` nakazać programowi <xref:System.Lazy%601> wystąpienia poprawnie obsłużyć wyścigu, w których jeden wątek zgłasza wyjątek w czasie inicjowania.</span><span class="sxs-lookup"><span data-stu-id="f66b9-148">If you intend to access the property from multiple threads, pass in `true` to instruct the <xref:System.Lazy%601> instance to correctly handle race conditions in which one thread throws an exception at initialization time.</span></span>  
  
 <span data-ttu-id="f66b9-149">Niektóre <xref:System.Lazy%601> mieć konstruktorów <xref:System.Threading.LazyThreadSafetyMode> parametru o nazwie `mode`.</span><span class="sxs-lookup"><span data-stu-id="f66b9-149">Some <xref:System.Lazy%601> constructors have a <xref:System.Threading.LazyThreadSafetyMode> parameter named `mode`.</span></span> <span data-ttu-id="f66b9-150">Konstruktory te zapewniają tryb awaryjny wątku dodatkowe.</span><span class="sxs-lookup"><span data-stu-id="f66b9-150">These constructors provide an additional thread safety mode.</span></span> <span data-ttu-id="f66b9-151">W poniższej tabeli przedstawiono, jak bezpieczeństwo wątku <xref:System.Lazy%601> obiektu dotyczy parametrami konstruktora, które określają bezpieczeństwo wątków.</span><span class="sxs-lookup"><span data-stu-id="f66b9-151">The following table shows how the thread safety of a <xref:System.Lazy%601> object is affected by constructor parameters that specify thread safety.</span></span> <span data-ttu-id="f66b9-152">Każdy Konstruktor ma co najwyżej jeden taki parametr.</span><span class="sxs-lookup"><span data-stu-id="f66b9-152">Each constructor has at most one such parameter.</span></span>  
  
|<span data-ttu-id="f66b9-153">Bezpieczeństwo wątków obiektu</span><span class="sxs-lookup"><span data-stu-id="f66b9-153">Thread safety of the object</span></span>|<span data-ttu-id="f66b9-154">`LazyThreadSafetyMode` `mode` Parametr</span><span class="sxs-lookup"><span data-stu-id="f66b9-154">`LazyThreadSafetyMode` `mode` parameter</span></span>|<span data-ttu-id="f66b9-155">Wartość logiczna `isThreadSafe` parametru</span><span class="sxs-lookup"><span data-stu-id="f66b9-155">Boolean `isThreadSafe` parameter</span></span>|<span data-ttu-id="f66b9-156">Brak parametrów bezpieczeństwa wątków</span><span class="sxs-lookup"><span data-stu-id="f66b9-156">No thread safety parameters</span></span>|  
|---------------------------------|---------------------------------------------|--------------------------------------|---------------------------------|  
|<span data-ttu-id="f66b9-157">Pełni wątkowo; tylko jeden wątek jednocześnie umożliwia podjęcie próby zainicjowania wartość.</span><span class="sxs-lookup"><span data-stu-id="f66b9-157">Fully thread-safe; only one thread at a time tries to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|<span data-ttu-id="f66b9-158">Tak.</span><span class="sxs-lookup"><span data-stu-id="f66b9-158">Yes.</span></span>|  
|<span data-ttu-id="f66b9-159">Nie wątkowo.</span><span class="sxs-lookup"><span data-stu-id="f66b9-159">Not thread-safe.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|<span data-ttu-id="f66b9-160">Nie dotyczy.</span><span class="sxs-lookup"><span data-stu-id="f66b9-160">Not applicable.</span></span>|  
|<span data-ttu-id="f66b9-161">Pełni wątkowo; wątki wyścigu zainicjować wartość.</span><span class="sxs-lookup"><span data-stu-id="f66b9-161">Fully thread-safe; threads race to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|<span data-ttu-id="f66b9-162">Nie dotyczy.</span><span class="sxs-lookup"><span data-stu-id="f66b9-162">Not applicable.</span></span>|<span data-ttu-id="f66b9-163">Nie dotyczy.</span><span class="sxs-lookup"><span data-stu-id="f66b9-163">Not applicable.</span></span>|  
  
 <span data-ttu-id="f66b9-164">Jak widać w tabeli, określając <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> dla `mode` parametr jest taki sam jak określenie `true` dla `isThreadSafe` parametru i określając <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> jest taka sama jak określanie `false`.</span><span class="sxs-lookup"><span data-stu-id="f66b9-164">As the table shows, specifying <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> for the `mode` parameter is the same as specifying `true` for the `isThreadSafe` parameter, and specifying <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> is the same as specifying `false`.</span></span>  
  
 <span data-ttu-id="f66b9-165">Określanie <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> zezwala na wiele wątków próbuje zainicjować <xref:System.Lazy%601> wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="f66b9-165">Specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> allows multiple threads to attempt to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="f66b9-166">Tylko jeden wątek można kupić tej wyścigu i inne wątki wyświetlony wartość, która została zainicjowana przez wątek powiodło się.</span><span class="sxs-lookup"><span data-stu-id="f66b9-166">Only one thread can win this race, and all the other threads receive the value that was initialized by the successful thread.</span></span> <span data-ttu-id="f66b9-167">Jeśli w wątku jest zgłaszany wyjątek podczas inicjowania, wątek nie otrzyma wartość ustawioną przez wątek powiodło się.</span><span class="sxs-lookup"><span data-stu-id="f66b9-167">If an exception is thrown on a thread during initialization, that thread does not receive the value set by the successful thread.</span></span> <span data-ttu-id="f66b9-168">Wyjątki nie są buforowane, dlatego kolejna próba dostępu do <xref:System.Lazy%601.Value%2A> właściwości może spowodować powiodło się inicjowanie.</span><span class="sxs-lookup"><span data-stu-id="f66b9-168">Exceptions are not cached, so a subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property can result in successful initialization.</span></span> <span data-ttu-id="f66b9-169">To różni się od sposobu wyjątki są traktowane w innych trybów, opisany w następnej sekcji.</span><span class="sxs-lookup"><span data-stu-id="f66b9-169">This differs from the way exceptions are treated in other modes, which is described in the following section.</span></span> <span data-ttu-id="f66b9-170">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.LazyThreadSafetyMode> wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="f66b9-170">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
<a name="ExceptionsInLazyObjects"></a>   
## <a name="exceptions-in-lazy-objects"></a><span data-ttu-id="f66b9-171">Wyjątki w obiektach opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="f66b9-171">Exceptions in Lazy Objects</span></span>  
 <span data-ttu-id="f66b9-172">Jak wspomniano wcześniej, <xref:System.Lazy%601> obiektu zawsze zwraca tego samego obiektu lub wartości, który został zainicjowany, i w związku z tym <xref:System.Lazy%601.Value%2A> właściwość jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="f66b9-172">As stated earlier, a <xref:System.Lazy%601> object always returns the same object or value that it was initialized with, and therefore the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="f66b9-173">Po włączeniu buforowanie wyjątek, to immutability uwzględniającą zachowanie wyjątku.</span><span class="sxs-lookup"><span data-stu-id="f66b9-173">If you enable exception caching, this immutability also extends to exception behavior.</span></span> <span data-ttu-id="f66b9-174">Jeśli obiekt opóźnieniem zainicjować jest włączone buforowanie wyjątku i zgłasza wyjątek jej metodę inicjowania podczas <xref:System.Lazy%601.Value%2A> najpierw dostępu do właściwości, tego samego wyjątek na każdym kolejne próby dostępu do <xref:System.Lazy%601.Value%2A> właściwości .</span><span class="sxs-lookup"><span data-stu-id="f66b9-174">If a lazy-initialized object has exception caching enabled and throws an exception from its initialization method when the <xref:System.Lazy%601.Value%2A> property is first accessed, that same exception is thrown on every subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property.</span></span> <span data-ttu-id="f66b9-175">Innymi słowy, Konstruktor opakowanej typu nigdy nie zostanie ponownie wywołana, nawet w scenariuszach wielowątkowych.</span><span class="sxs-lookup"><span data-stu-id="f66b9-175">In other words, the constructor of the wrapped type is never re-invoked, even in multithreaded scenarios.</span></span> <span data-ttu-id="f66b9-176">W związku z tym <xref:System.Lazy%601> obiektu nie można zgłosić wyjątek na dostęp do jednego i zwracać wartość kolejnych dostępu.</span><span class="sxs-lookup"><span data-stu-id="f66b9-176">Therefore, the <xref:System.Lazy%601> object cannot throw an exception on one access and return a value on a subsequent access.</span></span>  
  
 <span data-ttu-id="f66b9-177">Wyjątek buforowanie jest włączone, jeśli korzystasz z dowolnych <xref:System.Lazy%601?displayProperty=nameWithType> Konstruktor, który pobiera metodę inicjalizacji (`valueFactory` parametru), na przykład jest włączona, gdy używasz `Lazy(T)(Func(T))`konstruktora.</span><span class="sxs-lookup"><span data-stu-id="f66b9-177">Exception caching is enabled when you use any <xref:System.Lazy%601?displayProperty=nameWithType> constructor that takes an initialization method (`valueFactory` parameter); for example, it is enabled when you use the `Lazy(T)(Func(T))`constructor.</span></span> <span data-ttu-id="f66b9-178">Jeśli konstruktora również przyjmuje <xref:System.Threading.LazyThreadSafetyMode> wartość (`mode` parametru), określ <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> lub <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f66b9-178">If the constructor also takes a <xref:System.Threading.LazyThreadSafetyMode> value (`mode` parameter), specify <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> or <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f66b9-179">Określanie metody inicjującej umożliwia buforowanie wyjątku dla tych dwóch trybów.</span><span class="sxs-lookup"><span data-stu-id="f66b9-179">Specifying an initialization method enables exception caching for these two modes.</span></span> <span data-ttu-id="f66b9-180">Metoda inicjująca może być bardzo proste.</span><span class="sxs-lookup"><span data-stu-id="f66b9-180">The initialization method can be very simple.</span></span> <span data-ttu-id="f66b9-181">Na przykład może wywołać konstruktora domyślnego dla `T`: `new Lazy<Contents>(() => new Contents(), mode)` w języku C# lub `New Lazy(Of Contents)(Function() New Contents())` w języku Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="f66b9-181">For example, it might call the default constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic.</span></span> <span data-ttu-id="f66b9-182">Jeśli używasz <xref:System.Lazy%601?displayProperty=nameWithType> Konstruktor, który nie określa metodę inicjalizacji, wyjątki, które są generowane przez domyślny konstruktor `T` nie są buforowane.</span><span class="sxs-lookup"><span data-stu-id="f66b9-182">If you use a <xref:System.Lazy%601?displayProperty=nameWithType> constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for `T` are not cached.</span></span> <span data-ttu-id="f66b9-183">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.LazyThreadSafetyMode> wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="f66b9-183">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f66b9-184">W przypadku utworzenia <xref:System.Lazy%601> obiekt z `isThreadSafe` wartość parametru konstruktora `false` lub `mode` wartość parametru konstruktora <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, muszą uzyskać dostęp do <xref:System.Lazy%601> obiektu z jednego wątku lub Podaj własny Synchronizacja.</span><span class="sxs-lookup"><span data-stu-id="f66b9-184">If you create a <xref:System.Lazy%601> object with the `isThreadSafe` constructor parameter set to `false` or the `mode` constructor parameter set to <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, you must access the <xref:System.Lazy%601> object from a single thread or provide your own synchronization.</span></span> <span data-ttu-id="f66b9-185">Dotyczy to wszystkich aspektów obiektu, włączając buforowanie wyjątku.</span><span class="sxs-lookup"><span data-stu-id="f66b9-185">This applies to all aspects of the object, including exception caching.</span></span>  
  
 <span data-ttu-id="f66b9-186">Jak wspomniano w poprzedniej sekcji, <xref:System.Lazy%601> obiekty utworzone przez określenie <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> Traktuj wyjątki inaczej.</span><span class="sxs-lookup"><span data-stu-id="f66b9-186">As noted in the previous section, <xref:System.Lazy%601> objects created by specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> treat exceptions differently.</span></span> <span data-ttu-id="f66b9-187">Z <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, wiele wątków konkurować można zainicjować <xref:System.Lazy%601> wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="f66b9-187">With <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, multiple threads can compete to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="f66b9-188">W takim przypadku nie są buforowane wyjątki i próbuje uzyskać dostęp do <xref:System.Lazy%601.Value%2A> właściwości można kontynuować przed pomyślnym zakończeniem inicjowania.</span><span class="sxs-lookup"><span data-stu-id="f66b9-188">In this case, exceptions are not cached, and attempts to access the <xref:System.Lazy%601.Value%2A> property can continue until initialization is successful.</span></span>  
  
 <span data-ttu-id="f66b9-189">W poniższej tabeli przedstawiono sposób <xref:System.Lazy%601> konstruktorów kontrolować buforowanie wyjątku.</span><span class="sxs-lookup"><span data-stu-id="f66b9-189">The following table summarizes the way the <xref:System.Lazy%601> constructors control exception caching.</span></span>  
  
|<span data-ttu-id="f66b9-190">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="f66b9-190">Constructor</span></span>|<span data-ttu-id="f66b9-191">Tryb awaryjny wątku</span><span class="sxs-lookup"><span data-stu-id="f66b9-191">Thread safety mode</span></span>|<span data-ttu-id="f66b9-192">Używa metody inicjowania</span><span class="sxs-lookup"><span data-stu-id="f66b9-192">Uses initialization method</span></span>|<span data-ttu-id="f66b9-193">Wyjątki są buforowane.</span><span class="sxs-lookup"><span data-stu-id="f66b9-193">Exceptions are cached</span></span>|  
|-----------------|------------------------|--------------------------------|---------------------------|  
|<span data-ttu-id="f66b9-194">Lazy(T)()</span><span class="sxs-lookup"><span data-stu-id="f66b9-194">Lazy(T)()</span></span>|<span data-ttu-id="f66b9-195">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="f66b9-195">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="f66b9-196">Nie</span><span class="sxs-lookup"><span data-stu-id="f66b9-196">No</span></span>|<span data-ttu-id="f66b9-197">Nie</span><span class="sxs-lookup"><span data-stu-id="f66b9-197">No</span></span>|  
|<span data-ttu-id="f66b9-198">Lazy(T)(FUNC(T))</span><span class="sxs-lookup"><span data-stu-id="f66b9-198">Lazy(T)(Func(T))</span></span>|<span data-ttu-id="f66b9-199">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="f66b9-199">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="f66b9-200">Tak</span><span class="sxs-lookup"><span data-stu-id="f66b9-200">Yes</span></span>|<span data-ttu-id="f66b9-201">Tak</span><span class="sxs-lookup"><span data-stu-id="f66b9-201">Yes</span></span>|  
|<span data-ttu-id="f66b9-202">Lazy(T)(Boolean)</span><span class="sxs-lookup"><span data-stu-id="f66b9-202">Lazy(T)(Boolean)</span></span>|<span data-ttu-id="f66b9-203">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) lub `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="f66b9-203">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="f66b9-204">Nie</span><span class="sxs-lookup"><span data-stu-id="f66b9-204">No</span></span>|<span data-ttu-id="f66b9-205">Nie</span><span class="sxs-lookup"><span data-stu-id="f66b9-205">No</span></span>|  
|<span data-ttu-id="f66b9-206">Lazy(T)(FUNC(T), wartość logiczna)</span><span class="sxs-lookup"><span data-stu-id="f66b9-206">Lazy(T)(Func(T), Boolean)</span></span>|<span data-ttu-id="f66b9-207">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) lub `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="f66b9-207">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="f66b9-208">Tak</span><span class="sxs-lookup"><span data-stu-id="f66b9-208">Yes</span></span>|<span data-ttu-id="f66b9-209">Tak</span><span class="sxs-lookup"><span data-stu-id="f66b9-209">Yes</span></span>|  
|<span data-ttu-id="f66b9-210">Lazy(T)(LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="f66b9-210">Lazy(T)(LazyThreadSafetyMode)</span></span>|<span data-ttu-id="f66b9-211">Określone przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="f66b9-211">User-specified</span></span>|<span data-ttu-id="f66b9-212">Nie</span><span class="sxs-lookup"><span data-stu-id="f66b9-212">No</span></span>|<span data-ttu-id="f66b9-213">Nie</span><span class="sxs-lookup"><span data-stu-id="f66b9-213">No</span></span>|  
|<span data-ttu-id="f66b9-214">Lazy(T)(FUNC(T), LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="f66b9-214">Lazy(T)(Func(T), LazyThreadSafetyMode)</span></span>|<span data-ttu-id="f66b9-215">Określone przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="f66b9-215">User-specified</span></span>|<span data-ttu-id="f66b9-216">Tak</span><span class="sxs-lookup"><span data-stu-id="f66b9-216">Yes</span></span>|<span data-ttu-id="f66b9-217">Nie, jeśli użytkownik określi <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; w przeciwnym razie tak.</span><span class="sxs-lookup"><span data-stu-id="f66b9-217">No if user specifies <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; otherwise, yes.</span></span>|  
  
## <a name="implementing-a-lazy-initialized-property"></a><span data-ttu-id="f66b9-218">Implementowanie właściwości opóźnieniem zainicjowany</span><span class="sxs-lookup"><span data-stu-id="f66b9-218">Implementing a Lazy-Initialized Property</span></span>  
 <span data-ttu-id="f66b9-219">Aby zaimplementować właściwości publicznej przy użyciu inicjowania z opóźnieniem, zdefiniuj pola zapasowy właściwości jako <xref:System.Lazy%601>i zwróć <xref:System.Lazy%601.Value%2A> właściwości z `get` metody dostępu właściwości.</span><span class="sxs-lookup"><span data-stu-id="f66b9-219">To implement a public property by using lazy initialization, define the backing field of the property as a <xref:System.Lazy%601>, and return the <xref:System.Lazy%601.Value%2A> property from the `get` accessor of the property.</span></span>  
  
 [!code-csharp[Lazy#5](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#5)]
 [!code-vb[Lazy#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#5)]  
  
 <span data-ttu-id="f66b9-220"><xref:System.Lazy%601.Value%2A> Właściwość jest tylko do odczytu; w związku z tym nie ma właściwość, która udostępnia go `set` metody dostępu.</span><span class="sxs-lookup"><span data-stu-id="f66b9-220">The <xref:System.Lazy%601.Value%2A> property is read-only; therefore, the property that exposes it has no `set` accessor.</span></span> <span data-ttu-id="f66b9-221">Jeśli wymagane jest obsługiwana przez właściwości odczytu/zapisu <xref:System.Lazy%601> obiektu `set` dostępu należy utworzyć nowy <xref:System.Lazy%601> obiektu i przypisz go do magazynu zapasowego.</span><span class="sxs-lookup"><span data-stu-id="f66b9-221">If you require a read/write property backed by a <xref:System.Lazy%601> object, the `set` accessor must create a new <xref:System.Lazy%601> object and assign it to the backing store.</span></span> <span data-ttu-id="f66b9-222">`set` Dostępu należy utworzyć wyrażenie lambda, które zwraca nową wartość właściwości, która została przekazana do `set` metody dostępu i przekazać tego wyrażenia lambda do konstruktora dla nowego <xref:System.Lazy%601> obiektu.</span><span class="sxs-lookup"><span data-stu-id="f66b9-222">The `set` accessor must create a lambda expression that returns the new property value that was passed to the `set` accessor, and pass that lambda expression to the constructor for the new <xref:System.Lazy%601> object.</span></span> <span data-ttu-id="f66b9-223">Następny dostęp <xref:System.Lazy%601.Value%2A> właściwość spowoduje zainicjowanie nowej <xref:System.Lazy%601>i jego <xref:System.Lazy%601.Value%2A> właściwości następnie zwraca nową wartość, która została przypisana do właściwości.</span><span class="sxs-lookup"><span data-stu-id="f66b9-223">The next access of the <xref:System.Lazy%601.Value%2A> property will cause initialization of the new <xref:System.Lazy%601>, and its <xref:System.Lazy%601.Value%2A> property will thereafter return the new value that was assigned to the property.</span></span> <span data-ttu-id="f66b9-224">Przyczyna to rozmieszczenie zwichrowanych jest zachowanie wielowątkowość zabezpieczenia, wbudowane <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="f66b9-224">The reason for this convoluted arrangement is to preserve the multithreading protections built into <xref:System.Lazy%601>.</span></span> <span data-ttu-id="f66b9-225">W przeciwnym razie musi akcesorach właściwości pamięci podręcznej pierwsza wartość zwrócona przez <xref:System.Lazy%601.Value%2A> właściwości i modyfikować tylko wartość w pamięci podręcznej i trzeba napisać własny kod wątkowo, w tym celu.</span><span class="sxs-lookup"><span data-stu-id="f66b9-225">Otherwise, the property accessors would have to cache the first value returned by the <xref:System.Lazy%601.Value%2A> property and only modify the cached value, and you would have to write your own thread-safe code to do that.</span></span> <span data-ttu-id="f66b9-226">Ze względu na dodatkowe operacji inicjowania wymagane przez właściwości odczytu/zapisu przez <xref:System.Lazy%601> obiektu wydajności nie może być akceptowane.</span><span class="sxs-lookup"><span data-stu-id="f66b9-226">Because of the additional initializations required by a read/write property backed by a <xref:System.Lazy%601> object, the performance might not be acceptable.</span></span> <span data-ttu-id="f66b9-227">Ponadto w zależności od danego scenariusza dodatkowe koordynacji może być konieczne w celu uniknięcia wyścigu między metody ustawiające i metody pobierające.</span><span class="sxs-lookup"><span data-stu-id="f66b9-227">Furthermore, depending on the specific scenario, additional coordination might be required to avoid race conditions between setters and getters.</span></span>  
  
## <a name="thread-local-lazy-initialization"></a><span data-ttu-id="f66b9-228">Inicjalizacja z opóźnieniem Thread-Local</span><span class="sxs-lookup"><span data-stu-id="f66b9-228">Thread-Local Lazy Initialization</span></span>  
 <span data-ttu-id="f66b9-229">W niektórych scenariuszach wielowątkowe możesz nadać każdy wątek prywatnych danych.</span><span class="sxs-lookup"><span data-stu-id="f66b9-229">In some multithreaded scenarios, you might want to give each thread its own private data.</span></span> <span data-ttu-id="f66b9-230">Tych danych jest nazywany *danych lokalnych wątku*.</span><span class="sxs-lookup"><span data-stu-id="f66b9-230">Such data is called *thread-local data*.</span></span> <span data-ttu-id="f66b9-231">W programie .NET Framework w wersji 3.5 lub starszy, można zastosować `ThreadStatic` atrybutu zmienną statyczną aby była lokalnej wątku.</span><span class="sxs-lookup"><span data-stu-id="f66b9-231">In the .NET Framework version 3.5 and earlier, you could apply the `ThreadStatic` attribute to a static variable to make it thread-local.</span></span> <span data-ttu-id="f66b9-232">Jednak przy użyciu `ThreadStatic` atrybut może prowadzić do błędów niewielkie.</span><span class="sxs-lookup"><span data-stu-id="f66b9-232">However, using the `ThreadStatic` attribute can lead to subtle errors.</span></span> <span data-ttu-id="f66b9-233">Na przykład inicjowania nawet podstawowe instrukcje spowoduje, że zmienna można było zainicjować tylko na pierwszym wątku, który uzyskuje dostęp do, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="f66b9-233">For example, even basic initialization statements will cause the variable to be initialized only on the first thread that accesses it, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#6](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#6)]
 [!code-vb[Lazy#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#6)]  
  
 <span data-ttu-id="f66b9-234">Na inne wątki zmiennej zostaną zainicjowane przy użyciu jego wartość domyślna (zero).</span><span class="sxs-lookup"><span data-stu-id="f66b9-234">On all other threads, the variable will be initialized by using its default value (zero).</span></span> <span data-ttu-id="f66b9-235">Alternatywnie w programie .NET Framework w wersji 4, można użyć <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> typ, aby utworzyć zmienną na podstawie wystąpienia, lokalnej wątku, który jest inicjowana na wszystkie wątki przez <xref:System.Action%601> delegata, który podasz.</span><span class="sxs-lookup"><span data-stu-id="f66b9-235">As an alternative in the .NET Framework version 4, you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> type to create an instance-based, thread-local variable that is initialized on all threads by the <xref:System.Action%601> delegate that you provide.</span></span> <span data-ttu-id="f66b9-236">W poniższym przykładzie wszystkie wątki, który dostępu `counter` spowoduje wyświetlenie jej początkowej wartości 1.</span><span class="sxs-lookup"><span data-stu-id="f66b9-236">In the following example, all threads that access `counter` will see its starting value as 1.</span></span>  
  
 [!code-csharp[Lazy#7](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#7)]
 [!code-vb[Lazy#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#7)]  
  
 <span data-ttu-id="f66b9-237"><xref:System.Threading.ThreadLocal%601> otacza znacznie taki sam sposób jak jego obiekt <xref:System.Lazy%601>, z tych podstawowych różnic:</span><span class="sxs-lookup"><span data-stu-id="f66b9-237"><xref:System.Threading.ThreadLocal%601> wraps its object in much the same way as <xref:System.Lazy%601>, with these essential differences:</span></span>  
  
-   <span data-ttu-id="f66b9-238">Każdy wątek inicjuje zmiennej lokalnej wątku przy użyciu własnego dane prywatne, który nie jest dostępny z innych wątków.</span><span class="sxs-lookup"><span data-stu-id="f66b9-238">Each thread initializes the thread-local variable by using its own private data that is not accessible from other threads.</span></span>  
  
-   <span data-ttu-id="f66b9-239"><xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> Jest do odczytu / zapisu i może być modyfikowany dowolną liczbę razy.</span><span class="sxs-lookup"><span data-stu-id="f66b9-239">The <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> property is read-write, and can be modified any number of times.</span></span> <span data-ttu-id="f66b9-240">Może to mieć wpływ na propagacji wyjątków, na przykład jeden `get` operacji może zgłosić wyjątek, ale kolejnego może zostać pomyślnie zainicjowany wartość.</span><span class="sxs-lookup"><span data-stu-id="f66b9-240">This can affect exception propagation, for example, one `get` operation can raise an exception but the next one can successfully initialize the value.</span></span>  
  
-   <span data-ttu-id="f66b9-241">Jeśli delegat inicjowania, nie zostanie podany, <xref:System.Threading.ThreadLocal%601> zainicjuje opakowanej typu przy użyciu wartości domyślnej tego typu.</span><span class="sxs-lookup"><span data-stu-id="f66b9-241">If no initialization delegate is provided, <xref:System.Threading.ThreadLocal%601> will initialize its wrapped type by using the default value of the type.</span></span> <span data-ttu-id="f66b9-242">W tym zakresie <xref:System.Threading.ThreadLocal%601> jest zgodna z <xref:System.ThreadStaticAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="f66b9-242">In this regard, <xref:System.Threading.ThreadLocal%601> is consistent with the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
 <span data-ttu-id="f66b9-243">W poniższym przykładzie pokazano, że każdy wątek który uzyskuje dostęp do `ThreadLocal<int>` wystąpienia pobiera własną unikatową kopię danych.</span><span class="sxs-lookup"><span data-stu-id="f66b9-243">The following example demonstrates that every thread that accesses the `ThreadLocal<int>` instance gets its own unique copy of the data.</span></span>  
  
 [!code-csharp[Lazy#9](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#9)]
 [!code-vb[Lazy#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#9)]  
  
## <a name="thread-local-variables-in-parallelfor-and-foreach"></a><span data-ttu-id="f66b9-244">Zmienne lokalne wątków w równoległej i ForEach</span><span class="sxs-lookup"><span data-stu-id="f66b9-244">Thread-Local Variables in Parallel.For and ForEach</span></span>  
 <span data-ttu-id="f66b9-245">Jeśli używasz <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> metody lub <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metody iteracyjne źródeł danych równolegle, korzystając z przeciążeń, które mają wbudowaną obsługę danych lokalnych wątku.</span><span class="sxs-lookup"><span data-stu-id="f66b9-245">When you use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method or <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to iterate over data sources in parallel, you can use the overloads that have built-in support for thread-local data.</span></span> <span data-ttu-id="f66b9-246">W tych metod umiejscowienie wątku jest realizowane za pośrednictwem lokalnego delegatów do tworzenia, dostępu i wyczyścić dane.</span><span class="sxs-lookup"><span data-stu-id="f66b9-246">In these methods, the thread-locality is achieved by using local delegates to create, access, and clean up the data.</span></span> <span data-ttu-id="f66b9-247">Aby uzyskać więcej informacji, zobacz [porady: zapisywanie równoległej pętli for ze zmiennymi lokalnymi wątku](../../../docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) i [porady: zapisywanie równoległej pętli Foreach ze zmiennymi lokalnymi wątku](../../../docs/standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-thread-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="f66b9-247">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](../../../docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Thread-Local Variables](../../../docs/standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-thread-local-variables.md).</span></span>  
  
## <a name="using-lazy-initialization-for-low-overhead-scenarios"></a><span data-ttu-id="f66b9-248">W scenariuszach niskiego obciążenia przy użyciu inicjowania z opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="f66b9-248">Using Lazy Initialization for Low-Overhead Scenarios</span></span>  
 <span data-ttu-id="f66b9-249">W scenariuszach, w których konieczne opóźnieniem zainicjować dużą liczbę obiektów, możesz określić zawijania każdego obiektu w <xref:System.Lazy%601> wymaga zbyt dużej ilości pamięci lub zbyt wiele zasobów obliczeniowych.</span><span class="sxs-lookup"><span data-stu-id="f66b9-249">In scenarios where you have to lazy-initialize a large number of objects, you might decide that wrapping each object in a <xref:System.Lazy%601> requires too much memory or too many computing resources.</span></span> <span data-ttu-id="f66b9-250">Lub może być rygorystycznych wymagań o jak incjalizacji jest widoczna.</span><span class="sxs-lookup"><span data-stu-id="f66b9-250">Or, you might have stringent requirements about how lazy initialization is exposed.</span></span> <span data-ttu-id="f66b9-251">W takich przypadkach można użyć `static` (`Shared` w języku Visual Basic) metody <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> opóźnieniem inicjalizacji każdego obiektu bez zawijania go w wystąpieniu klasy <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="f66b9-251">In such cases, you can use the `static` (`Shared` in Visual Basic) methods of the <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> class to lazy-initialize each object without wrapping it in an instance of <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="f66b9-252">W poniższym przykładzie przyjęto założenie, że, zamiast zawijania cały `Orders` obiektu w jednym <xref:System.Lazy%601> obiektu, mieć indywidualne opóźnieniem zainicjować `Order` obiektów tylko, jeśli są one wymagane.</span><span class="sxs-lookup"><span data-stu-id="f66b9-252">In the following example, assume that, instead of wrapping an entire `Orders` object in one <xref:System.Lazy%601> object, you have lazy-initialized individual `Order` objects only if they are required.</span></span>  
  
 [!code-csharp[Lazy#10](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#10)]
 [!code-vb[Lazy#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#10)]  
  
 <span data-ttu-id="f66b9-253">W tym przykładzie należy zauważyć, że procedura inicjowania została wywołana w każdej iteracji pętli.</span><span class="sxs-lookup"><span data-stu-id="f66b9-253">In this example, notice that the initialization procedure is invoked on every iteration of the loop.</span></span> <span data-ttu-id="f66b9-254">W scenariuszach wielowątkowych pierwszym wątkiem do wywołania procedury inicjowania jest to, którego wartość jest odebrane przez wszystkie wątki.</span><span class="sxs-lookup"><span data-stu-id="f66b9-254">In multi-threaded scenarios, the first thread to invoke the initialization procedure is the one whose value is seen by all threads.</span></span> <span data-ttu-id="f66b9-255">Nowsze wątków także wywoływać procedury inicjowania, ale jego wyniki nie są używane.</span><span class="sxs-lookup"><span data-stu-id="f66b9-255">Later threads also invoke the initialization procedure, but their results are not used.</span></span> <span data-ttu-id="f66b9-256">Jeśli tego rodzaju potencjalnych sytuacji wyścigu nie jest dopuszczalne, użyj przeciążenia <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> pobierająca logiczną argumentu i obiekt synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="f66b9-256">If this kind of potential race condition is not acceptable, use the overload of <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> that takes a Boolean argument and a synchronization object.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f66b9-257">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="f66b9-257">See Also</span></span>  
 [<span data-ttu-id="f66b9-258">Zarządzana wątkowość — podstawy</span><span class="sxs-lookup"><span data-stu-id="f66b9-258">Managed Threading Basics</span></span>](../../../docs/standard/threading/managed-threading-basics.md)  
 [<span data-ttu-id="f66b9-259">Wątki i wątkowość</span><span class="sxs-lookup"><span data-stu-id="f66b9-259">Threads and Threading</span></span>](../../../docs/standard/threading/threads-and-threading.md)  
 [<span data-ttu-id="f66b9-260">Biblioteka zadań równoległych (TPL)</span><span class="sxs-lookup"><span data-stu-id="f66b9-260">Task Parallel Library (TPL)</span></span>](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)  
 [<span data-ttu-id="f66b9-261">Instrukcje: wykonywanie inicjowania obiektów z opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="f66b9-261">How to: Perform Lazy Initialization of Objects</span></span>](../../../docs/framework/performance/how-to-perform-lazy-initialization-of-objects.md)
