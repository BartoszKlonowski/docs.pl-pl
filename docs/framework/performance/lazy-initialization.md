---
title: Inicjalizacja z opóźnieniem
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lazy initialization in .NET, introduction
ms.assetid: 56b4ae5c-4745-44ff-ad78-ffe4fcde6b9b
ms.openlocfilehash: 4f2b585dded6e20bb604f623217c6d1f1505c097
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/12/2020
ms.locfileid: "79180566"
---
# <a name="lazy-initialization"></a><span data-ttu-id="3be2c-102">Inicjalizacja z opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="3be2c-102">Lazy Initialization</span></span>
<span data-ttu-id="3be2c-103">*Z opóźnieniem inicjowania* obiektu oznacza, że jego tworzenie jest odroczone, dopóki nie zostanie po raz pierwszy użyty.</span><span class="sxs-lookup"><span data-stu-id="3be2c-103">*Lazy initialization* of an object means that its creation is deferred until it is first used.</span></span> <span data-ttu-id="3be2c-104">(W tym temacie *terminy inicjalizacji z opóźnieniem* i wystąpienia *z* opóźnieniem są synonimami). Inicjalizacja z opóźnieniem jest używana przede wszystkim w celu zwiększenia wydajności, uniknięcia marnotrawstwa obliczeń i zmniejszenia wymagań dotyczących pamięci programu.</span><span class="sxs-lookup"><span data-stu-id="3be2c-104">(For this topic, the terms *lazy initialization* and *lazy instantiation* are synonymous.) Lazy initialization is primarily used to improve performance, avoid wasteful computation, and reduce program memory requirements.</span></span> <span data-ttu-id="3be2c-105">Są to najbardziej typowe scenariusze:</span><span class="sxs-lookup"><span data-stu-id="3be2c-105">These are the most common scenarios:</span></span>  
  
- <span data-ttu-id="3be2c-106">Jeśli masz obiekt, który jest kosztowne do utworzenia, a program może nie używać go.</span><span class="sxs-lookup"><span data-stu-id="3be2c-106">When you have an object that is expensive to create, and the program might not use it.</span></span> <span data-ttu-id="3be2c-107">Załóżmy na przykład, że `Customer` masz w `Orders` pamięci obiekt, który `Order` ma właściwość, która zawiera dużą tablicę obiektów, które mają być zainicjowane, wymaga połączenia z bazą danych.</span><span class="sxs-lookup"><span data-stu-id="3be2c-107">For example, assume that you have in memory a `Customer` object that has an `Orders` property that contains a large array of `Order` objects that, to be initialized, requires a database connection.</span></span> <span data-ttu-id="3be2c-108">Jeśli użytkownik nigdy nie prosi o wyświetlenie zamówień lub użycie danych w obliczeniach, nie ma powodu, aby używać pamięci systemowej lub cykli obliczeniowych do jego utworzenia.</span><span class="sxs-lookup"><span data-stu-id="3be2c-108">If the user never asks to display the Orders or use the data in a computation, then there is no reason to use system memory or computing cycles to create it.</span></span> <span data-ttu-id="3be2c-109">Za `Lazy<Orders>` pomocą do `Orders` deklarowania obiektu dla z opóźnieniem inicjowania, można uniknąć marnowania zasobów systemowych, gdy obiekt nie jest używany.</span><span class="sxs-lookup"><span data-stu-id="3be2c-109">By using `Lazy<Orders>` to declare the `Orders` object for lazy initialization, you can avoid wasting system resources when the object is not used.</span></span>  
  
- <span data-ttu-id="3be2c-110">Jeśli masz obiekt, który jest kosztowne do utworzenia i chcesz odroczyć jego tworzenie, aż po zakończeniu innych kosztownych operacji.</span><span class="sxs-lookup"><span data-stu-id="3be2c-110">When you have an object that is expensive to create, and you want to defer its creation until after other expensive operations have been completed.</span></span> <span data-ttu-id="3be2c-111">Załóżmy na przykład, że program ładuje kilka wystąpień obiektów po uruchomieniu, ale tylko niektóre z nich są wymagane natychmiast.</span><span class="sxs-lookup"><span data-stu-id="3be2c-111">For example, assume that your program loads several object instances when it starts, but only some of them are required immediately.</span></span> <span data-ttu-id="3be2c-112">Wydajność uruchamiania programu można poprawić, odraczając inicjowanie obiektów, które nie są wymagane, dopóki nie zostaną utworzone wymagane obiekty.</span><span class="sxs-lookup"><span data-stu-id="3be2c-112">You can improve the startup performance of the program by deferring initialization of the objects that are not required until the required objects have been created.</span></span>  
  
 <span data-ttu-id="3be2c-113">Chociaż można napisać własny kod do wykonywania inicjowania <xref:System.Lazy%601> z opóźnieniem, zaleca się zamiast tego użyć.</span><span class="sxs-lookup"><span data-stu-id="3be2c-113">Although you can write your own code to perform lazy initialization, we recommend that you use <xref:System.Lazy%601> instead.</span></span> <span data-ttu-id="3be2c-114"><xref:System.Lazy%601>i jego powiązane typy również obsługiwać bezpieczeństwo wątków i zapewnić spójne zasady propagacji wyjątków.</span><span class="sxs-lookup"><span data-stu-id="3be2c-114"><xref:System.Lazy%601> and its related types also support thread-safety and provide a consistent exception propagation policy.</span></span>  
  
 <span data-ttu-id="3be2c-115">W poniższej tabeli wymieniono typy, które zapewnia program .NET Framework w wersji 4, aby włączyć inicjowanie z opóźnieniem w różnych scenariuszach.</span><span class="sxs-lookup"><span data-stu-id="3be2c-115">The following table lists the types that the .NET Framework version 4 provides to enable lazy initialization in different scenarios.</span></span>  
  
|<span data-ttu-id="3be2c-116">Typ</span><span class="sxs-lookup"><span data-stu-id="3be2c-116">Type</span></span>|<span data-ttu-id="3be2c-117">Opis</span><span class="sxs-lookup"><span data-stu-id="3be2c-117">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601>|<span data-ttu-id="3be2c-118">Klasa otoki, która zapewnia semantyka inicjowania z opóźnieniem dla dowolnej biblioteki klas lub typu zdefiniowanego przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="3be2c-118">A wrapper class that provides lazy initialization semantics for any class library or user-defined type.</span></span>|  
|<xref:System.Threading.ThreadLocal%601>|<span data-ttu-id="3be2c-119">Przypomina <xref:System.Lazy%601> z tą różnicą, że zapewnia semantyka inicjowania z opóźnieniem na podstawie lokalnego wątku.</span><span class="sxs-lookup"><span data-stu-id="3be2c-119">Resembles <xref:System.Lazy%601> except that it provides lazy initialization semantics on a thread-local basis.</span></span> <span data-ttu-id="3be2c-120">Każdy wątek ma dostęp do własnej unikatowej wartości.</span><span class="sxs-lookup"><span data-stu-id="3be2c-120">Every thread has access to its own unique value.</span></span>|  
|<xref:System.Threading.LazyInitializer>|<span data-ttu-id="3be2c-121">Zapewnia `static` zaawansowane`Shared` (w języku Visual Basic) metody z opóźnieniem inicjowania obiektów bez narzutu klasy.</span><span class="sxs-lookup"><span data-stu-id="3be2c-121">Provides advanced `static` (`Shared` in Visual Basic) methods for lazy initialization of objects without the overhead of a class.</span></span>|  
  
## <a name="basic-lazy-initialization"></a><span data-ttu-id="3be2c-122">Podstawowe inicjowanie z opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="3be2c-122">Basic Lazy Initialization</span></span>  
 <span data-ttu-id="3be2c-123">Aby zdefiniować typ z opóźnieniem, `MyType`na `Lazy<MyType>` przykład`Lazy(Of MyType)` , użyj (w języku Visual Basic), jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="3be2c-123">To define a lazy-initialized type, for example, `MyType`, use `Lazy<MyType>` (`Lazy(Of MyType)` in Visual Basic), as shown in the following example.</span></span> <span data-ttu-id="3be2c-124">Jeśli żaden delegat nie <xref:System.Lazy%601> jest przekazywany w konstruktorze, opakowany typ jest tworzony przy użyciu, <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> gdy właściwość value jest po raz pierwszy dostępny.</span><span class="sxs-lookup"><span data-stu-id="3be2c-124">If no delegate is passed in the <xref:System.Lazy%601> constructor, the wrapped type is created by using <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> when the value property is first accessed.</span></span> <span data-ttu-id="3be2c-125">Jeśli typ nie ma konstruktora bez parametrów, wyjątek w czasie wykonywania jest zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="3be2c-125">If the type does not have a parameterless constructor, a run-time exception is thrown.</span></span>  
  
 <span data-ttu-id="3be2c-126">W poniższym przykładzie `Orders` załóżmy, że `Order` jest to klasa, która zawiera tablicę obiektów pobranych z bazy danych.</span><span class="sxs-lookup"><span data-stu-id="3be2c-126">In the following example, assume that `Orders` is a class that contains an array of `Order` objects retrieved from a database.</span></span> <span data-ttu-id="3be2c-127">Obiekt `Customer` zawiera wystąpienie `Orders`, ale w zależności od `Orders` akcji użytkownika, dane z obiektu mogą nie być wymagane.</span><span class="sxs-lookup"><span data-stu-id="3be2c-127">A `Customer` object contains an instance of `Orders`, but depending on user actions, the data from the `Orders` object might not be required.</span></span>  
  
 [!code-csharp[Lazy#1](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#1)]
 [!code-vb[Lazy#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#1)]  
  
 <span data-ttu-id="3be2c-128">Można również przekazać delegata <xref:System.Lazy%601> w konstruktorze, który wywołuje przeciążenie konstruktora na opakowane typu w czasie tworzenia i wykonać inne kroki inicjowania, które są wymagane, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="3be2c-128">You can also pass a delegate in the <xref:System.Lazy%601> constructor that invokes a specific constructor overload on the wrapped type at creation time, and perform any other initialization steps that are required, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#2](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#2)]
 [!code-vb[Lazy#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#2)]  
  
 <span data-ttu-id="3be2c-129">Po utworzeniu obiektu z opóźnieniem `Orders` nie jest <xref:System.Lazy%601.Value%2A> tworzone żadne wystąpienie, dopóki właściwość zmiennej z opóźnieniem nie zostanie po raz pierwszy dostępna.</span><span class="sxs-lookup"><span data-stu-id="3be2c-129">After the Lazy object is created, no instance of `Orders` is created until the <xref:System.Lazy%601.Value%2A> property of the Lazy variable is accessed for the first time.</span></span> <span data-ttu-id="3be2c-130">Przy pierwszym dostępie opakowany typ jest tworzony i zwracany i przechowywany dla każdego przyszłego dostępu.</span><span class="sxs-lookup"><span data-stu-id="3be2c-130">On first access, the wrapped type is created and returned, and stored for any future access.</span></span>  
  
 [!code-csharp[Lazy#3](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#3)]
 [!code-vb[Lazy#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#3)]  
  
 <span data-ttu-id="3be2c-131">Obiekt <xref:System.Lazy%601> zawsze zwraca ten sam obiekt lub wartość, z którą został zainicjowany.</span><span class="sxs-lookup"><span data-stu-id="3be2c-131">A <xref:System.Lazy%601> object always returns the same object or value that it was initialized with.</span></span> <span data-ttu-id="3be2c-132">W związku <xref:System.Lazy%601.Value%2A> z tym właściwość jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3be2c-132">Therefore, the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="3be2c-133">Jeśli <xref:System.Lazy%601.Value%2A> przechowuje typ odwołania, nie można przypisać do niego nowego obiektu.</span><span class="sxs-lookup"><span data-stu-id="3be2c-133">If <xref:System.Lazy%601.Value%2A> stores a reference type, you cannot assign a new object to it.</span></span> <span data-ttu-id="3be2c-134">(Można jednak zmienić wartość jego ustawionych pól publicznych i właściwości). Jeśli <xref:System.Lazy%601.Value%2A> przechowuje typ wartości, nie można zmodyfikować jego wartości.</span><span class="sxs-lookup"><span data-stu-id="3be2c-134">(However, you can change the value of its settable public fields and properties.) If <xref:System.Lazy%601.Value%2A> stores a value type, you cannot modify its value.</span></span> <span data-ttu-id="3be2c-135">Niemniej jednak można utworzyć nową zmienną, wywołując konstruktor zmiennych ponownie przy użyciu nowych argumentów.</span><span class="sxs-lookup"><span data-stu-id="3be2c-135">Nevertheless, you can create a new variable by invoking the variable constructor again by using new arguments.</span></span>  
  
 [!code-csharp[Lazy#4](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#4)]
 [!code-vb[Lazy#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#4)]  
  
 <span data-ttu-id="3be2c-136">Nowe wystąpienie z opóźnieniem, podobnie jak wcześniejsze, nie zawiera wystąpienia, `Orders` dopóki jego <xref:System.Lazy%601.Value%2A> właściwość nie zostanie po raz pierwszy uzyskiczona.</span><span class="sxs-lookup"><span data-stu-id="3be2c-136">The new lazy instance, like the earlier one, does not instantiate `Orders` until its <xref:System.Lazy%601.Value%2A> property is first accessed.</span></span>  
  
### <a name="thread-safe-initialization"></a><span data-ttu-id="3be2c-137">Inicjowanie bezpieczne dla wątków</span><span class="sxs-lookup"><span data-stu-id="3be2c-137">Thread-Safe Initialization</span></span>  
 <span data-ttu-id="3be2c-138">Domyślnie <xref:System.Lazy%601> obiekty są bezpieczne dla wątków.</span><span class="sxs-lookup"><span data-stu-id="3be2c-138">By default, <xref:System.Lazy%601> objects are thread-safe.</span></span> <span data-ttu-id="3be2c-139">Oznacza to, że jeśli konstruktor nie określa <xref:System.Lazy%601> rodzaju bezpieczeństwa wątku, obiekty, które tworzy są bezpieczne dla wątków.</span><span class="sxs-lookup"><span data-stu-id="3be2c-139">That is, if the constructor does not specify the kind of thread safety, the <xref:System.Lazy%601> objects it creates are thread-safe.</span></span> <span data-ttu-id="3be2c-140">W scenariuszach wielowątkowych pierwszy wątek dostępu <xref:System.Lazy%601.Value%2A> do <xref:System.Lazy%601> właściwości obiektu bezpiecznego wątku inicjuje go dla wszystkich kolejnych dostępów we wszystkich wątkach, a wszystkie wątki współużytkują te same dane.</span><span class="sxs-lookup"><span data-stu-id="3be2c-140">In multi-threaded scenarios, the first thread to access the <xref:System.Lazy%601.Value%2A> property of a thread-safe <xref:System.Lazy%601> object initializes it for all subsequent accesses on all threads, and all threads share the same data.</span></span> <span data-ttu-id="3be2c-141">W związku z tym nie ma znaczenia, który wątek inicjuje obiekt, a warunki wyścigu są łagodne.</span><span class="sxs-lookup"><span data-stu-id="3be2c-141">Therefore, it does not matter which thread initializes the object, and race conditions are benign.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="3be2c-142">Tę spójność można rozszerzyć na warunki błędu przy użyciu buforowania wyjątków.</span><span class="sxs-lookup"><span data-stu-id="3be2c-142">You can extend this consistency to error conditions by using exception caching.</span></span> <span data-ttu-id="3be2c-143">Aby uzyskać więcej informacji, zobacz następną sekcję [Wyjątki w obiektach z opóźnieniem](lazy-initialization.md#ExceptionsInLazyObjects).</span><span class="sxs-lookup"><span data-stu-id="3be2c-143">For more information, see the next section, [Exceptions in Lazy Objects](lazy-initialization.md#ExceptionsInLazyObjects).</span></span>  
  
 <span data-ttu-id="3be2c-144">Poniższy przykład pokazuje, `Lazy<int>` że to samo wystąpienie ma taką samą wartość dla trzech oddzielnych wątków.</span><span class="sxs-lookup"><span data-stu-id="3be2c-144">The following example shows that the same `Lazy<int>` instance has the same value for three separate threads.</span></span>  
  
 [!code-csharp[Lazy#8](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#8)]
 [!code-vb[Lazy#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#8)]  
  
 <span data-ttu-id="3be2c-145">Jeśli potrzebujesz oddzielnych danych w <xref:System.Threading.ThreadLocal%601> każdym wątku, należy użyć typu, zgodnie z opisem w dalszej części tego tematu.</span><span class="sxs-lookup"><span data-stu-id="3be2c-145">If you require separate data on each thread, use the <xref:System.Threading.ThreadLocal%601> type, as described later in this topic.</span></span>  
  
 <span data-ttu-id="3be2c-146">Niektóre <xref:System.Lazy%601> konstruktory mają `isThreadSafe` parametr logiczny o <xref:System.Lazy%601.Value%2A> nazwie, który jest używany do określenia, czy właściwość będzie dostępna z wielu wątków.</span><span class="sxs-lookup"><span data-stu-id="3be2c-146">Some <xref:System.Lazy%601> constructors have a Boolean parameter named `isThreadSafe` that is used to specify whether the <xref:System.Lazy%601.Value%2A> property will be accessed from multiple threads.</span></span> <span data-ttu-id="3be2c-147">Jeśli zamierzasz uzyskać dostęp do właściwości z `false` jednego wątku, przekaż, aby uzyskać skromną korzyść wydajności.</span><span class="sxs-lookup"><span data-stu-id="3be2c-147">If you intend to access the property from just one thread, pass in `false` to obtain a modest performance benefit.</span></span> <span data-ttu-id="3be2c-148">Jeśli zamierzasz uzyskać dostęp do właściwości z `true` wielu <xref:System.Lazy%601> wątków, przekazać, aby poinstruować wystąpienie, aby poprawnie obsługiwać warunki wyścigu, w którym jeden wątek zgłasza wyjątek w czasie inicjowania.</span><span class="sxs-lookup"><span data-stu-id="3be2c-148">If you intend to access the property from multiple threads, pass in `true` to instruct the <xref:System.Lazy%601> instance to correctly handle race conditions in which one thread throws an exception at initialization time.</span></span>  
  
 <span data-ttu-id="3be2c-149">Niektóre <xref:System.Lazy%601> konstruktory mają <xref:System.Threading.LazyThreadSafetyMode> parametr o nazwie `mode`.</span><span class="sxs-lookup"><span data-stu-id="3be2c-149">Some <xref:System.Lazy%601> constructors have a <xref:System.Threading.LazyThreadSafetyMode> parameter named `mode`.</span></span> <span data-ttu-id="3be2c-150">Konstruktory te zapewniają dodatkowy tryb bezpieczeństwa gwintu.</span><span class="sxs-lookup"><span data-stu-id="3be2c-150">These constructors provide an additional thread safety mode.</span></span> <span data-ttu-id="3be2c-151">W poniższej tabeli przedstawiono, jak na bezpieczeństwo wątku <xref:System.Lazy%601> obiektu wpływają parametry konstruktora określające bezpieczeństwo wątku.</span><span class="sxs-lookup"><span data-stu-id="3be2c-151">The following table shows how the thread safety of a <xref:System.Lazy%601> object is affected by constructor parameters that specify thread safety.</span></span> <span data-ttu-id="3be2c-152">Każdy konstruktor ma co najwyżej jeden taki parametr.</span><span class="sxs-lookup"><span data-stu-id="3be2c-152">Each constructor has at most one such parameter.</span></span>  
  
|<span data-ttu-id="3be2c-153">Bezpieczeństwo gwintu obiektu</span><span class="sxs-lookup"><span data-stu-id="3be2c-153">Thread safety of the object</span></span>|<span data-ttu-id="3be2c-154">`LazyThreadSafetyMode``mode` parametr</span><span class="sxs-lookup"><span data-stu-id="3be2c-154">`LazyThreadSafetyMode` `mode` parameter</span></span>|<span data-ttu-id="3be2c-155">Parametr `isThreadSafe` logiczny</span><span class="sxs-lookup"><span data-stu-id="3be2c-155">Boolean `isThreadSafe` parameter</span></span>|<span data-ttu-id="3be2c-156">Brak parametrów bezpieczeństwa gwintu</span><span class="sxs-lookup"><span data-stu-id="3be2c-156">No thread safety parameters</span></span>|  
|---------------------------------|---------------------------------------------|--------------------------------------|---------------------------------|  
|<span data-ttu-id="3be2c-157">W pełni bezpieczne dla gwintów; tylko jeden wątek naraz próbuje zainicjować wartość.</span><span class="sxs-lookup"><span data-stu-id="3be2c-157">Fully thread-safe; only one thread at a time tries to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|<span data-ttu-id="3be2c-158">Tak.</span><span class="sxs-lookup"><span data-stu-id="3be2c-158">Yes.</span></span>|  
|<span data-ttu-id="3be2c-159">Nie jest bezpieczny dla wątków.</span><span class="sxs-lookup"><span data-stu-id="3be2c-159">Not thread-safe.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|<span data-ttu-id="3be2c-160">Nie dotyczy.</span><span class="sxs-lookup"><span data-stu-id="3be2c-160">Not applicable.</span></span>|  
|<span data-ttu-id="3be2c-161">W pełni bezpieczne dla gwintów; wątki ścigają się, aby zainicjować wartość.</span><span class="sxs-lookup"><span data-stu-id="3be2c-161">Fully thread-safe; threads race to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|<span data-ttu-id="3be2c-162">Nie dotyczy.</span><span class="sxs-lookup"><span data-stu-id="3be2c-162">Not applicable.</span></span>|<span data-ttu-id="3be2c-163">Nie dotyczy.</span><span class="sxs-lookup"><span data-stu-id="3be2c-163">Not applicable.</span></span>|  
  
 <span data-ttu-id="3be2c-164">Jak pokazuje tabela, <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> określenie `mode` parametru jest takie `true` samo `isThreadSafe` jak określenie <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> parametru, a `false`określenie jest takie samo jak określenie .</span><span class="sxs-lookup"><span data-stu-id="3be2c-164">As the table shows, specifying <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> for the `mode` parameter is the same as specifying `true` for the `isThreadSafe` parameter, and specifying <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> is the same as specifying `false`.</span></span>  
  
 <span data-ttu-id="3be2c-165">Określenie <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> umożliwia wiele wątków, aby <xref:System.Lazy%601> spróbować zainicjować wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="3be2c-165">Specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> allows multiple threads to attempt to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="3be2c-166">Tylko jeden wątek może wygrać ten wyścig, a wszystkie inne wątki otrzymują wartość, która została zainicjowana przez udany wątek.</span><span class="sxs-lookup"><span data-stu-id="3be2c-166">Only one thread can win this race, and all the other threads receive the value that was initialized by the successful thread.</span></span> <span data-ttu-id="3be2c-167">Jeśli wyjątek jest zgłaszany na wątku podczas inicjowania, ten wątek nie otrzymuje wartość ustawioną przez pomyślny wątek.</span><span class="sxs-lookup"><span data-stu-id="3be2c-167">If an exception is thrown on a thread during initialization, that thread does not receive the value set by the successful thread.</span></span> <span data-ttu-id="3be2c-168">Wyjątki nie są buforowane, więc kolejna próba uzyskania dostępu do <xref:System.Lazy%601.Value%2A> właściwości może spowodować pomyślne zainicjowanie.</span><span class="sxs-lookup"><span data-stu-id="3be2c-168">Exceptions are not cached, so a subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property can result in successful initialization.</span></span> <span data-ttu-id="3be2c-169">Różni się to od sposobu traktowania wyjątków w innych trybach, co opisano w poniższej sekcji.</span><span class="sxs-lookup"><span data-stu-id="3be2c-169">This differs from the way exceptions are treated in other modes, which is described in the following section.</span></span> <span data-ttu-id="3be2c-170">Aby uzyskać więcej <xref:System.Threading.LazyThreadSafetyMode> informacji, zobacz wyliczenie.</span><span class="sxs-lookup"><span data-stu-id="3be2c-170">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
<a name="ExceptionsInLazyObjects"></a>
## <a name="exceptions-in-lazy-objects"></a><span data-ttu-id="3be2c-171">Wyjątki w obiektach z opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="3be2c-171">Exceptions in Lazy Objects</span></span>  
 <span data-ttu-id="3be2c-172">Jak wspomniano wcześniej, <xref:System.Lazy%601> obiekt zawsze zwraca ten sam obiekt lub wartość, <xref:System.Lazy%601.Value%2A> który został zainicjowany z, a zatem właściwość jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="3be2c-172">As stated earlier, a <xref:System.Lazy%601> object always returns the same object or value that it was initialized with, and therefore the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="3be2c-173">Jeśli włączysz buforowanie wyjątków, ta niezmienność rozciąga się również na zachowanie wyjątku.</span><span class="sxs-lookup"><span data-stu-id="3be2c-173">If you enable exception caching, this immutability also extends to exception behavior.</span></span> <span data-ttu-id="3be2c-174">Jeśli obiekt zainicjowany z opóźnieniem ma włączoną buforowanie wyjątków i zgłasza <xref:System.Lazy%601.Value%2A> wyjątek od metody inicjowania, gdy właściwość <xref:System.Lazy%601.Value%2A> jest po raz pierwszy dostępna, ten sam wyjątek jest zgłaszany przy każdej kolejnej próbie uzyskania dostępu do właściwości.</span><span class="sxs-lookup"><span data-stu-id="3be2c-174">If a lazy-initialized object has exception caching enabled and throws an exception from its initialization method when the <xref:System.Lazy%601.Value%2A> property is first accessed, that same exception is thrown on every subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property.</span></span> <span data-ttu-id="3be2c-175">Innymi słowy konstruktora typu zawinięte nigdy nie jest wywoływana ponownie, nawet w scenariuszach wielowątkowych.</span><span class="sxs-lookup"><span data-stu-id="3be2c-175">In other words, the constructor of the wrapped type is never re-invoked, even in multithreaded scenarios.</span></span> <span data-ttu-id="3be2c-176">W związku <xref:System.Lazy%601> z tym obiekt nie może zgłosić wyjątek na jeden dostęp i zwrócić wartość na kolejny dostęp.</span><span class="sxs-lookup"><span data-stu-id="3be2c-176">Therefore, the <xref:System.Lazy%601> object cannot throw an exception on one access and return a value on a subsequent access.</span></span>  
  
 <span data-ttu-id="3be2c-177">Buforowanie wyjątków jest włączone, <xref:System.Lazy%601?displayProperty=nameWithType> gdy używany jest dowolny konstruktor, który przyjmuje metodę inicjowania (parametr);`valueFactory` na przykład jest włączona podczas `Lazy(T)(Func(T))`korzystania z konstruktora.</span><span class="sxs-lookup"><span data-stu-id="3be2c-177">Exception caching is enabled when you use any <xref:System.Lazy%601?displayProperty=nameWithType> constructor that takes an initialization method (`valueFactory` parameter); for example, it is enabled when you use the `Lazy(T)(Func(T))`constructor.</span></span> <span data-ttu-id="3be2c-178">Jeśli konstruktor przyjmuje <xref:System.Threading.LazyThreadSafetyMode> również`mode` wartość <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> ( <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>parametr), należy określić lub .</span><span class="sxs-lookup"><span data-stu-id="3be2c-178">If the constructor also takes a <xref:System.Threading.LazyThreadSafetyMode> value (`mode` parameter), specify <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> or <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3be2c-179">Określenie metody inicjowania umożliwia buforowanie wyjątków dla tych dwóch trybów.</span><span class="sxs-lookup"><span data-stu-id="3be2c-179">Specifying an initialization method enables exception caching for these two modes.</span></span> <span data-ttu-id="3be2c-180">Metoda inicjowania może być bardzo prosta.</span><span class="sxs-lookup"><span data-stu-id="3be2c-180">The initialization method can be very simple.</span></span> <span data-ttu-id="3be2c-181">Na przykład może wywołać konstruktora `new Lazy<Contents>(() => new Contents(), mode)` bez parametrów `New Lazy(Of Contents)(Function() New Contents())` dla `T`: w języku C# lub w języku Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="3be2c-181">For example, it might call the parameterless constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic.</span></span> <span data-ttu-id="3be2c-182">Jeśli używasz <xref:System.Lazy%601?displayProperty=nameWithType> konstruktora, który nie określa metody inicjowania, wyjątki, które są generowane przez konstruktora bez parametrów dla `T` nie są buforowane.</span><span class="sxs-lookup"><span data-stu-id="3be2c-182">If you use a <xref:System.Lazy%601?displayProperty=nameWithType> constructor that does not specify an initialization method, exceptions that are thrown by the parameterless constructor for `T` are not cached.</span></span> <span data-ttu-id="3be2c-183">Aby uzyskać więcej <xref:System.Threading.LazyThreadSafetyMode> informacji, zobacz wyliczenie.</span><span class="sxs-lookup"><span data-stu-id="3be2c-183">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="3be2c-184">Jeśli tworzysz <xref:System.Lazy%601> obiekt `isThreadSafe` z parametrem `false` konstruktora ustawionym na , lub parametrem `mode` konstruktora ustawionym na <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, należy uzyskać dostęp do <xref:System.Lazy%601> obiektu z pojedynczego wątku lub zapewnić własną synchronizację.</span><span class="sxs-lookup"><span data-stu-id="3be2c-184">If you create a <xref:System.Lazy%601> object with the `isThreadSafe` constructor parameter set to `false` or the `mode` constructor parameter set to <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, you must access the <xref:System.Lazy%601> object from a single thread or provide your own synchronization.</span></span> <span data-ttu-id="3be2c-185">Dotyczy to wszystkich aspektów obiektu, w tym buforowania wyjątków.</span><span class="sxs-lookup"><span data-stu-id="3be2c-185">This applies to all aspects of the object, including exception caching.</span></span>  
  
 <span data-ttu-id="3be2c-186">Jak wspomniano w poprzedniej <xref:System.Lazy%601> sekcji, obiekty <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> utworzone przez określenie traktować wyjątki inaczej.</span><span class="sxs-lookup"><span data-stu-id="3be2c-186">As noted in the previous section, <xref:System.Lazy%601> objects created by specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> treat exceptions differently.</span></span> <span data-ttu-id="3be2c-187">Z <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, wiele wątków może <xref:System.Lazy%601> konkurować, aby zainicjować wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="3be2c-187">With <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, multiple threads can compete to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="3be2c-188">W takim przypadku wyjątki nie są buforowane <xref:System.Lazy%601.Value%2A> i próby dostępu do właściwości można kontynuować, dopóki inicjowanie zakończy się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="3be2c-188">In this case, exceptions are not cached, and attempts to access the <xref:System.Lazy%601.Value%2A> property can continue until initialization is successful.</span></span>  
  
 <span data-ttu-id="3be2c-189">W poniższej tabeli <xref:System.Lazy%601> podsumowano sposób, w jaki konstruktorzy kontrolują buforowanie wyjątków.</span><span class="sxs-lookup"><span data-stu-id="3be2c-189">The following table summarizes the way the <xref:System.Lazy%601> constructors control exception caching.</span></span>  
  
|<span data-ttu-id="3be2c-190">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="3be2c-190">Constructor</span></span>|<span data-ttu-id="3be2c-191">Tryb bezpieczeństwa gwintu</span><span class="sxs-lookup"><span data-stu-id="3be2c-191">Thread safety mode</span></span>|<span data-ttu-id="3be2c-192">Używa metody inicjowania</span><span class="sxs-lookup"><span data-stu-id="3be2c-192">Uses initialization method</span></span>|<span data-ttu-id="3be2c-193">Wyjątki są buforowane</span><span class="sxs-lookup"><span data-stu-id="3be2c-193">Exceptions are cached</span></span>|  
|-----------------|------------------------|--------------------------------|---------------------------|  
|<span data-ttu-id="3be2c-194">Z opóźnieniem()</span><span class="sxs-lookup"><span data-stu-id="3be2c-194">Lazy(T)()</span></span>|<span data-ttu-id="3be2c-195">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="3be2c-195">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="3be2c-196">Nie</span><span class="sxs-lookup"><span data-stu-id="3be2c-196">No</span></span>|<span data-ttu-id="3be2c-197">Nie</span><span class="sxs-lookup"><span data-stu-id="3be2c-197">No</span></span>|  
|<span data-ttu-id="3be2c-198">Leniwy(T)(Func(T))</span><span class="sxs-lookup"><span data-stu-id="3be2c-198">Lazy(T)(Func(T))</span></span>|<span data-ttu-id="3be2c-199">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="3be2c-199">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="3be2c-200">Tak</span><span class="sxs-lookup"><span data-stu-id="3be2c-200">Yes</span></span>|<span data-ttu-id="3be2c-201">Tak</span><span class="sxs-lookup"><span data-stu-id="3be2c-201">Yes</span></span>|  
|<span data-ttu-id="3be2c-202">Lazy(T)(logiczny)</span><span class="sxs-lookup"><span data-stu-id="3be2c-202">Lazy(T)(Boolean)</span></span>|<span data-ttu-id="3be2c-203">`True`(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) `false` <xref:System.Threading.LazyThreadSafetyMode.None>lub ( )</span><span class="sxs-lookup"><span data-stu-id="3be2c-203">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="3be2c-204">Nie</span><span class="sxs-lookup"><span data-stu-id="3be2c-204">No</span></span>|<span data-ttu-id="3be2c-205">Nie</span><span class="sxs-lookup"><span data-stu-id="3be2c-205">No</span></span>|  
|<span data-ttu-id="3be2c-206">Lazy(T)(Func(T), logiczny)</span><span class="sxs-lookup"><span data-stu-id="3be2c-206">Lazy(T)(Func(T), Boolean)</span></span>|<span data-ttu-id="3be2c-207">`True`(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) `false` <xref:System.Threading.LazyThreadSafetyMode.None>lub ( )</span><span class="sxs-lookup"><span data-stu-id="3be2c-207">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="3be2c-208">Tak</span><span class="sxs-lookup"><span data-stu-id="3be2c-208">Yes</span></span>|<span data-ttu-id="3be2c-209">Tak</span><span class="sxs-lookup"><span data-stu-id="3be2c-209">Yes</span></span>|  
|<span data-ttu-id="3be2c-210">Lazy(T)(LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="3be2c-210">Lazy(T)(LazyThreadSafetyMode)</span></span>|<span data-ttu-id="3be2c-211">Określone przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="3be2c-211">User-specified</span></span>|<span data-ttu-id="3be2c-212">Nie</span><span class="sxs-lookup"><span data-stu-id="3be2c-212">No</span></span>|<span data-ttu-id="3be2c-213">Nie</span><span class="sxs-lookup"><span data-stu-id="3be2c-213">No</span></span>|  
|<span data-ttu-id="3be2c-214">Lazy(T)(Func(T), LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="3be2c-214">Lazy(T)(Func(T), LazyThreadSafetyMode)</span></span>|<span data-ttu-id="3be2c-215">Określone przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="3be2c-215">User-specified</span></span>|<span data-ttu-id="3be2c-216">Tak</span><span class="sxs-lookup"><span data-stu-id="3be2c-216">Yes</span></span>|<span data-ttu-id="3be2c-217">Nie, jeśli <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>użytkownik określa ; w przeciwnym razie tak.</span><span class="sxs-lookup"><span data-stu-id="3be2c-217">No if user specifies <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; otherwise, yes.</span></span>|  
  
## <a name="implementing-a-lazy-initialized-property"></a><span data-ttu-id="3be2c-218">Implementowanie właściwości z opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="3be2c-218">Implementing a Lazy-Initialized Property</span></span>  
 <span data-ttu-id="3be2c-219">Aby zaimplementować właściwość publiczną przy użyciu inicjowania z opóźnieniem, należy zdefiniować pole zapasowe <xref:System.Lazy%601>właściwości jako , i zwrócić <xref:System.Lazy%601.Value%2A> właściwość z `get` akcesora właściwości.</span><span class="sxs-lookup"><span data-stu-id="3be2c-219">To implement a public property by using lazy initialization, define the backing field of the property as a <xref:System.Lazy%601>, and return the <xref:System.Lazy%601.Value%2A> property from the `get` accessor of the property.</span></span>  
  
 [!code-csharp[Lazy#5](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#5)]
 [!code-vb[Lazy#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#5)]  
  
 <span data-ttu-id="3be2c-220">Właściwość <xref:System.Lazy%601.Value%2A> jest tylko do odczytu; w związku z tym właściwość, `set` która udostępnia go nie ma akcesora.</span><span class="sxs-lookup"><span data-stu-id="3be2c-220">The <xref:System.Lazy%601.Value%2A> property is read-only; therefore, the property that exposes it has no `set` accessor.</span></span> <span data-ttu-id="3be2c-221">Jeśli wymagana jest właściwość odczytu/zapisu, która jest tworzęana <xref:System.Lazy%601> przez obiekt, `set` akcesor musi utworzyć nowy <xref:System.Lazy%601> obiekt i przypisać go do magazynu zapasowego.</span><span class="sxs-lookup"><span data-stu-id="3be2c-221">If you require a read/write property backed by a <xref:System.Lazy%601> object, the `set` accessor must create a new <xref:System.Lazy%601> object and assign it to the backing store.</span></span> <span data-ttu-id="3be2c-222">Akcesor `set` musi utworzyć wyrażenie lambda, który zwraca `set` nową wartość właściwości, która została przekazana do akcesora i przekazać to wyrażenie lambda do konstruktora dla nowego <xref:System.Lazy%601> obiektu.</span><span class="sxs-lookup"><span data-stu-id="3be2c-222">The `set` accessor must create a lambda expression that returns the new property value that was passed to the `set` accessor, and pass that lambda expression to the constructor for the new <xref:System.Lazy%601> object.</span></span> <span data-ttu-id="3be2c-223">Następny dostęp do <xref:System.Lazy%601.Value%2A> właściwości spowoduje inicjalizację <xref:System.Lazy%601> <xref:System.Lazy%601.Value%2A> nowego , a jego właściwość zwróci następnie nową wartość, która została przypisana do właściwości.</span><span class="sxs-lookup"><span data-stu-id="3be2c-223">The next access of the <xref:System.Lazy%601.Value%2A> property will cause initialization of the new <xref:System.Lazy%601>, and its <xref:System.Lazy%601.Value%2A> property will thereafter return the new value that was assigned to the property.</span></span> <span data-ttu-id="3be2c-224">Powodem tego zawiłego układu jest zachowanie wbudowanych <xref:System.Lazy%601>zabezpieczeń wielowątkowych.</span><span class="sxs-lookup"><span data-stu-id="3be2c-224">The reason for this convoluted arrangement is to preserve the multithreading protections built into <xref:System.Lazy%601>.</span></span> <span data-ttu-id="3be2c-225">W przeciwnym razie akcesory właściwości musiałby <xref:System.Lazy%601.Value%2A> buforować pierwszą wartość zwróconą przez właściwość i tylko zmodyfikować wartość buforowaną i trzeba napisać własny kod wątku, aby to zrobić.</span><span class="sxs-lookup"><span data-stu-id="3be2c-225">Otherwise, the property accessors would have to cache the first value returned by the <xref:System.Lazy%601.Value%2A> property and only modify the cached value, and you would have to write your own thread-safe code to do that.</span></span> <span data-ttu-id="3be2c-226">Ze względu na dodatkowe inicjalizowania wymagane przez <xref:System.Lazy%601> właściwość odczytu/zapisu wspierane przez obiekt, wydajność może być nie do przyjęcia.</span><span class="sxs-lookup"><span data-stu-id="3be2c-226">Because of the additional initializations required by a read/write property backed by a <xref:System.Lazy%601> object, the performance might not be acceptable.</span></span> <span data-ttu-id="3be2c-227">Ponadto, w zależności od konkretnego scenariusza, dodatkowa koordynacja może być wymagana w celu uniknięcia warunków wyścigu między ustawiających i getters.</span><span class="sxs-lookup"><span data-stu-id="3be2c-227">Furthermore, depending on the specific scenario, additional coordination might be required to avoid race conditions between setters and getters.</span></span>  
  
## <a name="thread-local-lazy-initialization"></a><span data-ttu-id="3be2c-228">Inicjowanie lokalne wątku</span><span class="sxs-lookup"><span data-stu-id="3be2c-228">Thread-Local Lazy Initialization</span></span>  
 <span data-ttu-id="3be2c-229">W niektórych scenariuszach wielowątkowych można nadać każdemu wątkowi własne dane prywatne.</span><span class="sxs-lookup"><span data-stu-id="3be2c-229">In some multithreaded scenarios, you might want to give each thread its own private data.</span></span> <span data-ttu-id="3be2c-230">Takie dane nazywane są *danymi lokalnymi wątków*.</span><span class="sxs-lookup"><span data-stu-id="3be2c-230">Such data is called *thread-local data*.</span></span> <span data-ttu-id="3be2c-231">W .NET Framework w wersji 3.5 i `ThreadStatic` wcześniejszych można zastosować atrybut do zmiennej statycznej, aby uczynić go lokalnym wątku.</span><span class="sxs-lookup"><span data-stu-id="3be2c-231">In the .NET Framework version 3.5 and earlier, you could apply the `ThreadStatic` attribute to a static variable to make it thread-local.</span></span> <span data-ttu-id="3be2c-232">Jednak za `ThreadStatic` pomocą atrybutu może prowadzić do błędów subtelne.</span><span class="sxs-lookup"><span data-stu-id="3be2c-232">However, using the `ThreadStatic` attribute can lead to subtle errors.</span></span> <span data-ttu-id="3be2c-233">Na przykład nawet podstawowe instrukcje inicjowania spowoduje, że zmienna ma być inicjowane tylko w pierwszym wątku, który uzyskuje do niego dostęp, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="3be2c-233">For example, even basic initialization statements will cause the variable to be initialized only on the first thread that accesses it, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#6](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#6)]
 [!code-vb[Lazy#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#6)]  
  
 <span data-ttu-id="3be2c-234">We wszystkich innych wątkach zmienna zostanie zainicjowana przy użyciu jej wartości domyślnej (zero).</span><span class="sxs-lookup"><span data-stu-id="3be2c-234">On all other threads, the variable will be initialized by using its default value (zero).</span></span> <span data-ttu-id="3be2c-235">Alternatywnie w programie .NET Framework w wersji <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> 4 można użyć tego typu do utworzenia zmiennej lokalnej opartej na wystąpieniu, która jest inicjowana we wszystkich wątkach przez <xref:System.Action%601> pełnomocnika, który podasz.</span><span class="sxs-lookup"><span data-stu-id="3be2c-235">As an alternative in the .NET Framework version 4, you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> type to create an instance-based, thread-local variable that is initialized on all threads by the <xref:System.Action%601> delegate that you provide.</span></span> <span data-ttu-id="3be2c-236">W poniższym przykładzie wszystkie `counter` wątki, do których dostęp będzie widzieć jego wartość początkową jako 1.</span><span class="sxs-lookup"><span data-stu-id="3be2c-236">In the following example, all threads that access `counter` will see its starting value as 1.</span></span>  
  
 [!code-csharp[Lazy#7](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#7)]
 [!code-vb[Lazy#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#7)]  
  
 <span data-ttu-id="3be2c-237"><xref:System.Threading.ThreadLocal%601>owija swój obiekt w <xref:System.Lazy%601>taki sam sposób jak , z tymi istotnymi różnicami:</span><span class="sxs-lookup"><span data-stu-id="3be2c-237"><xref:System.Threading.ThreadLocal%601> wraps its object in much the same way as <xref:System.Lazy%601>, with these essential differences:</span></span>  
  
- <span data-ttu-id="3be2c-238">Każdy wątek inicjuje zmienną lokalną wątku przy użyciu własnych danych prywatnych, które nie są dostępne z innych wątków.</span><span class="sxs-lookup"><span data-stu-id="3be2c-238">Each thread initializes the thread-local variable by using its own private data that is not accessible from other threads.</span></span>  
  
- <span data-ttu-id="3be2c-239">Właściwość <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> jest odczyt i zapis i może być modyfikowany dowolną liczbę razy.</span><span class="sxs-lookup"><span data-stu-id="3be2c-239">The <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> property is read-write, and can be modified any number of times.</span></span> <span data-ttu-id="3be2c-240">Może to mieć wpływ na propagację wyjątków, na przykład jedna `get` operacja może zgłosić wyjątek, ale następna może pomyślnie zainicjować wartość.</span><span class="sxs-lookup"><span data-stu-id="3be2c-240">This can affect exception propagation, for example, one `get` operation can raise an exception but the next one can successfully initialize the value.</span></span>  
  
- <span data-ttu-id="3be2c-241">Jeśli nie podano delegata <xref:System.Threading.ThreadLocal%601> inicjowania, zainisl jego typ opakowane przy użyciu domyślnej wartości typu.</span><span class="sxs-lookup"><span data-stu-id="3be2c-241">If no initialization delegate is provided, <xref:System.Threading.ThreadLocal%601> will initialize its wrapped type by using the default value of the type.</span></span> <span data-ttu-id="3be2c-242">W związku <xref:System.Threading.ThreadLocal%601> z tym <xref:System.ThreadStaticAttribute> jest zgodne z atrybutem.</span><span class="sxs-lookup"><span data-stu-id="3be2c-242">In this regard, <xref:System.Threading.ThreadLocal%601> is consistent with the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
 <span data-ttu-id="3be2c-243">Poniższy przykład pokazuje, że każdy `ThreadLocal<int>` wątek, który uzyskuje dostęp do wystąpienia pobiera własną unikatową kopię danych.</span><span class="sxs-lookup"><span data-stu-id="3be2c-243">The following example demonstrates that every thread that accesses the `ThreadLocal<int>` instance gets its own unique copy of the data.</span></span>  
  
 [!code-csharp[Lazy#9](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#9)]
 [!code-vb[Lazy#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#9)]  
  
## <a name="thread-local-variables-in-parallelfor-and-foreach"></a><span data-ttu-id="3be2c-244">Zmienne lokalne wątku w parallel.For i ForEach</span><span class="sxs-lookup"><span data-stu-id="3be2c-244">Thread-Local Variables in Parallel.For and ForEach</span></span>  
 <span data-ttu-id="3be2c-245">Korzystając z <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> metody <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> lub metody do iteracji za pomocą źródeł danych równolegle, można użyć przeciążenia, które mają wbudowaną obsługę danych lokalnych wątku.</span><span class="sxs-lookup"><span data-stu-id="3be2c-245">When you use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method or <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to iterate over data sources in parallel, you can use the overloads that have built-in support for thread-local data.</span></span> <span data-ttu-id="3be2c-246">W tych metodach lokalizacja wątku jest osiągana przy użyciu delegatów lokalnych do tworzenia, uzyskiwania dostępu i czyszczenia danych.</span><span class="sxs-lookup"><span data-stu-id="3be2c-246">In these methods, the thread-locality is achieved by using local delegates to create, access, and clean up the data.</span></span> <span data-ttu-id="3be2c-247">Aby uzyskać więcej informacji, zobacz [Jak: Napisz Parallel.For Pętli z wątku zmiennych lokalnych](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) i [jak: Napisz Parallel.ForEach pętli z partycji zmiennych lokalnych](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="3be2c-247">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Partition-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span></span>  
  
## <a name="using-lazy-initialization-for-low-overhead-scenarios"></a><span data-ttu-id="3be2c-248">Używanie inicjowania z opóźnieniem dla scenariuszy o niskim napowietrzniu</span><span class="sxs-lookup"><span data-stu-id="3be2c-248">Using Lazy Initialization for Low-Overhead Scenarios</span></span>  
 <span data-ttu-id="3be2c-249">W scenariuszach, w których trzeba z opóźnieniem zainicjować dużą liczbę obiektów, <xref:System.Lazy%601> można zdecydować, że zawijania każdego obiektu w wymaga zbyt dużo pamięci lub zbyt wiele zasobów obliczeniowych.</span><span class="sxs-lookup"><span data-stu-id="3be2c-249">In scenarios where you have to lazy-initialize a large number of objects, you might decide that wrapping each object in a <xref:System.Lazy%601> requires too much memory or too many computing resources.</span></span> <span data-ttu-id="3be2c-250">Lub może mieć rygorystyczne wymagania dotyczące jak z opóźnieniem inicjowania jest narażony.</span><span class="sxs-lookup"><span data-stu-id="3be2c-250">Or, you might have stringent requirements about how lazy initialization is exposed.</span></span> <span data-ttu-id="3be2c-251">W takich przypadkach można `static` użyć`Shared` (w języku Visual <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> Basic) metody klasy do z opóźnieniem inicjować każdy obiekt bez zawijania go w wystąpieniu <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="3be2c-251">In such cases, you can use the `static` (`Shared` in Visual Basic) methods of the <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> class to lazy-initialize each object without wrapping it in an instance of <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="3be2c-252">W poniższym przykładzie załóżmy, że `Orders` zamiast <xref:System.Lazy%601> zawijanie całego obiektu w `Order` jednym obiekcie, masz z opóźnieniem zainicjowane poszczególne obiekty tylko wtedy, gdy są one wymagane.</span><span class="sxs-lookup"><span data-stu-id="3be2c-252">In the following example, assume that, instead of wrapping an entire `Orders` object in one <xref:System.Lazy%601> object, you have lazy-initialized individual `Order` objects only if they are required.</span></span>  
  
 [!code-csharp[Lazy#10](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#10)]
 [!code-vb[Lazy#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#10)]  
  
 <span data-ttu-id="3be2c-253">W tym przykładzie należy zauważyć, że procedura inicjowania jest wywoływana na każdej iteracji pętli.</span><span class="sxs-lookup"><span data-stu-id="3be2c-253">In this example, notice that the initialization procedure is invoked on every iteration of the loop.</span></span> <span data-ttu-id="3be2c-254">W scenariuszach wielowątkowych pierwszy wątek do wywołania procedury inicjowania jest ten, którego wartość jest widoczna dla wszystkich wątków.</span><span class="sxs-lookup"><span data-stu-id="3be2c-254">In multi-threaded scenarios, the first thread to invoke the initialization procedure is the one whose value is seen by all threads.</span></span> <span data-ttu-id="3be2c-255">Późniejsze wątki również wywołać procedurę inicjowania, ale ich wyniki nie są używane.</span><span class="sxs-lookup"><span data-stu-id="3be2c-255">Later threads also invoke the initialization procedure, but their results are not used.</span></span> <span data-ttu-id="3be2c-256">Jeśli tego rodzaju potencjalnego stanu wyścigu nie <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> jest dopuszczalne, należy użyć przeciążenie, który przyjmuje argument logiczny i obiekt synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="3be2c-256">If this kind of potential race condition is not acceptable, use the overload of <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> that takes a Boolean argument and a synchronization object.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3be2c-257">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="3be2c-257">See also</span></span>

- [<span data-ttu-id="3be2c-258">Zarządzana wątkowość — podstawy</span><span class="sxs-lookup"><span data-stu-id="3be2c-258">Managed Threading Basics</span></span>](../../standard/threading/managed-threading-basics.md)
- [<span data-ttu-id="3be2c-259">Wątki i wątkowość</span><span class="sxs-lookup"><span data-stu-id="3be2c-259">Threads and Threading</span></span>](../../standard/threading/threads-and-threading.md)
- [<span data-ttu-id="3be2c-260">Biblioteka zadań równoległych (TPL)</span><span class="sxs-lookup"><span data-stu-id="3be2c-260">Task Parallel Library (TPL)</span></span>](../../standard/parallel-programming/task-parallel-library-tpl.md)
- [<span data-ttu-id="3be2c-261">Porady: wykonywanie incjalizacji obiektów z opóźnieniem</span><span class="sxs-lookup"><span data-stu-id="3be2c-261">How to: Perform Lazy Initialization of Objects</span></span>](how-to-perform-lazy-initialization-of-objects.md)
