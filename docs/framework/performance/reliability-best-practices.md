---
title: Najlepsze rozwiązania dotyczące niezawodności
ms.date: 03/30/2017
helpviewer_keywords:
- marking locks
- rebooting databases
- denial of service attacks
- back-out code
- SQL Server [.NET Framework], reliability
- synchronization, reliability
- single-threaded COM components
- slow leaks
- suspending threads
- asynchronous exception handling
- leaked resources [.NET Framework]
- unmanaged memory
- memory, reliability
- threading [.NET Framework], reliability
- process-wide domain shared states
- shared states
- SafeHandle class, reliability
- reliability contracts [.NET Framework]
- cleanup operations
- constrained execution regions
- CERs
- finalizers, reliability
- reliability [.NET Framework]
- blocks, reliability
- finally clauses
- cross-application domain shared states
- catch blocks
- identifying locks
- writing reliable code
- impersonation
- GC.KeepAlive method
- managed threading
- locks, reliability
- STA-dependent features
- fibers
ms.assetid: cf624c1f-c160-46a1-bb2b-213587688da7
author: mairaw
ms.author: mairaw
ms.openlocfilehash: 280e73ccd3d8a90b2f2b3a485d3f4240b434359b
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 01/23/2019
ms.locfileid: "54714857"
---
# <a name="reliability-best-practices"></a><span data-ttu-id="3459c-102">Najlepsze rozwiązania dotyczące niezawodności</span><span class="sxs-lookup"><span data-stu-id="3459c-102">Reliability Best Practices</span></span>
<span data-ttu-id="3459c-103">Następujące reguły dotyczące niezawodności są ukierunkowane do programu SQL Server; Jednakże są też stosowane do dowolnej aplikacji opartej na hoście serwera.</span><span class="sxs-lookup"><span data-stu-id="3459c-103">The following reliability rules are oriented to SQL Server; however, they also apply to any host-based server application.</span></span> <span data-ttu-id="3459c-104">Bardzo ważne jest, serwerów, takich jak SQL Server nie nastąpił przeciek zasobów i nie można przełączyć w dół.</span><span class="sxs-lookup"><span data-stu-id="3459c-104">It is extremely important that servers such as SQL Server not leak resources and not be brought down.</span></span>  <span data-ttu-id="3459c-105">Jednakże, nie można wykonać, pisząc kod wycofujący dla każdej metody, która zmienia stan obiektu.</span><span class="sxs-lookup"><span data-stu-id="3459c-105">However, that cannot be done by writing back-out code for every method that alters an object’s state.</span></span>  <span data-ttu-id="3459c-106">Celem jest nie do 100 procent niezawodne kodu zarządzanego, który zostanie przywrócona do działania z wszystkich błędów w każdej lokalizacji za pomocą kod wycofujący zapisu.</span><span class="sxs-lookup"><span data-stu-id="3459c-106">The goal is not to write 100 percent reliable managed code that will recover from any errors in every location with back-out code.</span></span>  <span data-ttu-id="3459c-107">Który będzie stanowić nie lada z niewielkie prawdopodobieństwo powodzenia.</span><span class="sxs-lookup"><span data-stu-id="3459c-107">That would be a daunting task with little chance of success.</span></span>  <span data-ttu-id="3459c-108">Środowisko uruchomieniowe języka wspólnego (CLR) nie można łatwo udostępnić wystarczająco silne gwarancje do zarządzanego kodu umożliwiają pisanie kodu doskonałe, jest to możliwe.</span><span class="sxs-lookup"><span data-stu-id="3459c-108">The common language runtime (CLR) cannot easily provide strong enough guarantees to managed code to make writing perfect code feasible.</span></span>  <span data-ttu-id="3459c-109">Należy pamiętać, że w przeciwieństwie do programu ASP.NET, czy program SQL Server, używa tylko jeden proces, który nie może zostać przetworzony ponownie bez konieczności wyłączania bazy danych dla bardzo dużo czasu.</span><span class="sxs-lookup"><span data-stu-id="3459c-109">Note that unlike ASP.NET, SQL Server uses only one process that cannot be recycled without taking a database down for an unacceptably long time.</span></span>  
  
 <span data-ttu-id="3459c-110">Za pomocą tych gwarancji słabszy i uruchomiona w ramach jednego procesu niezawodność opiera się na przerywanie wątków lub odtwarzania domen aplikacji, gdy nie przedostają niezbędne i zdolności do przyjmowania środki ostrożności, aby zasoby systemu operacyjnego, takich jak pamięci lub uchwytów.</span><span class="sxs-lookup"><span data-stu-id="3459c-110">With these weaker guarantees and running in a single process, reliability is based on terminating threads or recycling application domains when necessary and taking precautions to ensure operating system resources such as handles or memory are not leaked.</span></span>  <span data-ttu-id="3459c-111">Nawet w przypadku tego prostsze ograniczenia niezawodności jest nadal wymagane znacznie wyższą niezawodność:</span><span class="sxs-lookup"><span data-stu-id="3459c-111">Even with this simpler reliability constraint, there is still a significant reliability requirement:</span></span>  
  
-   <span data-ttu-id="3459c-112">Nigdy nie przecieku zasobów systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="3459c-112">Never leak operating system resources.</span></span>  
  
-   <span data-ttu-id="3459c-113">Identyfikowanie Blokada wszystkich zarządzanych w wszystkie formularze do środowiska CLR.</span><span class="sxs-lookup"><span data-stu-id="3459c-113">Identify all managed locks in all forms to the CLR.</span></span>  
  
-   <span data-ttu-id="3459c-114">Nigdy nie takie domenie międzyaplikacyjnej podziału, udostępniony stan, dzięki czemu <xref:System.AppDomain> odtwarzania sprawnego funkcjonowania.</span><span class="sxs-lookup"><span data-stu-id="3459c-114">Never break cross-application domain shared state, allowing <xref:System.AppDomain> recycling to function smoothly.</span></span>  
  
 <span data-ttu-id="3459c-115">Chociaż teoretycznie do pisania kodu zarządzanego, aby obsłużyć <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, i <xref:System.OutOfMemoryException> wyjątki, oczekiwano programistom pisanie nierozsądne jest takie niezawodny kod w całej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="3459c-115">Although it is theoretically possible to write managed code to handle <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException> exceptions, expecting developers to write such robust code throughout an entire application is unreasonable.</span></span>  <span data-ttu-id="3459c-116">Z tego powodu out-of-band wyjątków powoduje, iż wątek wykonujący przerywane; i przerwał wątek został edycji udostępnionego stanu, które można określić, czy wątek nałoży blokadę, a następnie <xref:System.AppDomain> jest zwalniana.</span><span class="sxs-lookup"><span data-stu-id="3459c-116">For that reason, out-of-band exceptions result in the executing thread being terminated; and if the terminated thread was editing shared state, which can be determined by whether the thread holds a lock, then the <xref:System.AppDomain> is unloaded.</span></span>  <span data-ttu-id="3459c-117">Gdy metoda, która jest edytowany udostępnionego stanu jest zakończone, stan będzie uszkodzony, ponieważ nie jest możliwe do zapisu niezawodny kod wycofujący aktualizacji udostępnionego stanu.</span><span class="sxs-lookup"><span data-stu-id="3459c-117">When a method that is editing shared state is terminated, the state will be corrupt because it is not possible to write reliable back-out code for updates to shared state.</span></span>  
  
 <span data-ttu-id="3459c-118">W .NET Framework w wersji 2.0, jedyny host, który wymaga programu SQL Server jest niezawodność.</span><span class="sxs-lookup"><span data-stu-id="3459c-118">In the .NET Framework version 2.0, the only host that requires reliability is SQL Server.</span></span>  <span data-ttu-id="3459c-119">Jeżeli zestaw będzie uruchamiany na serwerze SQL, należy wykonać pracę niezawodność dla każdej części tego zestawu, nawet w przypadku określonych funkcji, które są wyłączone podczas uruchamiania w bazie danych.</span><span class="sxs-lookup"><span data-stu-id="3459c-119">If your assembly will be run on SQL Server you should do the reliability work for every part of that assembly, even if there are specific features that are disabled when running in the database.</span></span>  <span data-ttu-id="3459c-120">Jest to wymagane, ponieważ aparat analizy kodu sprawdza, czy kod na poziomie zestawu i nie można odróżnić wyłączone kodu.</span><span class="sxs-lookup"><span data-stu-id="3459c-120">This is required because the code analysis engine examines code at the assembly level and cannot differentiate disabled code.</span></span> <span data-ttu-id="3459c-121">Inny program SQL Server programowania kwestią jest, że program SQL Server działa wszystko w jednym procesie i <xref:System.AppDomain> odtwarzania jest używany do czyszczenia wszystkie zasoby, takie jak pamięć i system operacyjny obsługuje.</span><span class="sxs-lookup"><span data-stu-id="3459c-121">Another SQL Server programming consideration is that SQL Server runs everything in one process, and <xref:System.AppDomain> recycling is used for cleaning up all resources such as memory and operating system handles.</span></span>  
  
 <span data-ttu-id="3459c-122">Nie może zależeć od finalizatory i destruktory lub `try/finally` bloków dla kod wycofujący.</span><span class="sxs-lookup"><span data-stu-id="3459c-122">You cannot depend on finalizers or destructors or `try/finally` blocks for back-out code.</span></span> <span data-ttu-id="3459c-123">Może być przerwana lub nie jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="3459c-123">They might be interrupted or not called.</span></span>  
  
 <span data-ttu-id="3459c-124">Wyjątki asynchroniczne mogą być generowane w nieoczekiwanych lokalizacjach, prawdopodobnie każdy instrukcji maszyny: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, i <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="3459c-124">Asynchronous exceptions can be thrown in unexpected locations, possibly every machine instruction: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException>.</span></span>  
  
 <span data-ttu-id="3459c-125">Zarządzane wątki, niekoniecznie są wątków Win32 w języku SQL; mogą one włókien.</span><span class="sxs-lookup"><span data-stu-id="3459c-125">Managed threads are not necessarily Win32 threads in SQL; they might be fibers.</span></span>  
  
 <span data-ttu-id="3459c-126">Modyfikowalny stan udostępnione całego procesu lub aplikacji dla wielu domen, jest bardzo trudno zmienić bezpieczne i w miarę możliwości należy unikać.</span><span class="sxs-lookup"><span data-stu-id="3459c-126">Process-wide or cross-application domain mutable shared state is extremely difficult to alter safely and should be avoided whenever possible.</span></span>  
  
 <span data-ttu-id="3459c-127">Warunki braku pamięci nie są rzadkie w programie SQL Server.</span><span class="sxs-lookup"><span data-stu-id="3459c-127">Out-of-memory conditions are not rare in SQL Server.</span></span>  
  
 <span data-ttu-id="3459c-128">Jeśli poprawnie biblioteki hostowanego w programie SQL Server nie są uaktualniane ich udostępnionego stanu, istnieje wysokie prawdopodobieństwo, że kod nie zostanie przywrócona do działania do momentu ponownego uruchomienia bazy danych.</span><span class="sxs-lookup"><span data-stu-id="3459c-128">If libraries hosted in SQL Server do not correctly update their shared state, there is a high probability that the code will not recover until the database has been restarted.</span></span>  <span data-ttu-id="3459c-129">Ponadto w skrajnych przypadkach jest to możliwe, może to spowodować procesu programu SQL Server zakończyć się niepowodzeniem, co powoduje bazy danych o ponownym uruchomieniu.</span><span class="sxs-lookup"><span data-stu-id="3459c-129">Additionally, in some extreme cases, it is possible this might cause the SQL Server process to fail, causing the database to reboot.</span></span>  <span data-ttu-id="3459c-130">Ponowne uruchamianie bazy danych można walce z witryny sieci Web lub wpływających na funkcjonowanie firmie przejąć dostępności.</span><span class="sxs-lookup"><span data-stu-id="3459c-130">Rebooting the database can take down a Web site or affect company operations, hurting availability.</span></span>  <span data-ttu-id="3459c-131">Powolne przecieku zasobów systemu operacyjnego, takich jak pamięci lub uchwytów może spowodować, że serwer po pewnym czasie niepowodzenie przydzielania uchwyty o braku możliwości odzyskiwania lub potencjalnie powoli spowodować spadek wydajności serwera i zmniejsza aplikacji klienta dostępność.</span><span class="sxs-lookup"><span data-stu-id="3459c-131">A slow leak of operating system resources such as memory or handles may cause the server to eventually fail allocating handles with no possibility of recovery, or potentially the server may slowly degrade in performance and reduces a customer’s application availability.</span></span>  <span data-ttu-id="3459c-132">Wyraźnie chcemy uniknąć tych scenariuszy.</span><span class="sxs-lookup"><span data-stu-id="3459c-132">Clearly we want to avoid these scenarios.</span></span>  
  
## <a name="best-practice-rules"></a><span data-ttu-id="3459c-133">Regułami najlepszych rozwiązań</span><span class="sxs-lookup"><span data-stu-id="3459c-133">Best Practice Rules</span></span>  
 <span data-ttu-id="3459c-134">Wprowadzenie koncentruje się na Przegląd kodu dla kodu zarządzanego, który jest uruchamiany na serwerze musiałby zostać przechwycony w celu zwiększenia stabilności i niezawodności Framework.</span><span class="sxs-lookup"><span data-stu-id="3459c-134">The introduction focused on what the code review for the managed code that runs in the server would have to catch to increase the stability and reliability of the framework.</span></span> <span data-ttu-id="3459c-135">Te sprawdzenia są dobrym rozwiązaniem, ogólnie rzecz biorąc, więc bezwzględnym musi na serwerze.</span><span class="sxs-lookup"><span data-stu-id="3459c-135">All these checks are good practice in general and an absolute must on the server.</span></span>  
  
 <span data-ttu-id="3459c-136">W przypadku braku ograniczenia blokady lub zasób, SQL Server spowoduje przerwanie wątku lub zatrzymywania <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="3459c-136">In the face of a dead lock or resource constraint, SQL Server will abort a thread or tear down an <xref:System.AppDomain>.</span></span>  <span data-ttu-id="3459c-137">W takiej sytuacji kod tylko wycofujący w regionie ograniczonego wykonania (CER) jest gwarantowane do uruchomienia.</span><span class="sxs-lookup"><span data-stu-id="3459c-137">When this happens, only back-out code in a constrained execution region (CER) is guaranteed to be run.</span></span>  
  
### <a name="use-safehandle-to-avoid-resource-leaks"></a><span data-ttu-id="3459c-138">Używaj klasy SafeHandle w celu uniknięcia przeciekom zasobów</span><span class="sxs-lookup"><span data-stu-id="3459c-138">Use SafeHandle to Avoid Resource Leaks</span></span>  
 <span data-ttu-id="3459c-139">W przypadku właściwości <xref:System.AppDomain> unload, nie może zależeć od `finally` bloków lub finalizatory wykonywana, dlatego ważne jest, aby abstrakcji wszystkich dostęp do zasobów systemu operacyjnego za pośrednictwem <xref:System.Runtime.InteropServices.SafeHandle> klasy zamiast <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef>, lub podobne klasy.</span><span class="sxs-lookup"><span data-stu-id="3459c-139">In the case of an <xref:System.AppDomain> unload, you cannot depend on `finally` blocks or finalizers being executed, so it is important to abstract all operating system resource access through the <xref:System.Runtime.InteropServices.SafeHandle> class rather than <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef>, or similar classes.</span></span> <span data-ttu-id="3459c-140">Dzięki temu CLR do śledzenia i zamknąć dojścia używasz nawet w <xref:System.AppDomain> przypadku zakończenia.</span><span class="sxs-lookup"><span data-stu-id="3459c-140">This allows the CLR to track and close the handles you use even in the <xref:System.AppDomain> tear-down case.</span></span>  <span data-ttu-id="3459c-141"><xref:System.Runtime.InteropServices.SafeHandle> będzie używać finalizator krytyczny, który zawsze działa, środowisko CLR.</span><span class="sxs-lookup"><span data-stu-id="3459c-141"><xref:System.Runtime.InteropServices.SafeHandle> will be using a critical finalizer which the CLR will always run.</span></span>  
  
 <span data-ttu-id="3459c-142">Dojście systemu operacyjnego są przechowywane w bezpiecznego dojścia, od chwili utworzenia do chwili, w których jest on zwalniany.</span><span class="sxs-lookup"><span data-stu-id="3459c-142">The operating system handle is stored in the safe handle from the moment it is created until the moment it is released.</span></span>  <span data-ttu-id="3459c-143">Brak żadnego okna, w którym <xref:System.Threading.ThreadAbortException> może wystąpić na uchwyt przecieki pamięci.</span><span class="sxs-lookup"><span data-stu-id="3459c-143">There is no window during which a <xref:System.Threading.ThreadAbortException> can occur to leak a handle.</span></span>  <span data-ttu-id="3459c-144">Ponadto wywołanie licznik odwołań zostanie uchwyt, która umożliwia zamknięcie śledzenia okresu istnienia uchwytu zapobieganie problem zabezpieczeń za pomocą wyścigu między platformy `Dispose` i metody, która jest obecnie za pomocą uchwytu.</span><span class="sxs-lookup"><span data-stu-id="3459c-144">Additionally, platform invoke will reference-count the handle, which allows close tracking of the lifetime of the handle, preventing a security issue with a race condition between `Dispose` and a method that is currently using the handle.</span></span>  
  
 <span data-ttu-id="3459c-145">Większość klas, które aktualnie mają finalizatory po prostu oczyszczania systemu operacyjnego obsługi nie będą już potrzebne finalizatora.</span><span class="sxs-lookup"><span data-stu-id="3459c-145">Most classes that currently have a finalizer to simply clean up an operating system handle will not need the finalizer anymore.</span></span> <span data-ttu-id="3459c-146">Zamiast tego będzie finalizator w <xref:System.Runtime.InteropServices.SafeHandle> klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="3459c-146">Instead, the finalizer will be on the <xref:System.Runtime.InteropServices.SafeHandle> derived class.</span></span>  
  
 <span data-ttu-id="3459c-147">Należy pamiętać, że <xref:System.Runtime.InteropServices.SafeHandle> nie jest zamiennikiem <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3459c-147">Note that <xref:System.Runtime.InteropServices.SafeHandle> is not a replacement for <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span></span>  <span data-ttu-id="3459c-148">Ma nadal potencjalnych zasobów rywalizacji o zasoby i wydajność zalet jawnie Usuń zasoby systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="3459c-148">There are still potential resource contention and performance advantages to explicitly dispose operating system resources.</span></span>  <span data-ttu-id="3459c-149">Po prostu należy pamiętać, że `finally` bloki, które jawnie usuwania zasobów nie może być wykonywane do zakończenia.</span><span class="sxs-lookup"><span data-stu-id="3459c-149">Just realize that `finally` blocks that do explicitly dispose of resources may not execute to completion.</span></span>  
  
 <span data-ttu-id="3459c-150"><xref:System.Runtime.InteropServices.SafeHandle> pozwala na implementowanie własnych <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> metodę, która wykonuje pracę z bezpłatnymi uchwyt, takie jak przekazywanie stanie obsługiwać system operacyjny, zwalniając procedury lub zwalnianie zestaw uchwytów w pętli.</span><span class="sxs-lookup"><span data-stu-id="3459c-150"><xref:System.Runtime.InteropServices.SafeHandle> allows you to implement your own <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method that performs the work to free the handle, such as passing state to an operating system handle freeing routine or freeing a set of handles in a loop.</span></span>  <span data-ttu-id="3459c-151">Środowisko CLR gwarantuje, że ta metoda jest uruchamiany.</span><span class="sxs-lookup"><span data-stu-id="3459c-151">The CLR guarantees that this method is run.</span></span>  <span data-ttu-id="3459c-152">Jest odpowiedzialny za autora <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementacji, aby upewnić się, że uchwyt jest publikowany w każdych okolicznościach.</span><span class="sxs-lookup"><span data-stu-id="3459c-152">It is the responsibility of the author of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation to ensure that the handle is released in all circumstances.</span></span> <span data-ttu-id="3459c-153">Niewykonanie tej czynności spowoduje, że uchwyt, aby mogą zostać ujawnione, co skutkuje często wyciekom natywne zasoby skojarzone z uchwytu.</span><span class="sxs-lookup"><span data-stu-id="3459c-153">Failure to do so will cause the handle to be leaked, which often results in the leakage of native resources associated with the handle.</span></span> <span data-ttu-id="3459c-154">W związku z tym jest krytyczny do struktury <xref:System.Runtime.InteropServices.SafeHandle> klasy pochodne tak, aby <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementacji nie wymaga alokacji zasobów, które mogą być niedostępne w momencie wywołania.</span><span class="sxs-lookup"><span data-stu-id="3459c-154">Therefore it is critical to structure <xref:System.Runtime.InteropServices.SafeHandle> derived classes such that the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation does not require the allocation of any resources that may not be available at invocation time.</span></span> <span data-ttu-id="3459c-155">Pamiętaj, że jest dopuszczalne do metod wywołania, które może zakończyć się niepowodzeniem w ramach wdrożenia <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> pod warunkiem, że Twój kod może obsłużyć takie błędy i ukończyć kontraktu na zwolnienie uchwytu natywnych.</span><span class="sxs-lookup"><span data-stu-id="3459c-155">Note that it is permissible to call methods that may fail within the implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> provided that your code can handle such failures and complete the contract to release the native handle.</span></span> <span data-ttu-id="3459c-156">Dla celów debugowania, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> ma <xref:System.Boolean> zwracają wartość, która może być ustawiona na `false` po napotkaniu błędu krytycznego, co uniemożliwia wersję zasobu.</span><span class="sxs-lookup"><span data-stu-id="3459c-156">For debugging purposes, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> has a <xref:System.Boolean> return value which may be set to `false` if a catastrophic error is encountered which prevents release of the resource.</span></span> <span data-ttu-id="3459c-157">To uaktywni [releaseHandleFailed](../../../docs/framework/debug-trace-profile/releasehandlefailed-mda.md) MDA, jeśli włączone, aby ułatwić zidentyfikowanie problemu.</span><span class="sxs-lookup"><span data-stu-id="3459c-157">Doing so will activate the [releaseHandleFailed](../../../docs/framework/debug-trace-profile/releasehandlefailed-mda.md) MDA, if enabled, to aid in identifying the problem.</span></span> <span data-ttu-id="3459c-158">Nie ma wpływu na środowisko uruchomieniowe w inny sposób: <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> nie zostanie ponownie wywołany dla tego samego zasobu i w związku z tym będzie przeciek uchwytu.</span><span class="sxs-lookup"><span data-stu-id="3459c-158">It does not affect the runtime in any other way; <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> will not be called again for the same resource and consequently the handle will be leaked.</span></span>  
  
 <span data-ttu-id="3459c-159"><xref:System.Runtime.InteropServices.SafeHandle> nie jest odpowiednie w określonych kontekstach.</span><span class="sxs-lookup"><span data-stu-id="3459c-159"><xref:System.Runtime.InteropServices.SafeHandle> is not appropriate in certain contexts.</span></span>  <span data-ttu-id="3459c-160">Ponieważ <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> metody mogą być uruchamiane na <xref:System.GC> wątek finalizatora wszystkie dojścia, które muszą zostać uwolniona w określonym wątku nie musi być ujęte w <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="3459c-160">Since the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method can be run on a <xref:System.GC> finalizer thread, any handles that are required to be freed on a particular thread should not be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle>.</span></span>  
  
 <span data-ttu-id="3459c-161">Wywoływanych otok środowiska uruchomieniowego (RCW) mogą być czyszczone przez środowisko CLR bez dodatkowego kodu.</span><span class="sxs-lookup"><span data-stu-id="3459c-161">Runtime callable wrappers (RCWs) can be cleaned by the CLR without additional code.</span></span>  <span data-ttu-id="3459c-162">Kod, który używa platformy wywołania i traktuje obiektu COM jako `IUnknown*` lub <xref:System.IntPtr>, kod powinien zostać przepisany używać RCW.</span><span class="sxs-lookup"><span data-stu-id="3459c-162">For code that uses platform invoke and treats a COM object as an `IUnknown*` or an <xref:System.IntPtr>, the code should be rewritten to use an RCW.</span></span>  <span data-ttu-id="3459c-163"><xref:System.Runtime.InteropServices.SafeHandle> może nie być odpowiednie dla tego scenariusza, ze względu na możliwość niezarządzanej wersji metody wywołań zwrotnych do kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="3459c-163"><xref:System.Runtime.InteropServices.SafeHandle> may not be adequate for this scenario due to the possibility of an unmanaged release method calling back into managed code.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3459c-164">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3459c-164">Code Analysis Rule</span></span>  
 <span data-ttu-id="3459c-165">Użyj <xref:System.Runtime.InteropServices.SafeHandle> celu hermetyzacji zasobów systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="3459c-165">Use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate operating system resources.</span></span> <span data-ttu-id="3459c-166">Nie używaj <xref:System.Runtime.InteropServices.HandleRef> lub pola typu <xref:System.IntPtr>.</span><span class="sxs-lookup"><span data-stu-id="3459c-166">Do not use <xref:System.Runtime.InteropServices.HandleRef> or fields of type <xref:System.IntPtr>.</span></span>  
  
### <a name="ensure-finalizers-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="3459c-167">Upewnij się, że do uruchomienia, aby uniknąć przecieku zasobów systemu operacyjnego nie mają finalizatory</span><span class="sxs-lookup"><span data-stu-id="3459c-167">Ensure Finalizers Do Not Have to Run to Prevent Leaking Operating System Resources</span></span>  
 <span data-ttu-id="3459c-168">Przejrzyj swoje finalizatorów, aby upewnić się, że nawet wtedy, gdy nie działają, zasób krytycznych systemu operacyjnego nie następuje przeciek.</span><span class="sxs-lookup"><span data-stu-id="3459c-168">Review your finalizers carefully to ensure that even if they do not run, a critical operating system resource is not leaked.</span></span>  <span data-ttu-id="3459c-169">W przeciwieństwie do normalnego <xref:System.AppDomain> zwolnienie podczas wykonywania aplikacji w stanie stabilnym lub serwera, takie jak SQL Server jest wyłączany, obiekty, zostały zakończone podczas nagłego <xref:System.AppDomain> zwolnienia.</span><span class="sxs-lookup"><span data-stu-id="3459c-169">Unlike a normal <xref:System.AppDomain> unload when the application is executing in a steady state or when a server such as SQL Server shuts down, objects are not finalized during an abrupt <xref:System.AppDomain> unload.</span></span>  <span data-ttu-id="3459c-170">Upewnij się, że nie wyciek zasobów w przypadku nagłego unload, ponieważ nie można zagwarantować poprawność aplikacji, ale integralność serwera musi być utrzymywana przez nie wyciek zasobów.</span><span class="sxs-lookup"><span data-stu-id="3459c-170">Ensure resources are not leaked in the case of an abrupt unload, since an application's correctness cannot be guaranteed, but the integrity of the server must be maintained by not leaking resources.</span></span>  <span data-ttu-id="3459c-171">Użyj <xref:System.Runtime.InteropServices.SafeHandle> zwolnić wszystkie zasoby systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="3459c-171">Use <xref:System.Runtime.InteropServices.SafeHandle> to free any operating system resources.</span></span>  
  
### <a name="ensure-that-finally-clauses-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="3459c-172">Oznacza koniec upewnij się klauzule nie jest konieczne uruchomienie, aby zapobiec wyciek zasobów systemu operacyjnego</span><span class="sxs-lookup"><span data-stu-id="3459c-172">Ensure That finally Clauses Do Not Have to Run to Prevent Leaking Operating System Resources</span></span>  
 <span data-ttu-id="3459c-173">`finally` klauzule nie ma gwarancji, uruchamiać poza CERs, wymagających deweloperom biblioteki nie zależą od kodu w ramach `finally` blok umożliwiający zwolnienie niezarządzanych zasobów.</span><span class="sxs-lookup"><span data-stu-id="3459c-173">`finally` clauses are not guaranteed to run outside of CERs, requiring library developers to not rely on code within a `finally` block to free unmanaged resources.</span></span>  <span data-ttu-id="3459c-174">Za pomocą <xref:System.Runtime.InteropServices.SafeHandle> jest zalecanym rozwiązaniem.</span><span class="sxs-lookup"><span data-stu-id="3459c-174">Using <xref:System.Runtime.InteropServices.SafeHandle> is the recommended solution.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3459c-175">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3459c-175">Code Analysis Rule</span></span>  
 <span data-ttu-id="3459c-176">Użyj <xref:System.Runtime.InteropServices.SafeHandle> wyczyścić zasoby systemu operacyjnego zamiast `Finalize`.</span><span class="sxs-lookup"><span data-stu-id="3459c-176">Use <xref:System.Runtime.InteropServices.SafeHandle> for cleaning up operating system resources instead of `Finalize`.</span></span> <span data-ttu-id="3459c-177">Nie używaj <xref:System.IntPtr>; użyj <xref:System.Runtime.InteropServices.SafeHandle> celu hermetyzacji zasobów.</span><span class="sxs-lookup"><span data-stu-id="3459c-177">Do not use <xref:System.IntPtr>; use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate resources.</span></span> <span data-ttu-id="3459c-178">Jeśli na końcu klauzuli należy uruchomić, umieść go w CER.</span><span class="sxs-lookup"><span data-stu-id="3459c-178">If the finally clause must run, place it in a CER.</span></span>  
  
### <a name="all-locks-should-go-through-existing-managed-locking-code"></a><span data-ttu-id="3459c-179">Wszystkie blokady powinny przechodzić przez istniejący kod do blokowania zarządzanych</span><span class="sxs-lookup"><span data-stu-id="3459c-179">All Locks Should Go Through Existing Managed Locking Code</span></span>  
 <span data-ttu-id="3459c-180">Środowisko CLR musi znać, jeśli kod jest w blokadę, dzięki czemu będzie wiadomo, aby usunąć <xref:System.AppDomain> zamiast po prostu zostanie przerwany wątek.</span><span class="sxs-lookup"><span data-stu-id="3459c-180">The CLR must know when code is in a lock so that it will know to tear down the <xref:System.AppDomain> rather than just aborting the thread.</span></span>  <span data-ttu-id="3459c-181">Trwa przerywanie wątku może być niebezpieczne, ponieważ dane przetwarzane przez wątek może pozostać w stanie niespójnym.</span><span class="sxs-lookup"><span data-stu-id="3459c-181">Aborting the thread could be dangerous as the data operated on by the thread could be left in an inconsistent state.</span></span> <span data-ttu-id="3459c-182">W związku z tym, całą <xref:System.AppDomain> ma zostać odzyskany.</span><span class="sxs-lookup"><span data-stu-id="3459c-182">Therefore, the entire <xref:System.AppDomain> has to be recycled.</span></span>  <span data-ttu-id="3459c-183">Konsekwencje kończy się niepowodzeniem zidentyfikować blokady może być zakleszczenia lub niepoprawne wyniki.</span><span class="sxs-lookup"><span data-stu-id="3459c-183">The consequences of failing to identify a lock can be either deadlocks or incorrect results.</span></span> <span data-ttu-id="3459c-184">Użyj metod <xref:System.Threading.Thread.BeginCriticalRegion%2A> i <xref:System.Threading.Thread.EndCriticalRegion%2A> do identyfikowania regionów blokady.</span><span class="sxs-lookup"><span data-stu-id="3459c-184">Use the methods <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> to identify lock regions.</span></span>  <span data-ttu-id="3459c-185">Są one metody statyczne <xref:System.Threading.Thread> klasy, które mają zastosowanie tylko do bieżącego wątku, zapobiegając jeden wątek edytują liczbę blokad inny wątek.</span><span class="sxs-lookup"><span data-stu-id="3459c-185">They are static methods on the <xref:System.Threading.Thread> class that only apply to the current thread, helping to prevent one thread from editing another thread’s lock count.</span></span>  
  
 <span data-ttu-id="3459c-186"><xref:System.Threading.Monitor.Enter%2A> i <xref:System.Threading.Monitor.Exit%2A> ma to powiadomienie CLR wbudowane, w związku z czym zaleca się ich użycia oraz korzystanie z [lock — instrukcja](~/docs/csharp/language-reference/keywords/lock-statement.md), który używa tych metod.</span><span class="sxs-lookup"><span data-stu-id="3459c-186"><xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> have this CLR notification built in, so their usage is recommended as well as the use of the [lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md), which uses these methods.</span></span>  
  
 <span data-ttu-id="3459c-187">Inne blokowania mechanizmów, takich jak pokrętła blokad i <xref:System.Threading.AutoResetEvent> musi wywoływać te metody, aby powiadomić środowiska CLR jest wprowadzanych sekcję krytyczną.</span><span class="sxs-lookup"><span data-stu-id="3459c-187">Other locking mechanisms such as spin locks and <xref:System.Threading.AutoResetEvent> must call these methods to notify the CLR that a critical section is being entered.</span></span>  <span data-ttu-id="3459c-188">Te metody nie przyjmują żadnych blokad; informują środowisko CLR, że kod jest wykonywany w sekcję krytyczną, i zostanie przerwany wątek może pozostawić niespójne udostępnionego stanu.</span><span class="sxs-lookup"><span data-stu-id="3459c-188">These methods do not take any locks; they inform the CLR that code is executing in a critical section and aborting the thread could leave shared state inconsistent.</span></span>  <span data-ttu-id="3459c-189">Jeśli zdefiniowano swój własny typ blokady, takie jak niestandardowe <xref:System.Threading.ReaderWriterLock> klasy, należy użyć następujących metod licznik blokady.</span><span class="sxs-lookup"><span data-stu-id="3459c-189">If you have defined your own lock type, such as a custom <xref:System.Threading.ReaderWriterLock> class, use these lock count methods.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3459c-190">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3459c-190">Code Analysis Rule</span></span>  
 <span data-ttu-id="3459c-191">Oznacz i zidentyfikować wszystkie blokady przy użyciu <xref:System.Threading.Thread.BeginCriticalRegion%2A> i <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="3459c-191">Mark and identify all locks using <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span></span> <span data-ttu-id="3459c-192">Nie używaj <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A>, i <xref:System.Threading.Interlocked.Decrement%2A> w pętli.</span><span class="sxs-lookup"><span data-stu-id="3459c-192">Do not use <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A>, and <xref:System.Threading.Interlocked.Decrement%2A> in a loop.</span></span>  <span data-ttu-id="3459c-193">Nie wykonuj platformę wywołania wariantów Win32 tych metod.</span><span class="sxs-lookup"><span data-stu-id="3459c-193">Do not do a platform invoke of the Win32 variants of these methods.</span></span>  <span data-ttu-id="3459c-194">Nie używaj <xref:System.Threading.Thread.Sleep%2A> w pętli.</span><span class="sxs-lookup"><span data-stu-id="3459c-194">Do not use <xref:System.Threading.Thread.Sleep%2A> in a loop.</span></span>  <span data-ttu-id="3459c-195">Nie należy używać pola nietrwałego.</span><span class="sxs-lookup"><span data-stu-id="3459c-195">Do not use volatile fields.</span></span>  
  
### <a name="cleanup-code-must-be-in-a-finally-or-a-catch-block-not-following-a-catch"></a><span data-ttu-id="3459c-196">Oczyszczanie kodu musi znajdować się w na końcu lub bloku catch bloku, nie następujących instrukcji catch</span><span class="sxs-lookup"><span data-stu-id="3459c-196">Cleanup Code Must Be in a finally or a catch Block, Not Following a catch</span></span>  
 <span data-ttu-id="3459c-197">Kod porządkujący nigdy nie należy stosować `catch` Blokuj; powinien znajdować się w `finally` lub `catch` block sam.</span><span class="sxs-lookup"><span data-stu-id="3459c-197">Cleanup code should never follow a `catch` block; it should be in a `finally` or in the `catch` block itself.</span></span>  <span data-ttu-id="3459c-198">Powinna to być normalne, dobrym rozwiązaniem.</span><span class="sxs-lookup"><span data-stu-id="3459c-198">This should be a normal good practice.</span></span>  <span data-ttu-id="3459c-199">A `finally` blok jest ogólnie metoda preferowana, ponieważ działa ten sam kod i gdy wyjątek jest zgłaszany po końcu `try` bloku normalnie zostanie osiągnięty.</span><span class="sxs-lookup"><span data-stu-id="3459c-199">A `finally` block is generally preferred because it runs the same code both when an exception is thrown and when the end of the `try` block is normally encountered.</span></span>  <span data-ttu-id="3459c-200">W przypadku nieoczekiwanych rzuceniem wyjątku, na przykład <xref:System.Threading.ThreadAbortException>, czyszczenie kodu nie zostaną uruchomione.</span><span class="sxs-lookup"><span data-stu-id="3459c-200">In the event of an unexpected exception being thrown, for example a <xref:System.Threading.ThreadAbortException>, the cleanup code will not run.</span></span>  <span data-ttu-id="3459c-201">Dowolne niezarządzanych zasobów, które może wyczyścić w `finally` najlepiej musi być ujęte w <xref:System.Runtime.InteropServices.SafeHandle> aby zapobiec przeciekom.</span><span class="sxs-lookup"><span data-stu-id="3459c-201">Any unmanaged resources that you would clean up in a `finally` should ideally be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle> to prevent leaks.</span></span>  <span data-ttu-id="3459c-202">Uwaga C# `using` — słowo kluczowe można efektywnie używać do usuwania obiektów, w tym uchwyty.</span><span class="sxs-lookup"><span data-stu-id="3459c-202">Note the C# `using` keyword can be used effectively to dispose of objects, including handles.</span></span>  
  
 <span data-ttu-id="3459c-203">Mimo że <xref:System.AppDomain> odtwarzanie można wyczyścić zasobów w wątku finalizatora, są nadal ważne umieścić kod porządkujący w odpowiednim miejscu.</span><span class="sxs-lookup"><span data-stu-id="3459c-203">Although <xref:System.AppDomain> recycling can clean up resources on the finalizer thread, it is still important to put cleanup code in the correct place.</span></span>  <span data-ttu-id="3459c-204">Należy pamiętać, że jeśli wątek otrzyma wyjątku asynchronicznego bez blokady, środowisko CLR próbuje zakończyć wątek bez konieczności odtwarzanie <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="3459c-204">Note that if a thread receives an asynchronous exception without holding a lock, the CLR attempts to end the thread itself without having to recycle the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="3459c-205">Zapewnienie, że zasoby są czyszczone wcześniej zamiast nowsze pomaga udostępnienia większej ilości zasobów i lepsze zarządzanie okresem istnienia.</span><span class="sxs-lookup"><span data-stu-id="3459c-205">Ensuring that resources are cleaned up sooner rather than later helps by making more resources available, and by better managing the lifetime.</span></span>  <span data-ttu-id="3459c-206">Jeśli nie zamykaj jawnie dojście do pliku w ścieżce kodu niektórych błędów Zaczekaj, aż <xref:System.Runtime.InteropServices.SafeHandle> finalizator oczyścić je, przy następnym kod jest wykonywany może zakończyć się niepowodzeniem próby uzyskania dostępu dokładnie tego samego pliku, jeśli finalizator nie został już uruchomiony.</span><span class="sxs-lookup"><span data-stu-id="3459c-206">If you do not explicitly close a handle to a file in some error code path then wait for the <xref:System.Runtime.InteropServices.SafeHandle> finalizer to clean it up, the next time your code runs it may fail trying to access the exact same file if the finalizer has not already run.</span></span>  <span data-ttu-id="3459c-207">Z tego powodu, może pomóc zagwarantowanie, że kod porządkujący istnieje i czy działa poprawnie odzyskiwanie po niepowodzeniach bardziej i szybko, mimo że nie jest bezwzględnie konieczne.</span><span class="sxs-lookup"><span data-stu-id="3459c-207">For this reason, ensuring that cleanup code exists and works correctly will help recover from failures more cleanly and quickly, even though it is not strictly necessary.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3459c-208">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3459c-208">Code Analysis Rule</span></span>  
 <span data-ttu-id="3459c-209">Kod porządkujący po `catch` musi być zapisana w `finally` bloku.</span><span class="sxs-lookup"><span data-stu-id="3459c-209">Cleanup code after `catch` needs to be in a `finally` block.</span></span> <span data-ttu-id="3459c-210">Wywołania do usuwania w bloku finally.</span><span class="sxs-lookup"><span data-stu-id="3459c-210">Place calls to dispose in a finally block.</span></span>  <span data-ttu-id="3459c-211">`catch` bloki powinien kończyć się throw lub Zgłoś ponownie.</span><span class="sxs-lookup"><span data-stu-id="3459c-211">`catch` blocks should end in a throw or rethrow.</span></span>  <span data-ttu-id="3459c-212">Podczas, gdy będzie istnieć wyjątki, takie jak kod wykrywanie, czy można nawiązać połączenia sieciowego może skąd znajdujących się w dużej liczby wyjątków, wszelki kod, który wymaga Przechwytywanie liczba wyjątków w normalnych warunkach powinien zapewnić wskazanie, że kod powinien być przetestowane, jeśli powiedzie.</span><span class="sxs-lookup"><span data-stu-id="3459c-212">While there will be exceptions, such as code detecting whether a network connection can be established where you might get any of a large number of exceptions, any code that requires the catching of a number of exceptions under normal circumstances should give an indication that the code should be tested to see if it will succeed.</span></span>  
  
### <a name="process-wide-mutable-shared-state-between-application-domains-should-be-eliminated-or-use-a-constrained-execution-region"></a><span data-ttu-id="3459c-213">Modyfikowalne udostępnionego stanu całego procesu między domenami aplikacji powinny zostać usunięte, lub użyj Region ograniczonego wykonania</span><span class="sxs-lookup"><span data-stu-id="3459c-213">Process-Wide Mutable Shared State Between Application Domains Should Be Eliminated or Use a Constrained Execution Region</span></span>  
 <span data-ttu-id="3459c-214">Zgodnie z opisem we wstępie, może być bardzo trudne do pisania kodu zarządzanego, który monitoruje stan udostępnione całego procesu między domenami aplikacji w sposób niezawodny.</span><span class="sxs-lookup"><span data-stu-id="3459c-214">As described in the introduction, it can be very difficult to write managed code that monitors process-wide shared state across application domains in a reliable manner.</span></span>  <span data-ttu-id="3459c-215">Stan udostępnione całego procesu jest dowolny rodzaj struktury danych współużytkowane między domenami aplikacji, albo w kodzie Win32, wewnątrz środowiska CLR lub w kodzie zarządzanym przy użyciu komunikacji zdalnej.</span><span class="sxs-lookup"><span data-stu-id="3459c-215">Process-wide shared state is any sort of data structure shared between application domains, either in Win32 code, inside the CLR, or in managed code using remoting.</span></span>  <span data-ttu-id="3459c-216">Dowolny modyfikowalny stan udostępnionych jest bardzo trudno jest poprawnie zapisać w kodzie zarządzanym i wszystkie statyczne udostępnionego stanu może odbywać się tylko w przypadku szczególną uwagę.</span><span class="sxs-lookup"><span data-stu-id="3459c-216">Any mutable shared state is very difficult to correctly write in managed code, and any static shared state might be done only with great care.</span></span>  <span data-ttu-id="3459c-217">Jeśli masz całego procesu lub dla komputera udostępnionego stanu, Znajdź jakiś sposób, aby wyeliminować go lub chronić udostępnionego stanu przy użyciu region ograniczonego wykonania (CER).</span><span class="sxs-lookup"><span data-stu-id="3459c-217">If you have process-wide or machine-wide shared state, find some way to eliminate it or protect the shared state using a constrained execution region (CER).</span></span>  <span data-ttu-id="3459c-218">Wszystkie biblioteki, za pomocą udostępnionego stanu, który nie jest zidentyfikowała i poprawiła powodować hosta, takie jak SQL Server, wymaga czyszczenie <xref:System.AppDomain> zwalnianie ulega awarii.</span><span class="sxs-lookup"><span data-stu-id="3459c-218">Note that any library with shared state that is not identified and corrected could cause a host, such as SQL Server, that requires clean <xref:System.AppDomain> unloading to crash.</span></span>  
  
 <span data-ttu-id="3459c-219">Jeśli kod używa obiektu COM, Unikaj udostępniania tego obiektu COM między domenami aplikacji.</span><span class="sxs-lookup"><span data-stu-id="3459c-219">If code uses a COM object, avoid sharing that COM object between application domains.</span></span>  
  
### <a name="locks-do-not-work-process-wide-or-between-application-domains"></a><span data-ttu-id="3459c-220">Blokady nie działają całego procesu lub między domenami aplikacji.</span><span class="sxs-lookup"><span data-stu-id="3459c-220">Locks Do Not Work Process-Wide or Between Application Domains.</span></span>  
 <span data-ttu-id="3459c-221">W przeszłości <xref:System.Threading.Monitor.Enter%2A> i [lock — instrukcja](~/docs/csharp/language-reference/keywords/lock-statement.md) zostały użyte w celu tworzenia procesu globalnego blokad.</span><span class="sxs-lookup"><span data-stu-id="3459c-221">In the past, <xref:System.Threading.Monitor.Enter%2A> and the [lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md) have been used to create global process locks.</span></span>  <span data-ttu-id="3459c-222">Na przykład ten błąd występuje podczas blokowania na <xref:System.AppDomain> klasy agile, takich jak <xref:System.Type> wystąpień z zestawów nieudostępnione, <xref:System.Threading.Thread> obiektów, interned ciągów i niektóre parametry współużytkowane w różnych domenach aplikacji przy użyciu komunikacji zdalnej.</span><span class="sxs-lookup"><span data-stu-id="3459c-222">For example, this occurs when locking on <xref:System.AppDomain> agile classes, such as <xref:System.Type> instances from non-shared assemblies, <xref:System.Threading.Thread> objects, interned strings, and some strings shared across application domains using remoting.</span></span>  <span data-ttu-id="3459c-223">Te blokady nie są już całego procesu.</span><span class="sxs-lookup"><span data-stu-id="3459c-223">These locks are no longer process-wide.</span></span>  <span data-ttu-id="3459c-224">Aby zidentyfikować obecności blokady domeny interapplication całego procesu, należy określić, czy kod w blokady korzysta dowolnych zasobów zewnętrznych, utrwalonych takiego jak plik na dysku, lub ewentualnie bazy danych.</span><span class="sxs-lookup"><span data-stu-id="3459c-224">To identify the presence of a process-wide interapplication domain lock, determine if the code within the lock uses any external, persisted resource such as a file on disk or possibly a database.</span></span>  
  
 <span data-ttu-id="3459c-225">Należy pamiętać, biorąc blokady w ramach <xref:System.AppDomain> może spowodować problemy, jeśli chroniony kod używa zewnętrznego zasobu, ponieważ ten kod może jednocześnie działać w wielu domenach aplikacji.</span><span class="sxs-lookup"><span data-stu-id="3459c-225">Note that taking a lock within an <xref:System.AppDomain> might cause problems if the protected code uses an external resource because that code may run simultaneously across multiple application domains.</span></span>  <span data-ttu-id="3459c-226">Może to być problem podczas zapisywania jeden plik dziennika lub powiązania z gniazdem dla całego procesu.</span><span class="sxs-lookup"><span data-stu-id="3459c-226">This can be a problem when writing to one log file or binding to a socket for the entire process.</span></span>  <span data-ttu-id="3459c-227">Te zmiany oznaczają, nie istnieje łatwy sposób, przy użyciu kodu zarządzanego, można uzyskać blokady globalnego procesu, na innych niż z użyciem nazwane <xref:System.Threading.Mutex> lub <xref:System.Threading.Semaphore> wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="3459c-227">These changes mean there is no easy way, using managed code, to get a process-global lock, other than using a named <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> instance.</span></span>  <span data-ttu-id="3459c-228">Tworzenie kodu, które nie jednoczesnego uruchamiania w dwóch domenach aplikacji, lub użyj <xref:System.Threading.Mutex> lub <xref:System.Threading.Semaphore> klasy.</span><span class="sxs-lookup"><span data-stu-id="3459c-228">Create code that does not run in two application domains simultaneously, or use the <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> classes.</span></span>  <span data-ttu-id="3459c-229">Nie można zmienić istniejący kod, nie używać Win32, w nazwie obiektu mutex do osiągnięcia tej synchronizacji, ponieważ uruchomiony w trybie włókien oznacza, że nie może zagwarantować, tym samym wątku systemu operacyjnego zostanie nabywania i wersji elementu mutex.</span><span class="sxs-lookup"><span data-stu-id="3459c-229">If existing code cannot be changed, do not use a Win32 named mutex to achieve this synchronization because running in fiber mode means you cannot guarantee the same operating system thread will acquire and release a mutex.</span></span>  <span data-ttu-id="3459c-230">Należy użyć zarządzanego <xref:System.Threading.Mutex> klasy lub nazwane <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent>, lub <xref:System.Threading.Semaphore> do synchronizowania blokady kodu w sposób, że środowisko CLR jest świadomy zamiast synchronizowanie blokady przy użyciu kodu niezarządzanego.</span><span class="sxs-lookup"><span data-stu-id="3459c-230">You must use the managed <xref:System.Threading.Mutex> class, or a named <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent>, or a <xref:System.Threading.Semaphore> to synchronize the code lock in a manner that the CLR is aware of instead of synchronizing the lock using unmanaged code.</span></span>  
  
#### <a name="avoid-locktypeofmytype"></a><span data-ttu-id="3459c-231">Należy unikać lock(typeof(MyType))</span><span class="sxs-lookup"><span data-stu-id="3459c-231">Avoid lock(typeof(MyType))</span></span>  
 <span data-ttu-id="3459c-232">Prywatne i publiczne <xref:System.Type> obiektów w zestawów współużytkowanych z tylko jedną kopię kodu współużytkowane przez wszystkie domeny aplikacji również stwarzać problemy.</span><span class="sxs-lookup"><span data-stu-id="3459c-232">Private and public <xref:System.Type> objects in shared assemblies with only one copy of the code shared across all application domains also present problems.</span></span>  <span data-ttu-id="3459c-233">Dla zestawów współużytkowanych istnieje tylko jedno wystąpienie <xref:System.Type> poszczególnym procesom, co oznacza, że wiele domen aplikacji udostępniać dokładnie takie same <xref:System.Type> wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="3459c-233">For shared assemblies, there is only one instance of a <xref:System.Type> per process, meaning that multiple application domains share the exact same <xref:System.Type> instance.</span></span>  <span data-ttu-id="3459c-234">Biorąc blokadę <xref:System.Type> wystąpienia ma blokadę, który nie ma wpływ na cały proces, po prostu z <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="3459c-234">Taking a lock on a <xref:System.Type> instance takes a lock that affects the entire process, not just the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="3459c-235">Jeśli taki <xref:System.AppDomain> zdobywa blokadę <xref:System.Type> następnie obiektu, że wątek pobiera nagle przerwany, nie zwolni blokadę.</span><span class="sxs-lookup"><span data-stu-id="3459c-235">If one <xref:System.AppDomain> takes a lock on a <xref:System.Type> object then that thread gets abruptly aborted, it will not release the lock.</span></span>  <span data-ttu-id="3459c-236">Ta blokada może spowodować innych domenach aplikacji zakleszczenie.</span><span class="sxs-lookup"><span data-stu-id="3459c-236">This lock then may cause other application domains to deadlock.</span></span>  
  
 <span data-ttu-id="3459c-237">Dobrym sposobem zająć blokad metody statyczne obejmuje dodanie obiektu statyczne wewnętrzne synchronizacji do kodu.</span><span class="sxs-lookup"><span data-stu-id="3459c-237">A good way to take locks in static methods involves adding a static internal synchronization object to the code.</span></span>  <span data-ttu-id="3459c-238">Można jej zainicjować w konstruktorze klasy są dostępne, ale nie mogą być inicjowane następująco:</span><span class="sxs-lookup"><span data-stu-id="3459c-238">This could be initialized in the class constructor if one is present, but if not it can be initialized like this:</span></span>  
  
```  
private static Object s_InternalSyncObject;  
private static Object InternalSyncObject   
{  
    get   
    {  
        if (s_InternalSyncObject == null)   
        {  
            Object o = new Object();  
            Interlocked.CompareExchange(  
                ref s_InternalSyncObject, o, null);  
        }  
        return s_InternalSyncObject;  
    }  
}  
```  
  
 <span data-ttu-id="3459c-239">Następnie robiąc blokadę, użyj `InternalSyncObject` właściwości do uzyskiwania obiektu do blokowania na.</span><span class="sxs-lookup"><span data-stu-id="3459c-239">Then when taking a lock, use the `InternalSyncObject` property to obtain an object to lock on.</span></span>  <span data-ttu-id="3459c-240">Nie trzeba użyć właściwości, jeśli obiekt wewnętrzny synchronizacji zainicjują w konstruktora klasy.</span><span class="sxs-lookup"><span data-stu-id="3459c-240">You do not need to use the property if you have initialized the internal synchronization object in your class constructor.</span></span>  <span data-ttu-id="3459c-241">Podwójne sprawdzanie, czy kod inicjujący blokady powinien wyglądać następująco:</span><span class="sxs-lookup"><span data-stu-id="3459c-241">The double checking lock initialization code should look like this example:</span></span>  
  
```  
public static MyClass SingletonProperty   
{  
    get   
    {  
        if (s_SingletonProperty == null)   
        {  
            lock(InternalSyncObject)   
            {  
                // Do not use lock(typeof(MyClass))   
                if (s_SingletonProperty == null)   
                {  
                    MyClass tmp = new MyClass(…);     
                    // Do all initialization before publishing  
                    s_SingletonProperty = tmp;  
                }  
            }  
        }  
        return s_SingletonProperty;  
    }  
}  
```  
  
#### <a name="a-note-about-lockthis"></a><span data-ttu-id="3459c-242">Uwaga dotycząca Lock(this)</span><span class="sxs-lookup"><span data-stu-id="3459c-242">A Note About Lock(this)</span></span>  
 <span data-ttu-id="3459c-243">Na ogół dopuszczalne jest podjęcie blokadę wybranego obiektu, który jest publicznie dostępny.</span><span class="sxs-lookup"><span data-stu-id="3459c-243">It is generally acceptable to take a lock on an individual object that is publicly accessible.</span></span>  <span data-ttu-id="3459c-244">Jednak jeśli obiekt jest pojedynczego obiektu, który może spowodować, że cały podsystemu do zakleszczenia, należy wziąć pod uwagę przy użyciu powyższych wzorca projektowego także.</span><span class="sxs-lookup"><span data-stu-id="3459c-244">However, if the object is a singleton object that might cause an entire subsystem to deadlock, consider using the above design pattern as well.</span></span>  <span data-ttu-id="3459c-245">Na przykład blokadę na architekturze <xref:System.Security.SecurityManager> obiektu może spowodować zakleszczenie w ramach <xref:System.AppDomain> wprowadzania całą <xref:System.AppDomain> uniemożliwiającym jego używanie.</span><span class="sxs-lookup"><span data-stu-id="3459c-245">For example, a lock on the one <xref:System.Security.SecurityManager> object could cause a deadlock within the <xref:System.AppDomain> making the entire <xref:System.AppDomain> unusable.</span></span> <span data-ttu-id="3459c-246">Jest dobrą praktyką, aby nie stosuje blokadę publicznie obiektu tego typu.</span><span class="sxs-lookup"><span data-stu-id="3459c-246">It is good practice to not take a lock on a publicly accessible object of this type.</span></span>  <span data-ttu-id="3459c-247">Jednak blokadę poszczególnych kolekcji lub tablicy, powinien ogólnie nieobecne problem.</span><span class="sxs-lookup"><span data-stu-id="3459c-247">However a lock on an individual collection or array should generally not present a problem.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3459c-248">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3459c-248">Code Analysis Rule</span></span>  
 <span data-ttu-id="3459c-249">Nie przyjmują blokady na typy, które mogą być używane w różnych domenach aplikacji, lub nie ma silnej poczucie tożsamości.</span><span class="sxs-lookup"><span data-stu-id="3459c-249">Do not take locks on types that might be used across application domains or do not have a strong sense of identity.</span></span> <span data-ttu-id="3459c-250">Nie wywołuj <xref:System.Threading.Monitor.Enter%2A> na <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread>, lub dowolnego obiektu, który pochodzi od klasy <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="3459c-250">Do not call <xref:System.Threading.Monitor.Enter%2A> on a <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread>, or any object that derives from <xref:System.MarshalByRefObject>.</span></span>  
  
### <a name="remove-gckeepalive-calls"></a><span data-ttu-id="3459c-251">Usuń wykaz Globalny. Wywołania utrzymywania aktywności</span><span class="sxs-lookup"><span data-stu-id="3459c-251">Remove GC.KeepAlive Calls</span></span>  
 <span data-ttu-id="3459c-252">Znacząca ilość kodu istniejących albo nie używa <xref:System.GC.KeepAlive%2A> po powinny lub używa ich, gdy nie jest właściwe.</span><span class="sxs-lookup"><span data-stu-id="3459c-252">A significant amount of existing code either does not use <xref:System.GC.KeepAlive%2A> when it should or uses it when it is not appropriate.</span></span>  <span data-ttu-id="3459c-253">Po przekonwertowaniu do <xref:System.Runtime.InteropServices.SafeHandle>, nie trzeba wywołać klasy <xref:System.GC.KeepAlive%2A>, zakładając, że nie ma finalizatora, ale korzystają z <xref:System.Runtime.InteropServices.SafeHandle> Aby sfinalizować system operacyjny obsługuje.</span><span class="sxs-lookup"><span data-stu-id="3459c-253">After converting to <xref:System.Runtime.InteropServices.SafeHandle>, classes do not need to call <xref:System.GC.KeepAlive%2A>, assuming they do not have a finalizer but rely on <xref:System.Runtime.InteropServices.SafeHandle> to finalize the operating system handles.</span></span>  <span data-ttu-id="3459c-254">While spadek wydajności przy zachowaniu wywołanie <xref:System.GC.KeepAlive%2A> może być nieznaczny, wrażenie, wywołanie <xref:System.GC.KeepAlive%2A> jest konieczne lub wystarczające, aby rozwiązać problem, który już nie istnieje sprawia, że kod jest bardziej trudne w utrzymaniu okres istnienia.</span><span class="sxs-lookup"><span data-stu-id="3459c-254">While the performance cost of retaining a call to <xref:System.GC.KeepAlive%2A> may be negligible, the perception that a call to <xref:System.GC.KeepAlive%2A> is either necessary or sufficient to solve a lifetime issue that may no longer exist makes the code more difficult to maintain.</span></span>  <span data-ttu-id="3459c-255">Jednakże, w przypadku korzystania z międzyoperacyjnego CLR wywoływanych otok COM (RCW) <xref:System.GC.KeepAlive%2A> jest nadal wymagana przez kod.</span><span class="sxs-lookup"><span data-stu-id="3459c-255">However, when using the COM interop CLR callable wrappers (RCWs), <xref:System.GC.KeepAlive%2A> is still required by code.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3459c-256">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3459c-256">Code Analysis Rule</span></span>  
 <span data-ttu-id="3459c-257">Usuń <xref:System.GC.KeepAlive%2A>.</span><span class="sxs-lookup"><span data-stu-id="3459c-257">Remove <xref:System.GC.KeepAlive%2A>.</span></span>  
  
### <a name="use-the-host-protection-attribute"></a><span data-ttu-id="3459c-258">Użyj atrybutu ochrony hosta</span><span class="sxs-lookup"><span data-stu-id="3459c-258">Use the Host Protection Attribute</span></span>  
 <span data-ttu-id="3459c-259"><xref:System.Security.Permissions.HostProtectionAttribute> (HPA) umożliwia korzystanie z akcji zabezpieczenia deklaratywne określenie wymagań dotyczących ochrony hosta, co hosta uniemożliwić wywoływania niektórych metod, które nie mają zastosowania do danego hosta, takie jak jeszczecałkowiciezaufanegokodu<xref:System.Environment.Exit%2A>lub <xref:System.Windows.Forms.MessageBox.Show%2A> dla programu SQL Server.</span><span class="sxs-lookup"><span data-stu-id="3459c-259">The <xref:System.Security.Permissions.HostProtectionAttribute> (HPA) provides the use of declarative security actions to determine host protection requirements, allowing the host to prevent even fully trusted code from calling certain methods which are inappropriate for the given host, such as <xref:System.Environment.Exit%2A> or <xref:System.Windows.Forms.MessageBox.Show%2A> for SQL Server.</span></span>  
  
 <span data-ttu-id="3459c-260">HPA dotyczy tylko niezarządzanych aplikacji obsługujących wspólnego języka środowiska uruchomieniowego i wdrożenie hosta ochrony, takie jak SQL Server.</span><span class="sxs-lookup"><span data-stu-id="3459c-260">The HPA affects only unmanaged applications that host the common language runtime and implement host protection, such as SQL Server.</span></span> <span data-ttu-id="3459c-261">Po zastosowaniu, wyniki akcji zabezpieczeń, w przypadku tworzenia zapotrzebowania na łącza na podstawie zasobów hosta ujawnia klasy lub metody.</span><span class="sxs-lookup"><span data-stu-id="3459c-261">When applied, the security action results in the creation of a link demand based on the host resources the class or method exposes.</span></span> <span data-ttu-id="3459c-262">Jeśli kod jest uruchamiany w aplikacji klienckiej lub na serwerze, który nie jest chroniony host, atrybut "evaporates"; Nie wykryto i w związku z tym nie zastosować.</span><span class="sxs-lookup"><span data-stu-id="3459c-262">If the code is run in a client application or on a server that is not host-protected, the attribute "evaporates"; it is not detected and therefore not applied.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3459c-263">Ten atrybut ma na celu wymuszania specyficzne dla hosta wytycznych programowania modelu, nie działanie zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="3459c-263">The purpose of this attribute is to enforce host-specific programming model guidelines, not security behavior.</span></span>  <span data-ttu-id="3459c-264">Mimo że zapotrzebowania na łącza służy pod kątem zgodności, wymagań modelu programowania <xref:System.Security.Permissions.HostProtectionAttribute> nie jest uprawnienia zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="3459c-264">Although a link demand is used to check for conformance to programming model requirements, the <xref:System.Security.Permissions.HostProtectionAttribute> is not a security permission.</span></span>  
  
 <span data-ttu-id="3459c-265">Jeśli host nie ma wymagań modelu programowania, nie występują zapotrzebowania na łącza.</span><span class="sxs-lookup"><span data-stu-id="3459c-265">If the host does not have programming model requirements, the link demands do not occur.</span></span>  
  
 <span data-ttu-id="3459c-266">Ten atrybut określa następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="3459c-266">This attribute identifies the following:</span></span>  
  
-   <span data-ttu-id="3459c-267">Metod lub klas, które nie pasują do hostów programowania modelu, ale są one w przeciwnym razie niegroźne.</span><span class="sxs-lookup"><span data-stu-id="3459c-267">Methods or classes that do not fit the host programming model, but are otherwise benign.</span></span>  
  
-   <span data-ttu-id="3459c-268">Metod lub klas, które nie mieszczą się model programowania hosta i może prowadzić do destabilizujące kod zarządzany serwer użytkownika.</span><span class="sxs-lookup"><span data-stu-id="3459c-268">Methods or classes that do not fit the host programming model and could lead to destabilizing server-managed user code.</span></span>  
  
-   <span data-ttu-id="3459c-269">Metod lub klas, które nie pasują do hostów programowania modelu i może prowadzić do destabilizacji sam proces serwera.</span><span class="sxs-lookup"><span data-stu-id="3459c-269">Methods or classes that do not fit the host programming model and could lead to a destabilization of the server process itself.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3459c-270">Jeśli tworzysz bibliotekę klas, który ma być wywoływany przez aplikacje, które może być wykonywane w środowisku hosta chronionego, należy zastosować ten atrybut do elementów członkowskich, które uwidaczniają <xref:System.Security.Permissions.HostProtectionResource> kategorie zasobów.</span><span class="sxs-lookup"><span data-stu-id="3459c-270">If you are creating a class library that is to be called by applications that may execute in a host protected environment, you should apply this attribute to members that expose <xref:System.Security.Permissions.HostProtectionResource> resource categories.</span></span> <span data-ttu-id="3459c-271">Elementy członkowskie biblioteki klas .NET Framework z tym atrybutem spowodować, że tylko bezpośredniego wywołującego do sprawdzenia.</span><span class="sxs-lookup"><span data-stu-id="3459c-271">The .NET Framework class library members with this attribute cause only the immediate caller to be checked.</span></span>  <span data-ttu-id="3459c-272">Biblioteka elementów członkowskich również mogą powodować sprawdzenie jego bezpośredniego obiektu wywołującego w taki sam sposób.</span><span class="sxs-lookup"><span data-stu-id="3459c-272">Your library member must also cause a check of its immediate caller in the same manner.</span></span>  
  
 <span data-ttu-id="3459c-273">Można znaleźć więcej informacji na temat HPA w <xref:System.Security.Permissions.HostProtectionAttribute>.</span><span class="sxs-lookup"><span data-stu-id="3459c-273">Please find more information on HPA in <xref:System.Security.Permissions.HostProtectionAttribute>.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3459c-274">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3459c-274">Code Analysis Rule</span></span>  
 <span data-ttu-id="3459c-275">Dla programu SQL Server wszystkie metody używane do wprowadzania synchronizacji lub wątkowości musi oznaczone symbolem hPa pakietu.</span><span class="sxs-lookup"><span data-stu-id="3459c-275">For SQL Server, all methods used to introduce synchronization or threading must identified with the HPA.</span></span> <span data-ttu-id="3459c-276">Obejmuje to metody, które udostępnianie stanu są synchronizowane i zarządzać procesami zewnętrznych.</span><span class="sxs-lookup"><span data-stu-id="3459c-276">This includes methods that share state, are synchronized, or manage external processes.</span></span> <span data-ttu-id="3459c-277"><xref:System.Security.Permissions.HostProtectionResource> Wartości, które mają wpływ na program SQL Server są <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization>, i <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span><span class="sxs-lookup"><span data-stu-id="3459c-277">The <xref:System.Security.Permissions.HostProtectionResource> values that impact SQL Server are <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization>, and <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span></span> <span data-ttu-id="3459c-278">Jednak dowolnej metody, która udostępnia żadnego <xref:System.Security.Permissions.HostProtectionResource> byli definiowani przez HPA, nie tylko te, które korzysta z zasobów mających wpływ na SQL.</span><span class="sxs-lookup"><span data-stu-id="3459c-278">However, any method that exposes any <xref:System.Security.Permissions.HostProtectionResource> should be identified by a HPA, not just those using resources affecting SQL.</span></span>  
  
### <a name="do-not-block-indefinitely-in-unmanaged-code"></a><span data-ttu-id="3459c-279">W kodzie niezarządzanym nie blokują przez czas nieokreślony</span><span class="sxs-lookup"><span data-stu-id="3459c-279">Do Not Block Indefinitely in Unmanaged Code</span></span>  
 <span data-ttu-id="3459c-280">Blokowanie w programie kodu niezarządzanego, zamiast w kodzie zarządzanym może spowodować "odmowa usługi", ponieważ środowisko CLR nie jest w stanie przerwania wątku.</span><span class="sxs-lookup"><span data-stu-id="3459c-280">Blocking in unmanaged code instead of in managed code can cause a denial of service attack because the CLR is not able to abort the thread.</span></span>  <span data-ttu-id="3459c-281">Zablokowany wątek zapobiega CLR zwalnianie <xref:System.AppDomain>, co najmniej bez wykonania tej czynności kilka bardzo niebezpieczny operacji.</span><span class="sxs-lookup"><span data-stu-id="3459c-281">A blocked thread prevents the CLR from unloading the <xref:System.AppDomain>, at least without doing some extremely unsafe operations.</span></span>  <span data-ttu-id="3459c-282">Blokuje, za pomocą systemu Win32 synchronizacji jest wyczyść przykładem coś, co firma Microsoft nie może dopuścić.</span><span class="sxs-lookup"><span data-stu-id="3459c-282">Blocking using a Win32 synchronization primitive is a clear example of something we cannot allow.</span></span>  <span data-ttu-id="3459c-283">Blokowanie w wywołaniu `ReadFile` na gniazdo należy unikać, jeśli jest to możliwe — najlepiej Win32 API należy zapewnić mechanizm operacji, takiej jak to przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="3459c-283">Blocking in a call to `ReadFile` on a socket should be avoided if possible — ideally the Win32 API should provide a mechanism for an operation like this to time out.</span></span>  
  
 <span data-ttu-id="3459c-284">Dowolną metodę, która wywołuje native najlepiej należy używać wywołanie Win32 z rozsądne, ograniczone Przekroczono limit czasu.</span><span class="sxs-lookup"><span data-stu-id="3459c-284">Any method that calls into native should ideally use a Win32 call with a reasonable, finite timeout.</span></span>  <span data-ttu-id="3459c-285">Jeśli użytkownik może określić limit czasu, użytkownik nie powinien określić nieskończony limit czasu bez pewnych uprawnień zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="3459c-285">If the user is allowed to specify the timeout, the user should not be allowed to specify an infinite timeout without some specific security permission.</span></span>  <span data-ttu-id="3459c-286">Zaleca się, jeśli metoda zablokuje się przez więcej niż ~ 10 sekund, należy korzystać z wersji, który obsługuje limity czasu lub potrzebujesz dodatkowej pomocy CLR.</span><span class="sxs-lookup"><span data-stu-id="3459c-286">As a guideline, if a method will block for more than ~10 seconds, you need to be using a version that supports timeouts or you need additional CLR support.</span></span>  
  
 <span data-ttu-id="3459c-287">Poniżej przedstawiono kilka przykładów problematyczne interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="3459c-287">Here are some examples of problematic API’s.</span></span>  <span data-ttu-id="3459c-288">Potoki (anonimowych i nazwanych) można tworzyć z limitem czasu; Jednakże, kod musi upewnić się, że nigdy nie wywołania `CreateNamedPipe` ani `WaitNamedPipe` z NMPWAIT_WAIT_FOREVER.</span><span class="sxs-lookup"><span data-stu-id="3459c-288">Pipes (both anonymous and named) can be created with a timeout; however, code must ensure it never calls `CreateNamedPipe` nor `WaitNamedPipe` with NMPWAIT_WAIT_FOREVER.</span></span>  <span data-ttu-id="3459c-289">Ponadto może wystąpić nieoczekiwany, blokowanie, nawet jeśli jest określony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="3459c-289">Additionally, there can be unexpected blocking even if a timeout is specified.</span></span>  <span data-ttu-id="3459c-290">Wywoływanie `WriteFile` na potoku anonimowego blokuje, dopóki nie zostaną zapisane wszystkie bajty, co oznacza, jeśli bufor składa się z nieprzeczytane dane, `WriteFile` blokuje wywołania do momentu czytnik ma zwolnienie miejsca w buforze potoku.</span><span class="sxs-lookup"><span data-stu-id="3459c-290">Calling `WriteFile` on an anonymous pipe will block until all bytes are written, meaning if the buffer has unread data in it, the `WriteFile` call will block until the reader has freed up space in the pipe’s buffer.</span></span>  <span data-ttu-id="3459c-291">Gniazda zawsze należy używać niektórych interfejsu API, który honoruje mechanizmu limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="3459c-291">Sockets should always use some API that honors a timeout mechanism.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3459c-292">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3459c-292">Code Analysis Rule</span></span>  
 <span data-ttu-id="3459c-293">Blokowanie bez limitu czasu w kodzie niezarządzanym jest typu "odmowa usługi".</span><span class="sxs-lookup"><span data-stu-id="3459c-293">Blocking without a timeout in unmanaged code is a denial of service attack.</span></span> <span data-ttu-id="3459c-294">Nie wykonuj platformy wywołania do `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects`, i `MsgWaitForMultipleObjectsEx`.</span><span class="sxs-lookup"><span data-stu-id="3459c-294">Do not perform platform invoke calls to `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects`, and `MsgWaitForMultipleObjectsEx`.</span></span>  <span data-ttu-id="3459c-295">Nie należy używać NMPWAIT_WAIT_FOREVER.</span><span class="sxs-lookup"><span data-stu-id="3459c-295">Do not use NMPWAIT_WAIT_FOREVER.</span></span>  
  
### <a name="identify-any-sta-dependent-features"></a><span data-ttu-id="3459c-296">Zidentyfikuj wszystkie funkcje zależne od STA.</span><span class="sxs-lookup"><span data-stu-id="3459c-296">Identify Any STA-Dependent Features.</span></span>  
 <span data-ttu-id="3459c-297">Zidentyfikuj wszelki kod, który korzysta z modelu COM jednowątkowe apartamentach (STAs).</span><span class="sxs-lookup"><span data-stu-id="3459c-297">Identify any code that uses COM single-threaded apartments (STAs).</span></span>  <span data-ttu-id="3459c-298">STAs są wyłączone w procesie programu SQL Server.</span><span class="sxs-lookup"><span data-stu-id="3459c-298">STAs are disabled in the SQL Server process.</span></span>  <span data-ttu-id="3459c-299">Funkcje, które są zależne od `CoInitialize`, takie jak liczniki wydajności lub Schowka, musi być wyłączone w programie SQL Server.</span><span class="sxs-lookup"><span data-stu-id="3459c-299">Features that depend on `CoInitialize`, such as performance counters or the clipboard, must be disabled within SQL Server.</span></span>  
  
### <a name="ensure-finalizers-are-free-of-synchronization-problems"></a><span data-ttu-id="3459c-300">Upewnij się, że finalizatory są wolne od problemów z synchronizacją</span><span class="sxs-lookup"><span data-stu-id="3459c-300">Ensure Finalizers Are Free of Synchronization Problems</span></span>  
 <span data-ttu-id="3459c-301">Wiele wątki finalizatorów, wątki może istnieć w przyszłych wersjach programu .NET Framework, co oznacza finalizatorów, dotyczy to różnych wystąpień tego samego typu, które są uruchomione jednocześnie.</span><span class="sxs-lookup"><span data-stu-id="3459c-301">Multiple finalizer threads might exist in future versions of the .NET Framework, meaning the finalizers for different instances of the same type run simultaneously.</span></span>  <span data-ttu-id="3459c-302">Nie muszą być całkowicie bezpieczny wątkowo; Moduł zbierający elementy bezużyteczne gwarantuje, że tylko jeden wątek uruchomi finalizatora dla wystąpienia danego obiektu.</span><span class="sxs-lookup"><span data-stu-id="3459c-302">They do not have to be completely thread safe; the garbage collector guarantees that only one thread will run the finalizer for a given object instance.</span></span>  <span data-ttu-id="3459c-303">Jednak finalizatory muszą być kodowane, aby uniknąć wyścigu i zakleszczenie podczas uruchamiania jednocześnie na wielu wystąpień innego obiektu.</span><span class="sxs-lookup"><span data-stu-id="3459c-303">However, the finalizers must be coded to avoid race conditions and deadlocks when running simultaneously on multiple different object instances.</span></span>  <span data-ttu-id="3459c-304">Korzystając z dowolny stan zewnętrzne, takie jak zapisywanie do pliku dziennika w finalizatora, problemy wielowątkowości dotyczące muszą być obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="3459c-304">When using any external state, such as writing to a log file, in a finalizer, threading issues must be handled.</span></span>  <span data-ttu-id="3459c-305">Nie należy polegać na finalizacji zapewnienie bezpieczeństwa wątków.</span><span class="sxs-lookup"><span data-stu-id="3459c-305">Do not rely on finalization to provide thread safety.</span></span> <span data-ttu-id="3459c-306">Lokalny magazyn wątków, zarządzane lub natywne, nie należy używać do przechowywania stanu w wątku finalizatora.</span><span class="sxs-lookup"><span data-stu-id="3459c-306">Do not use thread local storage, managed or native, to store state on the finalizer thread.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3459c-307">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3459c-307">Code Analysis Rule</span></span>  
 <span data-ttu-id="3459c-308">Finalizatory nie mogą być problemy z synchronizacją.</span><span class="sxs-lookup"><span data-stu-id="3459c-308">Finalizers must be free of synchronization problems.</span></span> <span data-ttu-id="3459c-309">Nie należy używać statycznych modyfikowalnego stanu w finalizatora.</span><span class="sxs-lookup"><span data-stu-id="3459c-309">Do not use a static mutable state in a finalizer.</span></span>  
  
### <a name="avoid-unmanaged-memory-if-possible"></a><span data-ttu-id="3459c-310">Należy unikać niezarządzanej pamięci, jeśli jest to możliwe</span><span class="sxs-lookup"><span data-stu-id="3459c-310">Avoid Unmanaged Memory If Possible</span></span>  
 <span data-ttu-id="3459c-311">Niezarządzanej pamięci mogą przedostawać, podobnie jak dojście systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="3459c-311">Unmanaged memory can be leaked, just like an operating system handle.</span></span>  <span data-ttu-id="3459c-312">Jeśli to możliwe, spróbuj użyć pamięci na stosie przy użyciu [stackalloc](~/docs/csharp/language-reference/keywords/stackalloc.md) lub przypiętych obiektu zarządzanego, takie jak [fixed Statement](~/docs/csharp/language-reference/keywords/fixed-statement.md) lub <xref:System.Runtime.InteropServices.GCHandle> przy użyciu byte [].</span><span class="sxs-lookup"><span data-stu-id="3459c-312">If possible, try to use memory on the stack using [stackalloc](~/docs/csharp/language-reference/keywords/stackalloc.md) or a pinned managed object such as the [fixed Statement](~/docs/csharp/language-reference/keywords/fixed-statement.md) or a <xref:System.Runtime.InteropServices.GCHandle> using a byte[].</span></span>  <span data-ttu-id="3459c-313"><xref:System.GC> Po pewnym czasie, które utraciły one.</span><span class="sxs-lookup"><span data-stu-id="3459c-313">The <xref:System.GC> eventually cleans these up.</span></span>  <span data-ttu-id="3459c-314">Jednak jeśli należy przydzielić niezarządzanej pamięci, należy wziąć pod uwagę przy użyciu klasy, która pochodzi od klasy <xref:System.Runtime.InteropServices.SafeHandle> opakowywać alokacji pamięci.</span><span class="sxs-lookup"><span data-stu-id="3459c-314">However, if you must allocate unmanaged memory, consider using a class that derives from <xref:System.Runtime.InteropServices.SafeHandle> to wrap the memory allocation.</span></span>  
  
 <span data-ttu-id="3459c-315">Należy pamiętać, że istnieje co najmniej jeden przypadek gdzie <xref:System.Runtime.InteropServices.SafeHandle> jest niewystarczające.</span><span class="sxs-lookup"><span data-stu-id="3459c-315">Note that there is at least one case where <xref:System.Runtime.InteropServices.SafeHandle> is not adequate.</span></span>  <span data-ttu-id="3459c-316">Dla modelu COM wywołań metod, które przydzielenia lub zwolnienia pamięci jest typowe dla jednej biblioteki DLL, można przydzielić pamięci za pomocą `CoTaskMemAlloc` , a następnie innej biblioteki DLL powoduje zwolnienie pamięci za pomocą `CoTaskMemFree`.</span><span class="sxs-lookup"><span data-stu-id="3459c-316">For COM method calls that allocate or free memory, it is common for one DLL to allocate memory via `CoTaskMemAlloc` then another DLL frees that memory with `CoTaskMemFree`.</span></span>  <span data-ttu-id="3459c-317">Za pomocą <xref:System.Runtime.InteropServices.SafeHandle> w tych miejscach będzie niewłaściwe ponieważ spróbuje ona powiązanie okres istnienia niezarządzanej pamięci z okresem istnienia <xref:System.Runtime.InteropServices.SafeHandle> zamiast zezwalać innym kontrolującym DLL okresu istnienia pamięci.</span><span class="sxs-lookup"><span data-stu-id="3459c-317">Using <xref:System.Runtime.InteropServices.SafeHandle> in these places would be inappropriate since it will attempt to tie the lifetime of the unmanaged memory to the lifetime of the <xref:System.Runtime.InteropServices.SafeHandle> instead of allowing the other DLL control the lifetime of the memory.</span></span>  
  
### <a name="review-all-uses-of-catchexception"></a><span data-ttu-id="3459c-318">Przejrzyj wszystkie przypadki użycia Catch(Exception)</span><span class="sxs-lookup"><span data-stu-id="3459c-318">Review All Uses of Catch(Exception)</span></span>  
 <span data-ttu-id="3459c-319">CATCH bloków, catch, wszystkie wyjątki, zamiast jednego określonego wyjątku teraz będzie przechwytywać wyjątki asynchroniczne.</span><span class="sxs-lookup"><span data-stu-id="3459c-319">Catch blocks that catch all exceptions instead of one specific exception will now catch the asynchronous exceptions as well.</span></span>  <span data-ttu-id="3459c-320">Sprawdź każdy blok catch(Exception), wyszukiwanie nie zasobów ważne przy zwalnianiu lub Wycofaj kod, który mogły zostać pominięte, a także potencjalnie nieprawidłowe zachowanie w bloku catch obsługi <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, lub <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="3459c-320">Examine every catch(Exception) block, looking for no important resource releasing or backout code that might be skipped, as well as potentially incorrect behavior within the catch block itself for handling a <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, or <xref:System.OutOfMemoryException>.</span></span>  <span data-ttu-id="3459c-321">Należy pamiętać, że jest to możliwe, ten kod może się zalogować lub niektóre założenie, że go może być widoczna tylko niektóre wyjątki lub który zawsze wtedy, gdy ma miejsce wyjątek go nie powiodła się dla dokładnie jednej określonej przyczyny.</span><span class="sxs-lookup"><span data-stu-id="3459c-321">Note that it is possible this code might be logging or making some assumptions that it may only see certain exceptions, or that whenever an exception happens it failed for exactly one particular reason.</span></span>  <span data-ttu-id="3459c-322">Może być konieczne zaktualizowano w celu uwzględnienia tych założeń <xref:System.Threading.ThreadAbortException>.</span><span class="sxs-lookup"><span data-stu-id="3459c-322">These assumptions may need to be updated to include <xref:System.Threading.ThreadAbortException>.</span></span>  
  
 <span data-ttu-id="3459c-323">Należy wziąć pod uwagę wszystkie zmiany umieszcza tego catch, zostanie zgłoszony, wszystkie wyjątki przechwytywanie wyjątku, który powinien być określonego typu, takie jak <xref:System.FormatException> z parametrów metod formatowania.</span><span class="sxs-lookup"><span data-stu-id="3459c-323">Consider changing all places that catch all exceptions to catching a specific type of exception that you expect will be thrown, such as a <xref:System.FormatException> from string formatting methods.</span></span>  <span data-ttu-id="3459c-324">Zapobiega uruchamianiu na nieoczekiwane wyjątki przez blok catch i może pomóc upewnić się, że kod nie ukrywa przez przechwytywanie wyjątków w nieoczekiwanych błędów.</span><span class="sxs-lookup"><span data-stu-id="3459c-324">This prevents the catch block from running on unexpected exceptions and will help ensure the code does not hide bugs by catching unexpected exceptions.</span></span>  <span data-ttu-id="3459c-325">Zgodnie z ogólną zasadą nigdy nie obsłużyć wyjątek w kodzie biblioteki (kod, który wymaga przechwytywać wyjątek, może oznaczać wad projektowych w kodzie, którą wywołujesz).</span><span class="sxs-lookup"><span data-stu-id="3459c-325">As a general rule never handle an exception in library code (code that requires you to catch an exception may indicate a design flaw in the code you are calling).</span></span>  <span data-ttu-id="3459c-326">W niektórych przypadkach można przechwytywać wyjątek i zgłosić innego typu wyjątku zapewnienie większej ilości danych.</span><span class="sxs-lookup"><span data-stu-id="3459c-326">In some cases you may want to catch an exception and throw a different exception type to provide more data.</span></span>  <span data-ttu-id="3459c-327">Użyj wyjątków zagnieżdżonych w tym przypadku przechowywanie rzeczywistych przyczynę niepowodzenia w <xref:System.Exception.InnerException%2A> właściwość nowy wyjątek.</span><span class="sxs-lookup"><span data-stu-id="3459c-327">Use nested exceptions in this case, storing the real cause of the failure in the <xref:System.Exception.InnerException%2A> property of the new exception.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3459c-328">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3459c-328">Code Analysis Rule</span></span>  
 <span data-ttu-id="3459c-329">Przejrzyj wszystkie bloki catch w kodzie zarządzanym tego catch, wszystkie obiekty lub catch, wszystkie wyjątki.</span><span class="sxs-lookup"><span data-stu-id="3459c-329">Review all catch blocks in managed code that catch all objects or catch all exceptions.</span></span>  <span data-ttu-id="3459c-330">W C#, oznacza to, że oba Oflagowanie `catch` {} i `catch(Exception)` {}.</span><span class="sxs-lookup"><span data-stu-id="3459c-330">In C#, this means flagging both `catch` {} and `catch(Exception)` {}.</span></span>  <span data-ttu-id="3459c-331">Rozważ przekształcenie bardzo specyficzny typ wyjątku, lub przejrzyj kod, aby upewnić się, że nie działa w nieprawidłowy sposób Jeżeli przechwyci kontrolę typu nieoczekiwany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="3459c-331">Consider making the exception type very specific, or review the code to ensure it does not act in a bad way if it catches an unexpected exception type.</span></span>  
  
### <a name="do-not-assume-a-managed-thread-is-a-win32-thread--it-is-a-fiber"></a><span data-ttu-id="3459c-332">Nie należy zakładać, wątek jest wątek Win32 — Fiber</span><span class="sxs-lookup"><span data-stu-id="3459c-332">Do Not Assume a Managed Thread Is a Win32 Thread – It Is a Fiber</span></span>  
 <span data-ttu-id="3459c-333">Za pomocą programu managed wątku lokalnego magazynu działa, ale nie możesz użyć pamięci lokalnej wątku niezarządzanym lub przyjęto założenie, że kod zostaną ponownie uruchomione w bieżącym wątku systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="3459c-333">Using managed thread local storage does work, but you may not use unmanaged thread local storage or assume the code will run on the current operating system thread again.</span></span>  <span data-ttu-id="3459c-334">Nie należy zmieniać ustawienia, takie jak ustawienia regionalne dla wątku.</span><span class="sxs-lookup"><span data-stu-id="3459c-334">Do not change settings like the thread’s locale.</span></span>  <span data-ttu-id="3459c-335">Nie wywołuj `InitializeCriticalSection` lub `CreateMutex` za pośrednictwem platformy wywołania, ponieważ wymagają one wątku systemu operacyjnego, który wprowadzi blokadę zakończyć działanie blokady.</span><span class="sxs-lookup"><span data-stu-id="3459c-335">Do not call `InitializeCriticalSection` or `CreateMutex` via platform invoke because they require the operating system thread that enters a lock also exit the lock.</span></span>  <span data-ttu-id="3459c-336">Ponieważ nie będzie to wymagane podczas korzystania z włókien, sekcje krytyczne Win32 i muteksy nie można użyć w języku SQL bezpośrednio.</span><span class="sxs-lookup"><span data-stu-id="3459c-336">Since this will not be the case when using fibers, Win32 critical sections and mutexes cannot be used in SQL directly.</span></span>  <span data-ttu-id="3459c-337">Należy pamiętać, że zarządzany <xref:System.Threading.Mutex> klasa nie obsługuje te rozważania koligacji wątku.</span><span class="sxs-lookup"><span data-stu-id="3459c-337">Note that the managed <xref:System.Threading.Mutex> class does not handle these thread affinity concerns.</span></span>  
  
 <span data-ttu-id="3459c-338">Można bezpiecznie korzystać z większości stanu na zarządzanej <xref:System.Threading.Thread> obiektu, łącznie z lokalnego magazynu zarządzanych wątków i bieżącej kultury interfejsu użytkownika dla wątku.</span><span class="sxs-lookup"><span data-stu-id="3459c-338">You can safely use most of the state on a managed <xref:System.Threading.Thread> object, including managed thread local storage and the thread’s current UI culture.</span></span>  <span data-ttu-id="3459c-339">Można również użyć <xref:System.ThreadStaticAttribute>, co sprawia, że wartość istniejącej zmiennej statycznej dostępna tylko przez bieżący wątek zarządzanych (jest to magazyn lokalny włókien w CLR w inny sposób).</span><span class="sxs-lookup"><span data-stu-id="3459c-339">You can also use the <xref:System.ThreadStaticAttribute>, which makes the value of an existing static variable accessible only by the current managed thread (this is another way of doing fiber local storage in the CLR).</span></span>  <span data-ttu-id="3459c-340">Podczas programowania modelu przyczyny, nie można zmienić bieżącej kultury wątku podczas uruchamiania w języku SQL.</span><span class="sxs-lookup"><span data-stu-id="3459c-340">For programming model reasons, you can not change the current culture of a thread when running in SQL.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3459c-341">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3459c-341">Code Analysis Rule</span></span>  
 <span data-ttu-id="3459c-342">SQL Server jest uruchomiony w trybie włókien; nie należy używać pamięci lokalnej wątku.</span><span class="sxs-lookup"><span data-stu-id="3459c-342">SQL Server runs in fiber mode; do not use thread local storage.</span></span> <span data-ttu-id="3459c-343">Należy unikać platformy wywołania do `TlsAlloc`, `TlsFree`, `TlsGetValue`, i `TlsSetValue.`</span><span class="sxs-lookup"><span data-stu-id="3459c-343">Avoid platform invoke calls to `TlsAlloc`, `TlsFree`, `TlsGetValue`, and `TlsSetValue.`</span></span>  
  
### <a name="let-sql-server-handle-impersonation"></a><span data-ttu-id="3459c-344">Pozwól personifikacji dojście do serwera SQL</span><span class="sxs-lookup"><span data-stu-id="3459c-344">Let SQL Server Handle Impersonation</span></span>  
 <span data-ttu-id="3459c-345">Ponieważ personifikacji działa na poziomie wątku, a SQL można uruchomić w trybie włókien kodu zarządzanego nie powinien personifikować użytkowników i nie powinien wywoływać `RevertToSelf`.</span><span class="sxs-lookup"><span data-stu-id="3459c-345">Since impersonation operates on the thread level and SQL can run in fiber mode, managed code should not impersonate users, and should not call `RevertToSelf`.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3459c-346">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3459c-346">Code Analysis Rule</span></span>  
 <span data-ttu-id="3459c-347">Pozwalają obsłużyć personifikacji w programie SQL Server.</span><span class="sxs-lookup"><span data-stu-id="3459c-347">Let SQL Server handle impersonation.</span></span> <span data-ttu-id="3459c-348">Nie używaj `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx`, lub `SetThreadToken`.</span><span class="sxs-lookup"><span data-stu-id="3459c-348">Do not use `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx`, or `SetThreadToken`.</span></span>  
  
### <a name="do-not-call-threadsuspend"></a><span data-ttu-id="3459c-349">Nie wywołuj Thread::Suspend</span><span class="sxs-lookup"><span data-stu-id="3459c-349">Do Not Call Thread::Suspend</span></span>  
 <span data-ttu-id="3459c-350">Możliwość wstrzymywania wątek może pojawić się prostą operacją, ale może to spowodować zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="3459c-350">The ability to suspend a thread may appear a simple operation, but it can cause deadlocks.</span></span>  <span data-ttu-id="3459c-351">Jeśli wątek, używane do przechowywania blokady zostanie zawieszone przez drugi wątek, a następnie drugi wątek spróbuje wykonanie tych samych blokady, występuje zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="3459c-351">If a thread holding a lock gets suspended by a second thread and then the second thread tries taking the same lock, a deadlock occurs.</span></span>  <span data-ttu-id="3459c-352"><xref:System.Threading.Thread.Suspend%2A> może zakłócać zabezpieczeń, ładowania klasy, komunikacji zdalnej i odbicia obecnie.</span><span class="sxs-lookup"><span data-stu-id="3459c-352"><xref:System.Threading.Thread.Suspend%2A> can interfere with security, class loading, remoting, and reflection currently.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3459c-353">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3459c-353">Code Analysis Rule</span></span>  
 <span data-ttu-id="3459c-354">Nie wywołuj <xref:System.Threading.Thread.Suspend%2A>.</span><span class="sxs-lookup"><span data-stu-id="3459c-354">Do not call <xref:System.Threading.Thread.Suspend%2A>.</span></span> <span data-ttu-id="3459c-355">Należy wziąć pod uwagę przy użyciu rzeczywistego synchronizacji pierwotnych zamiast tego, takie jak <xref:System.Threading.Semaphore> lub <xref:System.Threading.ManualResetEvent> .</span><span class="sxs-lookup"><span data-stu-id="3459c-355">Consider using a real synchronization primitive instead, such as a <xref:System.Threading.Semaphore> or <xref:System.Threading.ManualResetEvent> .</span></span>  
  
### <a name="protect-critical-operations-with-constrained-execution-regions-and-reliability-contracts"></a><span data-ttu-id="3459c-356">Chroń krytyczne operacje ograniczone regiony wykonania i kontrakty niezawodności</span><span class="sxs-lookup"><span data-stu-id="3459c-356">Protect Critical Operations with Constrained Execution Regions and Reliability Contracts</span></span>  
 <span data-ttu-id="3459c-357">Podczas wykonywania złożonych operacji, które aktualizuje stan udostępnionego lub wymagający w sposób deterministyczny albo w pełni powiedzie się lub w pełni zakończyć się niepowodzeniem, pamiętaj, że jest chroniony przez region ograniczonego wykonania (CER).</span><span class="sxs-lookup"><span data-stu-id="3459c-357">When performing a complex operation that updates a shared status or that needs to deterministically either fully succeed or fully fail, be sure that it is protected by a constrained execution region (CER).</span></span> <span data-ttu-id="3459c-358">Gwarantuje to, że kod działa w każdym przypadku, nawet wątku nagłego przerwania lub nagłego <xref:System.AppDomain> zwolnienia.</span><span class="sxs-lookup"><span data-stu-id="3459c-358">This guarantees that the code runs in every case, even an abrupt thread abort or an abrupt <xref:System.AppDomain> unload.</span></span>  
  
 <span data-ttu-id="3459c-359">CER jest konkretny `try/finally` bloku natychmiast poprzedzony przez wywołanie <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span><span class="sxs-lookup"><span data-stu-id="3459c-359">A CER is a particular `try/finally` block immediately preceded by a call to <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span></span>  
  
 <span data-ttu-id="3459c-360">Spowoduje to więc nakazuje kompilatorowi just-in-time przygotowanie cały kod w bloku finally przed uruchomieniem `try` bloku.</span><span class="sxs-lookup"><span data-stu-id="3459c-360">Doing so instructs the just-in-time compiler to prepare all the code in the finally block before running the `try` block.</span></span> <span data-ttu-id="3459c-361">Gwarantuje to, że kod na końcu bloku jest wbudowana i będzie działać we wszystkich przypadkach.</span><span class="sxs-lookup"><span data-stu-id="3459c-361">This guarantees that the code in the finally block is built and will run in all cases.</span></span> <span data-ttu-id="3459c-362">Nie jest nietypowy w CER ma pustą `try` bloku.</span><span class="sxs-lookup"><span data-stu-id="3459c-362">It is not uncommon in a CER to have an empty `try` block.</span></span> <span data-ttu-id="3459c-363">Za pomocą CER chroni przed przerwanie asynchronicznego wątku i wyjątki o braku pamięci.</span><span class="sxs-lookup"><span data-stu-id="3459c-363">Using a CER protects against asynchronous thread aborts and out-of-memory exceptions.</span></span> <span data-ttu-id="3459c-364">Zobacz <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> formularza CER, który dodatkowo przepełnienie stosu obsługi dla nadmiernie szczegółowe kodu.</span><span class="sxs-lookup"><span data-stu-id="3459c-364">See <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> for a form of a CER that additionally handles stack overflows for exceedingly deep code.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3459c-365">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="3459c-365">See also</span></span>
- <xref:System.Runtime.ConstrainedExecution>
- [<span data-ttu-id="3459c-366">Atrybuty ochrony hosta i programowanie SQL Server</span><span class="sxs-lookup"><span data-stu-id="3459c-366">SQL Server Programming and Host Protection Attributes</span></span>](../../../docs/framework/performance/sql-server-programming-and-host-protection-attributes.md)
