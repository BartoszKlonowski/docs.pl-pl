---
title: Najlepsze rozwiązania dotyczące niezawodności
description: Zapoznaj się z najlepszymi rozwiązaniami dotyczącymi niezawodności w aplikacjach serwerowych opartych na hoście .NET, takich jak SQL Server. Zapobiegaj przeciekowi zasobów lub przełączeniu.
ms.date: 03/30/2017
helpviewer_keywords:
- marking locks
- rebooting databases
- denial of service attacks
- back-out code
- SQL Server [.NET Framework], reliability
- synchronization, reliability
- single-threaded COM components
- slow leaks
- suspending threads
- asynchronous exception handling
- leaked resources [.NET Framework]
- unmanaged memory
- memory, reliability
- threading [.NET Framework], reliability
- process-wide domain shared states
- shared states
- SafeHandle class, reliability
- reliability contracts [.NET Framework]
- cleanup operations
- constrained execution regions
- CERs
- finalizers, reliability
- reliability [.NET Framework]
- blocks, reliability
- finally clauses
- cross-application domain shared states
- catch blocks
- identifying locks
- writing reliable code
- impersonation
- GC.KeepAlive method
- managed threading
- locks, reliability
- STA-dependent features
- fibers
ms.assetid: cf624c1f-c160-46a1-bb2b-213587688da7
ms.openlocfilehash: 134b71153f95dffd4525f307d291ce4389e0ce60
ms.sourcegitcommit: cf5a800a33de64d0aad6d115ffcc935f32375164
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 07/20/2020
ms.locfileid: "86474244"
---
# <a name="reliability-best-practices"></a><span data-ttu-id="cb916-104">Najlepsze rozwiązania dotyczące niezawodności</span><span class="sxs-lookup"><span data-stu-id="cb916-104">Reliability Best Practices</span></span>

<span data-ttu-id="cb916-105">Następujące reguły niezawodności są ukierunkowane na SQL Server; jednak mają zastosowanie również do dowolnej aplikacji serwerowej opartej na hoście.</span><span class="sxs-lookup"><span data-stu-id="cb916-105">The following reliability rules are oriented to SQL Server; however, they also apply to any host-based server application.</span></span> <span data-ttu-id="cb916-106">Niezwykle ważne jest, aby serwery takie jak SQL Server nie wyciekować zasobów i nie zostały przesunięte.</span><span class="sxs-lookup"><span data-stu-id="cb916-106">It is extremely important that servers such as SQL Server not leak resources and not be brought down.</span></span>  <span data-ttu-id="cb916-107">Jednak nie można tego zrobić, pisząc kod zapasowy dla każdej metody, która zmienia stan obiektu.</span><span class="sxs-lookup"><span data-stu-id="cb916-107">However, that cannot be done by writing back-out code for every method that alters an object’s state.</span></span>  <span data-ttu-id="cb916-108">Celem nie jest zapisanie przez 100 procent niezawodnego kodu zarządzanego, który odzyska się z błędów w każdej lokalizacji z kodem zapasowym.</span><span class="sxs-lookup"><span data-stu-id="cb916-108">The goal is not to write 100 percent reliable managed code that will recover from any errors in every location with back-out code.</span></span>  <span data-ttu-id="cb916-109">Jest to zadanie zniechęcające z niewielką szansą sukcesu.</span><span class="sxs-lookup"><span data-stu-id="cb916-109">That would be a daunting task with little chance of success.</span></span>  <span data-ttu-id="cb916-110">Środowisko uruchomieniowe języka wspólnego (CLR) nie może łatwo zapewnić mocnej wystarczającej ilości gwarancji do kodu zarządzanego, aby możliwe było napisanie doskonałego kodu.</span><span class="sxs-lookup"><span data-stu-id="cb916-110">The common language runtime (CLR) cannot easily provide strong enough guarantees to managed code to make writing perfect code feasible.</span></span>  <span data-ttu-id="cb916-111">Należy pamiętać, że w przeciwieństwie do ASP.NET, SQL Server używa tylko jednego procesu, którego nie można odtworzyć bez przełączenia bazy danych na nieakceptowalny czas.</span><span class="sxs-lookup"><span data-stu-id="cb916-111">Note that unlike ASP.NET, SQL Server uses only one process that cannot be recycled without taking a database down for an unacceptably long time.</span></span>

<span data-ttu-id="cb916-112">Dzięki tym słabszym gwarancjom i działaniu w pojedynczym procesie niezawodność jest oparta na przerywaniu wątków lub odtwarzaniu domen aplikacji w razie potrzeby i podejmując środki ostrożności, aby zapewnić, że zasoby systemu operacyjnego, takie jak uchwyty lub pamięć, nie są wyciekami.</span><span class="sxs-lookup"><span data-stu-id="cb916-112">With these weaker guarantees and running in a single process, reliability is based on terminating threads or recycling application domains when necessary and taking precautions to ensure operating system resources such as handles or memory are not leaked.</span></span>  <span data-ttu-id="cb916-113">Nawet w przypadku tego prostszego ograniczenia niezawodności wciąż istnieje znacząca wymagana niezawodność:</span><span class="sxs-lookup"><span data-stu-id="cb916-113">Even with this simpler reliability constraint, there is still a significant reliability requirement:</span></span>

- <span data-ttu-id="cb916-114">Nigdy nie wycieka zasobów systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="cb916-114">Never leak operating system resources.</span></span>

- <span data-ttu-id="cb916-115">Zidentyfikuj wszystkie zarządzane blokady we wszystkich formularzach do środowiska CLR.</span><span class="sxs-lookup"><span data-stu-id="cb916-115">Identify all managed locks in all forms to the CLR.</span></span>

- <span data-ttu-id="cb916-116">Nigdy nie przerywaj współużytkowanego stanu domeny, co umożliwia <xref:System.AppDomain> bezproblemowe działanie odtwarzania.</span><span class="sxs-lookup"><span data-stu-id="cb916-116">Never break cross-application domain shared state, allowing <xref:System.AppDomain> recycling to function smoothly.</span></span>

<span data-ttu-id="cb916-117">Chociaż jest to teoretycznie możliwe, aby napisać kod zarządzany do obsługi <xref:System.Threading.ThreadAbortException> , <xref:System.StackOverflowException> i <xref:System.OutOfMemoryException> wyjątków, oczekuje się, że deweloperzy mogą napisać taki niezawodny kod w całej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="cb916-117">Although it is theoretically possible to write managed code to handle <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException> exceptions, expecting developers to write such robust code throughout an entire application is unreasonable.</span></span>  <span data-ttu-id="cb916-118">Z tego powodu wyjątki poza pasmem powodują przerwanie wykonywania wątku. i jeśli wątek przerwał edytowanie stanu udostępnionego, który można określić, czy wątek utrzymuje blokadę, a następnie <xref:System.AppDomain> jest zwolniony.</span><span class="sxs-lookup"><span data-stu-id="cb916-118">For that reason, out-of-band exceptions result in the executing thread being terminated; and if the terminated thread was editing shared state, which can be determined by whether the thread holds a lock, then the <xref:System.AppDomain> is unloaded.</span></span>  <span data-ttu-id="cb916-119">Gdy metoda, która edytuje stan udostępniony, zostanie zakończona, stan będzie uszkodzony, ponieważ nie jest możliwe zapisanie niezawodnego kodu zapasowego dla aktualizacji stanu udostępnionego.</span><span class="sxs-lookup"><span data-stu-id="cb916-119">When a method that is editing shared state is terminated, the state will be corrupt because it is not possible to write reliable back-out code for updates to shared state.</span></span>

<span data-ttu-id="cb916-120">W .NET Framework w wersji 2,0, jedyny Host wymagający niezawodności jest SQL Server.</span><span class="sxs-lookup"><span data-stu-id="cb916-120">In the .NET Framework version 2.0, the only host that requires reliability is SQL Server.</span></span>  <span data-ttu-id="cb916-121">Jeśli zestaw zostanie uruchomiony na SQL Server należy wykonać niezawodność dla każdej części tego zestawu, nawet jeśli istnieją konkretne funkcje, które są wyłączone w przypadku uruchamiania w bazie danych programu.</span><span class="sxs-lookup"><span data-stu-id="cb916-121">If your assembly will be run on SQL Server you should do the reliability work for every part of that assembly, even if there are specific features that are disabled when running in the database.</span></span>  <span data-ttu-id="cb916-122">Jest to wymagane, ponieważ aparat analizy kodu analizuje kod na poziomie zestawu i nie może odróżnić wyłączonego kodu.</span><span class="sxs-lookup"><span data-stu-id="cb916-122">This is required because the code analysis engine examines code at the assembly level and cannot differentiate disabled code.</span></span> <span data-ttu-id="cb916-123">Innym SQL Serverom programowania jest to, że SQL Server uruchamia wszystko w jednym procesie, a <xref:System.AppDomain> recykling służy do czyszczenia wszystkich zasobów, takich jak pamięć i uchwyty systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="cb916-123">Another SQL Server programming consideration is that SQL Server runs everything in one process, and <xref:System.AppDomain> recycling is used for cleaning up all resources such as memory and operating system handles.</span></span>

<span data-ttu-id="cb916-124">Nie można zależeć od finalizatorów lub destruktorów ani `try/finally` bloków dla kodu zapasowego.</span><span class="sxs-lookup"><span data-stu-id="cb916-124">You cannot depend on finalizers or destructors or `try/finally` blocks for back-out code.</span></span> <span data-ttu-id="cb916-125">Mogą być one przerywane lub niewywoływane.</span><span class="sxs-lookup"><span data-stu-id="cb916-125">They might be interrupted or not called.</span></span>

<span data-ttu-id="cb916-126">Wyjątki asynchroniczne można zgłaszać w nieoczekiwanych lokalizacjach, prawdopodobnie każda instrukcja maszynowa: <xref:System.Threading.ThreadAbortException> , <xref:System.StackOverflowException> , i <xref:System.OutOfMemoryException> .</span><span class="sxs-lookup"><span data-stu-id="cb916-126">Asynchronous exceptions can be thrown in unexpected locations, possibly every machine instruction: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException>.</span></span>

<span data-ttu-id="cb916-127">Zarządzane wątki nie są koniecznie wątki Win32 w programie SQL Server; mogą być włókien.</span><span class="sxs-lookup"><span data-stu-id="cb916-127">Managed threads are not necessarily Win32 threads in SQL; they might be fibers.</span></span>

<span data-ttu-id="cb916-128">W przypadku domeny o szerokim zasięgu lub aplikacjach przetwarzanych poza aplikacjami jest niezwykle trudne do zmiany i należy je unikać, gdy jest to możliwe.</span><span class="sxs-lookup"><span data-stu-id="cb916-128">Process-wide or cross-application domain mutable shared state is extremely difficult to alter safely and should be avoided whenever possible.</span></span>

<span data-ttu-id="cb916-129">Warunki braku pamięci nie są rzadkie w SQL Server.</span><span class="sxs-lookup"><span data-stu-id="cb916-129">Out-of-memory conditions are not rare in SQL Server.</span></span>

<span data-ttu-id="cb916-130">Jeśli biblioteki hostowane w SQL Server nie będą poprawnie aktualizować swojego udostępnionego stanu, istnieje wysokie prawdopodobieństwo, że kod nie zostanie odzyskany, dopóki baza danych nie zostanie ponownie uruchomiona.</span><span class="sxs-lookup"><span data-stu-id="cb916-130">If libraries hosted in SQL Server do not correctly update their shared state, there is a high probability that the code will not recover until the database has been restarted.</span></span>  <span data-ttu-id="cb916-131">Ponadto w niektórych ekstremalnych przypadkach możliwe może być niepowodzenie procesu SQL Server, powodując ponowne uruchomienie bazy danych.</span><span class="sxs-lookup"><span data-stu-id="cb916-131">Additionally, in some extreme cases, it is possible this might cause the SQL Server process to fail, causing the database to reboot.</span></span>  <span data-ttu-id="cb916-132">Ponowne uruchomienie bazy danych może spowolnić witrynę sieci Web lub wpłynąć na operacje firmy, co pogarsza dostępność.</span><span class="sxs-lookup"><span data-stu-id="cb916-132">Rebooting the database can take down a Web site or affect company operations, hurting availability.</span></span>  <span data-ttu-id="cb916-133">Wolne wycieki zasobów systemu operacyjnego, takich jak pamięć lub dojścia, może spowodować, że serwer zakończył się niepowodzeniem przydzielenia dojścia bez możliwości odzyskiwania lub potencjalnie serwer może spowalniać wydajność i zmniejsza dostępność aplikacji klienta.</span><span class="sxs-lookup"><span data-stu-id="cb916-133">A slow leak of operating system resources such as memory or handles may cause the server to eventually fail allocating handles with no possibility of recovery, or potentially the server may slowly degrade in performance and reduces a customer’s application availability.</span></span>  <span data-ttu-id="cb916-134">Jasno chcemy unikać tych scenariuszy.</span><span class="sxs-lookup"><span data-stu-id="cb916-134">Clearly we want to avoid these scenarios.</span></span>

## <a name="best-practice-rules"></a><span data-ttu-id="cb916-135">Reguły najlepszych rozwiązań</span><span class="sxs-lookup"><span data-stu-id="cb916-135">Best practice rules</span></span>

<span data-ttu-id="cb916-136">Wprowadzenie koncentruje się na tym, co należy sprawdzić w kodzie zarządzanym kodu, który działa na serwerze, aby zwiększyć stabilność i niezawodność platformy.</span><span class="sxs-lookup"><span data-stu-id="cb916-136">The introduction focused on what the code review for the managed code that runs in the server would have to catch to increase the stability and reliability of the framework.</span></span> <span data-ttu-id="cb916-137">Wszystkie te testy są ogólnie zalecane i bezwzględne na serwerze.</span><span class="sxs-lookup"><span data-stu-id="cb916-137">All these checks are good practice in general and an absolute must on the server.</span></span>

<span data-ttu-id="cb916-138">W przypadku ograniczenia zamkniętej blokady lub zasobu, SQL Server przerywa wątek lub wyłączy <xref:System.AppDomain> .</span><span class="sxs-lookup"><span data-stu-id="cb916-138">In the face of a dead lock or resource constraint, SQL Server will abort a thread or tear down an <xref:System.AppDomain>.</span></span>  <span data-ttu-id="cb916-139">W takim przypadku należy uruchomić tylko kod zapasowy w ograniczonym regionie wykonywania (CER).</span><span class="sxs-lookup"><span data-stu-id="cb916-139">When this happens, only back-out code in a constrained execution region (CER) is guaranteed to be run.</span></span>

### <a name="use-safehandle-to-avoid-resource-leaks"></a><span data-ttu-id="cb916-140">Użyj elementu SafeHandle, aby uniknąć przecieków zasobów</span><span class="sxs-lookup"><span data-stu-id="cb916-140">Use SafeHandle to avoid resource leaks</span></span>

<span data-ttu-id="cb916-141">W przypadku <xref:System.AppDomain> zwolnienia nie można zależeć od `finally` bloków lub finalizatorów, dlatego ważne jest, aby przede wszystkim uzyskać dostęp do zasobów systemu operacyjnego za pomocą klasy, <xref:System.Runtime.InteropServices.SafeHandle> a nie <xref:System.IntPtr> , <xref:System.Runtime.InteropServices.HandleRef> lub podobnych klas.</span><span class="sxs-lookup"><span data-stu-id="cb916-141">In the case of an <xref:System.AppDomain> unload, you cannot depend on `finally` blocks or finalizers being executed, so it is important to abstract all operating system resource access through the <xref:System.Runtime.InteropServices.SafeHandle> class rather than <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef>, or similar classes.</span></span> <span data-ttu-id="cb916-142">Dzięki temu środowisko CLR będzie śledzić i zamykać wykorzystywane przez Ciebie uchwyty nawet w <xref:System.AppDomain> przypadku rozrywania.</span><span class="sxs-lookup"><span data-stu-id="cb916-142">This allows the CLR to track and close the handles you use even in the <xref:System.AppDomain> tear-down case.</span></span>  <span data-ttu-id="cb916-143"><xref:System.Runtime.InteropServices.SafeHandle>będzie używać finalizatora krytycznego, który będzie zawsze uruchamiany przez środowisko CLR.</span><span class="sxs-lookup"><span data-stu-id="cb916-143"><xref:System.Runtime.InteropServices.SafeHandle> will be using a critical finalizer which the CLR will always run.</span></span>

<span data-ttu-id="cb916-144">Dojście systemu operacyjnego jest przechowywane w bezpiecznym obsłudze od momentu jego utworzenia do momentu jego zwolnienia.</span><span class="sxs-lookup"><span data-stu-id="cb916-144">The operating system handle is stored in the safe handle from the moment it is created until the moment it is released.</span></span>  <span data-ttu-id="cb916-145">Nie ma okna, w którym <xref:System.Threading.ThreadAbortException> może wystąpić przeciek dojścia.</span><span class="sxs-lookup"><span data-stu-id="cb916-145">There is no window during which a <xref:System.Threading.ThreadAbortException> can occur to leak a handle.</span></span>  <span data-ttu-id="cb916-146">Ponadto wywołanie platformy będzie odwoływać się do dojścia, które umożliwia zamknięcie śledzenia okresu istnienia dojścia, uniemożliwiając problem z zabezpieczeniami z sytuacją wyścigu między `Dispose` i metodą, która aktualnie korzysta z dojścia.</span><span class="sxs-lookup"><span data-stu-id="cb916-146">Additionally, platform invoke will reference-count the handle, which allows close tracking of the lifetime of the handle, preventing a security issue with a race condition between `Dispose` and a method that is currently using the handle.</span></span>

<span data-ttu-id="cb916-147">Większość klas, które obecnie mają finalizator do zwykłego oczyszczenia dojścia systemu operacyjnego, nie potrzebuje już finalizatora.</span><span class="sxs-lookup"><span data-stu-id="cb916-147">Most classes that currently have a finalizer to simply clean up an operating system handle will not need the finalizer anymore.</span></span> <span data-ttu-id="cb916-148">Zamiast tego finalizator będzie znajdować się w <xref:System.Runtime.InteropServices.SafeHandle> klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="cb916-148">Instead, the finalizer will be on the <xref:System.Runtime.InteropServices.SafeHandle> derived class.</span></span>

<span data-ttu-id="cb916-149">Należy pamiętać, że <xref:System.Runtime.InteropServices.SafeHandle> nie zastępuje elementu <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="cb916-149">Note that <xref:System.Runtime.InteropServices.SafeHandle> is not a replacement for <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span></span>  <span data-ttu-id="cb916-150">Nadal istnieją potencjalne korzyści związane z rywalizacją o zasoby i wydajność w celu jawnego usuwania zasobów systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="cb916-150">There are still potential resource contention and performance advantages to explicitly dispose operating system resources.</span></span>  <span data-ttu-id="cb916-151">Wystarczy pamiętać, że `finally` bloki, które jawnie usuwają zasoby, mogą nie zostać wykonane do ukończenia.</span><span class="sxs-lookup"><span data-stu-id="cb916-151">Just realize that `finally` blocks that do explicitly dispose of resources may not execute to completion.</span></span>

<span data-ttu-id="cb916-152"><xref:System.Runtime.InteropServices.SafeHandle>umożliwia zaimplementowanie własnej <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> metody, która wykonuje zadania w celu zwolnienia dojścia, na przykład przekazanie stanu do procedury zwalniania obsługi systemu operacyjnego lub zwolnienie zestawu dojść w pętli.</span><span class="sxs-lookup"><span data-stu-id="cb916-152"><xref:System.Runtime.InteropServices.SafeHandle> allows you to implement your own <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method that performs the work to free the handle, such as passing state to an operating system handle freeing routine or freeing a set of handles in a loop.</span></span>  <span data-ttu-id="cb916-153">Środowisko CLR gwarantuje, że ta metoda jest uruchamiana.</span><span class="sxs-lookup"><span data-stu-id="cb916-153">The CLR guarantees that this method is run.</span></span>  <span data-ttu-id="cb916-154">Jest odpowiedzialny za autora <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementacji, aby upewnić się, że dojście zostanie wydane we wszystkich okolicznościach.</span><span class="sxs-lookup"><span data-stu-id="cb916-154">It is the responsibility of the author of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation to ensure that the handle is released in all circumstances.</span></span> <span data-ttu-id="cb916-155">Niewykonanie tej czynności spowoduje przeciek uchwytu, co często skutkuje wyciekiem zasobów natywnych skojarzonych z dojściem.</span><span class="sxs-lookup"><span data-stu-id="cb916-155">Failure to do so will cause the handle to be leaked, which often results in the leakage of native resources associated with the handle.</span></span> <span data-ttu-id="cb916-156">W związku z tym ma kluczowe znaczenie dla struktury <xref:System.Runtime.InteropServices.SafeHandle> klas pochodnych, tak że <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementacja nie wymaga przydziału żadnych zasobów, które mogą nie być dostępne w czasie wywołania.</span><span class="sxs-lookup"><span data-stu-id="cb916-156">Therefore it is critical to structure <xref:System.Runtime.InteropServices.SafeHandle> derived classes such that the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation does not require the allocation of any resources that may not be available at invocation time.</span></span> <span data-ttu-id="cb916-157">Należy zauważyć, że dozwolone jest wywoływanie metod, które mogą kończyć się niepowodzeniem w ramach implementacji <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> pod warunkiem, że kod może obsłużyć takie błędy i zakończyć kontrakt, aby zwolnić uchwyt macierzysty.</span><span class="sxs-lookup"><span data-stu-id="cb916-157">Note that it is permissible to call methods that may fail within the implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> provided that your code can handle such failures and complete the contract to release the native handle.</span></span> <span data-ttu-id="cb916-158">Na potrzeby debugowania program <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> ma <xref:System.Boolean> wartość zwracaną, która może być ustawiona na w `false` przypadku napotkania błędu krytycznego, który uniemożliwia wydanie zasobu.</span><span class="sxs-lookup"><span data-stu-id="cb916-158">For debugging purposes, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> has a <xref:System.Boolean> return value which may be set to `false` if a catastrophic error is encountered which prevents release of the resource.</span></span> <span data-ttu-id="cb916-159">Wykonanie tej czynności spowoduje aktywowanie [releaseHandleFailed](../debug-trace-profile/releasehandlefailed-mda.md) MDA, jeśli jest włączone, aby pomóc w zidentyfikowaniu problemu.</span><span class="sxs-lookup"><span data-stu-id="cb916-159">Doing so will activate the [releaseHandleFailed](../debug-trace-profile/releasehandlefailed-mda.md) MDA, if enabled, to aid in identifying the problem.</span></span> <span data-ttu-id="cb916-160">Nie ma to wpływu na środowisko uruchomieniowe w żaden inny sposób; <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>nie zostanie wywołane ponownie dla tego samego zasobu i w związku z tym dojście zostanie ujawnione.</span><span class="sxs-lookup"><span data-stu-id="cb916-160">It does not affect the runtime in any other way; <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> will not be called again for the same resource and consequently the handle will be leaked.</span></span>

<span data-ttu-id="cb916-161"><xref:System.Runtime.InteropServices.SafeHandle>nie jest odpowiednia w niektórych kontekstach.</span><span class="sxs-lookup"><span data-stu-id="cb916-161"><xref:System.Runtime.InteropServices.SafeHandle> is not appropriate in certain contexts.</span></span>  <span data-ttu-id="cb916-162">Ponieważ <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> Metoda może być uruchamiana w <xref:System.GC> wątku finalizatora, wszelkie uchwyty, które są wymagane do zwolnienia w określonym wątku, nie powinny być opakowane w <xref:System.Runtime.InteropServices.SafeHandle> .</span><span class="sxs-lookup"><span data-stu-id="cb916-162">Since the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method can be run on a <xref:System.GC> finalizer thread, any handles that are required to be freed on a particular thread should not be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle>.</span></span>

<span data-ttu-id="cb916-163">Wywoływane otoki środowiska uruchomieniowego (RCW) mogą być czyszczone przez środowisko CLR bez dodatkowego kodu.</span><span class="sxs-lookup"><span data-stu-id="cb916-163">Runtime callable wrappers (RCWs) can be cleaned by the CLR without additional code.</span></span>  <span data-ttu-id="cb916-164">Dla kodu, który używa wywołania platformy i traktuje obiekt COM jako `IUnknown*` lub <xref:System.IntPtr> , należy ponownie napisać kod, aby użyć otoki RCW.</span><span class="sxs-lookup"><span data-stu-id="cb916-164">For code that uses platform invoke and treats a COM object as an `IUnknown*` or an <xref:System.IntPtr>, the code should be rewritten to use an RCW.</span></span>  <span data-ttu-id="cb916-165"><xref:System.Runtime.InteropServices.SafeHandle>może nie być odpowiednie dla tego scenariusza ze względu na możliwość wywołania niezarządzanej metody wydania z powrotem do kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="cb916-165"><xref:System.Runtime.InteropServices.SafeHandle> may not be adequate for this scenario due to the possibility of an unmanaged release method calling back into managed code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cb916-166">Reguła analizy kodu</span><span class="sxs-lookup"><span data-stu-id="cb916-166">Code analysis rule</span></span>

<span data-ttu-id="cb916-167">Służy <xref:System.Runtime.InteropServices.SafeHandle> do hermetyzacji zasobów systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="cb916-167">Use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate operating system resources.</span></span> <span data-ttu-id="cb916-168">Nie używaj <xref:System.Runtime.InteropServices.HandleRef> ani pól typu <xref:System.IntPtr> .</span><span class="sxs-lookup"><span data-stu-id="cb916-168">Do not use <xref:System.Runtime.InteropServices.HandleRef> or fields of type <xref:System.IntPtr>.</span></span>

### <a name="ensure-finalizers-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="cb916-169">Upewnij się, że nie trzeba uruchamiać finalizatorów, aby zapobiec przeciekom zasobów systemu operacyjnego</span><span class="sxs-lookup"><span data-stu-id="cb916-169">Ensure finalizers do not have to run to prevent leaking operating system resources</span></span>

<span data-ttu-id="cb916-170">Uważnie Przejrzyj finalizatory, aby upewnić się, że nawet jeśli nie są uruchamiane, krytyczny zasób systemu operacyjnego nie jest wycieka.</span><span class="sxs-lookup"><span data-stu-id="cb916-170">Review your finalizers carefully to ensure that even if they do not run, a critical operating system resource is not leaked.</span></span>  <span data-ttu-id="cb916-171">W przeciwieństwie do normalnego <xref:System.AppDomain> zwalniania, gdy aplikacja jest wykonywana w stanie stałym lub gdy serwer taki jak SQL Server zamknięty, obiekty nie są finalizowane podczas nieoczekiwanej <xref:System.AppDomain> zwolnienia.</span><span class="sxs-lookup"><span data-stu-id="cb916-171">Unlike a normal <xref:System.AppDomain> unload when the application is executing in a steady state or when a server such as SQL Server shuts down, objects are not finalized during an abrupt <xref:System.AppDomain> unload.</span></span>  <span data-ttu-id="cb916-172">Upewnij się, że zasoby nie są wyciekami w przypadku nieoczekiwanej zwolnienia, ponieważ nie można zagwarantować poprawności aplikacji, ale integralność serwera musi być utrzymywana przez nie wycieki zasobów.</span><span class="sxs-lookup"><span data-stu-id="cb916-172">Ensure resources are not leaked in the case of an abrupt unload, since an application's correctness cannot be guaranteed, but the integrity of the server must be maintained by not leaking resources.</span></span>  <span data-ttu-id="cb916-173">Użyj <xref:System.Runtime.InteropServices.SafeHandle> , aby zwolnić wszystkie zasoby systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="cb916-173">Use <xref:System.Runtime.InteropServices.SafeHandle> to free any operating system resources.</span></span>

### <a name="ensure-that-finally-clauses-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="cb916-174">Upewnij się, że klauzule finally nie muszą działać, aby zapobiec przeciekom zasobów systemu operacyjnego</span><span class="sxs-lookup"><span data-stu-id="cb916-174">Ensure that finally clauses do not have to run to prevent leaking operating system resources</span></span>

<span data-ttu-id="cb916-175">`finally`klauzule nie są gwarantowane do uruchomienia poza programem CERs, co wymaga, aby deweloperzy biblioteki nie korzystali z kodu w `finally` bloku w celu zwolnienia niezarządzanych zasobów.</span><span class="sxs-lookup"><span data-stu-id="cb916-175">`finally` clauses are not guaranteed to run outside of CERs, requiring library developers to not rely on code within a `finally` block to free unmanaged resources.</span></span>  <span data-ttu-id="cb916-176">Użycie <xref:System.Runtime.InteropServices.SafeHandle> jest zalecanym rozwiązaniem.</span><span class="sxs-lookup"><span data-stu-id="cb916-176">Using <xref:System.Runtime.InteropServices.SafeHandle> is the recommended solution.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cb916-177">Reguła analizy kodu</span><span class="sxs-lookup"><span data-stu-id="cb916-177">Code analysis rule</span></span>

<span data-ttu-id="cb916-178">Służy <xref:System.Runtime.InteropServices.SafeHandle> do czyszczenia zasobów systemu operacyjnego zamiast `Finalize` .</span><span class="sxs-lookup"><span data-stu-id="cb916-178">Use <xref:System.Runtime.InteropServices.SafeHandle> for cleaning up operating system resources instead of `Finalize`.</span></span> <span data-ttu-id="cb916-179">Nie używaj <xref:System.IntPtr> ; służy <xref:System.Runtime.InteropServices.SafeHandle> do hermetyzacji zasobów.</span><span class="sxs-lookup"><span data-stu-id="cb916-179">Do not use <xref:System.IntPtr>; use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate resources.</span></span> <span data-ttu-id="cb916-180">Jeśli klauzula finally musi być uruchomiona, należy ją umieścić w CER.</span><span class="sxs-lookup"><span data-stu-id="cb916-180">If the finally clause must run, place it in a CER.</span></span>

### <a name="all-locks-should-go-through-existing-managed-locking-code"></a><span data-ttu-id="cb916-181">Wszystkie blokady powinny przechodzić przez istniejący zarządzany kod blokowania</span><span class="sxs-lookup"><span data-stu-id="cb916-181">All locks should go through existing managed locking code</span></span>

<span data-ttu-id="cb916-182">Środowisko CLR musi wiedzieć, gdy kod jest w blokadzie, dzięki czemu będzie wiadomo, że <xref:System.AppDomain> nie tylko przerywanie wątku.</span><span class="sxs-lookup"><span data-stu-id="cb916-182">The CLR must know when code is in a lock so that it will know to tear down the <xref:System.AppDomain> rather than just aborting the thread.</span></span>  <span data-ttu-id="cb916-183">Przerywanie wątku może być niebezpieczne, ponieważ dane obsługiwane przez wątek mogą pozostać w niespójnym stanie.</span><span class="sxs-lookup"><span data-stu-id="cb916-183">Aborting the thread could be dangerous as the data operated on by the thread could be left in an inconsistent state.</span></span> <span data-ttu-id="cb916-184">W związku z tym cały program <xref:System.AppDomain> musi być odtwarzany.</span><span class="sxs-lookup"><span data-stu-id="cb916-184">Therefore, the entire <xref:System.AppDomain> has to be recycled.</span></span>  <span data-ttu-id="cb916-185">Skutkiem niepowodzenia identyfikacji blokady mogą być zakleszczenia lub nieprawidłowe wyniki.</span><span class="sxs-lookup"><span data-stu-id="cb916-185">The consequences of failing to identify a lock can be either deadlocks or incorrect results.</span></span> <span data-ttu-id="cb916-186">Użyj metod <xref:System.Threading.Thread.BeginCriticalRegion%2A> i, <xref:System.Threading.Thread.EndCriticalRegion%2A> Aby zidentyfikować regiony blokady.</span><span class="sxs-lookup"><span data-stu-id="cb916-186">Use the methods <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> to identify lock regions.</span></span>  <span data-ttu-id="cb916-187">Są one metodami statycznymi <xref:System.Threading.Thread> klasy, które mają zastosowanie tylko do bieżącego wątku, co uniemożliwia jednemu wątkowi edytowanie liczby blokad innego wątku.</span><span class="sxs-lookup"><span data-stu-id="cb916-187">They are static methods on the <xref:System.Threading.Thread> class that only apply to the current thread, helping to prevent one thread from editing another thread’s lock count.</span></span>

<span data-ttu-id="cb916-188"><xref:System.Threading.Monitor.Enter%2A>i <xref:System.Threading.Monitor.Exit%2A> ma wbudowane powiadomienie środowiska CLR, dlatego zaleca się ich użycie, a także użycie [instrukcji lock](../../csharp/language-reference/keywords/lock-statement.md), która używa tych metod.</span><span class="sxs-lookup"><span data-stu-id="cb916-188"><xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> have this CLR notification built in, so their usage is recommended as well as the use of the [lock Statement](../../csharp/language-reference/keywords/lock-statement.md), which uses these methods.</span></span>

<span data-ttu-id="cb916-189">Inne mechanizmy blokowania, takie jak blokady pokrętła i <xref:System.Threading.AutoResetEvent> muszą wywoływać te metody w celu powiadomienia środowiska CLR o wprowadzeniu sekcji krytycznej.</span><span class="sxs-lookup"><span data-stu-id="cb916-189">Other locking mechanisms such as spin locks and <xref:System.Threading.AutoResetEvent> must call these methods to notify the CLR that a critical section is being entered.</span></span>  <span data-ttu-id="cb916-190">Te metody nie przyjmują żadnych blokad; informują one CLR, że kod jest wykonywany w sekcji krytycznej, a przerywanie wątku może pozostawiać stan współużytkowany niespójny.</span><span class="sxs-lookup"><span data-stu-id="cb916-190">These methods do not take any locks; they inform the CLR that code is executing in a critical section and aborting the thread could leave shared state inconsistent.</span></span>  <span data-ttu-id="cb916-191">Jeśli zdefiniowano własny typ blokady, taki jak Klasa niestandardowa <xref:System.Threading.ReaderWriterLock> , Użyj tych metod liczby blokad.</span><span class="sxs-lookup"><span data-stu-id="cb916-191">If you have defined your own lock type, such as a custom <xref:System.Threading.ReaderWriterLock> class, use these lock count methods.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cb916-192">Reguła analizy kodu</span><span class="sxs-lookup"><span data-stu-id="cb916-192">Code analysis rule</span></span>

<span data-ttu-id="cb916-193">Oznacz i zidentyfikuj wszystkie blokady przy użyciu <xref:System.Threading.Thread.BeginCriticalRegion%2A> i <xref:System.Threading.Thread.EndCriticalRegion%2A> .</span><span class="sxs-lookup"><span data-stu-id="cb916-193">Mark and identify all locks using <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span></span> <span data-ttu-id="cb916-194">Nie używaj <xref:System.Threading.Interlocked.CompareExchange%2A> , <xref:System.Threading.Interlocked.Increment%2A> i <xref:System.Threading.Interlocked.Decrement%2A> w pętli.</span><span class="sxs-lookup"><span data-stu-id="cb916-194">Do not use <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A>, and <xref:System.Threading.Interlocked.Decrement%2A> in a loop.</span></span>  <span data-ttu-id="cb916-195">Nie wykonuj wywołania platformy dla wariantów Win32 tych metod.</span><span class="sxs-lookup"><span data-stu-id="cb916-195">Do not do a platform invoke of the Win32 variants of these methods.</span></span>  <span data-ttu-id="cb916-196">Nie należy używać <xref:System.Threading.Thread.Sleep%2A> w pętli.</span><span class="sxs-lookup"><span data-stu-id="cb916-196">Do not use <xref:System.Threading.Thread.Sleep%2A> in a loop.</span></span>  <span data-ttu-id="cb916-197">Nie używaj pól nietrwałych.</span><span class="sxs-lookup"><span data-stu-id="cb916-197">Do not use volatile fields.</span></span>

### <a name="cleanup-code-must-be-in-a-finally-or-a-catch-block-not-following-a-catch"></a><span data-ttu-id="cb916-198">Kod czyszczący musi znajdować się w bloku finally lub catch, a nie po przechwyceniu</span><span class="sxs-lookup"><span data-stu-id="cb916-198">Cleanup code must be in a finally or a catch block, Not following a catch</span></span>

<span data-ttu-id="cb916-199">Kod czyszczący nigdy nie powinien występować po `catch` bloku; powinien znajdować się w `finally` lub w `catch` bloku.</span><span class="sxs-lookup"><span data-stu-id="cb916-199">Cleanup code should never follow a `catch` block; it should be in a `finally` or in the `catch` block itself.</span></span> <span data-ttu-id="cb916-200">Powinno to być normalne dobre rozwiązanie.</span><span class="sxs-lookup"><span data-stu-id="cb916-200">This should be a normal good practice.</span></span> <span data-ttu-id="cb916-201">`finally`Blok jest ogólnie preferowany, ponieważ ma ten sam kod zarówno w przypadku zgłoszenia wyjątku, jak i zakończenia ostatniego `try` bloku.</span><span class="sxs-lookup"><span data-stu-id="cb916-201">A `finally` block is generally preferred because it runs the same code both when an exception is thrown and when the end of the `try` block is normally encountered.</span></span>  <span data-ttu-id="cb916-202">W przypadku zgłaszania nieoczekiwanego wyjątku, na przykład <xref:System.Threading.ThreadAbortException> , kod czyszczenia nie zostanie uruchomiony.</span><span class="sxs-lookup"><span data-stu-id="cb916-202">In the event of an unexpected exception being thrown, for example a <xref:System.Threading.ThreadAbortException>, the cleanup code will not run.</span></span>  <span data-ttu-id="cb916-203">Wszelkie niezarządzane zasoby, które można oczyścić w programie, `finally` powinny być w sposób zawinięty w <xref:System.Runtime.InteropServices.SafeHandle> celu zapobieżenia wyciekom.</span><span class="sxs-lookup"><span data-stu-id="cb916-203">Any unmanaged resources that you would clean up in a `finally` should ideally be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle> to prevent leaks.</span></span>  <span data-ttu-id="cb916-204">Uwaga `using` słowo kluczowe języka C# może efektywnie służyć do usuwania obiektów, w tym dojścia.</span><span class="sxs-lookup"><span data-stu-id="cb916-204">Note the C# `using` keyword can be used effectively to dispose of objects, including handles.</span></span>

<span data-ttu-id="cb916-205">Mimo że <xref:System.AppDomain> odtwarzanie może czyścić zasoby w wątku finalizatora, nadal ważne jest, aby w prawidłowym miejscu umieścić kod czyszczący.</span><span class="sxs-lookup"><span data-stu-id="cb916-205">Although <xref:System.AppDomain> recycling can clean up resources on the finalizer thread, it is still important to put cleanup code in the correct place.</span></span> <span data-ttu-id="cb916-206">Należy pamiętać, że jeśli wątek odbiera wyjątek asynchroniczny bez utrzymywania blokady, środowisko CLR próbuje zakończyć wątek bez konieczności odtwarzania <xref:System.AppDomain> .</span><span class="sxs-lookup"><span data-stu-id="cb916-206">Note that if a thread receives an asynchronous exception without holding a lock, the CLR attempts to end the thread itself without having to recycle the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="cb916-207">Zapewnienie, że zasoby są czyszczone wcześniej, a nie w przyszłości, dzięki zwiększeniu liczby dostępnych zasobów i lepszym zarządzaniu okresem istnienia.</span><span class="sxs-lookup"><span data-stu-id="cb916-207">Ensuring that resources are cleaned up sooner rather than later helps by making more resources available, and by better managing the lifetime.</span></span> <span data-ttu-id="cb916-208">Jeśli nie zamkniesz jawnie dojścia do pliku w pewnej ścieżce kodu błędu, poczekaj na jego <xref:System.Runtime.InteropServices.SafeHandle> oczyszczenie, przy następnym uruchomieniu kodu może się nie powieść próba uzyskania dostępu do tego samego pliku, jeśli finalizator nie został jeszcze uruchomiony.</span><span class="sxs-lookup"><span data-stu-id="cb916-208">If you do not explicitly close a handle to a file in some error code path then wait for the <xref:System.Runtime.InteropServices.SafeHandle> finalizer to clean it up, the next time your code runs it may fail trying to access the exact same file if the finalizer has not already run.</span></span>  <span data-ttu-id="cb916-209">Z tego powodu, aby upewnić się, że kod czyszczący istnieje i działa prawidłowo, zapewni bardziej czyste i szybkie odzyskiwanie po błędach, nawet jeśli nie jest to absolutnie konieczne.</span><span class="sxs-lookup"><span data-stu-id="cb916-209">For this reason, ensuring that cleanup code exists and works correctly will help recover from failures more cleanly and quickly, even though it is not strictly necessary.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cb916-210">Reguła analizy kodu</span><span class="sxs-lookup"><span data-stu-id="cb916-210">Code analysis rule</span></span>

<span data-ttu-id="cb916-211">Kod czyszczący po `catch` musi znajdować się w `finally` bloku.</span><span class="sxs-lookup"><span data-stu-id="cb916-211">Cleanup code after `catch` needs to be in a `finally` block.</span></span> <span data-ttu-id="cb916-212">Umieść wywołania do usunięcia w bloku finally.</span><span class="sxs-lookup"><span data-stu-id="cb916-212">Place calls to dispose in a finally block.</span></span> <span data-ttu-id="cb916-213">`catch`bloki powinny kończyć się throw lub Rethrow.</span><span class="sxs-lookup"><span data-stu-id="cb916-213">`catch` blocks should end in a throw or rethrow.</span></span> <span data-ttu-id="cb916-214">Istnieją wyjątki, takie jak kod wykrywający, czy można nawiązać połączenie sieciowe, w przypadku których można uzyskać dowolną liczbę wyjątków, każdy kod wymagający przechwycenia liczby wyjątków w normalnych warunkach powinien dać wskazanie, że kod powinien zostać przetestowany w celu sprawdzenia, czy będzie on się kończyć pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="cb916-214">While there will be exceptions, such as code detecting whether a network connection can be established where you might get any of a large number of exceptions, any code that requires the catching of a number of exceptions under normal circumstances should give an indication that the code should be tested to see if it will succeed.</span></span>

### <a name="process-wide-mutable-shared-state-between-application-domains-should-be-eliminated-or-use-a-constrained-execution-region"></a><span data-ttu-id="cb916-215">Niemodyfikowalny współużytkowany stan procesu między domenami aplikacji należy wyeliminować lub użyć ograniczonego regionu wykonywania</span><span class="sxs-lookup"><span data-stu-id="cb916-215">Process-Wide mutable shared state between application domains should be eliminated or use a constrained execution region</span></span>

<span data-ttu-id="cb916-216">Zgodnie z opisem we wprowadzeniu, może być bardzo trudne, aby napisać kod zarządzany, który monitoruje stan współużytkowany w całej domenie aplikacji w niezawodny sposób.</span><span class="sxs-lookup"><span data-stu-id="cb916-216">As described in the introduction, it can be very difficult to write managed code that monitors process-wide shared state across application domains in a reliable manner.</span></span>  <span data-ttu-id="cb916-217">Współużytkowany stan procesu jest dowolnym rodzajem struktury danych współdzielonym między domenami aplikacji, w kodzie Win32, wewnątrz środowiska CLR lub w zarządzanym kodzie przy użyciu komunikacji zdalnej.</span><span class="sxs-lookup"><span data-stu-id="cb916-217">Process-wide shared state is any sort of data structure shared between application domains, either in Win32 code, inside the CLR, or in managed code using remoting.</span></span>  <span data-ttu-id="cb916-218">Każdy modyfikowalny stan współużytkowany jest bardzo trudny do poprawnego zapisu w kodzie zarządzanym, a wszystkie statyczne Stany udostępnione mogą być wykonywane tylko z dużą ostrożnością.</span><span class="sxs-lookup"><span data-stu-id="cb916-218">Any mutable shared state is very difficult to correctly write in managed code, and any static shared state might be done only with great care.</span></span>  <span data-ttu-id="cb916-219">Jeśli masz współużytkowany stan dla całego procesu lub całego komputera, Znajdź jakiś sposób, aby go wyeliminować lub chronić współużytkowany stan przy użyciu ograniczonego regionu wykonywania (CER).</span><span class="sxs-lookup"><span data-stu-id="cb916-219">If you have process-wide or machine-wide shared state, find some way to eliminate it or protect the shared state using a constrained execution region (CER).</span></span>  <span data-ttu-id="cb916-220">Należy pamiętać, że każda biblioteka ze stanem udostępnionym, który nie został zidentyfikowany i poprawiona, może spowodować, że host, taki jak SQL Server, wymaga czystego <xref:System.AppDomain> wyładowania do awarii.</span><span class="sxs-lookup"><span data-stu-id="cb916-220">Note that any library with shared state that is not identified and corrected could cause a host, such as SQL Server, that requires clean <xref:System.AppDomain> unloading to crash.</span></span>

<span data-ttu-id="cb916-221">Jeśli kod używa obiektu COM, należy unikać udostępniania tego obiektu COM między domenami aplikacji.</span><span class="sxs-lookup"><span data-stu-id="cb916-221">If code uses a COM object, avoid sharing that COM object between application domains.</span></span>

### <a name="locks-do-not-work-process-wide-or-between-application-domains"></a><span data-ttu-id="cb916-222">Blokady nie działają dla całego procesu ani między domenami aplikacji.</span><span class="sxs-lookup"><span data-stu-id="cb916-222">Locks do not work process-wide or between application domains.</span></span>

<span data-ttu-id="cb916-223">W przeszłości, <xref:System.Threading.Monitor.Enter%2A> a [instrukcja Lock](../../csharp/language-reference/keywords/lock-statement.md) została użyta do utworzenia globalnych blokad procesów.</span><span class="sxs-lookup"><span data-stu-id="cb916-223">In the past, <xref:System.Threading.Monitor.Enter%2A> and the [lock Statement](../../csharp/language-reference/keywords/lock-statement.md) have been used to create global process locks.</span></span>  <span data-ttu-id="cb916-224">Na przykład zdarza się to w przypadku blokowania <xref:System.AppDomain> klas Agile, takich jak <xref:System.Type> wystąpienia z zestawów nieudostępnianych, <xref:System.Threading.Thread> obiekty, ciągi InterNIC i niektóre ciągi współużytkowane przez domeny aplikacji przy użyciu komunikacji zdalnej.</span><span class="sxs-lookup"><span data-stu-id="cb916-224">For example, this occurs when locking on <xref:System.AppDomain> agile classes, such as <xref:System.Type> instances from non-shared assemblies, <xref:System.Threading.Thread> objects, interned strings, and some strings shared across application domains using remoting.</span></span>  <span data-ttu-id="cb916-225">Te blokady nie są już cały proces.</span><span class="sxs-lookup"><span data-stu-id="cb916-225">These locks are no longer process-wide.</span></span>  <span data-ttu-id="cb916-226">Aby określić obecność blokady domeny międzyaplikacji obejmującej cały proces, ustal, czy kod w ramach blokady używa dowolnego zewnętrznego, utrwalonego zasobu, takiego jak plik na dysku lub prawdopodobnie baza danych.</span><span class="sxs-lookup"><span data-stu-id="cb916-226">To identify the presence of a process-wide interapplication domain lock, determine if the code within the lock uses any external, persisted resource such as a file on disk or possibly a database.</span></span>

<span data-ttu-id="cb916-227">Należy pamiętać, że przejęcie blokady w ramach <xref:System.AppDomain> może powodować problemy, Jeśli chroniony kod używa zasobu zewnętrznego, ponieważ ten kod może działać jednocześnie w wielu domenach aplikacji.</span><span class="sxs-lookup"><span data-stu-id="cb916-227">Note that taking a lock within an <xref:System.AppDomain> might cause problems if the protected code uses an external resource because that code may run simultaneously across multiple application domains.</span></span>  <span data-ttu-id="cb916-228">Może to być problem podczas zapisywania do jednego pliku dziennika lub powiązania do gniazda dla całego procesu.</span><span class="sxs-lookup"><span data-stu-id="cb916-228">This can be a problem when writing to one log file or binding to a socket for the entire process.</span></span>  <span data-ttu-id="cb916-229">Te zmiany oznaczają, że nie można w prosty sposób korzystać z kodu zarządzanego, aby uzyskać blokadę globalną procesu, inną niż użycie nazwanego <xref:System.Threading.Mutex> lub <xref:System.Threading.Semaphore> wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="cb916-229">These changes mean there is no easy way, using managed code, to get a process-global lock, other than using a named <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> instance.</span></span>  <span data-ttu-id="cb916-230">Utwórz kod, który nie działa jednocześnie w dwóch domenach aplikacji, lub Użyj <xref:System.Threading.Mutex> <xref:System.Threading.Semaphore> klas lub.</span><span class="sxs-lookup"><span data-stu-id="cb916-230">Create code that does not run in two application domains simultaneously, or use the <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> classes.</span></span>  <span data-ttu-id="cb916-231">Jeśli nie można zmienić istniejącego kodu, nie należy używać Win32 o nazwie mutex do osiągnięcia tej synchronizacji, ponieważ działa w trybie Fiber, nie można zagwarantować, że ten sam wątek systemu operacyjnego uzyska i zwolni element mutex.</span><span class="sxs-lookup"><span data-stu-id="cb916-231">If existing code cannot be changed, do not use a Win32 named mutex to achieve this synchronization because running in fiber mode means you cannot guarantee the same operating system thread will acquire and release a mutex.</span></span>  <span data-ttu-id="cb916-232">Należy użyć klasy zarządzanej <xref:System.Threading.Mutex> , lub nazwanej, <xref:System.Threading.ManualResetEvent> <xref:System.Threading.AutoResetEvent> lub a, <xref:System.Threading.Semaphore> Aby zsynchronizować blokadę kodu w sposób, w jaki środowisko CLR ma świadomość zamiast synchronizowania blokady przy użyciu kodu niezarządzanego.</span><span class="sxs-lookup"><span data-stu-id="cb916-232">You must use the managed <xref:System.Threading.Mutex> class, or a named <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent>, or a <xref:System.Threading.Semaphore> to synchronize the code lock in a manner that the CLR is aware of instead of synchronizing the lock using unmanaged code.</span></span>

#### <a name="avoid-locktypeofmytype"></a><span data-ttu-id="cb916-233">Unikaj blokady (typeof (MyType))</span><span class="sxs-lookup"><span data-stu-id="cb916-233">Avoid lock(typeof(MyType))</span></span>

<span data-ttu-id="cb916-234">Obiekty prywatne i publiczne <xref:System.Type> w zestawach współużytkowanych mają tylko jedną kopię kodu współużytkowaną we wszystkich domenach aplikacji.</span><span class="sxs-lookup"><span data-stu-id="cb916-234">Private and public <xref:System.Type> objects in shared assemblies with only one copy of the code shared across all application domains also present problems.</span></span>  <span data-ttu-id="cb916-235">Dla zestawów współużytkowanych istnieje tylko jedno wystąpienie dla <xref:System.Type> każdego procesu, co oznacza, że wiele domen aplikacji współużytkuje to samo <xref:System.Type> wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="cb916-235">For shared assemblies, there is only one instance of a <xref:System.Type> per process, meaning that multiple application domains share the exact same <xref:System.Type> instance.</span></span>  <span data-ttu-id="cb916-236">Zablokowanie <xref:System.Type> wystąpienia ma blokadę, która ma wpływ na cały proces, a nie tylko <xref:System.AppDomain> .</span><span class="sxs-lookup"><span data-stu-id="cb916-236">Taking a lock on a <xref:System.Type> instance takes a lock that affects the entire process, not just the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="cb916-237">Jeśli jeden z nich <xref:System.AppDomain> przyjmuje blokadę <xref:System.Type> obiektu, ten wątek zostaje nagle przerwany, nie spowoduje zwolnienia blokady.</span><span class="sxs-lookup"><span data-stu-id="cb916-237">If one <xref:System.AppDomain> takes a lock on a <xref:System.Type> object then that thread gets abruptly aborted, it will not release the lock.</span></span>  <span data-ttu-id="cb916-238">Ta blokada może spowodować zakleszczenie innych domen aplikacji.</span><span class="sxs-lookup"><span data-stu-id="cb916-238">This lock then may cause other application domains to deadlock.</span></span>

<span data-ttu-id="cb916-239">Dobrym sposobem na wykonywanie blokad w metodach statycznych jest dodanie statycznego obiektu synchronizacji wewnętrznej do kodu.</span><span class="sxs-lookup"><span data-stu-id="cb916-239">A good way to take locks in static methods involves adding a static internal synchronization object to the code.</span></span>  <span data-ttu-id="cb916-240">Ten element może zostać zainicjowany w konstruktorze klasy, jeśli jest obecny, ale jeśli nie można go zainicjować w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="cb916-240">This could be initialized in the class constructor if one is present, but if not it can be initialized like this:</span></span>

```csharp
private static Object s_InternalSyncObject;
private static Object InternalSyncObject
{
    get
    {
        if (s_InternalSyncObject == null)
        {
            Object o = new Object();
            Interlocked.CompareExchange(
                ref s_InternalSyncObject, o, null);
        }
        return s_InternalSyncObject;
    }
}
```

<span data-ttu-id="cb916-241">Następnie przy zablokowaniu należy użyć `InternalSyncObject` właściwości, aby uzyskać obiekt do zablokowania.</span><span class="sxs-lookup"><span data-stu-id="cb916-241">Then when taking a lock, use the `InternalSyncObject` property to obtain an object to lock on.</span></span>  <span data-ttu-id="cb916-242">Nie trzeba używać właściwości, jeśli w konstruktorze klasy został zainicjowany obiekt synchronizacji wewnętrznej.</span><span class="sxs-lookup"><span data-stu-id="cb916-242">You do not need to use the property if you have initialized the internal synchronization object in your class constructor.</span></span>  <span data-ttu-id="cb916-243">Kod inicjalizacji blokady podwójnej kontroli powinien wyglądać podobnie do tego przykładu:</span><span class="sxs-lookup"><span data-stu-id="cb916-243">The double checking lock initialization code should look like this example:</span></span>

```csharp
public static MyClass SingletonProperty
{
    get
    {
        if (s_SingletonProperty == null)
        {
            lock(InternalSyncObject)
            {
                // Do not use lock(typeof(MyClass))
                if (s_SingletonProperty == null)
                {
                    MyClass tmp = new MyClass(…);
                    // Do all initialization before publishing
                    s_SingletonProperty = tmp;
                }
            }
        }
        return s_SingletonProperty;
    }
}
```

#### <a name="a-note-about-lockthis"></a><span data-ttu-id="cb916-244">Uwaga dotycząca blokady (ta)</span><span class="sxs-lookup"><span data-stu-id="cb916-244">A note about lock(this)</span></span>

<span data-ttu-id="cb916-245">Ogólnie akceptowalne jest zablokowanie pojedynczego obiektu, który jest publicznie dostępny.</span><span class="sxs-lookup"><span data-stu-id="cb916-245">It is generally acceptable to take a lock on an individual object that is publicly accessible.</span></span>  <span data-ttu-id="cb916-246">Jeśli jednak obiekt jest pojedynczym obiektem, który może spowodować zakleszczenie całego podsystemu, rozważ użycie powyższego wzorca projektowego.</span><span class="sxs-lookup"><span data-stu-id="cb916-246">However, if the object is a singleton object that might cause an entire subsystem to deadlock, consider using the above design pattern as well.</span></span>  <span data-ttu-id="cb916-247">Na przykład blokada jednego <xref:System.Security.SecurityManager> obiektu może spowodować zakleszczenie w <xref:System.AppDomain> całym <xref:System.AppDomain> stanie nieużytecznym.</span><span class="sxs-lookup"><span data-stu-id="cb916-247">For example, a lock on the one <xref:System.Security.SecurityManager> object could cause a deadlock within the <xref:System.AppDomain> making the entire <xref:System.AppDomain> unusable.</span></span> <span data-ttu-id="cb916-248">Dobrym sposobem, aby nie korzystać z blokady na publicznie dostępnym obiekcie tego typu.</span><span class="sxs-lookup"><span data-stu-id="cb916-248">It is good practice to not take a lock on a publicly accessible object of this type.</span></span>  <span data-ttu-id="cb916-249">Jednak blokada pojedynczej kolekcji lub tablicy nie powinna ogólnie stwarzać problemu.</span><span class="sxs-lookup"><span data-stu-id="cb916-249">However a lock on an individual collection or array should generally not present a problem.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cb916-250">Reguła analizy kodu</span><span class="sxs-lookup"><span data-stu-id="cb916-250">Code analysis rule</span></span>

<span data-ttu-id="cb916-251">Nie należy stosować blokad dla typów, które mogą być używane między domenami aplikacji lub nie mają silnego sensu tożsamości.</span><span class="sxs-lookup"><span data-stu-id="cb916-251">Do not take locks on types that might be used across application domains or do not have a strong sense of identity.</span></span> <span data-ttu-id="cb916-252">Nie wywołuj <xref:System.Threading.Monitor.Enter%2A> w <xref:System.Type> <xref:System.Reflection.MethodInfo> obiektach,,,,, <xref:System.Reflection.PropertyInfo> <xref:System.String> <xref:System.ValueType> <xref:System.Threading.Thread> ani żadnych obiektów, które pochodzą z <xref:System.MarshalByRefObject> .</span><span class="sxs-lookup"><span data-stu-id="cb916-252">Do not call <xref:System.Threading.Monitor.Enter%2A> on a <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread>, or any object that derives from <xref:System.MarshalByRefObject>.</span></span>

### <a name="remove-gckeepalive-calls"></a><span data-ttu-id="cb916-253">Usuwanie wykazu globalnego. Wywołania utrzymywania aktywności</span><span class="sxs-lookup"><span data-stu-id="cb916-253">Remove GC.KeepAlive calls</span></span>

<span data-ttu-id="cb916-254">Znaczna ilość istniejącego kodu nie jest używana, <xref:System.GC.KeepAlive%2A> gdy powinien lub używa go, gdy nie jest to konieczne.</span><span class="sxs-lookup"><span data-stu-id="cb916-254">A significant amount of existing code either does not use <xref:System.GC.KeepAlive%2A> when it should or uses it when it is not appropriate.</span></span>  <span data-ttu-id="cb916-255">Po konwersji na <xref:System.Runtime.InteropServices.SafeHandle> klasy nie muszą być wywoływane <xref:System.GC.KeepAlive%2A> , przy założeniu, że nie mają finalizatora, ale polegają na <xref:System.Runtime.InteropServices.SafeHandle> sfinalizowaniu dojść systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="cb916-255">After converting to <xref:System.Runtime.InteropServices.SafeHandle>, classes do not need to call <xref:System.GC.KeepAlive%2A>, assuming they do not have a finalizer but rely on <xref:System.Runtime.InteropServices.SafeHandle> to finalize the operating system handles.</span></span>  <span data-ttu-id="cb916-256">Chociaż koszt wydajności zachowywania wywołania <xref:System.GC.KeepAlive%2A> może być nieistotny, postrzeganie, że wywołanie <xref:System.GC.KeepAlive%2A> jest niezbędne lub wystarczające, aby rozwiązać problem z okresem istnienia, który może już nie istnieć, utrudnia utrzymywanie kodu.</span><span class="sxs-lookup"><span data-stu-id="cb916-256">While the performance cost of retaining a call to <xref:System.GC.KeepAlive%2A> may be negligible, the perception that a call to <xref:System.GC.KeepAlive%2A> is either necessary or sufficient to solve a lifetime issue that may no longer exist makes the code more difficult to maintain.</span></span>  <span data-ttu-id="cb916-257">Jednak w przypadku korzystania z wywoływanych otok (RCW) modelu COM międzyoperacyjności <xref:System.GC.KeepAlive%2A> jest nadal wymagany kod.</span><span class="sxs-lookup"><span data-stu-id="cb916-257">However, when using the COM interop CLR callable wrappers (RCWs), <xref:System.GC.KeepAlive%2A> is still required by code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cb916-258">Reguła analizy kodu</span><span class="sxs-lookup"><span data-stu-id="cb916-258">Code analysis rule</span></span>

<span data-ttu-id="cb916-259">Usuń <xref:System.GC.KeepAlive%2A> .</span><span class="sxs-lookup"><span data-stu-id="cb916-259">Remove <xref:System.GC.KeepAlive%2A>.</span></span>

### <a name="use-the-hostprotection-attribute"></a><span data-ttu-id="cb916-260">Użyj atrybutu HostProtection</span><span class="sxs-lookup"><span data-stu-id="cb916-260">Use the HostProtection Attribute</span></span>

<span data-ttu-id="cb916-261"><xref:System.Security.Permissions.HostProtectionAttribute>(HPA) umożliwia stosowanie deklaratywnych akcji zabezpieczeń w celu określenia wymagań dotyczących ochrony hosta, co pozwala hostowi zapobiec nawet całkowicie zaufanemu kodowi wywoływanie niektórych metod, które są nieodpowiednie dla danego hosta, takie jak <xref:System.Environment.Exit%2A> lub <xref:System.Windows.Forms.MessageBox.Show%2A> dla SQL Server.</span><span class="sxs-lookup"><span data-stu-id="cb916-261">The <xref:System.Security.Permissions.HostProtectionAttribute> (HPA) provides the use of declarative security actions to determine host protection requirements, allowing the host to prevent even fully trusted code from calling certain methods which are inappropriate for the given host, such as <xref:System.Environment.Exit%2A> or <xref:System.Windows.Forms.MessageBox.Show%2A> for SQL Server.</span></span>

<span data-ttu-id="cb916-262">HPA ma wpływ tylko na niezarządzane aplikacje obsługujące środowisko uruchomieniowe języka wspólnego i implementowanie ochrony hosta, takie jak SQL Server.</span><span class="sxs-lookup"><span data-stu-id="cb916-262">The HPA affects only unmanaged applications that host the common language runtime and implement host protection, such as SQL Server.</span></span> <span data-ttu-id="cb916-263">Po zastosowaniu Akcja zabezpieczeń powoduje utworzenie żądania linku opartego na zasobach hosta, które udostępnia Klasa lub metoda.</span><span class="sxs-lookup"><span data-stu-id="cb916-263">When applied, the security action results in the creation of a link demand based on the host resources the class or method exposes.</span></span> <span data-ttu-id="cb916-264">Jeśli kod jest uruchamiany w aplikacji klienckiej lub na serwerze, który nie jest chroniony przez hosta, atrybut "Parowanie"; nie została wykryta i dlatego nie jest stosowana.</span><span class="sxs-lookup"><span data-stu-id="cb916-264">If the code is run in a client application or on a server that is not host-protected, the attribute "evaporates"; it is not detected and therefore not applied.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="cb916-265">Ten atrybut ma na celu wymuszenie wytycznych dotyczących modelu programowania specyficznych dla hosta, a nie zachowania zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="cb916-265">The purpose of this attribute is to enforce host-specific programming model guidelines, not security behavior.</span></span>  <span data-ttu-id="cb916-266">Mimo że żądanie linku służy do sprawdzania zgodności z wymaganiami modelu programowania, <xref:System.Security.Permissions.HostProtectionAttribute> nie jest to uprawnienie zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="cb916-266">Although a link demand is used to check for conformance to programming model requirements, the <xref:System.Security.Permissions.HostProtectionAttribute> is not a security permission.</span></span>

<span data-ttu-id="cb916-267">Jeśli host nie ma wymagań dotyczących modelu programowania, wymagania dotyczące linków nie występują.</span><span class="sxs-lookup"><span data-stu-id="cb916-267">If the host does not have programming model requirements, the link demands do not occur.</span></span>

<span data-ttu-id="cb916-268">Ten atrybut identyfikuje następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="cb916-268">This attribute identifies the following:</span></span>

- <span data-ttu-id="cb916-269">Metody lub klasy, które nie pasują do modelu programowania hosta, ale są niegroźne.</span><span class="sxs-lookup"><span data-stu-id="cb916-269">Methods or classes that do not fit the host programming model, but are otherwise benign.</span></span>

- <span data-ttu-id="cb916-270">Metody lub klasy, które nie pasują do modelu programowania hosta i mogą prowadzić do destabilizacji kodu użytkownika zarządzanego przez serwer.</span><span class="sxs-lookup"><span data-stu-id="cb916-270">Methods or classes that do not fit the host programming model and could lead to destabilizing server-managed user code.</span></span>

- <span data-ttu-id="cb916-271">Metody lub klasy, które nie pasują do modelu programowania hosta i mogą prowadzić do destabilizacji samego procesu serwera.</span><span class="sxs-lookup"><span data-stu-id="cb916-271">Methods or classes that do not fit the host programming model and could lead to a destabilization of the server process itself.</span></span>

> [!NOTE]
> <span data-ttu-id="cb916-272">W przypadku tworzenia biblioteki klas, która ma być wywoływana przez aplikacje, które mogą być wykonywane w środowisku chronionym hosta, należy zastosować ten atrybut do członków, którzy uwidaczniają <xref:System.Security.Permissions.HostProtectionResource> kategorie zasobów.</span><span class="sxs-lookup"><span data-stu-id="cb916-272">If you are creating a class library that is to be called by applications that may execute in a host protected environment, you should apply this attribute to members that expose <xref:System.Security.Permissions.HostProtectionResource> resource categories.</span></span> <span data-ttu-id="cb916-273">Członkowie biblioteki klas .NET Framework z tym atrybutem powodują, że tylko bezpośredni obiekt wywołujący zostanie sprawdzony.</span><span class="sxs-lookup"><span data-stu-id="cb916-273">The .NET Framework class library members with this attribute cause only the immediate caller to be checked.</span></span>  <span data-ttu-id="cb916-274">Członek biblioteki musi również spowodować sprawdzenie jego bezpośredniego obiektu wywołującego w taki sam sposób.</span><span class="sxs-lookup"><span data-stu-id="cb916-274">Your library member must also cause a check of its immediate caller in the same manner.</span></span>

<span data-ttu-id="cb916-275">Więcej informacji na temat HPA można znaleźć w temacie <xref:System.Security.Permissions.HostProtectionAttribute> .</span><span class="sxs-lookup"><span data-stu-id="cb916-275">Please find more information on HPA in <xref:System.Security.Permissions.HostProtectionAttribute>.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cb916-276">Reguła analizy kodu</span><span class="sxs-lookup"><span data-stu-id="cb916-276">Code analysis rule</span></span>

<span data-ttu-id="cb916-277">W przypadku SQL Server wszystkie metody służące do wprowadzania synchronizacji lub wątkowości muszą być identyfikowane za pomocą HPA.</span><span class="sxs-lookup"><span data-stu-id="cb916-277">For SQL Server, all methods used to introduce synchronization or threading must identified with the HPA.</span></span> <span data-ttu-id="cb916-278">Obejmuje to metody, które udostępniają stan, są synchronizowane lub zarządzają procesami zewnętrznymi.</span><span class="sxs-lookup"><span data-stu-id="cb916-278">This includes methods that share state, are synchronized, or manage external processes.</span></span> <span data-ttu-id="cb916-279"><xref:System.Security.Permissions.HostProtectionResource>Wartości, które mają wpływ SQL Server <xref:System.Security.Permissions.HostProtectionResource.SharedState> to, <xref:System.Security.Permissions.HostProtectionResource.Synchronization> i <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt> .</span><span class="sxs-lookup"><span data-stu-id="cb916-279">The <xref:System.Security.Permissions.HostProtectionResource> values that impact SQL Server are <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization>, and <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span></span> <span data-ttu-id="cb916-280">Jednakże każda metoda, która ujawnia wszystkie <xref:System.Security.Permissions.HostProtectionResource> powinny być identyfikowane przez hPa, a nie tylko za pomocą zasobów wpływających na SQL.</span><span class="sxs-lookup"><span data-stu-id="cb916-280">However, any method that exposes any <xref:System.Security.Permissions.HostProtectionResource> should be identified by a HPA, not just those using resources affecting SQL.</span></span>

### <a name="do-not-block-indefinitely-in-unmanaged-code"></a><span data-ttu-id="cb916-281">Nie blokuj na czas nieokreślony w kodzie niezarządzanym</span><span class="sxs-lookup"><span data-stu-id="cb916-281">Do not block indefinitely in unmanaged code</span></span>

<span data-ttu-id="cb916-282">Zablokowanie w kodzie niezarządzanym zamiast w kodzie zarządzanym może spowodować atak typu "odmowa usługi", ponieważ środowisko CLR nie może przerwać wątku.</span><span class="sxs-lookup"><span data-stu-id="cb916-282">Blocking in unmanaged code instead of in managed code can cause a denial of service attack because the CLR is not able to abort the thread.</span></span>  <span data-ttu-id="cb916-283">Zablokowany wątek zapobiega zwalnianiu przez środowisko CLR <xref:System.AppDomain> , co najmniej bez wykonywania bardzo niebezpiecznych operacji.</span><span class="sxs-lookup"><span data-stu-id="cb916-283">A blocked thread prevents the CLR from unloading the <xref:System.AppDomain>, at least without doing some extremely unsafe operations.</span></span>  <span data-ttu-id="cb916-284">Blokowanie przy użyciu elementu podstawowego synchronizacji systemu Windows to oczywisty przykład niedozwolonego elementu.</span><span class="sxs-lookup"><span data-stu-id="cb916-284">Blocking using a Windows synchronization primitive is a clear example of something we cannot allow.</span></span>  <span data-ttu-id="cb916-285">`ReadFile`Jeśli to możliwe, należy unikać blokowania w gnieździe. najlepszym rozwiązaniem jest interfejs API systemu Windows, który umożliwia przekroczenie limitu czasu dla operacji.</span><span class="sxs-lookup"><span data-stu-id="cb916-285">Blocking in a call to `ReadFile` on a socket should be avoided if possible — ideally the Windows API should provide a mechanism for an operation like this to time out.</span></span>

<span data-ttu-id="cb916-286">Wszystkie metody, które wywołuje do natywnego, powinny używać wywołania Win32 z rozsądnym, ograniczonym limitem czasu.</span><span class="sxs-lookup"><span data-stu-id="cb916-286">Any method that calls into native should ideally use a Win32 call with a reasonable, finite timeout.</span></span>  <span data-ttu-id="cb916-287">Jeśli użytkownik może określić limit czasu, użytkownik nie powinien być uprawniony do określania nieskończonego limitu czasu bez określonego uprawnienia zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="cb916-287">If the user is allowed to specify the timeout, the user should not be allowed to specify an infinite timeout without some specific security permission.</span></span>  <span data-ttu-id="cb916-288">Jako wskazówkę, jeśli metoda będzie blokować ponad 10 sekund, należy używać wersji, która obsługuje limity czasu, lub potrzebna jest dodatkowa obsługa środowiska CLR.</span><span class="sxs-lookup"><span data-stu-id="cb916-288">As a guideline, if a method will block for more than ~10 seconds, you need to be using a version that supports timeouts or you need additional CLR support.</span></span>

<span data-ttu-id="cb916-289">Poniżej przedstawiono kilka przykładów problematycznych interfejsów API.</span><span class="sxs-lookup"><span data-stu-id="cb916-289">Here are some examples of problematic APIs.</span></span>  <span data-ttu-id="cb916-290">Potoki (anonimowe i nazwane) można utworzyć z limitem czasu; Jednak kod musi upewnić się, że nigdy nie wywołuje `CreateNamedPipe` ani nie `WaitNamedPipe` NMPWAIT_WAIT_FOREVER.</span><span class="sxs-lookup"><span data-stu-id="cb916-290">Pipes (both anonymous and named) can be created with a timeout; however, code must ensure it never calls `CreateNamedPipe` nor `WaitNamedPipe` with NMPWAIT_WAIT_FOREVER.</span></span>  <span data-ttu-id="cb916-291">Ponadto może wystąpić nieoczekiwane blokowanie nawet w przypadku określenia limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="cb916-291">Additionally, there can be unexpected blocking even if a timeout is specified.</span></span>  <span data-ttu-id="cb916-292">Wywołanie `WriteFile` dla potoku anonimowego będzie blokowane do momentu zapisania wszystkich bajtów, co oznacza, że bufor nie odczytał w nim danych, `WriteFile` wywołanie zostanie zablokowane do momentu, gdy czytnik zwolni miejsce w buforze potoku.</span><span class="sxs-lookup"><span data-stu-id="cb916-292">Calling `WriteFile` on an anonymous pipe will block until all bytes are written, meaning if the buffer has unread data in it, the `WriteFile` call will block until the reader has freed up space in the pipe’s buffer.</span></span>  <span data-ttu-id="cb916-293">Gniazda powinny zawsze używać niektórych interfejsów API, które zapewnią mechanizm przekroczenia limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="cb916-293">Sockets should always use some API that honors a timeout mechanism.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cb916-294">Reguła analizy kodu</span><span class="sxs-lookup"><span data-stu-id="cb916-294">Code analysis rule</span></span>

<span data-ttu-id="cb916-295">Zablokowanie bez limitu czasu w kodzie niezarządzanym oznacza atak typu "odmowa usługi".</span><span class="sxs-lookup"><span data-stu-id="cb916-295">Blocking without a timeout in unmanaged code is a denial of service attack.</span></span> <span data-ttu-id="cb916-296">Nie wykonuj wywołań wywołania platformy `WaitForSingleObject` ,,, `WaitForSingleObjectEx` `WaitForMultipleObjects` `MsgWaitForMultipleObjects` i `MsgWaitForMultipleObjectsEx` .</span><span class="sxs-lookup"><span data-stu-id="cb916-296">Do not perform platform invoke calls to `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects`, and `MsgWaitForMultipleObjectsEx`.</span></span>  <span data-ttu-id="cb916-297">Nie należy używać NMPWAIT_WAIT_FOREVER.</span><span class="sxs-lookup"><span data-stu-id="cb916-297">Do not use NMPWAIT_WAIT_FOREVER.</span></span>

### <a name="identify-any-sta-dependent-features"></a><span data-ttu-id="cb916-298">Identyfikowanie wszelkich funkcji zależnych od STA</span><span class="sxs-lookup"><span data-stu-id="cb916-298">Identify any STA-Dependent features</span></span>

<span data-ttu-id="cb916-299">Zidentyfikuj każdy kod, który używa apartamentach pojedynczego wątku COM (STAs).</span><span class="sxs-lookup"><span data-stu-id="cb916-299">Identify any code that uses COM single-threaded apartments (STAs).</span></span>  <span data-ttu-id="cb916-300">STAs są wyłączone w procesie SQL Server.</span><span class="sxs-lookup"><span data-stu-id="cb916-300">STAs are disabled in the SQL Server process.</span></span>  <span data-ttu-id="cb916-301">Funkcje, które są zależne od `CoInitialize` , takie jak liczniki wydajności lub schowek, muszą być wyłączone w SQL Server.</span><span class="sxs-lookup"><span data-stu-id="cb916-301">Features that depend on `CoInitialize`, such as performance counters or the clipboard, must be disabled within SQL Server.</span></span>

### <a name="ensure-finalizers-are-free-of-synchronization-problems"></a><span data-ttu-id="cb916-302">Upewnij się, że finalizatory nie mają problemów z synchronizacją</span><span class="sxs-lookup"><span data-stu-id="cb916-302">Ensure finalizers are free of synchronization problems</span></span>

<span data-ttu-id="cb916-303">W przyszłych wersjach .NET Framework może istnieć wiele wątków finalizatorów, co oznacza, że finalizatory dla różnych wystąpień tego samego typu są uruchamiane jednocześnie.</span><span class="sxs-lookup"><span data-stu-id="cb916-303">Multiple finalizer threads might exist in future versions of the .NET Framework, meaning the finalizers for different instances of the same type run simultaneously.</span></span>  <span data-ttu-id="cb916-304">Nie muszą być całkowicie bezpieczne wątkowo. Moduł wyrzucania elementów bezużytecznych gwarantuje, że tylko jeden wątek uruchomi finalizator dla danego wystąpienia obiektu.</span><span class="sxs-lookup"><span data-stu-id="cb916-304">They do not have to be completely thread safe; the garbage collector guarantees that only one thread will run the finalizer for a given object instance.</span></span>  <span data-ttu-id="cb916-305">Jednakże finalizatory muszą być kodowane, aby uniknąć sytuacji wyścigu i zakleszczenii podczas jednoczesnego uruchamiania na wielu różnych wystąpieniach obiektów.</span><span class="sxs-lookup"><span data-stu-id="cb916-305">However, the finalizers must be coded to avoid race conditions and deadlocks when running simultaneously on multiple different object instances.</span></span>  <span data-ttu-id="cb916-306">W przypadku korzystania z dowolnego stanu zewnętrznego, takiego jak zapis w pliku dziennika, w finalizatorze należy obsługiwać problemy wątkowości.</span><span class="sxs-lookup"><span data-stu-id="cb916-306">When using any external state, such as writing to a log file, in a finalizer, threading issues must be handled.</span></span>  <span data-ttu-id="cb916-307">Nie należy polegać na finalizowaniu w celu zapewnienia bezpieczeństwa wątków.</span><span class="sxs-lookup"><span data-stu-id="cb916-307">Do not rely on finalization to provide thread safety.</span></span> <span data-ttu-id="cb916-308">Nie używaj magazynu lokalnego wątku, zarządzanego lub natywnego, aby przechowywać stan w wątku finalizatora.</span><span class="sxs-lookup"><span data-stu-id="cb916-308">Do not use thread local storage, managed or native, to store state on the finalizer thread.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cb916-309">Reguła analizy kodu</span><span class="sxs-lookup"><span data-stu-id="cb916-309">Code analysis rule</span></span>

<span data-ttu-id="cb916-310">Finalizatory muszą być pozbawione problemów z synchronizacją.</span><span class="sxs-lookup"><span data-stu-id="cb916-310">Finalizers must be free of synchronization problems.</span></span> <span data-ttu-id="cb916-311">Nie należy używać statycznego stanu mutable w finalizatorze.</span><span class="sxs-lookup"><span data-stu-id="cb916-311">Do not use a static mutable state in a finalizer.</span></span>

### <a name="avoid-unmanaged-memory-if-possible"></a><span data-ttu-id="cb916-312">Unikaj niezarządzanej pamięci, jeśli jest to możliwe</span><span class="sxs-lookup"><span data-stu-id="cb916-312">Avoid unmanaged memory if possible</span></span>

<span data-ttu-id="cb916-313">Niezarządzana pamięć może być przeciekiem, podobnie jak dojście systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="cb916-313">Unmanaged memory can be leaked, just like an operating system handle.</span></span> <span data-ttu-id="cb916-314">Jeśli to możliwe, spróbuj użyć pamięci na stosie przy użyciu [stackalloc](../../csharp/language-reference/operators/stackalloc.md) lub przypiętego obiektu zarządzanego, takiego jak [instrukcja FIXED](../../csharp/language-reference/keywords/fixed-statement.md) lub <xref:System.Runtime.InteropServices.GCHandle> przy użyciu typu Byte [].</span><span class="sxs-lookup"><span data-stu-id="cb916-314">If possible, try to use memory on the stack using [stackalloc](../../csharp/language-reference/operators/stackalloc.md) or a pinned managed object such as the [fixed Statement](../../csharp/language-reference/keywords/fixed-statement.md) or a <xref:System.Runtime.InteropServices.GCHandle> using a byte[].</span></span> <span data-ttu-id="cb916-315"><xref:System.GC>Ostatecznie czyści te.</span><span class="sxs-lookup"><span data-stu-id="cb916-315">The <xref:System.GC> eventually cleans these up.</span></span> <span data-ttu-id="cb916-316">Jeśli jednak należy przydzielić pamięć niezarządzaną, należy rozważyć użycie klasy, która pochodzi od, <xref:System.Runtime.InteropServices.SafeHandle> aby otoczyć alokację pamięci.</span><span class="sxs-lookup"><span data-stu-id="cb916-316">However, if you must allocate unmanaged memory, consider using a class that derives from <xref:System.Runtime.InteropServices.SafeHandle> to wrap the memory allocation.</span></span>

<span data-ttu-id="cb916-317">Należy zauważyć, że istnieje co najmniej jeden przypadek, gdzie <xref:System.Runtime.InteropServices.SafeHandle> nie jest odpowiedni.</span><span class="sxs-lookup"><span data-stu-id="cb916-317">Note that there is at least one case where <xref:System.Runtime.InteropServices.SafeHandle> is not adequate.</span></span> <span data-ttu-id="cb916-318">W przypadku wywołań metod COM, które przydzielą lub zwalniają pamięć, typowe dla jednej biblioteki DLL do przydzielania pamięci za pośrednictwem `CoTaskMemAlloc` innej biblioteki dll powoduje zwolnienie tej pamięci z `CoTaskMemFree` .</span><span class="sxs-lookup"><span data-stu-id="cb916-318">For COM method calls that allocate or free memory, it is common for one DLL to allocate memory via `CoTaskMemAlloc` then another DLL frees that memory with `CoTaskMemFree`.</span></span>  <span data-ttu-id="cb916-319">Użycie <xref:System.Runtime.InteropServices.SafeHandle> w tych miejscach byłoby nieodpowiednie, ponieważ podejmie próbę powiązania okresu istnienia niezarządzanej pamięci z okresem istnienia <xref:System.Runtime.InteropServices.SafeHandle> zamiast zezwalania innej bibliotece DLL na kontrolowanie okresu istnienia pamięci.</span><span class="sxs-lookup"><span data-stu-id="cb916-319">Using <xref:System.Runtime.InteropServices.SafeHandle> in these places would be inappropriate since it will attempt to tie the lifetime of the unmanaged memory to the lifetime of the <xref:System.Runtime.InteropServices.SafeHandle> instead of allowing the other DLL control the lifetime of the memory.</span></span>

### <a name="review-all-uses-of-catchexception"></a><span data-ttu-id="cb916-320">Przejrzyj wszystkie zastosowania catch (Exception)</span><span class="sxs-lookup"><span data-stu-id="cb916-320">Review all uses of catch(Exception)</span></span>

<span data-ttu-id="cb916-321">Bloki catch, które przechwytują wszystkie wyjątki zamiast jednego konkretnego wyjątku, przechwytuje teraz także asynchroniczne wyjątki.</span><span class="sxs-lookup"><span data-stu-id="cb916-321">Catch blocks that catch all exceptions instead of one specific exception will now catch the asynchronous exceptions as well.</span></span> <span data-ttu-id="cb916-322">Sprawdzaj każdy blok catch (Exception), szukając braku ważnych zasobów do zwolnienia lub Wycofaj, które mogą zostać pominięte, a także potencjalnie niepoprawnych zachowań w ramach bloku catch do obsługi <xref:System.Threading.ThreadAbortException> , <xref:System.StackOverflowException> , lub <xref:System.OutOfMemoryException> .</span><span class="sxs-lookup"><span data-stu-id="cb916-322">Examine every catch(Exception) block, looking for no important resource releasing or backout code that might be skipped, as well as potentially incorrect behavior within the catch block itself for handling a <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, or <xref:System.OutOfMemoryException>.</span></span>  <span data-ttu-id="cb916-323">Należy zauważyć, że jest możliwe, że ten kod może być rejestrowany lub założono, że może on tylko widzieć pewne wyjątki, lub że w przypadku wystąpienia wyjątku nie powiodło się z dokładnie jedną z określonych przyczyn.</span><span class="sxs-lookup"><span data-stu-id="cb916-323">Note that it is possible this code might be logging or making some assumptions that it may only see certain exceptions, or that whenever an exception happens it failed for exactly one particular reason.</span></span>  <span data-ttu-id="cb916-324">Te założenia mogą wymagać aktualizacji w celu uwzględnienia <xref:System.Threading.ThreadAbortException> .</span><span class="sxs-lookup"><span data-stu-id="cb916-324">These assumptions may need to be updated to include <xref:System.Threading.ThreadAbortException>.</span></span>

<span data-ttu-id="cb916-325">Rozważ zmianę wszystkich miejsc, które przechwytują wszystkie wyjątki, aby przechwycić określony typ wyjątku, który będzie oczekiwany, na przykład <xref:System.FormatException> z metody formatowania ciągu.</span><span class="sxs-lookup"><span data-stu-id="cb916-325">Consider changing all places that catch all exceptions to catching a specific type of exception that you expect will be thrown, such as a <xref:System.FormatException> from string formatting methods.</span></span>  <span data-ttu-id="cb916-326">Zapobiega to uruchamianiu bloku catch w przypadku nieoczekiwanych wyjątków i pomaga upewnić się, że kod nie ukrywa błędów przez przechwycenie nieoczekiwanych wyjątków.</span><span class="sxs-lookup"><span data-stu-id="cb916-326">This prevents the catch block from running on unexpected exceptions and will help ensure the code does not hide bugs by catching unexpected exceptions.</span></span>  <span data-ttu-id="cb916-327">Ponieważ ogólna reguła nigdy nie obsługuje wyjątku w kodzie biblioteki (kod, który wymaga przechwytywania wyjątku może wskazywać na przykład projektu w wywoływanym kodzie).</span><span class="sxs-lookup"><span data-stu-id="cb916-327">As a general rule never handle an exception in library code (code that requires you to catch an exception may indicate a design flaw in the code you are calling).</span></span>  <span data-ttu-id="cb916-328">W niektórych przypadkach może być konieczne przechwycenie wyjątku i zgłoszenie innego typu wyjątku w celu zapewnienia większej ilości danych.</span><span class="sxs-lookup"><span data-stu-id="cb916-328">In some cases you may want to catch an exception and throw a different exception type to provide more data.</span></span>  <span data-ttu-id="cb916-329">Używaj zagnieżdżonych wyjątków w tym przypadku, przechowując rzeczywistą przyczynę niepowodzenia w <xref:System.Exception.InnerException%2A> właściwości nowego wyjątku.</span><span class="sxs-lookup"><span data-stu-id="cb916-329">Use nested exceptions in this case, storing the real cause of the failure in the <xref:System.Exception.InnerException%2A> property of the new exception.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cb916-330">Reguła analizy kodu</span><span class="sxs-lookup"><span data-stu-id="cb916-330">Code analysis rule</span></span>

<span data-ttu-id="cb916-331">Przejrzyj wszystkie bloki catch w zarządzanym kodzie, który przechwytuje wszystkie obiekty lub przechwytuje wszystkie wyjątki.</span><span class="sxs-lookup"><span data-stu-id="cb916-331">Review all catch blocks in managed code that catch all objects or catch all exceptions.</span></span>  <span data-ttu-id="cb916-332">W języku C# oznacza to Oflagowanie zarówno `catch` {} , jak i `catch(Exception)` {} .</span><span class="sxs-lookup"><span data-stu-id="cb916-332">In C#, this means flagging both `catch` {} and `catch(Exception)` {}.</span></span>  <span data-ttu-id="cb916-333">Rozważ, aby typ wyjątku był bardzo specyficzny, lub sprawdź kod, aby upewnić się, że nie działa w sposób niewłaściwy, jeśli przechwytuje nieoczekiwany typ wyjątku.</span><span class="sxs-lookup"><span data-stu-id="cb916-333">Consider making the exception type very specific, or review the code to ensure it does not act in a bad way if it catches an unexpected exception type.</span></span>

### <a name="do-not-assume-a-managed-thread-is-a-win32-thread--it-is-a-fiber"></a><span data-ttu-id="cb916-334">Nie przyjmij wątku zarządzanego jako wątku Win32 — jest to włókna</span><span class="sxs-lookup"><span data-stu-id="cb916-334">Do not assume a managed thread is a Win32 thread – It is a Fiber</span></span>

<span data-ttu-id="cb916-335">Korzystanie z lokalnego magazynu wątku zarządzanego działa, ale nie można użyć magazynu lokalnego wątku niezarządzanego lub założenia, że kod zostanie uruchomiony ponownie w bieżącym wątku systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="cb916-335">Using managed thread local storage does work, but you may not use unmanaged thread local storage or assume the code will run on the current operating system thread again.</span></span> <span data-ttu-id="cb916-336">Nie należy zmieniać ustawień, takich jak ustawienia regionalne wątku.</span><span class="sxs-lookup"><span data-stu-id="cb916-336">Do not change settings like the thread’s locale.</span></span> <span data-ttu-id="cb916-337">Nie wywołuj `InitializeCriticalSection` ani `CreateMutex` za pośrednictwem wywołania platformy, ponieważ wymagają one wątku systemu operacyjnego, który wprowadza blokadę, również zamyka blokadę.</span><span class="sxs-lookup"><span data-stu-id="cb916-337">Do not call `InitializeCriticalSection` or `CreateMutex` via platform invoke because they require the operating system thread that enters a lock also exit the lock.</span></span> <span data-ttu-id="cb916-338">Ponieważ nie będzie to miało znaczenia w przypadku korzystania z włókien, sekcje krytyczne Win32 i muteksy nie mogą być używane bezpośrednio w programie SQL.</span><span class="sxs-lookup"><span data-stu-id="cb916-338">Since this will not be the case when using fibers, Win32 critical sections and mutexes cannot be used in SQL directly.</span></span>  <span data-ttu-id="cb916-339">Należy zauważyć, że Klasa zarządzana nie obsługuje <xref:System.Threading.Mutex> tych kwestii koligacji wątków.</span><span class="sxs-lookup"><span data-stu-id="cb916-339">Note that the managed <xref:System.Threading.Mutex> class does not handle these thread affinity concerns.</span></span>

<span data-ttu-id="cb916-340">Można bezpiecznie użyć większości stanu na zarządzanym <xref:System.Threading.Thread> obiekcie, w tym lokalnego magazynu wątku zarządzanego i kultury interfejsu użytkownika bieżącego wątku.</span><span class="sxs-lookup"><span data-stu-id="cb916-340">You can safely use most of the state on a managed <xref:System.Threading.Thread> object, including managed thread local storage and the thread’s current UI culture.</span></span> <span data-ttu-id="cb916-341">Można również użyć <xref:System.ThreadStaticAttribute> , która powoduje, że wartość istniejącej zmiennej statycznej jest dostępna tylko w bieżącym wątku zarządzanym (jest to inny sposób na przeprowadzenie magazynu lokalnego Fiber w środowisku CLR).</span><span class="sxs-lookup"><span data-stu-id="cb916-341">You can also use the <xref:System.ThreadStaticAttribute>, which makes the value of an existing static variable accessible only by the current managed thread (this is another way of doing fiber local storage in the CLR).</span></span> <span data-ttu-id="cb916-342">Ze względu na model programowania nie można zmienić bieżącej kultury wątku w przypadku uruchamiania w programie SQL Server.</span><span class="sxs-lookup"><span data-stu-id="cb916-342">For programming model reasons, you can not change the current culture of a thread when running in SQL.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cb916-343">Reguła analizy kodu</span><span class="sxs-lookup"><span data-stu-id="cb916-343">Code analysis rule</span></span>

<span data-ttu-id="cb916-344">SQL Server działa w trybie Fiber; nie używaj magazynu lokalnego wątków.</span><span class="sxs-lookup"><span data-stu-id="cb916-344">SQL Server runs in fiber mode; do not use thread local storage.</span></span> <span data-ttu-id="cb916-345">Unikaj wywoływania wywołań przez platformę `TlsAlloc` , `TlsFree` , `TlsGetValue` , i`TlsSetValue.`</span><span class="sxs-lookup"><span data-stu-id="cb916-345">Avoid platform invoke calls to `TlsAlloc`, `TlsFree`, `TlsGetValue`, and `TlsSetValue.`</span></span>

### <a name="let-sql-server-handle-impersonation"></a><span data-ttu-id="cb916-346">Zezwól na SQL Server personifikacji</span><span class="sxs-lookup"><span data-stu-id="cb916-346">Let SQL Server handle impersonation</span></span>

<span data-ttu-id="cb916-347">Ponieważ personifikacja działa na poziomie wątku, a SQL może działać w trybie Fiber, kod zarządzany nie powinien personifikować użytkowników i nie powinien wywoływać `RevertToSelf` .</span><span class="sxs-lookup"><span data-stu-id="cb916-347">Since impersonation operates on the thread level and SQL can run in fiber mode, managed code should not impersonate users, and should not call `RevertToSelf`.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cb916-348">Reguła analizy kodu</span><span class="sxs-lookup"><span data-stu-id="cb916-348">Code analysis rule</span></span>

<span data-ttu-id="cb916-349">Zezwól na SQL Server personifikacji.</span><span class="sxs-lookup"><span data-stu-id="cb916-349">Let SQL Server handle impersonation.</span></span> <span data-ttu-id="cb916-350">Nie używaj `RevertToSelf` ,,,,,, `ImpersonateAnonymousToken` ,, `DdeImpersonateClient` `ImpersonateDdeClientWindow` `ImpersonateLoggedOnUser` `ImpersonateNamedPipeClient` `ImpersonateSelf` `RpcImpersonateClient` `RpcRevertToSelf` , `RpcRevertToSelfEx` , lub `SetThreadToken` .</span><span class="sxs-lookup"><span data-stu-id="cb916-350">Do not use `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx`, or `SetThreadToken`.</span></span>

### <a name="do-not-call-threadsuspend"></a><span data-ttu-id="cb916-351">Nie wywołuj wątku:: Suspend</span><span class="sxs-lookup"><span data-stu-id="cb916-351">Do not call Thread::Suspend</span></span>

<span data-ttu-id="cb916-352">Możliwość zawieszenia wątku może wydawać się prostą operacją, ale może to spowodować zakleszczenie.</span><span class="sxs-lookup"><span data-stu-id="cb916-352">The ability to suspend a thread may appear a simple operation, but it can cause deadlocks.</span></span>  <span data-ttu-id="cb916-353">Jeśli wątek przechowujący blokadę jest zawieszony przez drugi wątek, a następnie drugi wątek podejmuje tę samą blokadę, wystąpi zakleszczenie.</span><span class="sxs-lookup"><span data-stu-id="cb916-353">If a thread holding a lock gets suspended by a second thread and then the second thread tries taking the same lock, a deadlock occurs.</span></span>  <span data-ttu-id="cb916-354"><xref:System.Threading.Thread.Suspend%2A>może kolidować z zabezpieczeniami, ładowaniem klas, usługami zdalnymi i odbiciem.</span><span class="sxs-lookup"><span data-stu-id="cb916-354"><xref:System.Threading.Thread.Suspend%2A> can interfere with security, class loading, remoting, and reflection currently.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="cb916-355">Reguła analizy kodu</span><span class="sxs-lookup"><span data-stu-id="cb916-355">Code analysis rule</span></span>

<span data-ttu-id="cb916-356">Nie wywołuj <xref:System.Threading.Thread.Suspend%2A> .</span><span class="sxs-lookup"><span data-stu-id="cb916-356">Do not call <xref:System.Threading.Thread.Suspend%2A>.</span></span> <span data-ttu-id="cb916-357">Rozważ zamiast tego użycie rzeczywistego elementu podstawowego synchronizacji, takiego jak <xref:System.Threading.Semaphore> lub <xref:System.Threading.ManualResetEvent> .</span><span class="sxs-lookup"><span data-stu-id="cb916-357">Consider using a real synchronization primitive instead, such as a <xref:System.Threading.Semaphore> or <xref:System.Threading.ManualResetEvent> .</span></span>

### <a name="protect-critical-operations-with-constrained-execution-regions-and-reliability-contracts"></a><span data-ttu-id="cb916-358">Ochrona krytycznych operacji przy użyciu ograniczonych regionów wykonywania i kontraktów niezawodności</span><span class="sxs-lookup"><span data-stu-id="cb916-358">Protect critical operations with constrained execution regions and reliability contracts</span></span>

<span data-ttu-id="cb916-359">Podczas wykonywania złożonej operacji, która aktualizuje stan udostępniony lub który musi być deterministyczny w pełni powodzenie lub w pełni niepowodzeniem, należy się upewnić, że jest ona chroniona przez ograniczony region wykonywania (CER).</span><span class="sxs-lookup"><span data-stu-id="cb916-359">When performing a complex operation that updates a shared status or that needs to deterministically either fully succeed or fully fail, be sure that it is protected by a constrained execution region (CER).</span></span> <span data-ttu-id="cb916-360">Gwarantuje to, że kod jest uruchamiany w każdym przypadku, nawet Nagłe przerwanie wątku lub nagłe <xref:System.AppDomain> zwolnienie.</span><span class="sxs-lookup"><span data-stu-id="cb916-360">This guarantees that the code runs in every case, even an abrupt thread abort or an abrupt <xref:System.AppDomain> unload.</span></span>

<span data-ttu-id="cb916-361">CER jest określonym `try/finally` blokiem bezpośrednio poprzedzonym wywołaniem do <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> .</span><span class="sxs-lookup"><span data-stu-id="cb916-361">A CER is a particular `try/finally` block immediately preceded by a call to <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span></span>

<span data-ttu-id="cb916-362">Wykonanie tej czynności powoduje, że kompilator just in Time przygotowuje cały kod w bloku finally przed uruchomieniem `try` bloku.</span><span class="sxs-lookup"><span data-stu-id="cb916-362">Doing so instructs the just-in-time compiler to prepare all the code in the finally block before running the `try` block.</span></span> <span data-ttu-id="cb916-363">Gwarantuje to, że kod w bloku finally jest zbudowany i będzie działać we wszystkich przypadkach.</span><span class="sxs-lookup"><span data-stu-id="cb916-363">This guarantees that the code in the finally block is built and will run in all cases.</span></span> <span data-ttu-id="cb916-364">Nie jest to sytuacja, w której plik CER ma pusty `try` blok.</span><span class="sxs-lookup"><span data-stu-id="cb916-364">It is not uncommon in a CER to have an empty `try` block.</span></span> <span data-ttu-id="cb916-365">Używanie narzędzia CER chroni przed asynchronicznymi przerwami wątku i wyjątkami braku pamięci.</span><span class="sxs-lookup"><span data-stu-id="cb916-365">Using a CER protects against asynchronous thread aborts and out-of-memory exceptions.</span></span> <span data-ttu-id="cb916-366">Zapoznaj się z <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> formularzem cer, który dodatkowo obsługuje nadprzepływy stosu, aby przekroczyć poziom głębokiego kodu.</span><span class="sxs-lookup"><span data-stu-id="cb916-366">See <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> for a form of a CER that additionally handles stack overflows for exceedingly deep code.</span></span>

## <a name="see-also"></a><span data-ttu-id="cb916-367">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="cb916-367">See also</span></span>

- <xref:System.Runtime.ConstrainedExecution>
- [<span data-ttu-id="cb916-368">Atrybuty ochrony hosta i programowanie SQL Server</span><span class="sxs-lookup"><span data-stu-id="cb916-368">SQL Server Programming and Host Protection Attributes</span></span>](sql-server-programming-and-host-protection-attributes.md)
