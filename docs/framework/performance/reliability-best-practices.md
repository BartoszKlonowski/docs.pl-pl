---
title: Najlepsze rozwiązania dotyczące niezawodności
ms.date: 03/30/2017
helpviewer_keywords:
- marking locks
- rebooting databases
- denial of service attacks
- back-out code
- SQL Server [.NET Framework], reliability
- synchronization, reliability
- single-threaded COM components
- slow leaks
- suspending threads
- asynchronous exception handling
- leaked resources [.NET Framework]
- unmanaged memory
- memory, reliability
- threading [.NET Framework], reliability
- process-wide domain shared states
- shared states
- SafeHandle class, reliability
- reliability contracts [.NET Framework]
- cleanup operations
- constrained execution regions
- CERs
- finalizers, reliability
- reliability [.NET Framework]
- blocks, reliability
- finally clauses
- cross-application domain shared states
- catch blocks
- identifying locks
- writing reliable code
- impersonation
- GC.KeepAlive method
- managed threading
- locks, reliability
- STA-dependent features
- fibers
ms.assetid: cf624c1f-c160-46a1-bb2b-213587688da7
author: mairaw
ms.author: mairaw
ms.openlocfilehash: d6f29d15297fc7faff6bb3bb07ee535647c2bb7a
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 05/04/2018
---
# <a name="reliability-best-practices"></a><span data-ttu-id="3dc41-102">Najlepsze rozwiązania dotyczące niezawodności</span><span class="sxs-lookup"><span data-stu-id="3dc41-102">Reliability Best Practices</span></span>
<span data-ttu-id="3dc41-103">Następujące reguły niezawodności są ukierunkowane do programu SQL Server; jednak mają one również zastosowanie do aplikacji opartej na hoście serwera.</span><span class="sxs-lookup"><span data-stu-id="3dc41-103">The following reliability rules are oriented to SQL Server; however, they also apply to any host-based server application.</span></span> <span data-ttu-id="3dc41-104">Jest bardzo ważne, że serwery, takich jak SQL Server nie nastąpił przeciek zasobów i nie można przełączyć w dół.</span><span class="sxs-lookup"><span data-stu-id="3dc41-104">It is extremely important that servers such as SQL Server not leak resources and not be brought down.</span></span>  <span data-ttu-id="3dc41-105">Jednak, że nie można wykonać pisząc kod wycofujący się dla każdej metody, która zmienia stan obiektu.</span><span class="sxs-lookup"><span data-stu-id="3dc41-105">However, that cannot be done by writing back-out code for every method that alters an object’s state.</span></span>  <span data-ttu-id="3dc41-106">Celem jest nie do pisania 100 procent niezawodnej zarządzanego kodu, który będzie odzyskanie wszystkich błędów w każdej lokalizacji kod wycofujący się.</span><span class="sxs-lookup"><span data-stu-id="3dc41-106">The goal is not to write 100 percent reliable managed code that will recover from any errors in every location with back-out code.</span></span>  <span data-ttu-id="3dc41-107">Który będzie stanowić nie lada wyzwanie z małego prawdopodobieństwo pomyślnego.</span><span class="sxs-lookup"><span data-stu-id="3dc41-107">That would be a daunting task with little chance of success.</span></span>  <span data-ttu-id="3dc41-108">Środowisko uruchomieniowe języka wspólnego (CLR) nie można łatwo udostępnić wystarczająco silne gwarancje z kodem zarządzanym aby pisanie kodu doskonałe możliwe.</span><span class="sxs-lookup"><span data-stu-id="3dc41-108">The common language runtime (CLR) cannot easily provide strong enough guarantees to managed code to make writing perfect code feasible.</span></span>  <span data-ttu-id="3dc41-109">Należy pamiętać, że w przeciwieństwie do programu ASP.NET, program SQL Server używa tylko jednego procesu, który nie może zostać odtworzona bez konieczności przełączania bazy danych w dół przez zbyt długi czas.</span><span class="sxs-lookup"><span data-stu-id="3dc41-109">Note that unlike ASP.NET, SQL Server uses only one process that cannot be recycled without taking a database down for an unacceptably long time.</span></span>  
  
 <span data-ttu-id="3dc41-110">Te słabszych gwarancji i uruchomiony w ramach jednego procesu niezawodności jest oparta na przerywanie wątków lub odtwarzania domen aplikacji, gdy nie przedostają niezbędne oraz zdolności do przyjmowania środki ostrożności, aby zasoby systemu operacyjnego, takie jak dojść lub pamięci.</span><span class="sxs-lookup"><span data-stu-id="3dc41-110">With these weaker guarantees and running in a single process, reliability is based on terminating threads or recycling application domains when necessary and taking precautions to ensure operating system resources such as handles or memory are not leaked.</span></span>  <span data-ttu-id="3dc41-111">Nawet w przypadku tego ograniczenia niezawodność prostszy jest nadal wymagane znaczących niezawodności:</span><span class="sxs-lookup"><span data-stu-id="3dc41-111">Even with this simpler reliability constraint, there is still a significant reliability requirement:</span></span>  
  
-   <span data-ttu-id="3dc41-112">Nigdy nie nastąpił przeciek zasoby systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="3dc41-112">Never leak operating system resources.</span></span>  
  
-   <span data-ttu-id="3dc41-113">Zidentyfikuj wszystkich zarządzanych blokad w wszystkich formularzy do środowiska CLR.</span><span class="sxs-lookup"><span data-stu-id="3dc41-113">Identify all managed locks in all forms to the CLR.</span></span>  
  
-   <span data-ttu-id="3dc41-114">Nigdy nie międzyaplikacyjnej podziału domeny udostępniony stan, dzięki czemu <xref:System.AppDomain> odtwarzania sprawnego funkcjonowania.</span><span class="sxs-lookup"><span data-stu-id="3dc41-114">Never break cross-application domain shared state, allowing <xref:System.AppDomain> recycling to function smoothly.</span></span>  
  
 <span data-ttu-id="3dc41-115">Chociaż teoretycznie można zapisać kodu zarządzanego do obsługi <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, i <xref:System.OutOfMemoryException> wyjątki, oczekiwano deweloperom zapisać takie niezawodny kod w całej aplikacji jest wysokie.</span><span class="sxs-lookup"><span data-stu-id="3dc41-115">Although it is theoretically possible to write managed code to handle <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException> exceptions, expecting developers to write such robust code throughout an entire application is unreasonable.</span></span>  <span data-ttu-id="3dc41-116">Z tego powodu wyjątki poza pasmem powoduje wykonywania wątku przerywane; i przerwał wątek został edycji stanu udostępnionego, której można ustalić przy czy wątek utrzymuje blokadę, a następnie <xref:System.AppDomain> zostanie zwolniona.</span><span class="sxs-lookup"><span data-stu-id="3dc41-116">For that reason, out-of-band exceptions result in the executing thread being terminated; and if the terminated thread was editing shared state, which can be determined by whether the thread holds a lock, then the <xref:System.AppDomain> is unloaded.</span></span>  <span data-ttu-id="3dc41-117">Jeżeli metodę, która jest edytowanie stanu udostępnionego zostanie zakończona, stan będzie uszkodzony, ponieważ nie jest możliwe do zapisu niezawodnej kod wycofujący aktualizacji stanu udostępnionego.</span><span class="sxs-lookup"><span data-stu-id="3dc41-117">When a method that is editing shared state is terminated, the state will be corrupt because it is not possible to write reliable back-out code for updates to shared state.</span></span>  
  
 <span data-ttu-id="3dc41-118">W programie .NET Framework w wersji 2.0 tylko hosta, który wymaga niezawodności jest program SQL Server.</span><span class="sxs-lookup"><span data-stu-id="3dc41-118">In the .NET Framework version 2.0, the only host that requires reliability is SQL Server.</span></span>  <span data-ttu-id="3dc41-119">Jeśli używanemu zestawowi zostanie uruchomiony na serwerze SQL dla każdej części tego zestawu, należy wykonać pracy niezawodności nawet w przypadku określonych funkcji, które są wyłączone podczas uruchamiania w bazie danych.</span><span class="sxs-lookup"><span data-stu-id="3dc41-119">If your assembly will be run on SQL Server you should do the reliability work for every part of that assembly, even if there are specific features that are disabled when running in the database.</span></span>  <span data-ttu-id="3dc41-120">Jest to wymagane, ponieważ aparat analizy kodu sprawdza kod na poziomie zestawu i nie rozróżnianie wyłączone kodu.</span><span class="sxs-lookup"><span data-stu-id="3dc41-120">This is required because the code analysis engine examines code at the assembly level and cannot differentiate disabled code.</span></span> <span data-ttu-id="3dc41-121">Inny serwer SQL programowania to, że program SQL Server działa wszystko w jednym procesie i <xref:System.AppDomain> odtwarzania służy do oczyszczania wszystkie zasoby, takie jak uchwyty pamięci i systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="3dc41-121">Another SQL Server programming consideration is that SQL Server runs everything in one process, and <xref:System.AppDomain> recycling is used for cleaning up all resources such as memory and operating system handles.</span></span>  
  
 <span data-ttu-id="3dc41-122">Nie może zależeć od finalizatory i destruktory lub `try/finally` bloków dla kod wycofujący.</span><span class="sxs-lookup"><span data-stu-id="3dc41-122">You cannot depend on finalizers or destructors or `try/finally` blocks for back-out code.</span></span> <span data-ttu-id="3dc41-123">Może być przerwane lub nie jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="3dc41-123">They might be interrupted or not called.</span></span>  
  
 <span data-ttu-id="3dc41-124">Może zostać wygenerowany asynchroniczne wyjątków w nieoczekiwanych lokalizacjach, prawdopodobnie co instrukcji maszyny: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, i <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="3dc41-124">Asynchronous exceptions can be thrown in unexpected locations, possibly every machine instruction: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException>.</span></span>  
  
 <span data-ttu-id="3dc41-125">Zarządzanych wątków niekoniecznie Win32 wątków w usłudze SQL; mogą one włókien.</span><span class="sxs-lookup"><span data-stu-id="3dc41-125">Managed threads are not necessarily Win32 threads in SQL; they might be fibers.</span></span>  
  
 <span data-ttu-id="3dc41-126">Modyfikowalne stan udostępnionego dla procesu lub międzyaplikacyjnej domeny jest bardzo trudne do zmiany bezpiecznie i w miarę możliwości należy unikać.</span><span class="sxs-lookup"><span data-stu-id="3dc41-126">Process-wide or cross-application domain mutable shared state is extremely difficult to alter safely and should be avoided whenever possible.</span></span>  
  
 <span data-ttu-id="3dc41-127">Warunki braku pamięci nie są rzadko w programie SQL Server.</span><span class="sxs-lookup"><span data-stu-id="3dc41-127">Out-of-memory conditions are not rare in SQL Server.</span></span>  
  
 <span data-ttu-id="3dc41-128">Biblioteki hostowanego w programie SQL Server nie poprawnie zaktualizować ich stanu udostępnionego, istnieje wysokie prawdopodobieństwo, że kod nie zostanie odzyskana do czasu ponownego uruchomienia bazy danych.</span><span class="sxs-lookup"><span data-stu-id="3dc41-128">If libraries hosted in SQL Server do not correctly update their shared state, there is a high probability that the code will not recover until the database has been restarted.</span></span>  <span data-ttu-id="3dc41-129">Ponadto w niektórych przypadkach extreme jest możliwe, może to spowodować procesu programu SQL Server nie powiedzie się, powodując bazy danych o ponownym uruchomieniu.</span><span class="sxs-lookup"><span data-stu-id="3dc41-129">Additionally, in some extreme cases, it is possible this might cause the SQL Server process to fail, causing the database to reboot.</span></span>  <span data-ttu-id="3dc41-130">Ponowne uruchomienie bazy danych można wyłączyć witryny sieci Web lub wpływających na funkcjonowanie firmy przejąć dostępności.</span><span class="sxs-lookup"><span data-stu-id="3dc41-130">Rebooting the database can take down a Web site or affect company operations, hurting availability.</span></span>  <span data-ttu-id="3dc41-131">Powolne przecieków zasobów systemu operacyjnego, np. pamięci lub uchwytów może spowodować serwera po pewnym czasie niepowodzenie przydzielania uchwytów o możliwości odzyskiwania lub potencjalnie serwer powoli spowodować spadek wydajności i zmniejsza aplikacji klienta dostępność.</span><span class="sxs-lookup"><span data-stu-id="3dc41-131">A slow leak of operating system resources such as memory or handles may cause the server to eventually fail allocating handles with no possibility of recovery, or potentially the server may slowly degrade in performance and reduces a customer’s application availability.</span></span>  <span data-ttu-id="3dc41-132">Wyraźnie chcemy uniknąć tych scenariuszy.</span><span class="sxs-lookup"><span data-stu-id="3dc41-132">Clearly we want to avoid these scenarios.</span></span>  
  
## <a name="best-practice-rules"></a><span data-ttu-id="3dc41-133">Regułami najlepszych rozwiązań</span><span class="sxs-lookup"><span data-stu-id="3dc41-133">Best Practice Rules</span></span>  
 <span data-ttu-id="3dc41-134">Wprowadzenie koncentruje się na Przegląd kodu dla zarządzanego kodu, który jest uruchamiany na serwerze byłyby do wychwytywania w celu zwiększenia stabilności i niezawodnością platformy.</span><span class="sxs-lookup"><span data-stu-id="3dc41-134">The introduction focused on what the code review for the managed code that runs in the server would have to catch to increase the stability and reliability of the framework.</span></span> <span data-ttu-id="3dc41-135">Kontrole te są dobrym rozwiązaniem, ogólnie rzecz biorąc, i musi bezwzględnej na serwerze.</span><span class="sxs-lookup"><span data-stu-id="3dc41-135">All these checks are good practice in general and an absolute must on the server.</span></span>  
  
 <span data-ttu-id="3dc41-136">W wypadku braku ograniczenia blokady lub zasób, SQL Server będzie przerwać wątek lub zerwanie <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="3dc41-136">In the face of a dead lock or resource constraint, SQL Server will abort a thread or tear down an <xref:System.AppDomain>.</span></span>  <span data-ttu-id="3dc41-137">W takim przypadku tylko wycofujący kodu w regionie ograniczonego wykonania (CER) jest gwarantowana do uruchomienia.</span><span class="sxs-lookup"><span data-stu-id="3dc41-137">When this happens, only back-out code in a constrained execution region (CER) is guaranteed to be run.</span></span>  
  
### <a name="use-safehandle-to-avoid-resource-leaks"></a><span data-ttu-id="3dc41-138">Używaj klasy SafeHandle w celu uniknięcia przecieków zasobów</span><span class="sxs-lookup"><span data-stu-id="3dc41-138">Use SafeHandle to Avoid Resource Leaks</span></span>  
 <span data-ttu-id="3dc41-139">W przypadku liczby <xref:System.AppDomain> zwolniony, nie może zależeć od `finally` bloków lub finalizatory wykonywana, dlatego ważne jest, aby abstrakcyjnej wszystkich dostęp do zasobów systemu operacyjnego za pomocą <xref:System.Runtime.InteropServices.SafeHandle> klasy zamiast <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef>, lub podobne klasy.</span><span class="sxs-lookup"><span data-stu-id="3dc41-139">In the case of an <xref:System.AppDomain> unload, you cannot depend on `finally` blocks or finalizers being executed, so it is important to abstract all operating system resource access through the <xref:System.Runtime.InteropServices.SafeHandle> class rather than <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef>, or similar classes.</span></span> <span data-ttu-id="3dc41-140">Dzięki temu CLR do śledzenia i zamknąć dojścia używasz nawet w <xref:System.AppDomain> przypadku zakończenia.</span><span class="sxs-lookup"><span data-stu-id="3dc41-140">This allows the CLR to track and close the handles you use even in the <xref:System.AppDomain> tear-down case.</span></span>  <span data-ttu-id="3dc41-141"><xref:System.Runtime.InteropServices.SafeHandle> będzie używać krytyczne finalizator CLR zawsze będzie działał.</span><span class="sxs-lookup"><span data-stu-id="3dc41-141"><xref:System.Runtime.InteropServices.SafeHandle> will be using a critical finalizer which the CLR will always run.</span></span>  
  
 <span data-ttu-id="3dc41-142">Dojście systemu operacyjnego są przechowywane w bezpieczne dojście od chwili utworzenia aż do momentu jego zwolnienia.</span><span class="sxs-lookup"><span data-stu-id="3dc41-142">The operating system handle is stored in the safe handle from the moment it is created until the moment it is released.</span></span>  <span data-ttu-id="3dc41-143">Brak żadnego okna, podczas którego <xref:System.Threading.ThreadAbortException> może wystąpić zostały publicznie dojścia.</span><span class="sxs-lookup"><span data-stu-id="3dc41-143">There is no window during which a <xref:System.Threading.ThreadAbortException> can occur to leak a handle.</span></span>  <span data-ttu-id="3dc41-144">Ponadto wywołanie liczebności referencyjnej zostanie uchwytu, dzięki czemu Zamknij śledzenia ważności uchwytu uniemożliwia problem zabezpieczeń z wyścigu między platformy `Dispose` i metody, które jest aktualnie używane dojście.</span><span class="sxs-lookup"><span data-stu-id="3dc41-144">Additionally, platform invoke will reference-count the handle, which allows close tracking of the lifetime of the handle, preventing a security issue with a race condition between `Dispose` and a method that is currently using the handle.</span></span>  
  
 <span data-ttu-id="3dc41-145">Większość klas, które obecnie ma finalizator po prostu oczyszczania systemu operacyjnego obsługi nie będą już potrzebne finalizatora.</span><span class="sxs-lookup"><span data-stu-id="3dc41-145">Most classes that currently have a finalizer to simply clean up an operating system handle will not need the finalizer anymore.</span></span> <span data-ttu-id="3dc41-146">Zamiast tego będzie finalizator na <xref:System.Runtime.InteropServices.SafeHandle> klasy.</span><span class="sxs-lookup"><span data-stu-id="3dc41-146">Instead, the finalizer will be on the <xref:System.Runtime.InteropServices.SafeHandle> derived class.</span></span>  
  
 <span data-ttu-id="3dc41-147">Należy pamiętać, że <xref:System.Runtime.InteropServices.SafeHandle> nie zastępuje ona dla <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3dc41-147">Note that <xref:System.Runtime.InteropServices.SafeHandle> is not a replacement for <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span></span>  <span data-ttu-id="3dc41-148">Ma nadal potencjalnych zasobów rywalizacji i wydajności zalet jawnie usunąć zasoby systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="3dc41-148">There are still potential resource contention and performance advantages to explicitly dispose operating system resources.</span></span>  <span data-ttu-id="3dc41-149">Po prostu należy pamiętać, że `finally` bloków, które jawnie usuwa zasoby mogą być wykonywane do zakończenia.</span><span class="sxs-lookup"><span data-stu-id="3dc41-149">Just realize that `finally` blocks that do explicitly dispose of resources may not execute to completion.</span></span>  
  
 <span data-ttu-id="3dc41-150"><xref:System.Runtime.InteropServices.SafeHandle> Umożliwia wdrożenie własne <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> metodę, która wykonuje pracę, aby zwolnić dojścia, takich jak przekazywanie stanu do dojścia systemu operacyjnego zwalnianie procedury lub zwalnianie zestaw uchwytów w pętli.</span><span class="sxs-lookup"><span data-stu-id="3dc41-150"><xref:System.Runtime.InteropServices.SafeHandle> allows you to implement your own <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method that performs the work to free the handle, such as passing state to an operating system handle freeing routine or freeing a set of handles in a loop.</span></span>  <span data-ttu-id="3dc41-151">Środowisko CLR gwarantuje, że ta metoda jest uruchomione.</span><span class="sxs-lookup"><span data-stu-id="3dc41-151">The CLR guarantees that this method is run.</span></span>  <span data-ttu-id="3dc41-152">Jest odpowiedzialny za Autor <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementacji, aby upewnić się, jest zwolnienie uchwytu we wszystkich okolicznościach.</span><span class="sxs-lookup"><span data-stu-id="3dc41-152">It is the responsibility of the author of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation to ensure that the handle is released in all circumstances.</span></span> <span data-ttu-id="3dc41-153">Błąd w tym celu spowoduje, że dojście do przedostawać, który często powoduje wyciek natywne zasoby skojarzone z dojścia.</span><span class="sxs-lookup"><span data-stu-id="3dc41-153">Failure to do so will cause the handle to be leaked, which often results in the leakage of native resources associated with the handle.</span></span> <span data-ttu-id="3dc41-154">W związku z tym jest krytyczny do struktury <xref:System.Runtime.InteropServices.SafeHandle> klas pochodnych tak, aby <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementacji nie wymaga Alokacja wszystkie zasoby, które mogą być niedostępne w momencie wywołania.</span><span class="sxs-lookup"><span data-stu-id="3dc41-154">Therefore it is critical to structure <xref:System.Runtime.InteropServices.SafeHandle> derived classes such that the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation does not require the allocation of any resources that may not be available at invocation time.</span></span> <span data-ttu-id="3dc41-155">Zauważ, że dozwolone wywołania metody, które może zakończyć się niepowodzeniem w ramach wdrożenia <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> pod warunkiem, że swój kod obsługi tych błędów i ukończyć kontraktu, aby zwolnić uchwyt macierzysty.</span><span class="sxs-lookup"><span data-stu-id="3dc41-155">Note that it is permissible to call methods that may fail within the implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> provided that your code can handle such failures and complete the contract to release the native handle.</span></span> <span data-ttu-id="3dc41-156">Na potrzeby debugowania, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> ma <xref:System.Boolean> zwrócić wartość, która może być ustawiony na `false` po napotkaniu błędu krytycznego, co uniemożliwia wersji zasobu.</span><span class="sxs-lookup"><span data-stu-id="3dc41-156">For debugging purposes, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> has a <xref:System.Boolean> return value which may be set to `false` if a catastrophic error is encountered which prevents release of the resource.</span></span> <span data-ttu-id="3dc41-157">Dzięki temu będzie uaktywniać [releaseHandleFailed](../../../docs/framework/debug-trace-profile/releasehandlefailed-mda.md) MDA, jeśli jest włączona, które pomogą zidentyfikować problem.</span><span class="sxs-lookup"><span data-stu-id="3dc41-157">Doing so will activate the [releaseHandleFailed](../../../docs/framework/debug-trace-profile/releasehandlefailed-mda.md) MDA, if enabled, to aid in identifying the problem.</span></span> <span data-ttu-id="3dc41-158">Nie ma wpływu na środowisko uruchomieniowe w inny sposób; <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> nie zostanie ponownie wywołany dla tego samego zasobu i w związku z tym przecieku dojścia.</span><span class="sxs-lookup"><span data-stu-id="3dc41-158">It does not affect the runtime in any other way; <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> will not be called again for the same resource and consequently the handle will be leaked.</span></span>  
  
 <span data-ttu-id="3dc41-159"><xref:System.Runtime.InteropServices.SafeHandle> nie jest odpowiednia w niektórych kontekstach.</span><span class="sxs-lookup"><span data-stu-id="3dc41-159"><xref:System.Runtime.InteropServices.SafeHandle> is not appropriate in certain contexts.</span></span>  <span data-ttu-id="3dc41-160">Ponieważ <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> metoda może być uruchamiane w <xref:System.GC> wątku finalizatora żadnych dojścia, które są wymagane do zwolniona, w szczególności wątku nie musi być ujęte w <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="3dc41-160">Since the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method can be run on a <xref:System.GC> finalizer thread, any handles that are required to be freed on a particular thread should not be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle>.</span></span>  
  
 <span data-ttu-id="3dc41-161">Wywoływane otoki środowiska uruchomieniowego (RCWs) mogą być czyszczone przez środowisko CLR bez dodatkowego kodu.</span><span class="sxs-lookup"><span data-stu-id="3dc41-161">Runtime callable wrappers (RCWs) can be cleaned by the CLR without additional code.</span></span>  <span data-ttu-id="3dc41-162">Dla kodu korzystającego z platformy wywołania i traktuje obiektu modelu COM jako `IUnknown*` lub <xref:System.IntPtr>, kod powinien ulegną do użycia otoki RCW.</span><span class="sxs-lookup"><span data-stu-id="3dc41-162">For code that uses platform invoke and treats a COM object as an `IUnknown*` or an <xref:System.IntPtr>, the code should be rewritten to use an RCW.</span></span>  <span data-ttu-id="3dc41-163"><xref:System.Runtime.InteropServices.SafeHandle> może nie być odpowiednie dla tego scenariusza z powodu możliwości wersji niezarządzanej metody wywołań zwrotnych do kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="3dc41-163"><xref:System.Runtime.InteropServices.SafeHandle> may not be adequate for this scenario due to the possibility of an unmanaged release method calling back into managed code.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3dc41-164">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3dc41-164">Code Analysis Rule</span></span>  
 <span data-ttu-id="3dc41-165">Użyj <xref:System.Runtime.InteropServices.SafeHandle> celu hermetyzacji zasobów systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="3dc41-165">Use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate operating system resources.</span></span> <span data-ttu-id="3dc41-166">Nie używaj <xref:System.Runtime.InteropServices.HandleRef> lub pól typu <xref:System.IntPtr>.</span><span class="sxs-lookup"><span data-stu-id="3dc41-166">Do not use <xref:System.Runtime.InteropServices.HandleRef> or fields of type <xref:System.IntPtr>.</span></span>  
  
### <a name="ensure-finalizers-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="3dc41-167">Upewnij się, że finalizatory nie ma potrzeby wykonywania, aby zapobiec przeciekom zasoby systemu operacyjnego</span><span class="sxs-lookup"><span data-stu-id="3dc41-167">Ensure Finalizers Do Not Have to Run to Prevent Leaking Operating System Resources</span></span>  
 <span data-ttu-id="3dc41-168">Zapoznaj się z finalizatory dokładnie, aby upewnić się, że nawet jeśli nie można uruchamiać, zasobu krytycznego systemu operacyjnego jest nie przedostają.</span><span class="sxs-lookup"><span data-stu-id="3dc41-168">Review your finalizers carefully to ensure that even if they do not run, a critical operating system resource is not leaked.</span></span>  <span data-ttu-id="3dc41-169">W odróżnieniu od zwykłym <xref:System.AppDomain> zwolniony, gdy aplikacja jest wykonywany w stanie stabilności lub serwera, takie jak program SQL Server wyłącza, obiekty, zostały zakończone podczas niespodziewane <xref:System.AppDomain> zwolnienia.</span><span class="sxs-lookup"><span data-stu-id="3dc41-169">Unlike a normal <xref:System.AppDomain> unload when the application is executing in a steady state or when a server such as SQL Server shuts down, objects are not finalized during an abrupt <xref:System.AppDomain> unload.</span></span>  <span data-ttu-id="3dc41-170">Upewnij się, że zasoby nie przedostają w przypadku nagłego zwolniony, ponieważ nie można zagwarantować poprawność aplikacji, ale integralność serwera muszą być obsługiwane za nie przeciek zasobów.</span><span class="sxs-lookup"><span data-stu-id="3dc41-170">Ensure resources are not leaked in the case of an abrupt unload, since an application's correctness cannot be guaranteed, but the integrity of the server must be maintained by not leaking resources.</span></span>  <span data-ttu-id="3dc41-171">Użyj <xref:System.Runtime.InteropServices.SafeHandle> zwolnić wszystkie zasoby systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="3dc41-171">Use <xref:System.Runtime.InteropServices.SafeHandle> to free any operating system resources.</span></span>  
  
### <a name="ensure-that-finally-clauses-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="3dc41-172">Oznacza koniec upewnij się, klauzule nie ma potrzeby uruchom, aby zapobiec przeciekom zasoby systemu operacyjnego</span><span class="sxs-lookup"><span data-stu-id="3dc41-172">Ensure That finally Clauses Do Not Have to Run to Prevent Leaking Operating System Resources</span></span>  
 <span data-ttu-id="3dc41-173">`finally` klauzule nie ma gwarancji uruchomiony poza CERs, wymagających deweloperom biblioteki nie zależą od kodu w ramach `finally` bloku do zwalniania niezarządzanych zasobów.</span><span class="sxs-lookup"><span data-stu-id="3dc41-173">`finally` clauses are not guaranteed to run outside of CERs, requiring library developers to not rely on code within a `finally` block to free unmanaged resources.</span></span>  <span data-ttu-id="3dc41-174">Przy użyciu <xref:System.Runtime.InteropServices.SafeHandle> jest zalecanym rozwiązaniem.</span><span class="sxs-lookup"><span data-stu-id="3dc41-174">Using <xref:System.Runtime.InteropServices.SafeHandle> is the recommended solution.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3dc41-175">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3dc41-175">Code Analysis Rule</span></span>  
 <span data-ttu-id="3dc41-176">Użyj <xref:System.Runtime.InteropServices.SafeHandle> oczyszczania zasoby systemu operacyjnego zamiast `Finalize`.</span><span class="sxs-lookup"><span data-stu-id="3dc41-176">Use <xref:System.Runtime.InteropServices.SafeHandle> for cleaning up operating system resources instead of `Finalize`.</span></span> <span data-ttu-id="3dc41-177">Nie używaj <xref:System.IntPtr>; użyj <xref:System.Runtime.InteropServices.SafeHandle> celu hermetyzacji zasobów.</span><span class="sxs-lookup"><span data-stu-id="3dc41-177">Do not use <xref:System.IntPtr>; use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate resources.</span></span> <span data-ttu-id="3dc41-178">Jeśli koniec klauzuli musi uruchomić, umieść go w CER.</span><span class="sxs-lookup"><span data-stu-id="3dc41-178">If the finally clause must run, place it in a CER.</span></span>  
  
### <a name="all-locks-should-go-through-existing-managed-locking-code"></a><span data-ttu-id="3dc41-179">Wszystkie blokady powinien przejść przez istniejące zarządzanego kodu blokowania</span><span class="sxs-lookup"><span data-stu-id="3dc41-179">All Locks Should Go Through Existing Managed Locking Code</span></span>  
 <span data-ttu-id="3dc41-180">Środowisko CLR muszą znać, jeśli kod jest w blokady tak, aby wiedzieli, aby usunąć <xref:System.AppDomain> zamiast właśnie Trwa przerywanie wątku.</span><span class="sxs-lookup"><span data-stu-id="3dc41-180">The CLR must know when code is in a lock so that it will know to tear down the <xref:System.AppDomain> rather than just aborting the thread.</span></span>  <span data-ttu-id="3dc41-181">Trwa przerywanie wątku może być niebezpieczne, jak dane zasilaniu przez wątek może pozostać w niespójnym stanie.</span><span class="sxs-lookup"><span data-stu-id="3dc41-181">Aborting the thread could be dangerous as the data operated on by the thread could be left in an inconsistent state.</span></span> <span data-ttu-id="3dc41-182">W związku z tym całą <xref:System.AppDomain> musi zostać odtworzona.</span><span class="sxs-lookup"><span data-stu-id="3dc41-182">Therefore, the entire <xref:System.AppDomain> has to be recycled.</span></span>  <span data-ttu-id="3dc41-183">Konsekwencje można zidentyfikować blokady może być zakleszczenie lub niepoprawne wyniki.</span><span class="sxs-lookup"><span data-stu-id="3dc41-183">The consequences of failing to identify a lock can be either deadlocks or incorrect results.</span></span> <span data-ttu-id="3dc41-184">Użyj metody <xref:System.Threading.Thread.BeginCriticalRegion%2A> i <xref:System.Threading.Thread.EndCriticalRegion%2A> do identyfikowania regionów blokady.</span><span class="sxs-lookup"><span data-stu-id="3dc41-184">Use the methods <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> to identify lock regions.</span></span>  <span data-ttu-id="3dc41-185">Są one metody statyczne <xref:System.Threading.Thread> klasy, które mają zastosowanie tylko do bieżącego wątku, pomaga w zapobieganiu jeden wątek Edycja liczbę blokad inny wątek.</span><span class="sxs-lookup"><span data-stu-id="3dc41-185">They are static methods on the <xref:System.Threading.Thread> class that only apply to the current thread, helping to prevent one thread from editing another thread’s lock count.</span></span>  
  
 <span data-ttu-id="3dc41-186"><xref:System.Threading.Monitor.Enter%2A> i <xref:System.Threading.Monitor.Exit%2A> ma to powiadomienie CLR wbudowane, dlatego zaleca się ich użycia oraz stosowania [lock — instrukcja](~/docs/csharp/language-reference/keywords/lock-statement.md), który używa tych metod.</span><span class="sxs-lookup"><span data-stu-id="3dc41-186"><xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> have this CLR notification built in, so their usage is recommended as well as the use of the [lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md), which uses these methods.</span></span>  
  
 <span data-ttu-id="3dc41-187">Innych mechanizmów blokowania, takich jak pokrętła blokad i <xref:System.Threading.AutoResetEvent> należy wywołać tych metod, aby powiadomić CLR jest wprowadzane sekcja krytyczna.</span><span class="sxs-lookup"><span data-stu-id="3dc41-187">Other locking mechanisms such as spin locks and <xref:System.Threading.AutoResetEvent> must call these methods to notify the CLR that a critical section is being entered.</span></span>  <span data-ttu-id="3dc41-188">Tych metod nie wykonuj żadnych blokad; informują wykonywanego kodu w sekcji krytycznej środowiska CLR i przerywanie wątku można pozostawić niespójne udostępniania stanu.</span><span class="sxs-lookup"><span data-stu-id="3dc41-188">These methods do not take any locks; they inform the CLR that code is executing in a critical section and aborting the thread could leave shared state inconsistent.</span></span>  <span data-ttu-id="3dc41-189">Jeśli zdefiniowano własne typu blokady, na przykład niestandardowy <xref:System.Threading.ReaderWriterLock> klasy, należy użyć tych metod licznik blokady.</span><span class="sxs-lookup"><span data-stu-id="3dc41-189">If you have defined your own lock type, such as a custom <xref:System.Threading.ReaderWriterLock> class, use these lock count methods.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3dc41-190">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3dc41-190">Code Analysis Rule</span></span>  
 <span data-ttu-id="3dc41-191">Oznacz i Znajdź wszystkie blokady przy użyciu <xref:System.Threading.Thread.BeginCriticalRegion%2A> i <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="3dc41-191">Mark and identify all locks using <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span></span> <span data-ttu-id="3dc41-192">Nie używaj <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A>, i <xref:System.Threading.Interlocked.Decrement%2A> w pętli.</span><span class="sxs-lookup"><span data-stu-id="3dc41-192">Do not use <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A>, and <xref:System.Threading.Interlocked.Decrement%2A> in a loop.</span></span>  <span data-ttu-id="3dc41-193">Czy platforma wywołania wariantów Win32 tych metod.</span><span class="sxs-lookup"><span data-stu-id="3dc41-193">Do not do a platform invoke of the Win32 variants of these methods.</span></span>  <span data-ttu-id="3dc41-194">Nie używaj <xref:System.Threading.Thread.Sleep%2A> w pętli.</span><span class="sxs-lookup"><span data-stu-id="3dc41-194">Do not use <xref:System.Threading.Thread.Sleep%2A> in a loop.</span></span>  <span data-ttu-id="3dc41-195">Nie należy używać pola nietrwałego.</span><span class="sxs-lookup"><span data-stu-id="3dc41-195">Do not use volatile fields.</span></span>  
  
### <a name="cleanup-code-must-be-in-a-finally-or-a-catch-block-not-following-a-catch"></a><span data-ttu-id="3dc41-196">Oczyszczanie kodu musi być w finally lub catch bloku nie następujących instrukcji catch</span><span class="sxs-lookup"><span data-stu-id="3dc41-196">Cleanup Code Must Be in a finally or a catch Block, Not Following a catch</span></span>  
 <span data-ttu-id="3dc41-197">Oczyszczanie kodu nigdy nie należy stosować `catch` Blokuj; powinna być w `finally` lub `catch` się zablokować.</span><span class="sxs-lookup"><span data-stu-id="3dc41-197">Cleanup code should never follow a `catch` block; it should be in a `finally` or in the `catch` block itself.</span></span>  <span data-ttu-id="3dc41-198">Powinno to być normalna dobrym rozwiązaniem.</span><span class="sxs-lookup"><span data-stu-id="3dc41-198">This should be a normal good practice.</span></span>  <span data-ttu-id="3dc41-199">A `finally` bloku jest zazwyczaj preferowana, ponieważ uruchomieniu tego samego kodu, zarówno w przypadku jest zwracany wyjątek, jak i podczas koniec `try` zwykle napotkano bloku.</span><span class="sxs-lookup"><span data-stu-id="3dc41-199">A `finally` block is generally preferred because it runs the same code both when an exception is thrown and when the end of the `try` block is normally encountered.</span></span>  <span data-ttu-id="3dc41-200">W przypadku wystąpił nieoczekiwany wyjątek został zgłoszony, na przykład <xref:System.Threading.ThreadAbortException>, czyszczenie kodu nie zostaną uruchomione.</span><span class="sxs-lookup"><span data-stu-id="3dc41-200">In the event of an unexpected exception being thrown, for example a <xref:System.Threading.ThreadAbortException>, the cleanup code will not run.</span></span>  <span data-ttu-id="3dc41-201">Wszelkie niezarządzane zasoby, które może wyczyścić w `finally` najlepiej musi być ujęte w <xref:System.Runtime.InteropServices.SafeHandle> do zapobieganie wyciekom.</span><span class="sxs-lookup"><span data-stu-id="3dc41-201">Any unmanaged resources that you would clean up in a `finally` should ideally be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle> to prevent leaks.</span></span>  <span data-ttu-id="3dc41-202">Należy pamiętać, C# `using` — słowo kluczowe można skutecznie usuwanie obiektów, w tym uchwytów.</span><span class="sxs-lookup"><span data-stu-id="3dc41-202">Note the C# `using` keyword can be used effectively to dispose of objects, including handles.</span></span>  
  
 <span data-ttu-id="3dc41-203">Mimo że <xref:System.AppDomain> odtwarzania można wyczyścić zasobów w wątku finalizatora, jest nadal należy umieścić oczyszczanie kodu w odpowiednie miejsce.</span><span class="sxs-lookup"><span data-stu-id="3dc41-203">Although <xref:System.AppDomain> recycling can clean up resources on the finalizer thread, it is still important to put cleanup code in the correct place.</span></span>  <span data-ttu-id="3dc41-204">Należy pamiętać, że jeśli wątek odebrał wyjątek asynchroniczny bez blokada, CLR próbuje zakończyć wątku bez konieczności Odtwórz <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="3dc41-204">Note that if a thread receives an asynchronous exception without holding a lock, the CLR attempts to end the thread itself without having to recycle the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="3dc41-205">Zapewnienie, że zasoby są czyszczone wcześniej zamiast nowsze pomaga udostępniając więcej zasobów, a także lepsze zarządzanie przez czas ich istnienia.</span><span class="sxs-lookup"><span data-stu-id="3dc41-205">Ensuring that resources are cleaned up sooner rather than later helps by making more resources available, and by better managing the lifetime.</span></span>  <span data-ttu-id="3dc41-206">Jeśli nie zamykaj jawnie dojście do pliku w ścieżce kodu błędu, niektóre poczekaj <xref:System.Runtime.InteropServices.SafeHandle> finalizatorów, aby wyczyścić go, przy następnym kodzie uruchamia go może zakończyć się niepowodzeniem próby uzyskania dostępu dokładnie tego samego pliku, jeśli finalizator nie został już uruchomiony.</span><span class="sxs-lookup"><span data-stu-id="3dc41-206">If you do not explicitly close a handle to a file in some error code path then wait for the <xref:System.Runtime.InteropServices.SafeHandle> finalizer to clean it up, the next time your code runs it may fail trying to access the exact same file if the finalizer has not already run.</span></span>  <span data-ttu-id="3dc41-207">Z tego powodu zagwarantowaniu, że oczyszczanie kodu istnieje i że działa ona prawidłowo może pomóc skutków błędów więcej prawidłowo i szybko, mimo że nie jest to bezwzględnie konieczne.</span><span class="sxs-lookup"><span data-stu-id="3dc41-207">For this reason, ensuring that cleanup code exists and works correctly will help recover from failures more cleanly and quickly, even though it is not strictly necessary.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3dc41-208">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3dc41-208">Code Analysis Rule</span></span>  
 <span data-ttu-id="3dc41-209">Oczyszczanie kodu po `catch` musi być w `finally` bloku.</span><span class="sxs-lookup"><span data-stu-id="3dc41-209">Cleanup code after `catch` needs to be in a `finally` block.</span></span> <span data-ttu-id="3dc41-210">Wywołania do usunięcia w bloku finally.</span><span class="sxs-lookup"><span data-stu-id="3dc41-210">Place calls to dispose in a finally block.</span></span>  <span data-ttu-id="3dc41-211">`catch` bloki powinien kończyć się throw albo ponownie Zgłoś.</span><span class="sxs-lookup"><span data-stu-id="3dc41-211">`catch` blocks should end in a throw or rethrow.</span></span>  <span data-ttu-id="3dc41-212">Gdy będzie istnieć wyjątki, takie jak kod wykrywania, czy można nawiązać połączenia sieciowego gdzie może przyczynić się do żadnego z dużą liczbę wyjątków, kodu, który wymaga Przechwytywanie liczba wyjątków w normalnych okolicznościach nadać Wskazuje, że kod powinien być testowane, jeśli powiedzie.</span><span class="sxs-lookup"><span data-stu-id="3dc41-212">While there will be exceptions, such as code detecting whether a network connection can be established where you might get any of a large number of exceptions, any code that requires the catching of a number of exceptions under normal circumstances should give an indication that the code should be tested to see if it will succeed.</span></span>  
  
### <a name="process-wide-mutable-shared-state-between-application-domains-should-be-eliminated-or-use-a-constrained-execution-region"></a><span data-ttu-id="3dc41-213">Modyfikowalne stanu udostępnionego całego procesu między domenami aplikacji powinny zostać usunięte lub użyj Region ograniczonego wykonania</span><span class="sxs-lookup"><span data-stu-id="3dc41-213">Process-Wide Mutable Shared State Between Application Domains Should Be Eliminated or Use a Constrained Execution Region</span></span>  
 <span data-ttu-id="3dc41-214">Zgodnie z opisem we wprowadzeniu, może być bardzo trudne do pisania kodu zarządzanego, który monitoruje stan udostępnionego całego procesu między domenami aplikacji w sposób niezawodny.</span><span class="sxs-lookup"><span data-stu-id="3dc41-214">As described in the introduction, it can be very difficult to write managed code that monitors process-wide shared state across application domains in a reliable manner.</span></span>  <span data-ttu-id="3dc41-215">Udostępniony stan całego procesu jest dowolny rodzaj struktury danych udostępnionych między domenami aplikacji w kodzie Win32, wewnątrz środowiska CLR lub w kodzie zarządzanym przy użyciu usług zdalnych.</span><span class="sxs-lookup"><span data-stu-id="3dc41-215">Process-wide shared state is any sort of data structure shared between application domains, either in Win32 code, inside the CLR, or in managed code using remoting.</span></span>  <span data-ttu-id="3dc41-216">Dowolny modyfikowalną udostępniony stan jest bardzo trudne do poprawnie zapisać w kodzie zarządzanym i wszelkie statyczny udostępnionego stanu może być wykonywana tylko ze szczególną uwagę na to.</span><span class="sxs-lookup"><span data-stu-id="3dc41-216">Any mutable shared state is very difficult to correctly write in managed code, and any static shared state might be done only with great care.</span></span>  <span data-ttu-id="3dc41-217">Jeśli masz całego procesu lub dla komputera stanu udostępnionego, Znajdź sposobem jej wyeliminowania lub ochrony stanu udostępnionego, przy użyciu region ograniczonego wykonania (CER).</span><span class="sxs-lookup"><span data-stu-id="3dc41-217">If you have process-wide or machine-wide shared state, find some way to eliminate it or protect the shared state using a constrained execution region (CER).</span></span>  <span data-ttu-id="3dc41-218">Wszystkie biblioteki z stanu udostępnionego, który nie jest zidentyfikowała i poprawiła powodować hosta, takich jak SQL Server, wymaga czystej <xref:System.AppDomain> zwalnianie awarię.</span><span class="sxs-lookup"><span data-stu-id="3dc41-218">Note that any library with shared state that is not identified and corrected could cause a host, such as SQL Server, that requires clean <xref:System.AppDomain> unloading to crash.</span></span>  
  
 <span data-ttu-id="3dc41-219">Jeśli kod używa obiektu COM, należy unikać udostępniania tego obiektu COM między domenami aplikacji.</span><span class="sxs-lookup"><span data-stu-id="3dc41-219">If code uses a COM object, avoid sharing that COM object between application domains.</span></span>  
  
### <a name="locks-do-not-work-process-wide-or-between-application-domains"></a><span data-ttu-id="3dc41-220">Blokady nie działają całego procesu lub między domenami aplikacji.</span><span class="sxs-lookup"><span data-stu-id="3dc41-220">Locks Do Not Work Process-Wide or Between Application Domains.</span></span>  
 <span data-ttu-id="3dc41-221">W przeszłości <xref:System.Threading.Monitor.Enter%2A> i [lock — instrukcja](~/docs/csharp/language-reference/keywords/lock-statement.md) zostały już użyte do utworzenia procesu globalnego blokad.</span><span class="sxs-lookup"><span data-stu-id="3dc41-221">In the past, <xref:System.Threading.Monitor.Enter%2A> and the [lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md) have been used to create global process locks.</span></span>  <span data-ttu-id="3dc41-222">Na przykład ten błąd występuje podczas blokowania na <xref:System.AppDomain> agile klas, takich jak <xref:System.Type> wystąpień z nieudostępnione zestawy <xref:System.Threading.Thread> obiektów, interned ciągów i niektórych ciągów udostępniane między domenami aplikacji przy użyciu usług zdalnych.</span><span class="sxs-lookup"><span data-stu-id="3dc41-222">For example, this occurs when locking on <xref:System.AppDomain> agile classes, such as <xref:System.Type> instances from non-shared assemblies, <xref:System.Threading.Thread> objects, interned strings, and some strings shared across application domains using remoting.</span></span>  <span data-ttu-id="3dc41-223">Te blokad nie są już dla procesu.</span><span class="sxs-lookup"><span data-stu-id="3dc41-223">These locks are no longer process-wide.</span></span>  <span data-ttu-id="3dc41-224">Aby zidentyfikować obecności blokady całego procesu interapplication domeny, należy określić, czy kod w blokady korzysta wszystkich zasobów zewnętrznych, utrwalonych takich jak plik na dysku lub bazy danych.</span><span class="sxs-lookup"><span data-stu-id="3dc41-224">To identify the presence of a process-wide interapplication domain lock, determine if the code within the lock uses any external, persisted resource such as a file on disk or possibly a database.</span></span>  
  
 <span data-ttu-id="3dc41-225">Należy pamiętać, biorąc blokady w <xref:System.AppDomain> może spowodować problemy w przypadku chronionych kodu wykorzystuje zasób zewnętrzny, ponieważ ten kod może działać jednocześnie w wielu domenach aplikacji.</span><span class="sxs-lookup"><span data-stu-id="3dc41-225">Note that taking a lock within an <xref:System.AppDomain> might cause problems if the protected code uses an external resource because that code may run simultaneously across multiple application domains.</span></span>  <span data-ttu-id="3dc41-226">Może to stanowić problem podczas zapisywania do powiązania z gniazdem dla całego procesu lub jeden plik dziennika.</span><span class="sxs-lookup"><span data-stu-id="3dc41-226">This can be a problem when writing to one log file or binding to a socket for the entire process.</span></span>  <span data-ttu-id="3dc41-227">Te zmiany oznaczają nie istnieje łatwy sposób, przy użyciu kodu zarządzanego na uzyskanie blokady globalne procesu w innych niż z użyciem nazwane <xref:System.Threading.Mutex> lub <xref:System.Threading.Semaphore> wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="3dc41-227">These changes mean there is no easy way, using managed code, to get a process-global lock, other than using a named <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> instance.</span></span>  <span data-ttu-id="3dc41-228">Tworzenie kodu, który nie działać jednocześnie w dwóch domen aplikacji, lub użyj <xref:System.Threading.Mutex> lub <xref:System.Threading.Semaphore> klasy.</span><span class="sxs-lookup"><span data-stu-id="3dc41-228">Create code that does not run in two application domains simultaneously, or use the <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> classes.</span></span>  <span data-ttu-id="3dc41-229">Jeśli nie można zmienić istniejący kod, nie należy używać Win32 nazwanego obiektu mutex do osiągnięcia tej synchronizacji, ponieważ uruchomiony w trybie włókien oznacza, że nie może zagwarantować tego samego wątku systemu operacyjnego zostanie nabywania i zwolnić obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="3dc41-229">If existing code cannot be changed, do not use a Win32 named mutex to achieve this synchronization because running in fiber mode means you cannot guarantee the same operating system thread will acquire and release a mutex.</span></span>  <span data-ttu-id="3dc41-230">Należy użyć zarządzanej <xref:System.Threading.Mutex> klasy lub nazwanym <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent>, lub <xref:System.Threading.Semaphore> do synchronizowania blokady kodu w sposób świadomość zamiast synchronizacji blokady przy użyciu kodu niezarządzanego CLR.</span><span class="sxs-lookup"><span data-stu-id="3dc41-230">You must use the managed <xref:System.Threading.Mutex> class, or a named <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent>, or a <xref:System.Threading.Semaphore> to synchronize the code lock in a manner that the CLR is aware of instead of synchronizing the lock using unmanaged code.</span></span>  
  
#### <a name="avoid-locktypeofmytype"></a><span data-ttu-id="3dc41-231">Unikaj lock(typeof(MyType))</span><span class="sxs-lookup"><span data-stu-id="3dc41-231">Avoid lock(typeof(MyType))</span></span>  
 <span data-ttu-id="3dc41-232">Prywatne i publiczne <xref:System.Type> obiektów w zestawy udostępnione z tylko jedną kopię kodu udostępnionych we wszystkich domenach aplikacji stanowi również problemy.</span><span class="sxs-lookup"><span data-stu-id="3dc41-232">Private and public <xref:System.Type> objects in shared assemblies with only one copy of the code shared across all application domains also present problems.</span></span>  <span data-ttu-id="3dc41-233">Dla udostępnionych zestawów jest tylko jedno wystąpienie <xref:System.Type> na proces, co oznacza, że wiele domen aplikacji udostępniać dokładnie takie same <xref:System.Type> wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="3dc41-233">For shared assemblies, there is only one instance of a <xref:System.Type> per process, meaning that multiple application domains share the exact same <xref:System.Type> instance.</span></span>  <span data-ttu-id="3dc41-234">Biorąc blokady <xref:System.Type> blokady, który ma wpływ na cały proces nie ma wystąpienia właśnie <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="3dc41-234">Taking a lock on a <xref:System.Type> instance takes a lock that affects the entire process, not just the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="3dc41-235">Jeśli <xref:System.AppDomain> przejmuje blokady <xref:System.Type> następnie obiekt, że wątek pobiera nagle przerwane, nie będzie nie zwalnia blokadę.</span><span class="sxs-lookup"><span data-stu-id="3dc41-235">If one <xref:System.AppDomain> takes a lock on a <xref:System.Type> object then that thread gets abruptly aborted, it will not release the lock.</span></span>  <span data-ttu-id="3dc41-236">Ta blokada może spowodować innych domen aplikacji do zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="3dc41-236">This lock then may cause other application domains to deadlock.</span></span>  
  
 <span data-ttu-id="3dc41-237">Dobrym sposobem wykonuj blokad w statycznej metody obejmuje dodawanie obiektu statyczne wewnętrzne synchronizacji z kodu.</span><span class="sxs-lookup"><span data-stu-id="3dc41-237">A good way to take locks in static methods involves adding a static internal synchronization object to the code.</span></span>  <span data-ttu-id="3dc41-238">Można jej zainicjować w konstruktorze klasy jest dostępny, ale nie mogą być inicjowane następująco:</span><span class="sxs-lookup"><span data-stu-id="3dc41-238">This could be initialized in the class constructor if one is present, but if not it can be initialized like this:</span></span>  
  
```  
private static Object s_InternalSyncObject;  
private static Object InternalSyncObject   
{  
    get   
    {  
        if (s_InternalSyncObject == null)   
        {  
            Object o = new Object();  
            Interlocked.CompareExchange(  
                ref s_InternalSyncObject, o, null);  
        }  
        return s_InternalSyncObject;  
    }  
}  
```  
  
 <span data-ttu-id="3dc41-239">Następnie podejmując blokady, użyj `InternalSyncObject` właściwości, aby uzyskać obiekt ma być blokowany na.</span><span class="sxs-lookup"><span data-stu-id="3dc41-239">Then when taking a lock, use the `InternalSyncObject` property to obtain an object to lock on.</span></span>  <span data-ttu-id="3dc41-240">Nie trzeba używać właściwości, jeśli w Twojej konstruktora klasy mają zainicjować obiektu wewnętrznego synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="3dc41-240">You do not need to use the property if you have initialized the internal synchronization object in your class constructor.</span></span>  <span data-ttu-id="3dc41-241">Podwójne sprawdzanie, czy kod inicjujący blokady powinna wyglądać w tym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="3dc41-241">The double checking lock initialization code should look like this example:</span></span>  
  
```  
public static MyClass SingletonProperty   
{  
    get   
    {  
        if (s_SingletonProperty == null)   
        {  
            lock(InternalSyncObject)   
            {  
                // Do not use lock(typeof(MyClass))   
                if (s_SingletonProperty == null)   
                {  
                    MyClass tmp = new MyClass(…);     
                    // Do all initialization before publishing  
                    s_SingletonProperty = tmp;  
                }  
            }  
        }  
        return s_SingletonProperty;  
    }  
}  
```  
  
#### <a name="a-note-about-lockthis"></a><span data-ttu-id="3dc41-242">Uwagi dotyczące Lock(this)</span><span class="sxs-lookup"><span data-stu-id="3dc41-242">A Note About Lock(this)</span></span>  
 <span data-ttu-id="3dc41-243">Na ogół dopuszczalne jest podjęcie blokady wybranego obiektu, który jest dostępny publicznie.</span><span class="sxs-lookup"><span data-stu-id="3dc41-243">It is generally acceptable to take a lock on an individual object that is publicly accessible.</span></span>  <span data-ttu-id="3dc41-244">Jednak jeśli obiekt pojedynczego obiektu, który może spowodować, że cały podsystemu do zakleszczenia, należy rozważyć użycie również powyżej wzorzec projektowy.</span><span class="sxs-lookup"><span data-stu-id="3dc41-244">However, if the object is a singleton object that might cause an entire subsystem to deadlock, consider using the above design pattern as well.</span></span>  <span data-ttu-id="3dc41-245">Na przykład blokady na ten <xref:System.Security.SecurityManager> obiektu może spowodować zakleszczenie w <xref:System.AppDomain> wprowadzania całą <xref:System.AppDomain> korzystanie z niej.</span><span class="sxs-lookup"><span data-stu-id="3dc41-245">For example, a lock on the one <xref:System.Security.SecurityManager> object could cause a deadlock within the <xref:System.AppDomain> making the entire <xref:System.AppDomain> unusable.</span></span> <span data-ttu-id="3dc41-246">Jest dobrym rozwiązaniem, które nie zostały blokady na publicznie dostępny obiekt tego typu.</span><span class="sxs-lookup"><span data-stu-id="3dc41-246">It is good practice to not take a lock on a publicly accessible object of this type.</span></span>  <span data-ttu-id="3dc41-247">Jednak blokady na poszczególnych kolekcji lub tablicy, należy zwykle stanowi problem.</span><span class="sxs-lookup"><span data-stu-id="3dc41-247">However a lock on an individual collection or array should generally not present a problem.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3dc41-248">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3dc41-248">Code Analysis Rule</span></span>  
 <span data-ttu-id="3dc41-249">Nie wykonuj blokad na typy, które mogą być używane między domenami aplikacji lub nie ma w pewnym sensie silnej tożsamości.</span><span class="sxs-lookup"><span data-stu-id="3dc41-249">Do not take locks on types that might be used across application domains or do not have a strong sense of identity.</span></span> <span data-ttu-id="3dc41-250">Nie wywołuj <xref:System.Threading.Monitor.Enter%2A> na <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread>, lub dowolnego obiektu, która jest pochodną <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="3dc41-250">Do not call <xref:System.Threading.Monitor.Enter%2A> on a <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread>, or any object that derives from <xref:System.MarshalByRefObject>.</span></span>  
  
### <a name="remove-gckeepalive-calls"></a><span data-ttu-id="3dc41-251">Usuń GC. Wywołania utrzymywania aktywności</span><span class="sxs-lookup"><span data-stu-id="3dc41-251">Remove GC.KeepAlive Calls</span></span>  
 <span data-ttu-id="3dc41-252">Albo nie używa znaczną ilość istniejący kod <xref:System.GC.KeepAlive%2A> gdy powinna lub korzysta, gdy nie jest odpowiedni.</span><span class="sxs-lookup"><span data-stu-id="3dc41-252">A significant amount of existing code either does not use <xref:System.GC.KeepAlive%2A> when it should or uses it when it is not appropriate.</span></span>  <span data-ttu-id="3dc41-253">Po skonwertowaniu na <xref:System.Runtime.InteropServices.SafeHandle>, nie trzeba wywołać klasy <xref:System.GC.KeepAlive%2A>, zakładając, że nie ma finalizator, ale korzystają z <xref:System.Runtime.InteropServices.SafeHandle> celu sfinalizowania system operacyjny obsługuje.</span><span class="sxs-lookup"><span data-stu-id="3dc41-253">After converting to <xref:System.Runtime.InteropServices.SafeHandle>, classes do not need to call <xref:System.GC.KeepAlive%2A>, assuming they do not have a finalizer but rely on <xref:System.Runtime.InteropServices.SafeHandle> to finalize the operating system handles.</span></span>  <span data-ttu-id="3dc41-254">Podczas koszt wydajności utrzymania wywołanie <xref:System.GC.KeepAlive%2A> może być niewielka, z punktu widzenia użytkownika który wywołanie <xref:System.GC.KeepAlive%2A> jest konieczne lub wystarczające, aby rozwiązać problem, który już nie istnieje sprawia, że kod jest bardziej trudne w utrzymaniu okres istnienia.</span><span class="sxs-lookup"><span data-stu-id="3dc41-254">While the performance cost of retaining a call to <xref:System.GC.KeepAlive%2A> may be negligible, the perception that a call to <xref:System.GC.KeepAlive%2A> is either necessary or sufficient to solve a lifetime issue that may no longer exist makes the code more difficult to maintain.</span></span>  <span data-ttu-id="3dc41-255">Jednak, w przypadku korzystania z międzyoperacyjnego CLR wywoływane otoki COM (RCWs), <xref:System.GC.KeepAlive%2A> nadal jest wymagane przez kod.</span><span class="sxs-lookup"><span data-stu-id="3dc41-255">However, when using the COM interop CLR callable wrappers (RCWs), <xref:System.GC.KeepAlive%2A> is still required by code.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3dc41-256">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3dc41-256">Code Analysis Rule</span></span>  
 <span data-ttu-id="3dc41-257">Usuń <xref:System.GC.KeepAlive%2A>.</span><span class="sxs-lookup"><span data-stu-id="3dc41-257">Remove <xref:System.GC.KeepAlive%2A>.</span></span>  
  
### <a name="use-the-host-protection-attribute"></a><span data-ttu-id="3dc41-258">Użyj atrybutu ochrony hosta</span><span class="sxs-lookup"><span data-stu-id="3dc41-258">Use the Host Protection Attribute</span></span>  
 <span data-ttu-id="3dc41-259"><xref:System.Security.Permissions.HostProtectionAttribute> (HPA) umożliwia korzystanie z akcji zabezpieczenia deklaratywne ustalenie wymagań dotyczących ochrony hosta, co hosta zapobiec wywoływania niektórych metod, które nie mają zastosowania do danego hosta, takich jak nawetcałkowiciezaufanegokodu<xref:System.Environment.Exit%2A>lub <xref:System.Windows.Forms.MessageBox.Show%2A> dla programu SQL Server.</span><span class="sxs-lookup"><span data-stu-id="3dc41-259">The <xref:System.Security.Permissions.HostProtectionAttribute> (HPA) provides the use of declarative security actions to determine host protection requirements, allowing the host to prevent even fully trusted code from calling certain methods which are inappropriate for the given host, such as <xref:System.Environment.Exit%2A> or <xref:System.Windows.Forms.MessageBox.Show%2A> for SQL Server.</span></span>  
  
 <span data-ttu-id="3dc41-260">HPA dotyczy tylko niezarządzanych aplikacji obsługujących wspólnego języka środowiska uruchomieniowego i wdrożenie hosta ochrony, takie jak SQL Server.</span><span class="sxs-lookup"><span data-stu-id="3dc41-260">The HPA affects only unmanaged applications that host the common language runtime and implement host protection, such as SQL Server.</span></span> <span data-ttu-id="3dc41-261">Po zastosowaniu, wyniki akcji zabezpieczeń podczas tworzenia żądania łącza na podstawie zasobów hosta ujawnia klasa lub metoda.</span><span class="sxs-lookup"><span data-stu-id="3dc41-261">When applied, the security action results in the creation of a link demand based on the host resources the class or method exposes.</span></span> <span data-ttu-id="3dc41-262">Jeśli kod jest uruchamiana w aplikacji klienckiej lub na serwerze, który nie jest chroniony przez hosta, atrybut "evaporates"; nie jest wykrywane i w związku z tym nie zastosować.</span><span class="sxs-lookup"><span data-stu-id="3dc41-262">If the code is run in a client application or on a server that is not host-protected, the attribute "evaporates"; it is not detected and therefore not applied.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3dc41-263">Ten atrybut ma na celu wymuszenia specyficzne dla hosta wytycznych programowania modelu, nie działanie zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="3dc41-263">The purpose of this attribute is to enforce host-specific programming model guidelines, not security behavior.</span></span>  <span data-ttu-id="3dc41-264">Mimo że żądanie łącza jest używany do sprawdzania zgodności do wymagania modelu programowania <xref:System.Security.Permissions.HostProtectionAttribute> nie jest uprawnienia zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="3dc41-264">Although a link demand is used to check for conformance to programming model requirements, the <xref:System.Security.Permissions.HostProtectionAttribute> is not a security permission.</span></span>  
  
 <span data-ttu-id="3dc41-265">Jeśli host nie ma wymagań modelu programowania, nie występują żądania łączy.</span><span class="sxs-lookup"><span data-stu-id="3dc41-265">If the host does not have programming model requirements, the link demands do not occur.</span></span>  
  
 <span data-ttu-id="3dc41-266">Ten atrybut określa następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="3dc41-266">This attribute identifies the following:</span></span>  
  
-   <span data-ttu-id="3dc41-267">Metod lub klas, które nie pasują do hosta programowania modelu, ale są w przeciwnym razie niegroźne.</span><span class="sxs-lookup"><span data-stu-id="3dc41-267">Methods or classes that do not fit the host programming model, but are otherwise benign.</span></span>  
  
-   <span data-ttu-id="3dc41-268">Metod lub klas, które nie pasują do jej modelu programowania hosta i może prowadzić do destabilizing kod zarządzany serwer użytkownika.</span><span class="sxs-lookup"><span data-stu-id="3dc41-268">Methods or classes that do not fit the host programming model and could lead to destabilizing server-managed user code.</span></span>  
  
-   <span data-ttu-id="3dc41-269">Metod lub klas, które nie pasują do hosta programowania modelu i może prowadzić do destabilizacji sam proces serwera.</span><span class="sxs-lookup"><span data-stu-id="3dc41-269">Methods or classes that do not fit the host programming model and could lead to a destabilization of the server process itself.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3dc41-270">W przypadku tworzenia biblioteki klas, który ma być wywoływany przez aplikacje, które mogą być wykonywane w środowisku hosta chronione elementy członkowskie, które udostępniają należy zastosować atrybut <xref:System.Security.Permissions.HostProtectionResource> kategorie zasobów.</span><span class="sxs-lookup"><span data-stu-id="3dc41-270">If you are creating a class library that is to be called by applications that may execute in a host protected environment, you should apply this attribute to members that expose <xref:System.Security.Permissions.HostProtectionResource> resource categories.</span></span> <span data-ttu-id="3dc41-271">Elementy członkowskie biblioteki klas .NET Framework z tym atrybutem spowodować tylko bezpośredniego obiektu wywołującego ma być sprawdzany.</span><span class="sxs-lookup"><span data-stu-id="3dc41-271">The .NET Framework class library members with this attribute cause only the immediate caller to be checked.</span></span>  <span data-ttu-id="3dc41-272">Biblioteka elementów członkowskich musi powodować kontrolę jego bezpośredniego obiektu wywołującego w taki sam sposób.</span><span class="sxs-lookup"><span data-stu-id="3dc41-272">Your library member must also cause a check of its immediate caller in the same manner.</span></span>  
  
 <span data-ttu-id="3dc41-273">Znajdziesz więcej informacji na temat HPA w <xref:System.Security.Permissions.HostProtectionAttribute>.</span><span class="sxs-lookup"><span data-stu-id="3dc41-273">Please find more information on HPA in <xref:System.Security.Permissions.HostProtectionAttribute>.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3dc41-274">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3dc41-274">Code Analysis Rule</span></span>  
 <span data-ttu-id="3dc41-275">Dla programu SQL Server wszystkie metody używane do wprowadzania synchronizacji lub wątkowość musi oznaczone symbolem HPA.</span><span class="sxs-lookup"><span data-stu-id="3dc41-275">For SQL Server, all methods used to introduce synchronization or threading must identified with the HPA.</span></span> <span data-ttu-id="3dc41-276">Dotyczy to również metody udostępniania stanu, są zsynchronizowane lub zarządzać procesów zewnętrznych.</span><span class="sxs-lookup"><span data-stu-id="3dc41-276">This includes methods that share state, are synchronized, or manage external processes.</span></span> <span data-ttu-id="3dc41-277"><xref:System.Security.Permissions.HostProtectionResource> Wartości, które mają wpływ na program SQL Server są <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization>, i <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span><span class="sxs-lookup"><span data-stu-id="3dc41-277">The <xref:System.Security.Permissions.HostProtectionResource> values that impact SQL Server are <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization>, and <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span></span> <span data-ttu-id="3dc41-278">Jednak wszystkie metody, która udostępnia żadnego <xref:System.Security.Permissions.HostProtectionResource> powinny zostać zidentyfikowane na podstawie HPA, nie tylko te, które korzysta z zasobów mających wpływ na SQL.</span><span class="sxs-lookup"><span data-stu-id="3dc41-278">However, any method that exposes any <xref:System.Security.Permissions.HostProtectionResource> should be identified by a HPA, not just those using resources affecting SQL.</span></span>  
  
### <a name="do-not-block-indefinitely-in-unmanaged-code"></a><span data-ttu-id="3dc41-279">Nie należy blokować nieskończoność za pomocą kodu niezarządzanego</span><span class="sxs-lookup"><span data-stu-id="3dc41-279">Do Not Block Indefinitely in Unmanaged Code</span></span>  
 <span data-ttu-id="3dc41-280">Blokowanie za pomocą kodu niezarządzanego, a nie w kodzie zarządzanym może spowodować odmowę usługi, ponieważ CLR nie jest w stanie przerwać wątek.</span><span class="sxs-lookup"><span data-stu-id="3dc41-280">Blocking in unmanaged code instead of in managed code can cause a denial of service attack because the CLR is not able to abort the thread.</span></span>  <span data-ttu-id="3dc41-281">Zablokowane wątku uniemożliwia zwalnianie CLR <xref:System.AppDomain>, co najmniej nie robiąc niektóre operacje bardzo niebezpieczne.</span><span class="sxs-lookup"><span data-stu-id="3dc41-281">A blocked thread prevents the CLR from unloading the <xref:System.AppDomain>, at least without doing some extremely unsafe operations.</span></span>  <span data-ttu-id="3dc41-282">Blokowanie przy użyciu Win32 prymitywu synchronizacji jest wyczyść przykładem coś, co nie może dopuścić do nas.</span><span class="sxs-lookup"><span data-stu-id="3dc41-282">Blocking using a Win32 synchronization primitive is a clear example of something we cannot allow.</span></span>  <span data-ttu-id="3dc41-283">Blokowanie w wywołaniu `ReadFile` na gnieździe należy unikać Jeśli to możliwe — najlepiej Win32 API powinien mechanizm operacji podobny do tego limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="3dc41-283">Blocking in a call to `ReadFile` on a socket should be avoided if possible — ideally the Win32 API should provide a mechanism for an operation like this to time out.</span></span>  
  
 <span data-ttu-id="3dc41-284">Dowolnej metody, która wywołuje w trybie macierzystym w idealnym przypadku należy używać wywołania Win32 uzasadnione, ograniczone limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="3dc41-284">Any method that calls into native should ideally use a Win32 call with a reasonable, finite timeout.</span></span>  <span data-ttu-id="3dc41-285">Jeśli użytkownik może określić limit czasu, użytkownik nie powinien być dozwolony, aby określić nieskończony limit czasu bez pewnych uprawnień zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="3dc41-285">If the user is allowed to specify the timeout, the user should not be allowed to specify an infinite timeout without some specific security permission.</span></span>  <span data-ttu-id="3dc41-286">Przyjąć Jeśli metoda będzie blokować przez więcej niż ~ 10 sekund, należy korzystać z wersji, który obsługuje limity czasu lub potrzebujesz dodatkowej pomocy CLR.</span><span class="sxs-lookup"><span data-stu-id="3dc41-286">As a guideline, if a method will block for more than ~10 seconds, you need to be using a version that supports timeouts or you need additional CLR support.</span></span>  
  
 <span data-ttu-id="3dc41-287">Oto kilka przykładów problematyczne interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="3dc41-287">Here are some examples of problematic API’s.</span></span>  <span data-ttu-id="3dc41-288">Potoki (anonimowe i nazwane) można tworzyć z limitem czasu; Jednak kod należy upewnić się, że nigdy nie wywołuje `CreateNamedPipe` ani `WaitNamedPipe` z NMPWAIT_WAIT_FOREVER.</span><span class="sxs-lookup"><span data-stu-id="3dc41-288">Pipes (both anonymous and named) can be created with a timeout; however, code must ensure it never calls `CreateNamedPipe` nor `WaitNamedPipe` with NMPWAIT_WAIT_FOREVER.</span></span>  <span data-ttu-id="3dc41-289">Ponadto może istnieć nieoczekiwany, blokowanie, nawet jeśli jest określony limit czasu.</span><span class="sxs-lookup"><span data-stu-id="3dc41-289">Additionally, there can be unexpected blocking even if a timeout is specified.</span></span>  <span data-ttu-id="3dc41-290">Wywoływanie `WriteFile` na anonimowe potoku zablokuje dopóki nie zostaną zapisane wszystkie bajty, co oznacza, jeśli bufor składa się z nieprzeczytana danych w ramach tego `WriteFile` wywołania zablokuje dopóki czytnik został zwolniony miejsca w buforze potoku.</span><span class="sxs-lookup"><span data-stu-id="3dc41-290">Calling `WriteFile` on an anonymous pipe will block until all bytes are written, meaning if the buffer has unread data in it, the `WriteFile` call will block until the reader has freed up space in the pipe’s buffer.</span></span>  <span data-ttu-id="3dc41-291">Gniazda zawsze należy używać niektórych interfejs API, który będzie honorować mechanizm limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="3dc41-291">Sockets should always use some API that honors a timeout mechanism.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3dc41-292">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3dc41-292">Code Analysis Rule</span></span>  
 <span data-ttu-id="3dc41-293">Blokowanie bez limitu czasu za pomocą kodu niezarządzanego jest typu "odmowa usługi".</span><span class="sxs-lookup"><span data-stu-id="3dc41-293">Blocking without a timeout in unmanaged code is a denial of service attack.</span></span> <span data-ttu-id="3dc41-294">Nie wykonuj platformy wywołania wywołania `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects`, i `MsgWaitForMultipleObjectsEx`.</span><span class="sxs-lookup"><span data-stu-id="3dc41-294">Do not perform platform invoke calls to `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects`, and `MsgWaitForMultipleObjectsEx`.</span></span>  <span data-ttu-id="3dc41-295">Nie należy używać NMPWAIT_WAIT_FOREVER.</span><span class="sxs-lookup"><span data-stu-id="3dc41-295">Do not use NMPWAIT_WAIT_FOREVER.</span></span>  
  
### <a name="identify-any-sta-dependent-features"></a><span data-ttu-id="3dc41-296">Zidentyfikuj wszystkie funkcje zależne od STA.</span><span class="sxs-lookup"><span data-stu-id="3dc41-296">Identify Any STA-Dependent Features.</span></span>  
 <span data-ttu-id="3dc41-297">Zidentyfikuj kodu, który używa apartamentach jednowątkowe COM (STAs).</span><span class="sxs-lookup"><span data-stu-id="3dc41-297">Identify any code that uses COM single-threaded apartments (STAs).</span></span>  <span data-ttu-id="3dc41-298">STAs są wyłączone w procesie programu SQL Server.</span><span class="sxs-lookup"><span data-stu-id="3dc41-298">STAs are disabled in the SQL Server process.</span></span>  <span data-ttu-id="3dc41-299">Funkcje, które są zależne od `CoInitialize`, takie jak liczników wydajności lub Schowka, musi zostać wyłączone w programie SQL Server.</span><span class="sxs-lookup"><span data-stu-id="3dc41-299">Features that depend on `CoInitialize`, such as performance counters or the clipboard, must be disabled within SQL Server.</span></span>  
  
### <a name="ensure-finalizers-are-free-of-synchronization-problems"></a><span data-ttu-id="3dc41-300">Upewnij się, że finalizatory bez problemów z synchronizacją</span><span class="sxs-lookup"><span data-stu-id="3dc41-300">Ensure Finalizers Are Free of Synchronization Problems</span></span>  
 <span data-ttu-id="3dc41-301">Wiele wątków finalizator może istnieć w przyszłych wersji systemu .NET Framework, co oznacza finalizatory dla różnych wystąpień tego samego typu działać jednocześnie.</span><span class="sxs-lookup"><span data-stu-id="3dc41-301">Multiple finalizer threads might exist in future versions of the .NET Framework, meaning the finalizers for different instances of the same type run simultaneously.</span></span>  <span data-ttu-id="3dc41-302">Nie mają być całkowicie wielowątkowość; Moduł zbierający elementy bezużyteczne gwarantuje, że tylko jeden wątek uruchomi finalizatora dla wystąpienia danego obiektu.</span><span class="sxs-lookup"><span data-stu-id="3dc41-302">They do not have to be completely thread safe; the garbage collector guarantees that only one thread will run the finalizer for a given object instance.</span></span>  <span data-ttu-id="3dc41-303">Jednak finalizatory musi być kodowane w celu uniknięcia wyścigu i zakleszczenie podczas uruchamiania jednocześnie na wielu różnych obiektów.</span><span class="sxs-lookup"><span data-stu-id="3dc41-303">However, the finalizers must be coded to avoid race conditions and deadlocks when running simultaneously on multiple different object instances.</span></span>  <span data-ttu-id="3dc41-304">Gdy przy użyciu dowolnego stanu zewnętrznych, takich jak zapisywania do pliku dziennika w finalizator, problemy wielowątkowości musi być obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="3dc41-304">When using any external state, such as writing to a log file, in a finalizer, threading issues must be handled.</span></span>  <span data-ttu-id="3dc41-305">Nie należy polegać na finalizację w celu zapewnienia bezpieczeństwa wątków.</span><span class="sxs-lookup"><span data-stu-id="3dc41-305">Do not rely on finalization to provide thread safety.</span></span> <span data-ttu-id="3dc41-306">Lokalny magazyn wątków, zarządzanym lub macierzystym, nie należy używać do przechowywania stanu w wątku finalizatora.</span><span class="sxs-lookup"><span data-stu-id="3dc41-306">Do not use thread local storage, managed or native, to store state on the finalizer thread.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3dc41-307">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3dc41-307">Code Analysis Rule</span></span>  
 <span data-ttu-id="3dc41-308">Finalizatory musi zawierać problemów z synchronizacją.</span><span class="sxs-lookup"><span data-stu-id="3dc41-308">Finalizers must be free of synchronization problems.</span></span> <span data-ttu-id="3dc41-309">Nie należy używać statycznego modyfikowalną stanie finalizator.</span><span class="sxs-lookup"><span data-stu-id="3dc41-309">Do not use a static mutable state in a finalizer.</span></span>  
  
### <a name="avoid-unmanaged-memory-if-possible"></a><span data-ttu-id="3dc41-310">Unikaj niezarządzanej pamięci, jeśli to możliwe</span><span class="sxs-lookup"><span data-stu-id="3dc41-310">Avoid Unmanaged Memory If Possible</span></span>  
 <span data-ttu-id="3dc41-311">Niezarządzanej pamięci mogą przedostawać, podobnie jak dojścia systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="3dc41-311">Unmanaged memory can be leaked, just like an operating system handle.</span></span>  <span data-ttu-id="3dc41-312">Jeśli to możliwe, spróbuj użyć pamięci przy użyciu stosu [stackalloc](~/docs/csharp/language-reference/keywords/stackalloc.md) lub przypiętych obiektu zarządzanego, takich jak [stałej instrukcji](~/docs/csharp/language-reference/keywords/fixed-statement.md) lub <xref:System.Runtime.InteropServices.GCHandle> przy użyciu typu byte [].</span><span class="sxs-lookup"><span data-stu-id="3dc41-312">If possible, try to use memory on the stack using [stackalloc](~/docs/csharp/language-reference/keywords/stackalloc.md) or a pinned managed object such as the [fixed Statement](~/docs/csharp/language-reference/keywords/fixed-statement.md) or a <xref:System.Runtime.InteropServices.GCHandle> using a byte[].</span></span>  <span data-ttu-id="3dc41-313"><xref:System.GC> Ostatecznie czyści je.</span><span class="sxs-lookup"><span data-stu-id="3dc41-313">The <xref:System.GC> eventually cleans these up.</span></span>  <span data-ttu-id="3dc41-314">Jednak jeśli należy przydzielić niezarządzanej pamięci, należy rozważyć użycie klasy, która jest pochodną <xref:System.Runtime.InteropServices.SafeHandle> opakowywać alokacji pamięci.</span><span class="sxs-lookup"><span data-stu-id="3dc41-314">However, if you must allocate unmanaged memory, consider using a class that derives from <xref:System.Runtime.InteropServices.SafeHandle> to wrap the memory allocation.</span></span>  
  
 <span data-ttu-id="3dc41-315">Należy pamiętać, że istnieje co najmniej jeden przypadek gdzie <xref:System.Runtime.InteropServices.SafeHandle> jest nieodpowiedni.</span><span class="sxs-lookup"><span data-stu-id="3dc41-315">Note that there is at least one case where <xref:System.Runtime.InteropServices.SafeHandle> is not adequate.</span></span>  <span data-ttu-id="3dc41-316">Dla wywołań metod modelu COM, których alokacji lub zwolnić pamięć, jest typowe dla jednej biblioteki DLL można przydzielić pamięci za pomocą `CoTaskMemAlloc` , a następnie innej bibliotece DLL zwalnia pamięci z `CoTaskMemFree`.</span><span class="sxs-lookup"><span data-stu-id="3dc41-316">For COM method calls that allocate or free memory, it is common for one DLL to allocate memory via `CoTaskMemAlloc` then another DLL frees that memory with `CoTaskMemFree`.</span></span>  <span data-ttu-id="3dc41-317">Przy użyciu <xref:System.Runtime.InteropServices.SafeHandle> w tych miejscach będzie nieodpowiednie ponieważ podejmie próbę powiązanie okres istnienia pamięci niezarządzane przez cały czas trwania <xref:System.Runtime.InteropServices.SafeHandle> zamiast zezwalać inny formant DLL okres istnienia pamięci.</span><span class="sxs-lookup"><span data-stu-id="3dc41-317">Using <xref:System.Runtime.InteropServices.SafeHandle> in these places would be inappropriate since it will attempt to tie the lifetime of the unmanaged memory to the lifetime of the <xref:System.Runtime.InteropServices.SafeHandle> instead of allowing the other DLL control the lifetime of the memory.</span></span>  
  
### <a name="review-all-uses-of-catchexception"></a><span data-ttu-id="3dc41-318">Przejrzyj wszystkie użycia Catch(Exception)</span><span class="sxs-lookup"><span data-stu-id="3dc41-318">Review All Uses of Catch(Exception)</span></span>  
 <span data-ttu-id="3dc41-319">Bloki czy catch wszystkie wyjątki zamiast co określony wyjątek zostanie teraz catch również asynchroniczne wyjątki catch.</span><span class="sxs-lookup"><span data-stu-id="3dc41-319">Catch blocks that catch all exceptions instead of one specific exception will now catch the asynchronous exceptions as well.</span></span>  <span data-ttu-id="3dc41-320">Sprawdź każdy blok catch(Exception), wyszukiwanie nie zasobów ważne zwalniania lub Wycofaj kod, który mogły zostać pominięte, a także potencjalnie nieprawidłowe zachowanie w bloku catch do obsługi <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, lub <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="3dc41-320">Examine every catch(Exception) block, looking for no important resource releasing or backout code that might be skipped, as well as potentially incorrect behavior within the catch block itself for handling a <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, or <xref:System.OutOfMemoryException>.</span></span>  <span data-ttu-id="3dc41-321">Należy pamiętać, że jest możliwe, ten kod może być rejestrowania lub niektóre założenie, że jej może zobaczyć tylko pewne wyjątki, lub że zawsze, gdy wyjątek sytuacji go nie powiodło się dla dokładnie jednej przyczyny.</span><span class="sxs-lookup"><span data-stu-id="3dc41-321">Note that it is possible this code might be logging or making some assumptions that it may only see certain exceptions, or that whenever an exception happens it failed for exactly one particular reason.</span></span>  <span data-ttu-id="3dc41-322">Zaktualizowano w celu uwzględnienia tych założeń może wymagać <xref:System.Threading.ThreadAbortException>.</span><span class="sxs-lookup"><span data-stu-id="3dc41-322">These assumptions may need to be updated to include <xref:System.Threading.ThreadAbortException>.</span></span>  
  
 <span data-ttu-id="3dc41-323">Rozważ zmianę wszystkich miejsc tego catch Przechwytywanie określony typ wyjątku, który będzie wszystkie wyjątki zostaną zgłoszone, takich jak <xref:System.FormatException> z ciągu metod formatowania.</span><span class="sxs-lookup"><span data-stu-id="3dc41-323">Consider changing all places that catch all exceptions to catching a specific type of exception that you expect will be thrown, such as a <xref:System.FormatException> from string formatting methods.</span></span>  <span data-ttu-id="3dc41-324">Uniemożliwia uruchomiony na wyjątki nieoczekiwany blok catch i może pomóc upewnić się, że kod nie ukrywa przez przechwytywanie wyjątków w nieoczekiwanych błędów.</span><span class="sxs-lookup"><span data-stu-id="3dc41-324">This prevents the catch block from running on unexpected exceptions and will help ensure the code does not hide bugs by catching unexpected exceptions.</span></span>  <span data-ttu-id="3dc41-325">Zasadniczo nigdy nie obsługi wyjątku w kodzie biblioteki (kod, który wymaga catch wyjątku może wskazywać projektowania luka w kodzie wywołujesz).</span><span class="sxs-lookup"><span data-stu-id="3dc41-325">As a general rule never handle an exception in library code (code that requires you to catch an exception may indicate a design flaw in the code you are calling).</span></span>  <span data-ttu-id="3dc41-326">W niektórych przypadkach można przechwytywać wyjątku i zgłosić innego typu wyjątku w celu zapewnienia większej ilości danych.</span><span class="sxs-lookup"><span data-stu-id="3dc41-326">In some cases you may want to catch an exception and throw a different exception type to provide more data.</span></span>  <span data-ttu-id="3dc41-327">W takim przypadku użycia wyjątków zagnieżdżonych przechowywania rzeczywistych przyczynę awarii w <xref:System.Exception.InnerException%2A> właściwości nowej wyjątek.</span><span class="sxs-lookup"><span data-stu-id="3dc41-327">Use nested exceptions in this case, storing the real cause of the failure in the <xref:System.Exception.InnerException%2A> property of the new exception.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3dc41-328">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3dc41-328">Code Analysis Rule</span></span>  
 <span data-ttu-id="3dc41-329">Przejrzyj wszystkie bloki catch w kodzie zarządzanym tej catch wszystkich obiektów lub catch wszystkie wyjątki.</span><span class="sxs-lookup"><span data-stu-id="3dc41-329">Review all catch blocks in managed code that catch all objects or catch all exceptions.</span></span>  <span data-ttu-id="3dc41-330">W języku C#, oznacza to, zarówno Flagowanie `catch` {} i `catch(Exception)` {}.</span><span class="sxs-lookup"><span data-stu-id="3dc41-330">In C#, this means flagging both `catch` {} and `catch(Exception)` {}.</span></span>  <span data-ttu-id="3dc41-331">Należy rozważyć zmianę bardzo określonego typu wyjątku lub przejrzyj kod, aby upewnić się, że jej nie działa w nieprawidłowy sposób, jeśli jego przechwytuje nieoczekiwany wyjątek typu.</span><span class="sxs-lookup"><span data-stu-id="3dc41-331">Consider making the exception type very specific, or review the code to ensure it does not act in a bad way if it catches an unexpected exception type.</span></span>  
  
### <a name="do-not-assume-a-managed-thread-is-a-win32-thread--it-is-a-fiber"></a><span data-ttu-id="3dc41-332">Zakłada się zarządzanego wątku jest wątku Win32 — włókien</span><span class="sxs-lookup"><span data-stu-id="3dc41-332">Do Not Assume a Managed Thread Is a Win32 Thread – It Is a Fiber</span></span>  
 <span data-ttu-id="3dc41-333">Użycie zarządzanych wątków lokalnych magazynu działa, ale nie możesz użyć magazynu lokalnego wątku niezarządzanego lub przyjęto założenie, że kod zostaną ponownie uruchomione w bieżącym wątku systemu operacyjnego.</span><span class="sxs-lookup"><span data-stu-id="3dc41-333">Using managed thread local storage does work, but you may not use unmanaged thread local storage or assume the code will run on the current operating system thread again.</span></span>  <span data-ttu-id="3dc41-334">Nie należy zmieniać ustawienia, takie jak ustawienia regionalne wątku.</span><span class="sxs-lookup"><span data-stu-id="3dc41-334">Do not change settings like the thread’s locale.</span></span>  <span data-ttu-id="3dc41-335">Nie wywołuj `InitializeCriticalSection` lub `CreateMutex` za pośrednictwem platformy wywołania, ponieważ wymagają one wątku systemu operacyjnego, który przechodzi blokady również zakończyć blokady.</span><span class="sxs-lookup"><span data-stu-id="3dc41-335">Do not call `InitializeCriticalSection` or `CreateMutex` via platform invoke because they require the operating system thread that enters a lock also exit the lock.</span></span>  <span data-ttu-id="3dc41-336">Ponieważ to nie będzie w przypadku gdy przy użyciu włókien, sekcje krytyczne Win32 i muteksy nie można używać w języku SQL bezpośrednio.</span><span class="sxs-lookup"><span data-stu-id="3dc41-336">Since this will not be the case when using fibers, Win32 critical sections and mutexes cannot be used in SQL directly.</span></span>  <span data-ttu-id="3dc41-337">Należy pamiętać, że zarządzanej <xref:System.Threading.Mutex> klasa nie obsługuje te problemy koligacji wątku.</span><span class="sxs-lookup"><span data-stu-id="3dc41-337">Note that the managed <xref:System.Threading.Mutex> class does not handle these thread affinity concerns.</span></span>  
  
 <span data-ttu-id="3dc41-338">Można bezpiecznie użyć większości stanu na zarządzanego <xref:System.Threading.Thread> obiektu, w tym lokalny magazyn wątków zarządzanych i wątku bieżącej kultury interfejsu użytkownika.</span><span class="sxs-lookup"><span data-stu-id="3dc41-338">You can safely use most of the state on a managed <xref:System.Threading.Thread> object, including managed thread local storage and the thread’s current UI culture.</span></span>  <span data-ttu-id="3dc41-339">Można również użyć <xref:System.ThreadStaticAttribute>, która sprawia, że wartość istniejącej zmiennej statycznych dostępne tylko przez bieżący wątek zarządzanych (jest to inny sposób realizacji włókien magazynu lokalnego w środowisku CLR).</span><span class="sxs-lookup"><span data-stu-id="3dc41-339">You can also use the <xref:System.ThreadStaticAttribute>, which makes the value of an existing static variable accessible only by the current managed thread (this is another way of doing fiber local storage in the CLR).</span></span>  <span data-ttu-id="3dc41-340">Programowania powodów modelu, nie można zmienić bieżącej kultury wątku podczas uruchamiania w języku SQL.</span><span class="sxs-lookup"><span data-stu-id="3dc41-340">For programming model reasons, you can not change the current culture of a thread when running in SQL.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3dc41-341">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3dc41-341">Code Analysis Rule</span></span>  
 <span data-ttu-id="3dc41-342">SQL Server jest uruchomiony w trybie włókien; nie należy używać magazynu lokalnego wątku.</span><span class="sxs-lookup"><span data-stu-id="3dc41-342">SQL Server runs in fiber mode; do not use thread local storage.</span></span> <span data-ttu-id="3dc41-343">Unikaj platformy wywołania wywołania `TlsAlloc`, `TlsFree`, `TlsGetValue`, i `TlsSetValue.`</span><span class="sxs-lookup"><span data-stu-id="3dc41-343">Avoid platform invoke calls to `TlsAlloc`, `TlsFree`, `TlsGetValue`, and `TlsSetValue.`</span></span>  
  
### <a name="let-sql-server-handle-impersonation"></a><span data-ttu-id="3dc41-344">Let personifikacji dojście do serwera SQL</span><span class="sxs-lookup"><span data-stu-id="3dc41-344">Let SQL Server Handle Impersonation</span></span>  
 <span data-ttu-id="3dc41-345">Ponieważ personifikacji operuje na poziomie wątku i SQL można uruchomić w trybie włókien, kodu zarządzanego nie ma personifikować użytkowników i nie powinny wywoływać `RevertToSelf`.</span><span class="sxs-lookup"><span data-stu-id="3dc41-345">Since impersonation operates on the thread level and SQL can run in fiber mode, managed code should not impersonate users, and should not call `RevertToSelf`.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3dc41-346">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3dc41-346">Code Analysis Rule</span></span>  
 <span data-ttu-id="3dc41-347">Pozwolić, aby obsłużyć personifikacji programu SQL Server.</span><span class="sxs-lookup"><span data-stu-id="3dc41-347">Let SQL Server handle impersonation.</span></span> <span data-ttu-id="3dc41-348">Nie używaj `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx`, lub `SetThreadToken`.</span><span class="sxs-lookup"><span data-stu-id="3dc41-348">Do not use `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx`, or `SetThreadToken`.</span></span>  
  
### <a name="do-not-call-threadsuspend"></a><span data-ttu-id="3dc41-349">Nie wywołuj Thread::Suspend</span><span class="sxs-lookup"><span data-stu-id="3dc41-349">Do Not Call Thread::Suspend</span></span>  
 <span data-ttu-id="3dc41-350">Możliwość wstrzymywania wątku mogą wydawać się prostą operacją, ale może spowodować zakleszczenie.</span><span class="sxs-lookup"><span data-stu-id="3dc41-350">The ability to suspend a thread may appear a simple operation, but it can cause deadlocks.</span></span>  <span data-ttu-id="3dc41-351">Jeśli wątek posiadająca blokady pobiera zawieszony przez drugi wątek, a następnie drugiego wątku spróbuje, biorąc tego samego blokady, zakleszczenie występuje.</span><span class="sxs-lookup"><span data-stu-id="3dc41-351">If a thread holding a lock gets suspended by a second thread and then the second thread tries taking the same lock, a deadlock occurs.</span></span>  <span data-ttu-id="3dc41-352"><xref:System.Threading.Thread.Suspend%2A> może zakłócać zabezpieczeń, podczas ładowania klasy usług zdalnych i odbicie obecnie.</span><span class="sxs-lookup"><span data-stu-id="3dc41-352"><xref:System.Threading.Thread.Suspend%2A> can interfere with security, class loading, remoting, and reflection currently.</span></span>  
  
#### <a name="code-analysis-rule"></a><span data-ttu-id="3dc41-353">Reguł analizy kodu</span><span class="sxs-lookup"><span data-stu-id="3dc41-353">Code Analysis Rule</span></span>  
 <span data-ttu-id="3dc41-354">Nie wywołuj <xref:System.Threading.Thread.Suspend%2A>.</span><span class="sxs-lookup"><span data-stu-id="3dc41-354">Do not call <xref:System.Threading.Thread.Suspend%2A>.</span></span> <span data-ttu-id="3dc41-355">Należy rozważyć użycie rzeczywistych synchronizacji pierwotne, takie jak <xref:System.Threading.Semaphore> lub <xref:System.Threading.ManualResetEvent> .</span><span class="sxs-lookup"><span data-stu-id="3dc41-355">Consider using a real synchronization primitive instead, such as a <xref:System.Threading.Semaphore> or <xref:System.Threading.ManualResetEvent> .</span></span>  
  
### <a name="protect-critical-operations-with-constrained-execution-regions-and-reliability-contracts"></a><span data-ttu-id="3dc41-356">Chroń ważne operacje z ograniczone regiony wykonania i kontrakty niezawodności</span><span class="sxs-lookup"><span data-stu-id="3dc41-356">Protect Critical Operations with Constrained Execution Regions and Reliability Contracts</span></span>  
 <span data-ttu-id="3dc41-357">Podczas wykonywania operacji złożonych, że aktualizacje stanu udostępnionego lub który musi być w sposób niejednoznaczny albo pełni powiedzie się lub pełni zakończyć się niepowodzeniem, należy się upewnić, że jest chroniony przez region ograniczonego wykonania (CER).</span><span class="sxs-lookup"><span data-stu-id="3dc41-357">When performing a complex operation that updates a shared status or that needs to deterministically either fully succeed or fully fail, be sure that it is protected by a constrained execution region (CER).</span></span> <span data-ttu-id="3dc41-358">Gwarantuje to, że kod jest uruchomiony w każdym przypadku nawet przerwania niespodziewane wątku lub nagłego <xref:System.AppDomain> zwolnienia.</span><span class="sxs-lookup"><span data-stu-id="3dc41-358">This guarantees that the code runs in every case, even an abrupt thread abort or an abrupt <xref:System.AppDomain> unload.</span></span>  
  
 <span data-ttu-id="3dc41-359">CER jest określonego `try/finally` bloku natychmiast poprzedzony przez wywołanie <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span><span class="sxs-lookup"><span data-stu-id="3dc41-359">A CER is a particular `try/finally` block immediately preceded by a call to <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span></span>  
  
 <span data-ttu-id="3dc41-360">Wykonanie tej tak instruuje kompilator just in time, aby przygotować cały kod w bloku finally przed uruchomieniem `try` bloku.</span><span class="sxs-lookup"><span data-stu-id="3dc41-360">Doing so instructs the just-in-time compiler to prepare all the code in the finally block before running the `try` block.</span></span> <span data-ttu-id="3dc41-361">Gwarantuje to, że kod w koniec bloku jest wbudowana i będzie działać we wszystkich przypadkach.</span><span class="sxs-lookup"><span data-stu-id="3dc41-361">This guarantees that the code in the finally block is built and will run in all cases.</span></span> <span data-ttu-id="3dc41-362">Nie jest rzadko w CER ma pustą `try` bloku.</span><span class="sxs-lookup"><span data-stu-id="3dc41-362">It is not uncommon in a CER to have an empty `try` block.</span></span> <span data-ttu-id="3dc41-363">Przy użyciu CER chroni przed przerwanie asynchronicznego wątku i wyjątki o braku pamięci.</span><span class="sxs-lookup"><span data-stu-id="3dc41-363">Using a CER protects against asynchronous thread aborts and out-of-memory exceptions.</span></span> <span data-ttu-id="3dc41-364">Zobacz <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> formularza CER, które dodatkowo przepełnienie stosu uchwytów nadmiernie dokładnego kodu.</span><span class="sxs-lookup"><span data-stu-id="3dc41-364">See <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> for a form of a CER that additionally handles stack overflows for exceedingly deep code.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3dc41-365">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="3dc41-365">See Also</span></span>  
 <xref:System.Runtime.ConstrainedExecution>  
 [<span data-ttu-id="3dc41-366">Atrybuty ochrony hosta i programowanie SQL Server</span><span class="sxs-lookup"><span data-stu-id="3dc41-366">SQL Server Programming and Host Protection Attributes</span></span>](../../../docs/framework/performance/sql-server-programming-and-host-protection-attributes.md)
