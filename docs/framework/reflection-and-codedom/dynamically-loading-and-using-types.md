---
title: Dynamiczne ładowanie i używanie typów
description: Dynamiczne ładowanie i używanie typów w programie .NET. Użyj odbicia, które zapewnia infrastrukturę używaną przez kompilatory języka do implementacji niejawnego późnego wiązania.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
- cpp
helpviewer_keywords:
- late binding, about late binding
- early binding
- dynamically loading and using types
- implicit late binding
- reflection, dynamically using types
ms.assetid: db985bec-5942-40ec-b13a-771ae98623dc
ms.openlocfilehash: be9991a4df866f65aabe063be3cc2b374f4d124d
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 11/26/2020
ms.locfileid: "96266795"
---
# <a name="dynamically-loading-and-using-types"></a><span data-ttu-id="f7a4d-104">Dynamiczne ładowanie i używanie typów</span><span class="sxs-lookup"><span data-stu-id="f7a4d-104">Dynamically Loading and Using Types</span></span>

<span data-ttu-id="f7a4d-105">Odbicie zapewnia infrastrukturę używaną przez kompilatory języka do implementowania niejawnego późnego wiązania.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-105">Reflection provides infrastructure used by language compilers to implement implicit late binding.</span></span> <span data-ttu-id="f7a4d-106">Powiązanie jest procesem lokalizowania deklaracji (czyli implementacji), która odnosi się do jednoznacznie określonego typu.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-106">Binding is the process of locating the declaration (that is, the implementation) that corresponds to a uniquely specified type.</span></span> <span data-ttu-id="f7a4d-107">Gdy ten proces wystąpi w czasie wykonywania, a nie w czasie kompilacji, jest nazywany późnym wiązaniem.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-107">When this process occurs at run time rather than at compile time, it is called late binding.</span></span> <span data-ttu-id="f7a4d-108">Visual Basic umożliwia użycie niejawnego późnego wiązania w kodzie. Kompilator Visual Basic wywołuje metodę pomocnika, która używa odbicia w celu uzyskania typu obiektu.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-108">Visual Basic allows you to use implicit late binding in your code; the Visual Basic compiler calls a helper method that uses reflection to obtain the object type.</span></span> <span data-ttu-id="f7a4d-109">Argumenty przekazane do metody pomocnika powodują wywołanie odpowiedniej metody w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-109">The arguments passed to the helper method cause the appropriate method to be invoked at run time.</span></span> <span data-ttu-id="f7a4d-110">Te argumenty są wystąpieniem (obiektem), na którym należy wywołać metodę, nazwę wywołanej metody (ciąg) i argumenty przekazane do wywołanej metody (tablicę obiektów).</span><span class="sxs-lookup"><span data-stu-id="f7a4d-110">These arguments are the instance (an object) on which to invoke the method, the name of the invoked method (a string), and the arguments passed to the invoked method (an array of objects).</span></span>  
  
 <span data-ttu-id="f7a4d-111">W poniższym przykładzie kompilator Visual Basic używa odbicia niejawnie do wywołania metody w obiekcie, którego typ nie jest znany w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-111">In the following example, the Visual Basic compiler uses reflection implicitly to call a method on an object whose type is not known at compile time.</span></span> <span data-ttu-id="f7a4d-112">Klasa **HelloWorld** ma metodę **PrintHello** , która drukuje "Hello World" połączone z tekstem, który jest przesyłany do metody **PrintHello** .</span><span class="sxs-lookup"><span data-stu-id="f7a4d-112">A **HelloWorld** class has a **PrintHello** method that prints out "Hello World" concatenated with some text that is passed to the **PrintHello** method.</span></span> <span data-ttu-id="f7a4d-113">Metoda **PrintHello** wywołana w tym przykładzie jest w rzeczywistości a <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> ; kod Visual Basic umożliwia wywoływanie metody **PrintHello** , tak jakby typ obiektu (helloObj) był znany w czasie kompilacji (wczesne wiązanie), a nie w czasie wykonywania (późne wiązanie).</span><span class="sxs-lookup"><span data-stu-id="f7a4d-113">The **PrintHello** method called in this example is actually a <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>; the Visual Basic code allows the **PrintHello** method to be invoked as if the type of the object (helloObj) were known at compile time (early binding) rather than at run time (late binding).</span></span>  
  
```vb
Module Hello  
    Sub Main()  
        ' Sets up the variable.  
        Dim helloObj As Object  
        ' Creates the object.  
        helloObj = new HelloWorld()  
        ' Invokes the print method as if it was early bound  
        ' even though it is really late bound.  
        helloObj.PrintHello("Visual Basic Late Bound")  
    End Sub  
End Module  
```  
  
## <a name="custom-binding"></a><span data-ttu-id="f7a4d-114">Wiązanie niestandardowe</span><span class="sxs-lookup"><span data-stu-id="f7a4d-114">Custom Binding</span></span>  

 <span data-ttu-id="f7a4d-115">Oprócz użycia niejawnie przez kompilatory dla późnego wiązania, odbicie może być używane jawnie w kodzie do osiągnięcia późnego wiązania.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-115">In addition to being used implicitly by compilers for late binding, reflection can be used explicitly in code to accomplish late binding.</span></span>  
  
 <span data-ttu-id="f7a4d-116">[Środowisko uruchomieniowe języka wspólnego](../../standard/clr.md) obsługuje wiele języków programowania, a reguły powiązań tych języków różnią się.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-116">The [common language runtime](../../standard/clr.md) supports multiple programming languages, and the binding rules of these languages differ.</span></span> <span data-ttu-id="f7a4d-117">W przypadku wczesnej ograniczonej wielkości generatory kodu mogą całkowicie kontrolować to powiązanie.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-117">In the early-bound case, code generators can completely control this binding.</span></span> <span data-ttu-id="f7a4d-118">Jednak w późnym łączeniu poprzez odbicie powiązanie musi być kontrolowane przez dostosowane powiązanie.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-118">However, in late binding through reflection, binding must be controlled by customized binding.</span></span> <span data-ttu-id="f7a4d-119"><xref:System.Reflection.Binder>Klasa zawiera niestandardową kontrolkę wyboru elementu członkowskiego i wywołania.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-119">The <xref:System.Reflection.Binder> class provides custom control of member selection and invocation.</span></span>  
  
 <span data-ttu-id="f7a4d-120">Przy użyciu powiązania niestandardowego można załadować zestaw w czasie wykonywania, uzyskać informacje o typach w tym zestawie, określić typ, a następnie wywołać metody lub uzyskać dostęp do pól lub właściwości tego typu.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-120">Using custom binding, you can load an assembly at run time, obtain information about types in that assembly, specify the type that you want, and then invoke methods or access fields or properties on that type.</span></span> <span data-ttu-id="f7a4d-121">Ta technika jest przydatna, jeśli nie znasz typu obiektu w czasie kompilacji, na przykład gdy typ obiektu jest zależny od danych wejściowych użytkownika.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-121">This technique is useful if you do not know an object's type at compile time, such as when the object type is dependent on user input.</span></span>  
  
 <span data-ttu-id="f7a4d-122">Poniższy przykład ilustruje prosty niestandardowy spinacz, który nie zapewnia konwersji typu argumentu.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-122">The following example demonstrates a simple custom binder that provides no argument type conversion.</span></span> <span data-ttu-id="f7a4d-123">Kod `Simple_Type.dll` poprzedzający główny przykład.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-123">Code for `Simple_Type.dll` precedes the main example.</span></span> <span data-ttu-id="f7a4d-124">Pamiętaj, aby skompilować `Simple_Type.dll` , a następnie dołączyć odwołanie do niego w projekcie w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-124">Be sure to build `Simple_Type.dll` and then include a reference to it in the project at build time.</span></span>  
  
 [!code-cpp[Conceptual.Types.Dynamic#1](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source1.cpp#1)]
 [!code-csharp[Conceptual.Types.Dynamic#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source1.cs#1)]
 [!code-vb[Conceptual.Types.Dynamic#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source1.vb#1)]  
  
### <a name="invokemember-and-createinstance"></a><span data-ttu-id="f7a4d-125">InvokeMember i CreateInstance</span><span class="sxs-lookup"><span data-stu-id="f7a4d-125">InvokeMember and CreateInstance</span></span>  

 <span data-ttu-id="f7a4d-126">Służy <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> do wywoływania elementu członkowskiego typu.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-126">Use <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> to invoke a member of a type.</span></span> <span data-ttu-id="f7a4d-127">Metody **CreateInstance** różnych klas, takie jak <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> i <xref:System.Reflection.Assembly.CreateInstance%2A?displayProperty=nameWithType> , są wyspecjalizowanymi formami **InvokeMember** , które tworzą nowe wystąpienia określonego typu.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-127">The **CreateInstance** methods of various classes, such as <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> and <xref:System.Reflection.Assembly.CreateInstance%2A?displayProperty=nameWithType>, are specialized forms of **InvokeMember** that create new instances of the specified type.</span></span> <span data-ttu-id="f7a4d-128">Klasa **spinacza** jest używana na potrzeby rozpoznawania przeciążenia i przekształcania argumentów w tych metodach.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-128">The **Binder** class is used for overload resolution and argument coercion in these methods.</span></span>  
  
 <span data-ttu-id="f7a4d-129">Poniższy przykład pokazuje trzy możliwe kombinacje przekształcenia argumentów (konwersja typu) i wybór elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-129">The following example shows the three possible combinations of argument coercion (type conversion) and member selection.</span></span> <span data-ttu-id="f7a4d-130">W przypadku 1 nie jest wymagana Konwersja argumentów ani wybór elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-130">In Case 1, no argument coercion or member selection is needed.</span></span> <span data-ttu-id="f7a4d-131">W przypadku 2 wymagany jest tylko wybór elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-131">In Case 2, only member selection is needed.</span></span> <span data-ttu-id="f7a4d-132">W przypadku 3 jest wymagana tylko wymuszone przekształcenie argumentu.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-132">In Case 3, only argument coercion is needed.</span></span>  
  
 [!code-cpp[Conceptual.Types.Dynamic#2](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source2.cpp#2)]
 [!code-csharp[Conceptual.Types.Dynamic#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source2.cs#2)]
 [!code-vb[Conceptual.Types.Dynamic#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source2.vb#2)]  
  
 <span data-ttu-id="f7a4d-133">Jeśli jest dostępny więcej niż jeden element członkowski o tej samej nazwie, jest wymagana rozdzielczość przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-133">Overload resolution is needed when more than one member with the same name is available.</span></span> <span data-ttu-id="f7a4d-134"><xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType>Metody i służą <xref:System.Reflection.Binder.BindToField%2A?displayProperty=nameWithType> do rozpoznawania powiązań z pojedynczym elementem członkowskim.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-134">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.Binder.BindToField%2A?displayProperty=nameWithType> methods are used to resolve binding to a single member.</span></span> <span data-ttu-id="f7a4d-135">Obiekt **Binder. BindToMethod** udostępnia również rozpoznawanie właściwości poprzez metody dostępu do właściwości **Get** i **Set** .</span><span class="sxs-lookup"><span data-stu-id="f7a4d-135">**Binder.BindToMethod** also provides property resolution through the **get** and **set** property accessors.</span></span>  
  
 <span data-ttu-id="f7a4d-136">**BindToMethod** zwraca <xref:System.Reflection.MethodBase> element do Invoke lub odwołanie o wartości null (**Nothing** w Visual Basic), jeśli takie wywołanie nie jest możliwe.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-136">**BindToMethod** returns the <xref:System.Reflection.MethodBase> to invoke, or a null reference (**Nothing** in Visual Basic) if no such invocation is possible.</span></span> <span data-ttu-id="f7a4d-137">Wartość zwracana **element MethodBase** nie musi być jedną z tych zawartych w parametrze *Match* , chociaż jest to zwykły przypadek.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-137">The **MethodBase** return value need not be one of those contained in the *match* parameter, although that is the usual case.</span></span>  
  
 <span data-ttu-id="f7a4d-138">Gdy są obecne argumenty ByRef, obiekt wywołujący może chcieć uzyskać zwrot.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-138">When ByRef arguments are present, the caller might want to get them back.</span></span> <span data-ttu-id="f7a4d-139">W związku z tym, **spinacz** umożliwia klientowi mapowanie tablicy argumentów z powrotem do oryginalnej postaci, jeśli **BindToMethod** operuje tablicą argumentów.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-139">Therefore, **Binder** allows a client to map the array of arguments back to its original form if **BindToMethod** has manipulated the argument array.</span></span> <span data-ttu-id="f7a4d-140">Aby to zrobić, obiekt wywołujący musi mieć gwarancję, że kolejność argumentów nie jest zmieniana.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-140">In order to do this, the caller must be guaranteed that the order of the arguments is unchanged.</span></span> <span data-ttu-id="f7a4d-141">Gdy argumenty są przekazane według nazwy, **spinacz** zmienia kolejność tablic argumentów i jest to, co obiekt wywołujący widzi.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-141">When arguments are passed by name, **Binder** reorders the argument array, and that is what the caller sees.</span></span> <span data-ttu-id="f7a4d-142">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.Binder.ReorderArgumentArray%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-142">For more information, see <xref:System.Reflection.Binder.ReorderArgumentArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f7a4d-143">Zestaw dostępnych elementów członkowskich to elementy członkowskie zdefiniowane w typie lub dowolnym typie podstawowym.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-143">The set of available members are those members defined in the type or any base type.</span></span> <span data-ttu-id="f7a4d-144">Jeśli <xref:System.Reflection.BindingFlags> jest określony, elementy członkowskie dowolnego ułatwienia dostępu zostaną zwrócone w zestawie.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-144">If <xref:System.Reflection.BindingFlags> is specified, members of any accessibility will be returned in the set.</span></span> <span data-ttu-id="f7a4d-145">Jeśli **BindingFlags. inpublic** nie jest określony, spinacz musi wymusić reguły ułatwień dostępu.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-145">If **BindingFlags.NonPublic** is not specified, the binder must enforce accessibility rules.</span></span> <span data-ttu-id="f7a4d-146">Podczas określania **publicznej** lub **niepublicznej** flagi powiązania należy również określić **wystąpienie** lub flagę powiązania **statycznego** albo nie zwraca żadnych elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-146">When specifying the **Public** or **NonPublic** binding flag, you must also specify the **Instance** or **Static** binding flag, or no members will be returned.</span></span>  
  
 <span data-ttu-id="f7a4d-147">Jeśli istnieje tylko jeden element członkowski danej nazwy, wywołanie zwrotne nie jest wymagane, a powiązanie jest wykonywane dla tej metody.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-147">If there is only one member of the given name, no callback is necessary, and binding is done on that method.</span></span> <span data-ttu-id="f7a4d-148">Przypadek 1 przykładu kodu ilustruje ten punkt: tylko jedna metoda **PrintBob** jest dostępna i dlatego nie jest konieczne wywołanie zwrotne.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-148">Case 1 of the code example illustrates this point: Only one **PrintBob** method is available, and therefore no callback is needed.</span></span>  
  
 <span data-ttu-id="f7a4d-149">Jeśli istnieje więcej niż jeden element członkowski w dostępnym zestawie, wszystkie te metody są przesyłane do **BindToMethod**, co wybiera odpowiednią metodę i zwraca ją.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-149">If there is more than one member in the available set, all these methods are passed to **BindToMethod**, which selects the appropriate method and returns it.</span></span> <span data-ttu-id="f7a4d-150">W przypadku 2 przykładowego kodu istnieją dwie metody o nazwie **PrintValue**.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-150">In Case 2 of the code example, there are two methods named **PrintValue**.</span></span> <span data-ttu-id="f7a4d-151">Odpowiednia metoda jest wybierana przez wywołanie do **BindToMethod**.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-151">The appropriate method is selected by the call to **BindToMethod**.</span></span>  
  
 <span data-ttu-id="f7a4d-152"><xref:System.Reflection.Binder.ChangeType%2A> wykonuje przekształcenie argumentu (konwersja typu), które konwertuje rzeczywiste argumenty na typ argumentów formalnych wybranej metody.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-152"><xref:System.Reflection.Binder.ChangeType%2A> performs argument coercion (type conversion), which converts the actual arguments to the type of the formal arguments of the selected method.</span></span> <span data-ttu-id="f7a4d-153">**ChangeType** jest wywoływana dla każdego argumentu, nawet jeśli typy pasują dokładnie.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-153">**ChangeType** is called for every argument even if the types match exactly.</span></span>  
  
 <span data-ttu-id="f7a4d-154">W przypadku 3 przykładu kodu rzeczywisty argument typu **String** o wartości "5,5" jest przenoszona do metody z formalnym argumentem typu **Double**.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-154">In Case 3 of the code example, an actual argument of type **String** with a value of "5.5" is passed to a method with a formal argument of type **Double**.</span></span> <span data-ttu-id="f7a4d-155">Aby wywołanie zakończyło się pomyślnie, wartość ciągu "5,5" musi być konwertowana na wartość typu Double.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-155">For the invocation to succeed, the string value "5.5" must be converted to a double value.</span></span> <span data-ttu-id="f7a4d-156">**ChangeType** wykonuje tę konwersję.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-156">**ChangeType** performs this conversion.</span></span>  
  
 <span data-ttu-id="f7a4d-157">**ChangeType** wykonuje tylko przekształcenia bezstratne lub [rozszerzające](../../standard/base-types/type-conversion.md), jak pokazano w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-157">**ChangeType** performs only lossless or [widening coercions](../../standard/base-types/type-conversion.md), as shown in the following table.</span></span>  
  
|<span data-ttu-id="f7a4d-158">Typ źródła</span><span class="sxs-lookup"><span data-stu-id="f7a4d-158">Source type</span></span>|<span data-ttu-id="f7a4d-159">Typ docelowy</span><span class="sxs-lookup"><span data-stu-id="f7a4d-159">Target type</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="f7a4d-160">Dowolny typ</span><span class="sxs-lookup"><span data-stu-id="f7a4d-160">Any type</span></span>|<span data-ttu-id="f7a4d-161">Jego typ podstawowy</span><span class="sxs-lookup"><span data-stu-id="f7a4d-161">Its base type</span></span>|  
|<span data-ttu-id="f7a4d-162">Dowolny typ</span><span class="sxs-lookup"><span data-stu-id="f7a4d-162">Any type</span></span>|<span data-ttu-id="f7a4d-163">Interfejs, który implementuje</span><span class="sxs-lookup"><span data-stu-id="f7a4d-163">Interface it implements</span></span>|  
|<span data-ttu-id="f7a4d-164">Char</span><span class="sxs-lookup"><span data-stu-id="f7a4d-164">Char</span></span>|<span data-ttu-id="f7a4d-165">UInt16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="f7a4d-165">UInt16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="f7a4d-166">Byte</span><span class="sxs-lookup"><span data-stu-id="f7a4d-166">Byte</span></span>|<span data-ttu-id="f7a4d-167">Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="f7a4d-167">Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="f7a4d-168">SByte</span><span class="sxs-lookup"><span data-stu-id="f7a4d-168">SByte</span></span>|<span data-ttu-id="f7a4d-169">Int16, Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="f7a4d-169">Int16, Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="f7a4d-170">UInt16</span><span class="sxs-lookup"><span data-stu-id="f7a4d-170">UInt16</span></span>|<span data-ttu-id="f7a4d-171">UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="f7a4d-171">UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="f7a4d-172">Int16</span><span class="sxs-lookup"><span data-stu-id="f7a4d-172">Int16</span></span>|<span data-ttu-id="f7a4d-173">Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="f7a4d-173">Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="f7a4d-174">UInt32</span><span class="sxs-lookup"><span data-stu-id="f7a4d-174">UInt32</span></span>|<span data-ttu-id="f7a4d-175">UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="f7a4d-175">UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="f7a4d-176">Int32</span><span class="sxs-lookup"><span data-stu-id="f7a4d-176">Int32</span></span>|<span data-ttu-id="f7a4d-177">Int64, pojedyncze, podwójne</span><span class="sxs-lookup"><span data-stu-id="f7a4d-177">Int64, Single, Double</span></span>|  
|<span data-ttu-id="f7a4d-178">UInt64</span><span class="sxs-lookup"><span data-stu-id="f7a4d-178">UInt64</span></span>|<span data-ttu-id="f7a4d-179">Pojedyncza, Podwójna</span><span class="sxs-lookup"><span data-stu-id="f7a4d-179">Single, Double</span></span>|  
|<span data-ttu-id="f7a4d-180">Int64</span><span class="sxs-lookup"><span data-stu-id="f7a4d-180">Int64</span></span>|<span data-ttu-id="f7a4d-181">Pojedyncza, Podwójna</span><span class="sxs-lookup"><span data-stu-id="f7a4d-181">Single, Double</span></span>|  
|<span data-ttu-id="f7a4d-182">Pojedyncze</span><span class="sxs-lookup"><span data-stu-id="f7a4d-182">Single</span></span>|<span data-ttu-id="f7a4d-183">Double</span><span class="sxs-lookup"><span data-stu-id="f7a4d-183">Double</span></span>|  
|<span data-ttu-id="f7a4d-184">Typ niereferencyjny</span><span class="sxs-lookup"><span data-stu-id="f7a4d-184">Nonreference type</span></span>|<span data-ttu-id="f7a4d-185">Typ odwołania</span><span class="sxs-lookup"><span data-stu-id="f7a4d-185">Reference type</span></span>|  
  
 <span data-ttu-id="f7a4d-186"><xref:System.Type>Klasa ma metody **Get** , które używają parametrów typu **spinacza** do rozpoznawania odwołań do określonego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-186">The <xref:System.Type> class has **Get** methods that use parameters of type **Binder** to resolve references to a particular member.</span></span> <span data-ttu-id="f7a4d-187"><xref:System.Type.GetConstructor%2A?displayProperty=nameWithType>, <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> i <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> Wyszukiwanie określonego elementu członkowskiego bieżącego typu przez podanie informacji o sygnaturze dla tego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-187"><xref:System.Type.GetConstructor%2A?displayProperty=nameWithType>, <xref:System.Type.GetMethod%2A?displayProperty=nameWithType>, and <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> search for a particular member of the current type by providing signature information for that member.</span></span> <span data-ttu-id="f7a4d-188"><xref:System.Reflection.Binder.SelectMethod%2A?displayProperty=nameWithType> i <xref:System.Reflection.Binder.SelectProperty%2A?displayProperty=nameWithType> są wywoływane z powrotem w celu wybrania informacji o podpisie odpowiednich metod.</span><span class="sxs-lookup"><span data-stu-id="f7a4d-188"><xref:System.Reflection.Binder.SelectMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.Binder.SelectProperty%2A?displayProperty=nameWithType> are called back on to select the given signature information of the appropriate methods.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f7a4d-189">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="f7a4d-189">See also</span></span>

- <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>
- <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>
- [<span data-ttu-id="f7a4d-190">Wyświetlanie informacji o typie</span><span class="sxs-lookup"><span data-stu-id="f7a4d-190">Viewing Type Information</span></span>](viewing-type-information.md)
- [<span data-ttu-id="f7a4d-191">Konwersja typów w programie .NET Framework</span><span class="sxs-lookup"><span data-stu-id="f7a4d-191">Type Conversion in the .NET Framework</span></span>](../../standard/base-types/type-conversion.md)
