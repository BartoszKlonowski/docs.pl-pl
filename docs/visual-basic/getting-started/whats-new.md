---
title: Co nowego w programie Visual Basic
ms.date: 10/24/2018
f1_keywords:
- VB.StartPage.WhatsNew
helpviewer_keywords:
- new features, Visual Basic
- what's new [Visual Basic]
- Visual Basic, what's new
ms.assetid: d7e97396-7f42-4873-a81c-4ebcc4b6ca02
ms.openlocfilehash: 3ab468f6c68429a3a5cb8706152288afae520df3
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/15/2020
ms.locfileid: "79187141"
---
# <a name="whats-new-for-visual-basic"></a><span data-ttu-id="22471-102">Co nowego w programie Visual Basic</span><span class="sxs-lookup"><span data-stu-id="22471-102">What's new for Visual Basic</span></span>

<span data-ttu-id="22471-103">W tym temacie wymieniono nazwy kluczowych funkcji dla każdej wersji programu Visual Basic wraz ze szczegółowymi opisami nowych i ulepszonych funkcji w najnowszych wersjach języka.</span><span class="sxs-lookup"><span data-stu-id="22471-103">This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the latest versions of the language.</span></span>

## <a name="current-version"></a><span data-ttu-id="22471-104">Bieżąca wersja</span><span class="sxs-lookup"><span data-stu-id="22471-104">Current version</span></span>

<span data-ttu-id="22471-105">Visual Basic 16.0 / Visual Studio 2019 w wersji 16.0</span><span class="sxs-lookup"><span data-stu-id="22471-105">Visual Basic 16.0 / Visual Studio 2019 version 16.0</span></span>\
<span data-ttu-id="22471-106">Aby uzyskać nowe funkcje, zobacz [Visual Basic 16.0](#visual-basic-160).</span><span class="sxs-lookup"><span data-stu-id="22471-106">For new features, see [Visual Basic 16.0](#visual-basic-160).</span></span>

## <a name="previous-versions"></a><span data-ttu-id="22471-107">Poprzednie wersje</span><span class="sxs-lookup"><span data-stu-id="22471-107">Previous versions</span></span>

<span data-ttu-id="22471-108">Visual Basic 15.8 / Visual Studio 2017 w wersji 15.8</span><span class="sxs-lookup"><span data-stu-id="22471-108">Visual Basic 15.8 / Visual Studio 2017 version 15.8</span></span>\
<span data-ttu-id="22471-109">Aby uzyskać nowe funkcje, zobacz [Visual Basic 15.8](#visual-basic-158).</span><span class="sxs-lookup"><span data-stu-id="22471-109">For new features, see [Visual Basic 15.8](#visual-basic-158).</span></span>

<span data-ttu-id="22471-110">Visual Basic 15.5 / Visual Studio 2017 w wersji 15.5</span><span class="sxs-lookup"><span data-stu-id="22471-110">Visual Basic 15.5 / Visual Studio 2017 version 15.5</span></span>\
<span data-ttu-id="22471-111">Aby uzyskać nowe funkcje, zobacz [Visual Basic 15.5](#visual-basic-155).</span><span class="sxs-lookup"><span data-stu-id="22471-111">For new features, see [Visual Basic 15.5](#visual-basic-155).</span></span>

<span data-ttu-id="22471-112">Visual Basic 15.3 / Visual Studio 2017 w wersji 15.3</span><span class="sxs-lookup"><span data-stu-id="22471-112">Visual Basic 15.3 / Visual Studio 2017 version 15.3</span></span>\
<span data-ttu-id="22471-113">Aby uzyskać nowe funkcje, zobacz [Visual Basic 15.3](#visual-basic-153).</span><span class="sxs-lookup"><span data-stu-id="22471-113">For new features, see [Visual Basic 15.3](#visual-basic-153).</span></span>

<span data-ttu-id="22471-114">Visual Basic 2017 / Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="22471-114">Visual Basic 2017 / Visual Studio 2017</span></span>\
<span data-ttu-id="22471-115">Aby uzyskać nowe funkcje, zobacz [Visual Basic 2017](#visual-basic-2017).</span><span class="sxs-lookup"><span data-stu-id="22471-115">For new features, see [Visual Basic 2017](#visual-basic-2017).</span></span>

<span data-ttu-id="22471-116">Visual Basic / Visual Studio 2015</span><span class="sxs-lookup"><span data-stu-id="22471-116">Visual Basic / Visual Studio 2015</span></span>\
<span data-ttu-id="22471-117">Aby uzyskać nowe funkcje, zobacz [Visual Basic 14](#visual-basic-14).</span><span class="sxs-lookup"><span data-stu-id="22471-117">For new features, see [Visual Basic 14](#visual-basic-14).</span></span>

<span data-ttu-id="22471-118">Visual Basic / Visual Studio 2013</span><span class="sxs-lookup"><span data-stu-id="22471-118">Visual Basic / Visual Studio 2013</span></span>\
<span data-ttu-id="22471-119">Podglądy technologii platformy kompilatora .NET ("Roslyn")</span><span class="sxs-lookup"><span data-stu-id="22471-119">Technology previews of the .NET Compiler Platform ("Roslyn")</span></span>

<span data-ttu-id="22471-120">Visual Basic / Visual Studio 2012</span><span class="sxs-lookup"><span data-stu-id="22471-120">Visual Basic / Visual Studio 2012</span></span>\
<span data-ttu-id="22471-121">`Async`i `await` słowa kluczowe, iteratory, atrybuty informacji o rozmówcy</span><span class="sxs-lookup"><span data-stu-id="22471-121">`Async` and `await` keywords, iterators, caller info attributes</span></span>

<span data-ttu-id="22471-122">Visual Basic, Visual Studio 2010</span><span class="sxs-lookup"><span data-stu-id="22471-122">Visual Basic, Visual Studio 2010</span></span>\
<span data-ttu-id="22471-123">Automatycznie implementowane właściwości, inicjatory kolekcji, kontynuacja wiersza niejawnego, dynamiczne, ogólne odchylenie co/contra, globalny dostęp do przestrzeni nazw</span><span class="sxs-lookup"><span data-stu-id="22471-123">Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access</span></span>

<span data-ttu-id="22471-124">Visual Basic / Visual Studio 2008</span><span class="sxs-lookup"><span data-stu-id="22471-124">Visual Basic / Visual Studio 2008</span></span>\
<span data-ttu-id="22471-125">Zintegrowane zapytanie językowe (LINQ), literały XML, wnioskowanie o typach lokalnych, inicjatory obiektów, typy anonimowe, metody rozszerzenia, wnioskowanie o typie lokalnym, `var` wyrażenia lambda, `if` operator, metody częściowe, typy wartości nullable</span><span class="sxs-lookup"><span data-stu-id="22471-125">Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local `var` type inference, lambda expressions, `if` operator, partial methods, nullable value types</span></span>

<span data-ttu-id="22471-126">Visual Basic / Visual Studio 2005</span><span class="sxs-lookup"><span data-stu-id="22471-126">Visual Basic / Visual Studio 2005</span></span>\
<span data-ttu-id="22471-127">Typy `My` typów i pomocników (dostęp do aplikacji, komputera, systemu plików, sieci)</span><span class="sxs-lookup"><span data-stu-id="22471-127">The `My` type and helper types (access to app, computer, files system, network)</span></span>

<span data-ttu-id="22471-128">Visual Basic / Visual Studio .NET 2003</span><span class="sxs-lookup"><span data-stu-id="22471-128">Visual Basic / Visual Studio .NET 2003</span></span>\
<span data-ttu-id="22471-129">Operatory zmiany bitowej, deklaracja zmiennej pętli</span><span class="sxs-lookup"><span data-stu-id="22471-129">Bit-shift operators, loop variable declaration</span></span>

<span data-ttu-id="22471-130">Visual Basic / Visual Studio .NET 2002</span><span class="sxs-lookup"><span data-stu-id="22471-130">Visual Basic / Visual Studio .NET 2002</span></span>\
<span data-ttu-id="22471-131">Pierwsze wydanie programu Visual Basic .NET</span><span class="sxs-lookup"><span data-stu-id="22471-131">The first release of Visual Basic .NET</span></span>

## <a name="visual-basic-160"></a><span data-ttu-id="22471-132">Visual Basic 16.0</span><span class="sxs-lookup"><span data-stu-id="22471-132">Visual Basic 16.0</span></span>

<span data-ttu-id="22471-133">Program Visual Basic 16.0 koncentruje się na dostarczaniu większej liczby funkcji środowiska wykonawczego języka Visual Basic (microsoft.visualbasic.dll) do platformy .NET Core i jest pierwszą wersją programu Visual Basic skoncentrowaną na programie .NET Core.</span><span class="sxs-lookup"><span data-stu-id="22471-133">Visual Basic 16.0 focuses on supplying more of the features of the Visual Basic Runtime (microsoft.visualbasic.dll) to .NET Core and is the first version of Visual Basic focused on .NET Core.</span></span> <span data-ttu-id="22471-134">Wiele części środowiska wykonawczego języka Visual Basic zależy od wersji WinForms, które zostaną dodane w nowszej wersji programu Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="22471-134">Many portions of the Visual Basic Runtime depend on WinForms and these will be added in a later version of Visual Basic.</span></span>

<span data-ttu-id="22471-135">**Komentarze dozwolone w większej liczbie miejsc w zestawieniach**</span><span class="sxs-lookup"><span data-stu-id="22471-135">**Comments allowed in more places within statements**</span></span>

<span data-ttu-id="22471-136">W języku Visual Basic 15.8 i wcześniejszych wersjach komentarze są dozwolone tylko w pustych wierszach, na końcu instrukcji lub w określonych miejscach w instrukcji, w których dozwolona jest kontynuacja wiersza niejawnego.</span><span class="sxs-lookup"><span data-stu-id="22471-136">In Visual Basic 15.8 and earlier versions, comments are only allowed on blank lines, at the end of a statement, or in specific places within a statement where an implicit line continuation is allowed.</span></span> <span data-ttu-id="22471-137">Począwszy od języka Visual Basic 16.0, komentarze są również dozwolone po jawne kontynuacje wiersza i w instrukcji w wierszu, począwszy od spacji, po której następuje podkreślenie.</span><span class="sxs-lookup"><span data-stu-id="22471-137">Starting with Visual Basic 16.0, comments are also allowed after explicit line continuations and within a statement on a line beginning with a space followed by an underscore.</span></span>

```vb
Public Sub Main()
    cmd.CommandText = ' Comment is allowed here without _
        "SELECT * FROM Titles JOIN Publishers " _ ' This is a comment
        & "ON Publishers.PubId = Titles.PubID " _
 _ ' This is a comment on a line without code
        & "WHERE Publishers.State = 'CA'"
End Sub
```

## <a name="visual-basic-158"></a><span data-ttu-id="22471-138">Visual Basic 15.8</span><span class="sxs-lookup"><span data-stu-id="22471-138">Visual Basic 15.8</span></span>

<span data-ttu-id="22471-139">**Zoptymalizowana konwersja zmiennoprzecinka do liczby całkowitej**</span><span class="sxs-lookup"><span data-stu-id="22471-139">**Optimized floating-point to integer conversion**</span></span>

<span data-ttu-id="22471-140">W poprzednich wersjach języka Visual Basic konwersja wartości [Double](../language-reference/data-types/double-data-type.md) i [Single](../language-reference/data-types/single-data-type.md) na liczby całkowite oferowała stosunkowo niską wydajność.</span><span class="sxs-lookup"><span data-stu-id="22471-140">In previous versions of Visual Basic, conversion of [Double](../language-reference/data-types/double-data-type.md) and [Single](../language-reference/data-types/single-data-type.md) values to integers offered relatively poor performance.</span></span> <span data-ttu-id="22471-141">Visual Basic 15.8 znacznie zwiększa wydajność konwersji zmiennoprzecinkowych do liczb całkowitych po przeznaczeniu wartości zwróconej za pomocą jednej z następujących metod do jednej z [wewnętrznych funkcji konwersji całkowitej Visual Basic](../language-reference/functions/type-conversion-functions.md) (CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng) lub gdy wartość zwrócona przez którąkolwiek z następujących metod jest niejawnie rzutowany na integralny [typ,](../language-reference/statements/option-strict-statement.md) gdy opcja Strict jest ustawiona na: `Off`</span><span class="sxs-lookup"><span data-stu-id="22471-141">Visual Basic 15.8 significantly enhances the performance of floating-point conversions to integers when you pass the value returned by any of the following methods to one of the [intrinsic Visual Basic integer conversion functions](../language-reference/functions/type-conversion-functions.md) (CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng), or when the value returned by any of the following methods is implicitly cast to an integral type when [Option Strict](../language-reference/statements/option-strict-statement.md) is set to `Off`:</span></span>

- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Single)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Single)?displayProperty=nameWithType>
- <xref:System.Math.Ceiling(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Floor(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Round(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Truncate(System.Double)?displayProperty=nameWithType>

<span data-ttu-id="22471-142">Ta optymalizacja umożliwia szybsze uruchamianie kodu — nawet dwa razy szybciej dla kodu, który wykonuje dużą liczbę konwersji do typów liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="22471-142">This optimization allows code to run faster -- up to twice as fast for code that does a large number of conversions to integer types.</span></span> <span data-ttu-id="22471-143">Poniższy przykład ilustruje kilka prostych wywołań metody, których dotyczy ta optymalizacja:</span><span class="sxs-lookup"><span data-stu-id="22471-143">The following example illustrates some simple method calls that are affected by this optimization:</span></span>

```vb
Dim s As Single = 173.7619
Dim d As Double = s

Dim i1 As Integer = CInt(Fix(s))               ' Result: 173
Dim b1 As Byte = CByte(Int(d))                 ' Result: 173
Dim s1 AS Short = CShort(Math.Truncate(s))     ' Result: 173
Dim i2 As Integer = CInt(Math.Ceiling(d))      ' Result: 174
Dim i3 As Integer = CInt(Math.Round(s))        ' Result: 174
```

<span data-ttu-id="22471-144">Należy zauważyć, że to obcina, a nie zaokrągla wartości zmiennoprzecinkowych.</span><span class="sxs-lookup"><span data-stu-id="22471-144">Note that this truncates rather than rounds floating-point values.</span></span>

## <a name="visual-basic-155"></a><span data-ttu-id="22471-145">Visual Basic 15.5</span><span class="sxs-lookup"><span data-stu-id="22471-145">Visual Basic 15.5</span></span>

[<span data-ttu-id="22471-146">Argumenty nazwane inne niż końcowe</span><span class="sxs-lookup"><span data-stu-id="22471-146">Non-trailing named arguments</span></span>](../programming-guide/language-features/procedures/passing-arguments-by-position-and-by-name.md#mixing-arguments-by-position-and-by-name)

<span data-ttu-id="22471-147">W języku Visual Basic 15.3 i wcześniejszych wersjach, gdy wywołanie metody zawierało argumenty zarówno według pozycji, jak i nazwy, argumenty pozycyjne musiały poprzedzać nazwane argumenty.</span><span class="sxs-lookup"><span data-stu-id="22471-147">In Visual Basic 15.3 and earlier versions, when a method call included arguments both by position and by name, positional arguments had to precede named arguments.</span></span> <span data-ttu-id="22471-148">Począwszy od języka Visual Basic 15.5, argumenty pozycyjne i nazwane mogą być wyświetlane w dowolnej kolejności, o ile wszystkie argumenty do ostatniego argumentu pozycyjnego znajdują się we właściwej pozycji.</span><span class="sxs-lookup"><span data-stu-id="22471-148">Starting with Visual Basic 15.5, positional and named arguments can appear in any order as long as all arguments up to the last positional argument are in the correct position.</span></span> <span data-ttu-id="22471-149">Jest to szczególnie przydatne, gdy nazwane argumenty są używane do kodu bardziej czytelny.</span><span class="sxs-lookup"><span data-stu-id="22471-149">This is particularly useful when named arguments are used to make code more readable.</span></span>

<span data-ttu-id="22471-150">Na przykład następujące wywołanie metody ma dwa argumenty pozycyjne między argumentem nazwany.</span><span class="sxs-lookup"><span data-stu-id="22471-150">For example, the following method call has two positional arguments between a named argument.</span></span> <span data-ttu-id="22471-151">Nazwany argument wyjaśnia, że wartość 19 reprezentuje wiek.</span><span class="sxs-lookup"><span data-stu-id="22471-151">The named argument makes it clear that the value 19 represents an age.</span></span>

```vb
StudentInfo.Display("Mary", age:=19, #9/21/1998#)
```

[<span data-ttu-id="22471-152">`Private Protected`modyfikator dostępu do członków</span><span class="sxs-lookup"><span data-stu-id="22471-152">`Private Protected` member access modifier</span></span>](../language-reference/modifiers/private-protected.md)

<span data-ttu-id="22471-153">Ta nowa kombinacja słów kluczowych definiuje element członkowski, który jest dostępny dla wszystkich elementów członkowskich w jego klasy zawierającej, jak również przez typy pochodzące z klasy zawierającej, ale tylko wtedy, gdy znajdują się one również w zestawie zawierającym.</span><span class="sxs-lookup"><span data-stu-id="22471-153">This new keyword combination defines a member that is accessible by all members in its containing class as well as by types derived from the containing class, but only if they are also found in the containing assembly.</span></span> <span data-ttu-id="22471-154">Ponieważ struktury nie mogą `Private Protected` być dziedziczone, mogą być stosowane tylko do członków klasy.</span><span class="sxs-lookup"><span data-stu-id="22471-154">Because structures cannot be inherited, `Private Protected` can only be applied to the members of a class.</span></span>

<span data-ttu-id="22471-155">**Wiodący separator sześciokątny/binarny/ósemkowy**</span><span class="sxs-lookup"><span data-stu-id="22471-155">**Leading hex/binary/octal separator**</span></span>

<span data-ttu-id="22471-156">W programie Visual Basic 2017`_`dodano obsługę znaku podkreślenia ( ) jako separatora cyfr.</span><span class="sxs-lookup"><span data-stu-id="22471-156">Visual Basic 2017 added support for the underscore character (`_`) as a digit separator.</span></span> <span data-ttu-id="22471-157">Począwszy od języka Visual Basic 15.5, można użyć znaku podkreślenia jako interełownika między prefiksem a cyframi szesnastkowymi, binarnymi lub ósemkowymi.</span><span class="sxs-lookup"><span data-stu-id="22471-157">Starting with Visual Basic 15.5, you can use the underscore character as a leading separator between the prefix and hexadecimal, binary, or octal digits.</span></span> <span data-ttu-id="22471-158">W poniższym przykładzie użyto separatora cyfr wiodących do zdefiniowania 3 271 948 384 jako liczby szesnastkowej:</span><span class="sxs-lookup"><span data-stu-id="22471-158">The following example uses a leading digit separator to define 3,271,948,384 as a hexadecimal number:</span></span>

```vb
Dim number As Integer = &H_C305_F860
```

<span data-ttu-id="22471-159">Aby użyć znaku podkreślenia jako separatora wiodącego, należy dodać\*następujący element do pliku projektu języka Visual Basic ( .vbproj):</span><span class="sxs-lookup"><span data-stu-id="22471-159">To use the underscore character as a leading separator, you must add the following element to your Visual Basic project (\*.vbproj) file:</span></span>

```xml
<PropertyGroup>
  <LangVersion>15.5</LangVersion>
</PropertyGroup>
```

## <a name="visual-basic-153"></a><span data-ttu-id="22471-160">Visual Basic 15.3</span><span class="sxs-lookup"><span data-stu-id="22471-160">Visual Basic 15.3</span></span>

[<span data-ttu-id="22471-161">**Wnioskowanie o nazwie krotki**</span><span class="sxs-lookup"><span data-stu-id="22471-161">**Named tuple inference**</span></span>](../programming-guide/language-features/data-types/tuples.md#inferred-tuple-element-names)

<span data-ttu-id="22471-162">Po przypisaniu wartości elementów krotki ze zmiennych visual basic wnioskuje nazwę elementów krotki z odpowiednich nazw zmiennych; nie trzeba jawnie nazwać elementu krotki.</span><span class="sxs-lookup"><span data-stu-id="22471-162">When you assign the value of tuple elements from variables, Visual Basic infers the name of tuple elements from the corresponding variable names; you do not have to explicitly name a tuple element.</span></span> <span data-ttu-id="22471-163">W poniższym przykładzie użyto wnioskowania do utworzenia krotki z trzema nazwanymi elementami, `state`, `stateName`i `capital`.</span><span class="sxs-lookup"><span data-stu-id="22471-163">The following example uses inference to create a tuple with three named elements, `state`, `stateName`, and `capital`.</span></span>

[!code-vb[Inferred tuple names](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

<span data-ttu-id="22471-164">**Dodatkowe przełączniki kompilatora**</span><span class="sxs-lookup"><span data-stu-id="22471-164">**Additional compiler switches**</span></span>

<span data-ttu-id="22471-165">Kompilator wiersza polecenia języka Visual Basic obsługuje teraz opcje kompilatora [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) i [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) do kontrolowania danych wyjściowych zestawów referencyjnych.</span><span class="sxs-lookup"><span data-stu-id="22471-165">The Visual Basic command-line compiler now supports the [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) and [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) compiler options to control the output of reference assemblies.</span></span> <span data-ttu-id="22471-166">**-refout** definiuje katalog wyjściowy zestawu odwołań i **-refonly** określa, że tylko zestaw odniesienia ma być wyprowadzany przez kompilację.</span><span class="sxs-lookup"><span data-stu-id="22471-166">**-refout** defines the output directory of the reference assembly, and **-refonly** specifies that only a reference assembly is to be output by compilation.</span></span>

## <a name="visual-basic-2017"></a><span data-ttu-id="22471-167">Program Visual Basic 2017</span><span class="sxs-lookup"><span data-stu-id="22471-167">Visual Basic 2017</span></span>

[<span data-ttu-id="22471-168">**Krotek**</span><span class="sxs-lookup"><span data-stu-id="22471-168">**Tuples**</span></span>](../programming-guide/language-features/data-types/tuples.md)

<span data-ttu-id="22471-169">Krotek są odciążona struktura danych, która najczęściej jest używana do zwracania wielu wartości z wywołania pojedynczej metody.</span><span class="sxs-lookup"><span data-stu-id="22471-169">Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.</span></span> <span data-ttu-id="22471-170">Zwykle, aby zwrócić wiele wartości z metody, należy wykonać jedną z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="22471-170">Ordinarily, to return multiple values from a method, you have to do one of the following:</span></span>

- <span data-ttu-id="22471-171">Zdefiniuj `Class` typ `Structure`niestandardowy (a lub a ).</span><span class="sxs-lookup"><span data-stu-id="22471-171">Define a custom type (a `Class` or a `Structure`).</span></span> <span data-ttu-id="22471-172">Jest to rozwiązanie wagi ciężkiej.</span><span class="sxs-lookup"><span data-stu-id="22471-172">This is a heavyweight solution.</span></span>

- <span data-ttu-id="22471-173">Zdefiniuj jeden lub więcej `ByRef` parametrów, oprócz zwracania wartości z metody.</span><span class="sxs-lookup"><span data-stu-id="22471-173">Define one or more `ByRef` parameters, in addition to returning a value from the method.</span></span>

<span data-ttu-id="22471-174">Obsługa krotek w języku Visual Basic umożliwia szybkie zdefiniowanie krotki, opcjonalnie przypisać nazwy semantyczne do jego wartości i szybko pobrać jego wartości.</span><span class="sxs-lookup"><span data-stu-id="22471-174">Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.</span></span> <span data-ttu-id="22471-175">Poniższy przykład otacza wywołanie <xref:System.Int32.TryParse%2A> metody i zwraca krotki.</span><span class="sxs-lookup"><span data-stu-id="22471-175">The following example wraps a call to the <xref:System.Int32.TryParse%2A> method and returns a tuple.</span></span>

[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

<span data-ttu-id="22471-176">Następnie można wywołać metodę i obsłużyć zwróconą kroszkę z kodem, podobnie jak poniżej.</span><span class="sxs-lookup"><span data-stu-id="22471-176">You can then call the method and handle the returned tuple with code like the following.</span></span>

[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)]

<span data-ttu-id="22471-177">**Literały binarne i separatory cyfr**</span><span class="sxs-lookup"><span data-stu-id="22471-177">**Binary literals and digit separators**</span></span>

<span data-ttu-id="22471-178">Literał binarny można zdefiniować `&B` za `&b`pomocą prefiksu lub pliku .</span><span class="sxs-lookup"><span data-stu-id="22471-178">You can define a binary literal by using the prefix `&B` or `&b`.</span></span> <span data-ttu-id="22471-179">Ponadto można użyć znaku podkreślenia, jako separatora cyfry, `_`aby zwiększyć czytelność.</span><span class="sxs-lookup"><span data-stu-id="22471-179">In addition, you can use the underscore character, `_`, as a digit separator to enhance readability.</span></span> <span data-ttu-id="22471-180">W poniższym przykładzie użyto `Byte` obu operacji do przypisania wartości i wyświetlenia jej jako liczby dziesiętnej, szesnastkowej i binarnej.</span><span class="sxs-lookup"><span data-stu-id="22471-180">The following example uses both features to assign a `Byte` value and to display it as a decimal, hexadecimal, and binary number.</span></span>

[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]

<span data-ttu-id="22471-181">Aby uzyskać więcej informacji, zobacz sekcję "Przydziały dosłowne" typów danych [Bajt](../language-reference/data-types/byte-data-type.md#literal-assignments), [Liczba całkowita](../language-reference/data-types/integer-data-type.md#literal-assignments), [Długa](../language-reference/data-types/long-data-type.md#literal-assignments), [Krótka, Bajt,](../language-reference/data-types/sbyte-data-type.md#literal-assignments) [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments)i [UShort.](../language-reference/data-types/ushort-data-type.md#literal-assignments) [Short](../language-reference/data-types/short-data-type.md#literal-assignments)</span><span class="sxs-lookup"><span data-stu-id="22471-181">For more information, see the "Literal assignments" section of the [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), and [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) data types.</span></span>

[<span data-ttu-id="22471-182">**Obsługa wartości zwracania odwołania c#**</span><span class="sxs-lookup"><span data-stu-id="22471-182">**Support for C# reference return values**</span></span>](../programming-guide/language-features/procedures/ref-return-values.md)

<span data-ttu-id="22471-183">Począwszy od języka C# 7.0, C# obsługuje odwołania wartości zwracane.</span><span class="sxs-lookup"><span data-stu-id="22471-183">Starting with C# 7.0, C# supports reference return values.</span></span> <span data-ttu-id="22471-184">Oznacza to, że gdy wywołanie metoda odbiera wartość zwróconą przez odwołanie, można zmienić wartość odwołania.</span><span class="sxs-lookup"><span data-stu-id="22471-184">That is, when the calling method receives a value returned by reference, it can change the value of the reference.</span></span> <span data-ttu-id="22471-185">Visual Basic nie pozwala na tworzenie metod z odwołania zwracane wartości, ale to pozwala na korzystanie i modyfikowanie wartości zwracane odwołania.</span><span class="sxs-lookup"><span data-stu-id="22471-185">Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.</span></span>

<span data-ttu-id="22471-186">Na przykład następująca `Sentence` klasa napisana w `FindNext` języku C# zawiera metodę, która znajduje następny wyraz w zdaniu, który zaczyna się od określonego podciągu.</span><span class="sxs-lookup"><span data-stu-id="22471-186">For example, the following `Sentence` class written in C# includes a `FindNext` method that finds the next word in a sentence that begins with a specified substring.</span></span> <span data-ttu-id="22471-187">Ciąg jest zwracany jako odwołanie wartości `Boolean` zwracanej, a zmienna przekazywana przez odwołanie do metody wskazuje, czy wyszukiwanie zakończyło się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="22471-187">The string is returned as a reference return value, and a `Boolean` variable passed by reference to the method indicates whether the search was successful.</span></span> <span data-ttu-id="22471-188">Oznacza to, że oprócz odczytu zwracana wartość, obiektu wywołującego można również `Sentence` zmodyfikować go i tej modyfikacji jest odzwierciedlone w klasie.</span><span class="sxs-lookup"><span data-stu-id="22471-188">This means that in addition to reading the returned value, the caller can also modify it, and that modification is reflected in the `Sentence` class.</span></span>

[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]

<span data-ttu-id="22471-189">W najprostszej formie można zmodyfikować słowo znalezione w zdaniu za pomocą kodu, takiego jak poniżej.</span><span class="sxs-lookup"><span data-stu-id="22471-189">In its simplest form, you can modify the word found in the sentence by using code like the following.</span></span> <span data-ttu-id="22471-190">Należy zauważyć, że nie są przypisywanie wartości do metody, ale raczej do wyrażenia, które zwraca metoda, która jest odwołanie wartości zwracanej.</span><span class="sxs-lookup"><span data-stu-id="22471-190">Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]

<span data-ttu-id="22471-191">Problem z tym kodem jest jednak, że jeśli dopasowanie nie zostanie znaleziony, metoda zwraca pierwsze słowo.</span><span class="sxs-lookup"><span data-stu-id="22471-191">A problem with this code, though, is that if a match is not found, the method returns the first word.</span></span> <span data-ttu-id="22471-192">Ponieważ w przykładzie nie bada `Boolean` wartość argumentu, aby ustalić, czy dopasowanie zostanie znalezione, modyfikuje pierwszy wyraz, jeśli nie ma dopasowania.</span><span class="sxs-lookup"><span data-stu-id="22471-192">Since the example does not examine the value of the `Boolean` argument to determine whether a match is found, it modifies the first word if there is no match.</span></span> <span data-ttu-id="22471-193">Poniższy przykład koryguje to, zastępując pierwszy wyraz z siebie, jeśli nie ma dopasowania.</span><span class="sxs-lookup"><span data-stu-id="22471-193">The following example corrects this by replacing the first word with itself if there is no match.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]

<span data-ttu-id="22471-194">Lepszym rozwiązaniem jest użycie metody pomocnika, do której wartość zwracana odwołanie jest przekazywana przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="22471-194">A better solution is to use a helper method to which the reference return value is passed by reference.</span></span> <span data-ttu-id="22471-195">Metoda pomocnika można następnie zmodyfikować argument przekazany do niego przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="22471-195">The helper method can then modify the argument passed to it by reference.</span></span> <span data-ttu-id="22471-196">Poniższy przykład to robi.</span><span class="sxs-lookup"><span data-stu-id="22471-196">The following example does that.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]

<span data-ttu-id="22471-197">Aby uzyskać więcej informacji, zobacz [Odwołanie do wartości zwracane](../programming-guide/language-features/procedures/ref-return-values.md).</span><span class="sxs-lookup"><span data-stu-id="22471-197">For more information, see [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md).</span></span>

## <a name="visual-basic-14"></a><span data-ttu-id="22471-198">Visual Basic 14</span><span class="sxs-lookup"><span data-stu-id="22471-198">Visual Basic 14</span></span>

[<span data-ttu-id="22471-199">NazwaOf</span><span class="sxs-lookup"><span data-stu-id="22471-199">NameOf</span></span>](../language-reference/operators/nameof.md)

<span data-ttu-id="22471-200">Można uzyskać niekwalifikowaną nazwę ciągu typu lub elementu członkowskiego do użycia w komunikacie o błędzie bez twardego kodowania ciągu.</span><span class="sxs-lookup"><span data-stu-id="22471-200">You can get the unqualified string name of a type or member for use in an error message without hard coding a string.</span></span>  <span data-ttu-id="22471-201">Dzięki temu kod zachować poprawne podczas refaktoryzacji.</span><span class="sxs-lookup"><span data-stu-id="22471-201">This allows your code to remain correct when refactoring.</span></span>  <span data-ttu-id="22471-202">Ta funkcja jest również przydatna do podłączania łącza MVC kontrolera widoku modelu i wypalania zdarzeń zmienionych właściwości.</span><span class="sxs-lookup"><span data-stu-id="22471-202">This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.</span></span>

[<span data-ttu-id="22471-203">Interpolacja ciągów</span><span class="sxs-lookup"><span data-stu-id="22471-203">String interpolation</span></span>](../../visual-basic/programming-guide/language-features/strings/interpolated-strings.md)

<span data-ttu-id="22471-204">Do konstruowania ciągów można użyć wyrażeń interpolacji ciągów.</span><span class="sxs-lookup"><span data-stu-id="22471-204">You can use string interpolation expressions to construct strings.</span></span>  <span data-ttu-id="22471-205">Interpolowane wyrażenie ciągu wygląda jak ciąg szablonu zawierający wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="22471-205">An interpolated string expression looks like a template string that contains expressions.</span></span>  <span data-ttu-id="22471-206">Interpolowany ciąg jest łatwiejszy do zrozumienia w odniesieniu do argumentów niż [formatowanie złożone](../../standard/base-types/composite-formatting.md).</span><span class="sxs-lookup"><span data-stu-id="22471-206">An interpolated string is easier to understand with respect to arguments than [Composite Formatting](../../standard/base-types/composite-formatting.md).</span></span>

[<span data-ttu-id="22471-207">Dostęp do elementów członkowskich warunkowych z wartością null i indeksowanie</span><span class="sxs-lookup"><span data-stu-id="22471-207">Null-conditional member access and indexing</span></span>](../language-reference/operators/null-conditional-operators.md)

<span data-ttu-id="22471-208">Przed wykonaniem operacji dostępu elementu członkowskiego (`?.`) lub index (`?[]`) można przetestować wartość null w bardzo lekki sposób składniowy.</span><span class="sxs-lookup"><span data-stu-id="22471-208">You can test for null in a very light syntactic way before performing a member access (`?.`) or index (`?[]`) operation.</span></span>  <span data-ttu-id="22471-209">Te operatory ułatwiają pisanie mniej kodu do obsługi kontroli null, szczególnie w przypadku malejąco do struktur danych.</span><span class="sxs-lookup"><span data-stu-id="22471-209">These operators help you write less code to handle null checks, especially for descending into data structures.</span></span>  <span data-ttu-id="22471-210">Jeśli lewy argument lub odwołanie do obiektu ma wartość null, operacje zwracają wartość null.</span><span class="sxs-lookup"><span data-stu-id="22471-210">If the left operand or object reference is null, the operations returns null.</span></span>

[<span data-ttu-id="22471-211">Literały ciągów wielowierszowych</span><span class="sxs-lookup"><span data-stu-id="22471-211">Multi-line string literals</span></span>](../../visual-basic/programming-guide/language-features/strings/string-basics.md)

<span data-ttu-id="22471-212">Literały ciągów mogą zawierać sekwencje nowego linii.</span><span class="sxs-lookup"><span data-stu-id="22471-212">String literals can contain newline sequences.</span></span>  <span data-ttu-id="22471-213">Nie potrzebujesz już starej pracy wokół korzystania z`<xml><![CDATA[...text with newlines...]]></xml>.Value`</span><span class="sxs-lookup"><span data-stu-id="22471-213">You no longer need the old work around of using `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span></span>

<span data-ttu-id="22471-214">**Komentarze**</span><span class="sxs-lookup"><span data-stu-id="22471-214">**Comments**</span></span>

<span data-ttu-id="22471-215">Można umieścić komentarze po niejawnych kontynuacji wiersza, wewnątrz wyrażeń inicjatora i wśród terminów wyrażenia LINQ.</span><span class="sxs-lookup"><span data-stu-id="22471-215">You can put comments after implicit line continuations, inside initializer expressions, and among LINQ expression terms.</span></span>

<span data-ttu-id="22471-216">**Inteligentniejsza, w pełni kwalifikowana rozdzielczość nazw**</span><span class="sxs-lookup"><span data-stu-id="22471-216">**Smarter fully-qualified name resolution**</span></span>

<span data-ttu-id="22471-217">Biorąc pod `Threading.Thread.Sleep(1000)`uwagę kod, takich jak Visual Basic używane do wyszukiwania obszaru nazw "Wątki", odkryć, że był niejednoznaczny między System.Threading i System.Windows.Threading, a następnie zgłosić błąd.</span><span class="sxs-lookup"><span data-stu-id="22471-217">Given code such as `Threading.Thread.Sleep(1000)`, Visual Basic used to look up the namespace "Threading", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.</span></span>  <span data-ttu-id="22471-218">Visual Basic uwzględnia teraz oba możliwe przestrzenie nazw razem.</span><span class="sxs-lookup"><span data-stu-id="22471-218">Visual Basic now considers both possible namespaces together.</span></span>  <span data-ttu-id="22471-219">Jeśli zostanie wyświetlona lista ukończenia, edytor programu Visual Studio wyświetla listę członków z obu typów na liście uzupełniania.</span><span class="sxs-lookup"><span data-stu-id="22471-219">If you show the completion list, the Visual Studio editor lists members from both types in the completion list.</span></span>

<span data-ttu-id="22471-220">**Literały daty na początku roku**</span><span class="sxs-lookup"><span data-stu-id="22471-220">**Year-first date literals**</span></span>

<span data-ttu-id="22471-221">Możesz mieć dosłowy daty w formacie yyyy-mm-dd, `#2015-03-17 16:10 PM#`.</span><span class="sxs-lookup"><span data-stu-id="22471-221">You can have date literals in yyyy-mm-dd format, `#2015-03-17 16:10 PM#`.</span></span>

<span data-ttu-id="22471-222">**Właściwości interfejsu readonly**</span><span class="sxs-lookup"><span data-stu-id="22471-222">**Readonly interface properties**</span></span>

<span data-ttu-id="22471-223">Można zaimplementować tylko do odczytu właściwości interfejsu przy użyciu readwrite właściwości.</span><span class="sxs-lookup"><span data-stu-id="22471-223">You can implement readonly interface properties using a readwrite property.</span></span> <span data-ttu-id="22471-224">Interfejs gwarantuje minimalne funkcje i nie zatrzymuje implementującej klasy z zezwalania na właściwość, która ma być ustawiona.</span><span class="sxs-lookup"><span data-stu-id="22471-224">The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.</span></span>

[<span data-ttu-id="22471-225">TypeOf \<expr> IsNot \<typ></span><span class="sxs-lookup"><span data-stu-id="22471-225">TypeOf \<expr> IsNot \<type></span></span>](../../visual-basic/language-reference/operators/typeof-operator.md)

<span data-ttu-id="22471-226">Aby uzyskać więcej czytelności kodu, `TypeOf` można `IsNot`teraz używać z .</span><span class="sxs-lookup"><span data-stu-id="22471-226">For more readability of your code, you can now use `TypeOf` with `IsNot`.</span></span>

[<span data-ttu-id="22471-227">> identyfikator ostrzeżenia \<#Disable i>identyfikatora ostrzeżenia \<#Enable</span><span class="sxs-lookup"><span data-stu-id="22471-227">#Disable Warning \<ID> and #Enable Warning \<ID></span></span>](../../visual-basic/language-reference/directives/index.md)

<span data-ttu-id="22471-228">Można wyłączyć i włączyć określone ostrzeżenia dla regionów w pliku źródłowym.</span><span class="sxs-lookup"><span data-stu-id="22471-228">You can disable and enable specific warnings for regions within a source file.</span></span>

<span data-ttu-id="22471-229">**Ulepszenia komentarza do doc XML**</span><span class="sxs-lookup"><span data-stu-id="22471-229">**XML doc comment improvements**</span></span>

<span data-ttu-id="22471-230">Podczas pisania komentarzy doc, można uzyskać inteligentny edytor i budować `crefs` obsługę sprawdzania poprawności nazw parametrów, właściwej obsługi (ogólne, operatory, itp.), kolorowanie i refaktoryzacji.</span><span class="sxs-lookup"><span data-stu-id="22471-230">When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of `crefs` (generics, operators, etc.), colorizing, and refactoring.</span></span>

[<span data-ttu-id="22471-231">Definicje modułów częściowych i interfejsów</span><span class="sxs-lookup"><span data-stu-id="22471-231">Partial module and interface definitions</span></span>](../../visual-basic/language-reference/modifiers/partial.md)

<span data-ttu-id="22471-232">Oprócz klas i struktur można zadeklarować częściowe moduły i interfejsy.</span><span class="sxs-lookup"><span data-stu-id="22471-232">In addition to classes and structs, you can declare partial modules and interfaces.</span></span>

[<span data-ttu-id="22471-233">#Region dyrektyw wewnątrz organów metod</span><span class="sxs-lookup"><span data-stu-id="22471-233">#Region directives inside method bodies</span></span>](../../visual-basic/language-reference/directives/region-directive.md)

<span data-ttu-id="22471-234">Można umieścić #Region... #End ograniczniki regionu w dowolnym miejscu w pliku, wewnątrz funkcji, a nawet obejmujące między organami funkcji.</span><span class="sxs-lookup"><span data-stu-id="22471-234">You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.</span></span>

[<span data-ttu-id="22471-235">Definicje zastępowań są niejawnie przeciążeniami</span><span class="sxs-lookup"><span data-stu-id="22471-235">Overrides definitions are implicitly overloads</span></span>](../../visual-basic/language-reference/modifiers/overrides.md)

<span data-ttu-id="22471-236">Jeśli dodasz `Overrides` modyfikator do definicji, kompilator niejawnie dodaje, `Overloads` dzięki czemu można wpisać mniej kodu w typowych przypadkach.</span><span class="sxs-lookup"><span data-stu-id="22471-236">If you add the `Overrides` modifier to a definition, the compiler implicitly adds `Overloads` so that you can type less code in common cases.</span></span>

<span data-ttu-id="22471-237">**CObj dozwolone w argumentach atrybutów**</span><span class="sxs-lookup"><span data-stu-id="22471-237">**CObj allowed in attributes arguments**</span></span>

<span data-ttu-id="22471-238">Kompilator używany do podania błędu, który CObj (...) nie był stałą, gdy był używany w konstrukcjach atrybutów.</span><span class="sxs-lookup"><span data-stu-id="22471-238">The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.</span></span>

<span data-ttu-id="22471-239">**Deklarowanie i spożywanie niejednoznacznych metod z różnych interfejsów**</span><span class="sxs-lookup"><span data-stu-id="22471-239">**Declaring and consuming ambiguous methods from different interfaces**</span></span>

<span data-ttu-id="22471-240">Wcześniej następujący kod dał błędy, które uniemożliwiały `IMock` deklarowanie `GetDetails` lub wywoływanie (jeśli zostały one zadeklarowane w języku C#):</span><span class="sxs-lookup"><span data-stu-id="22471-240">Previously the following code yielded errors that prevented you from declaring `IMock` or from calling `GetDetails` (if these had been declared in C#):</span></span>

```vb
Interface ICustomer
  Sub GetDetails(x As Integer)
End Interface

Interface ITime
  Sub GetDetails(x As String)
End Interface

Interface IMock : Inherits ICustomer, ITime
  Overloads Sub GetDetails(x As Char)
End Interface

Interface IMock2 : Inherits ICustomer, ITime
End Interface
```

<span data-ttu-id="22471-241">Teraz kompilator użyje normalnych reguł rozpoznawania `GetDetails` przeciążenia, aby wybrać najbardziej odpowiednie do wywołania i można zadeklarować relacje interfejsu w języku Visual Basic, takie jak te pokazane w przykładzie.</span><span class="sxs-lookup"><span data-stu-id="22471-241">Now the compiler will use normal overload resolution rules to choose the most appropriate `GetDetails` to call, and you can declare interface relationships in Visual Basic like those shown in the sample.</span></span>

## <a name="see-also"></a><span data-ttu-id="22471-242">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="22471-242">See also</span></span>

- [<span data-ttu-id="22471-243">Co nowego w programie Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="22471-243">What's New in Visual Studio 2017</span></span>](/visualstudio/ide/whats-new-visual-studio-2017)
- [<span data-ttu-id="22471-244">Co nowego w programie Visual Studio 2019</span><span class="sxs-lookup"><span data-stu-id="22471-244">What's New in Visual Studio 2019</span></span>](/visualstudio/ide/whats-new-visual-studio-2019)
