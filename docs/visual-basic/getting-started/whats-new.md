---
title: Co nowego w Visual Basic
ms.date: 10/24/2018
f1_keywords:
- VB.StartPage.WhatsNew
helpviewer_keywords:
- new features, Visual Basic
- what's new [Visual Basic]
- Visual Basic, what's new
ms.assetid: d7e97396-7f42-4873-a81c-4ebcc4b6ca02
ms.openlocfilehash: a9bac04a7839796229a2e1c61771ca32573f8fcd
ms.sourcegitcommit: f8c270376ed905f6a8896ce0fe25b4f4b38ff498
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 06/04/2020
ms.locfileid: "84374515"
---
# <a name="whats-new-for-visual-basic"></a><span data-ttu-id="7a701-102">Co nowego w Visual Basic</span><span class="sxs-lookup"><span data-stu-id="7a701-102">What's new for Visual Basic</span></span>

<span data-ttu-id="7a701-103">Ten temat zawiera listę najważniejszych nazw funkcji dla każdej wersji Visual Basic z szczegółowymi opisami nowych i ulepszonych funkcji w najnowszych wersjach języka.</span><span class="sxs-lookup"><span data-stu-id="7a701-103">This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the latest versions of the language.</span></span>

## <a name="current-version"></a><span data-ttu-id="7a701-104">Bieżąca wersja</span><span class="sxs-lookup"><span data-stu-id="7a701-104">Current version</span></span>

<span data-ttu-id="7a701-105">Visual Basic 16,0/Visual Studio 2019 wersja 16,0 </span><span class="sxs-lookup"><span data-stu-id="7a701-105">Visual Basic 16.0 / Visual Studio 2019 version 16.0</span></span>\
<span data-ttu-id="7a701-106">Aby poznać nowe funkcje, zobacz [Visual Basic 16,0](#visual-basic-160).</span><span class="sxs-lookup"><span data-stu-id="7a701-106">For new features, see [Visual Basic 16.0](#visual-basic-160).</span></span>

## <a name="previous-versions"></a><span data-ttu-id="7a701-107">Poprzednie wersje</span><span class="sxs-lookup"><span data-stu-id="7a701-107">Previous versions</span></span>

<span data-ttu-id="7a701-108">Visual Basic 15,8/Visual Studio 2017 wersja 15,8 </span><span class="sxs-lookup"><span data-stu-id="7a701-108">Visual Basic 15.8 / Visual Studio 2017 version 15.8</span></span>\
<span data-ttu-id="7a701-109">Aby poznać nowe funkcje, zobacz [Visual Basic 15,8](#visual-basic-158).</span><span class="sxs-lookup"><span data-stu-id="7a701-109">For new features, see [Visual Basic 15.8](#visual-basic-158).</span></span>

<span data-ttu-id="7a701-110">Visual Basic 15,5/Visual Studio 2017 wersja 15,5 </span><span class="sxs-lookup"><span data-stu-id="7a701-110">Visual Basic 15.5 / Visual Studio 2017 version 15.5</span></span>\
<span data-ttu-id="7a701-111">Aby poznać nowe funkcje, zobacz [Visual Basic 15,5](#visual-basic-155).</span><span class="sxs-lookup"><span data-stu-id="7a701-111">For new features, see [Visual Basic 15.5](#visual-basic-155).</span></span>

<span data-ttu-id="7a701-112">Visual Basic 15,3/Visual Studio 2017 wersja 15,3 </span><span class="sxs-lookup"><span data-stu-id="7a701-112">Visual Basic 15.3 / Visual Studio 2017 version 15.3</span></span>\
<span data-ttu-id="7a701-113">Aby poznać nowe funkcje, zobacz [Visual Basic 15,3](#visual-basic-153).</span><span class="sxs-lookup"><span data-stu-id="7a701-113">For new features, see [Visual Basic 15.3](#visual-basic-153).</span></span>

<span data-ttu-id="7a701-114">Visual Basic 2017/Visual Studio 2017 </span><span class="sxs-lookup"><span data-stu-id="7a701-114">Visual Basic 2017 / Visual Studio 2017</span></span>\
<span data-ttu-id="7a701-115">Aby poznać nowe funkcje, zobacz [Visual Basic 2017](#visual-basic-2017).</span><span class="sxs-lookup"><span data-stu-id="7a701-115">For new features, see [Visual Basic 2017](#visual-basic-2017).</span></span>

<span data-ttu-id="7a701-116">Visual Basic/Visual Studio 2015 </span><span class="sxs-lookup"><span data-stu-id="7a701-116">Visual Basic / Visual Studio 2015</span></span>\
<span data-ttu-id="7a701-117">Aby poznać nowe funkcje, zobacz [Visual Basic 14](#visual-basic-14).</span><span class="sxs-lookup"><span data-stu-id="7a701-117">For new features, see [Visual Basic 14](#visual-basic-14).</span></span>

<span data-ttu-id="7a701-118">Visual Basic/Visual Studio 2013 </span><span class="sxs-lookup"><span data-stu-id="7a701-118">Visual Basic / Visual Studio 2013</span></span>\
<span data-ttu-id="7a701-119">Wersje zapoznawcze technologii .NET Compiler Platform ("Roslyn")</span><span class="sxs-lookup"><span data-stu-id="7a701-119">Technology previews of the .NET Compiler Platform ("Roslyn")</span></span>

<span data-ttu-id="7a701-120">Visual Basic/Visual Studio 2012 </span><span class="sxs-lookup"><span data-stu-id="7a701-120">Visual Basic / Visual Studio 2012</span></span>\
<span data-ttu-id="7a701-121">`Async`i `await` słowa kluczowe, Iteratory, atrybuty informacji o wywołującym</span><span class="sxs-lookup"><span data-stu-id="7a701-121">`Async` and `await` keywords, iterators, caller info attributes</span></span>

<span data-ttu-id="7a701-122">Visual Basic, Visual Studio 2010 </span><span class="sxs-lookup"><span data-stu-id="7a701-122">Visual Basic, Visual Studio 2010</span></span>\
<span data-ttu-id="7a701-123">Właściwości zaimplementowane przez autoimplementację, Inicjatory kolekcji, niejawne kontynuacja wiersza, dynamiczne, ogólne, proste/odchylenia, globalny dostęp do przestrzeni nazw</span><span class="sxs-lookup"><span data-stu-id="7a701-123">Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access</span></span>

<span data-ttu-id="7a701-124">Visual Basic/Visual Studio 2008 </span><span class="sxs-lookup"><span data-stu-id="7a701-124">Visual Basic / Visual Studio 2008</span></span>\
<span data-ttu-id="7a701-125">Language Integrated Query (LINQ), literały XML, wnioskowanie typu lokalnego, Inicjatory obiektów, typy anonimowe, metody rozszerzające, `var` wnioskowanie typu lokalnego, wyrażenia lambda, `if` operator, metody częściowe, typy wartości null</span><span class="sxs-lookup"><span data-stu-id="7a701-125">Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local `var` type inference, lambda expressions, `if` operator, partial methods, nullable value types</span></span>

<span data-ttu-id="7a701-126">Visual Basic/Visual Studio 2005 </span><span class="sxs-lookup"><span data-stu-id="7a701-126">Visual Basic / Visual Studio 2005</span></span>\
<span data-ttu-id="7a701-127">`My`Typ i typy pomocnika (dostęp do aplikacji, komputera, systemu plików, sieci)</span><span class="sxs-lookup"><span data-stu-id="7a701-127">The `My` type and helper types (access to app, computer, files system, network)</span></span>

<span data-ttu-id="7a701-128">Visual Basic/Visual Studio .NET 2003 </span><span class="sxs-lookup"><span data-stu-id="7a701-128">Visual Basic / Visual Studio .NET 2003</span></span>\
<span data-ttu-id="7a701-129">Operatory przesunięcia bitowego, deklaracja zmiennej pętli</span><span class="sxs-lookup"><span data-stu-id="7a701-129">Bit-shift operators, loop variable declaration</span></span>

<span data-ttu-id="7a701-130">Visual Basic/Visual Studio .NET 2002 </span><span class="sxs-lookup"><span data-stu-id="7a701-130">Visual Basic / Visual Studio .NET 2002</span></span>\
<span data-ttu-id="7a701-131">Pierwsze wydanie Visual Basic .NET</span><span class="sxs-lookup"><span data-stu-id="7a701-131">The first release of Visual Basic .NET</span></span>

## <a name="visual-basic-160"></a><span data-ttu-id="7a701-132">Visual Basic 16,0</span><span class="sxs-lookup"><span data-stu-id="7a701-132">Visual Basic 16.0</span></span>

<span data-ttu-id="7a701-133">Visual Basic 16,0 koncentruje się na dostarczaniu większej liczby funkcji środowiska uruchomieniowego Visual Basic (Microsoft. VisualBasic. dll) do programu .NET Core i to pierwsza wersja Visual Basic skoncentrowana na platformie .NET Core.</span><span class="sxs-lookup"><span data-stu-id="7a701-133">Visual Basic 16.0 focuses on supplying more of the features of the Visual Basic Runtime (microsoft.visualbasic.dll) to .NET Core and is the first version of Visual Basic focused on .NET Core.</span></span> <span data-ttu-id="7a701-134">Wiele części środowiska uruchomieniowego Visual Basic jest zależne od WinForms i zostaną dodane do nowszej wersji Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="7a701-134">Many portions of the Visual Basic Runtime depend on WinForms and these will be added in a later version of Visual Basic.</span></span>

<span data-ttu-id="7a701-135">**Komentarze są dozwolone w większej liczbie miejsc w instrukcjach**</span><span class="sxs-lookup"><span data-stu-id="7a701-135">**Comments allowed in more places within statements**</span></span>

<span data-ttu-id="7a701-136">W Visual Basic 15,8 i wcześniejszych wersjach Komentarze są dozwolone tylko w pustych wierszach, na końcu instrukcji lub w określonych miejscach w instrukcji, w których niejawna kontynuacja wiersza jest dozwolona.</span><span class="sxs-lookup"><span data-stu-id="7a701-136">In Visual Basic 15.8 and earlier versions, comments are only allowed on blank lines, at the end of a statement, or in specific places within a statement where an implicit line continuation is allowed.</span></span> <span data-ttu-id="7a701-137">Począwszy od Visual Basic 16,0, komentarze są również dozwolone po jawnej kontynuacji wiersza i wewnątrz instrukcji w wierszu rozpoczynającym się od znaku podkreślenia.</span><span class="sxs-lookup"><span data-stu-id="7a701-137">Starting with Visual Basic 16.0, comments are also allowed after explicit line continuations and within a statement on a line beginning with a space followed by an underscore.</span></span>

```vb
Public Sub Main()
    cmd.CommandText = ' Comment is allowed here without _
        "SELECT * FROM Titles JOIN Publishers " _ ' This is a comment
        & "ON Publishers.PubId = Titles.PubID " _
 _ ' This is a comment on a line without code
        & "WHERE Publishers.State = 'CA'"
End Sub
```

## <a name="visual-basic-158"></a><span data-ttu-id="7a701-138">Visual Basic 15,8</span><span class="sxs-lookup"><span data-stu-id="7a701-138">Visual Basic 15.8</span></span>

<span data-ttu-id="7a701-139">**Optymalizacja konwersji zmiennoprzecinkowej na liczbę całkowitą**</span><span class="sxs-lookup"><span data-stu-id="7a701-139">**Optimized floating-point to integer conversion**</span></span>

<span data-ttu-id="7a701-140">W poprzednich wersjach Visual Basic konwersja wartości [podwójnej](../language-reference/data-types/double-data-type.md) i [pojedynczej](../language-reference/data-types/single-data-type.md) na liczbę całkowitą oferuje stosunkowo niską wydajność.</span><span class="sxs-lookup"><span data-stu-id="7a701-140">In previous versions of Visual Basic, conversion of [Double](../language-reference/data-types/double-data-type.md) and [Single](../language-reference/data-types/single-data-type.md) values to integers offered relatively poor performance.</span></span> <span data-ttu-id="7a701-141">Visual Basic 15,8 znacząco podnosi wydajność konwersji zmiennoprzecinkowych do liczb całkowitych, gdy przekazujesz wartość zwróconą przez dowolną z następujących metod do jednej z [funkcji konwersji wewnętrznej Visual Basic liczb całkowitych](../language-reference/functions/type-conversion-functions.md) (CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng) lub gdy wartość zwrócona przez dowolną z następujących metod jest niejawnie rzutowana na typ całkowity, gdy [opcja Strict](../language-reference/statements/option-strict-statement.md) jest ustawiona na `Off` :</span><span class="sxs-lookup"><span data-stu-id="7a701-141">Visual Basic 15.8 significantly enhances the performance of floating-point conversions to integers when you pass the value returned by any of the following methods to one of the [intrinsic Visual Basic integer conversion functions](../language-reference/functions/type-conversion-functions.md) (CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng), or when the value returned by any of the following methods is implicitly cast to an integral type when [Option Strict](../language-reference/statements/option-strict-statement.md) is set to `Off`:</span></span>

- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Single)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Single)?displayProperty=nameWithType>
- <xref:System.Math.Ceiling(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Floor(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Round(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Truncate(System.Double)?displayProperty=nameWithType>

<span data-ttu-id="7a701-142">Ta optymalizacja umożliwia szybsze uruchamianie kodu — maksymalnie dwa razy w przypadku kodu, który wykonuje dużą liczbę konwersji na typy całkowite.</span><span class="sxs-lookup"><span data-stu-id="7a701-142">This optimization allows code to run faster -- up to twice as fast for code that does a large number of conversions to integer types.</span></span> <span data-ttu-id="7a701-143">Poniższy przykład ilustruje niektóre proste wywołania metod, których dotyczy ta Optymalizacja:</span><span class="sxs-lookup"><span data-stu-id="7a701-143">The following example illustrates some simple method calls that are affected by this optimization:</span></span>

```vb
Dim s As Single = 173.7619
Dim d As Double = s

Dim i1 As Integer = CInt(Fix(s))               ' Result: 173
Dim b1 As Byte = CByte(Int(d))                 ' Result: 173
Dim s1 AS Short = CShort(Math.Truncate(s))     ' Result: 173
Dim i2 As Integer = CInt(Math.Ceiling(d))      ' Result: 174
Dim i3 As Integer = CInt(Math.Round(s))        ' Result: 174
```

<span data-ttu-id="7a701-144">Należy zauważyć, że to obcina zamiast zaokrąglania wartości zmiennoprzecinkowych.</span><span class="sxs-lookup"><span data-stu-id="7a701-144">Note that this truncates rather than rounds floating-point values.</span></span>

## <a name="visual-basic-155"></a><span data-ttu-id="7a701-145">Visual Basic 15,5</span><span class="sxs-lookup"><span data-stu-id="7a701-145">Visual Basic 15.5</span></span>

[<span data-ttu-id="7a701-146">Argumenty nazwane inne niż końcowe</span><span class="sxs-lookup"><span data-stu-id="7a701-146">Non-trailing named arguments</span></span>](../programming-guide/language-features/procedures/passing-arguments-by-position-and-by-name.md#mixing-arguments-by-position-and-by-name)

<span data-ttu-id="7a701-147">W Visual Basic 15,3 i starszych wersjach, gdy wywołanie metody zawierało argumenty w obu położeniach i według nazwy, argumenty pozycyjne musiały poprzedzać nazwane argumenty.</span><span class="sxs-lookup"><span data-stu-id="7a701-147">In Visual Basic 15.3 and earlier versions, when a method call included arguments both by position and by name, positional arguments had to precede named arguments.</span></span> <span data-ttu-id="7a701-148">Począwszy od Visual Basic 15,5, argumenty pozycyjne i nazwane mogą pojawiać się w dowolnej kolejności, tak długo, jak wszystkie argumenty do ostatniego argumentu pozycyjnego znajdują się w poprawnej pozycji.</span><span class="sxs-lookup"><span data-stu-id="7a701-148">Starting with Visual Basic 15.5, positional and named arguments can appear in any order as long as all arguments up to the last positional argument are in the correct position.</span></span> <span data-ttu-id="7a701-149">Jest to szczególnie przydatne w przypadku, gdy nazwane argumenty są używane w celu łatwiejszego odczytywania kodu.</span><span class="sxs-lookup"><span data-stu-id="7a701-149">This is particularly useful when named arguments are used to make code more readable.</span></span>

<span data-ttu-id="7a701-150">Na przykład następujące wywołanie metody ma dwa argumenty pozycyjne między nazwanym argumentem.</span><span class="sxs-lookup"><span data-stu-id="7a701-150">For example, the following method call has two positional arguments between a named argument.</span></span> <span data-ttu-id="7a701-151">Nazwany argument sprawia, że wartość 19 reprezentuje wiek.</span><span class="sxs-lookup"><span data-stu-id="7a701-151">The named argument makes it clear that the value 19 represents an age.</span></span>

```vb
StudentInfo.Display("Mary", age:=19, #9/21/1998#)
```

[<span data-ttu-id="7a701-152">`Private Protected`Modyfikator dostępu składowej</span><span class="sxs-lookup"><span data-stu-id="7a701-152">`Private Protected` member access modifier</span></span>](../language-reference/modifiers/private-protected.md)

<span data-ttu-id="7a701-153">Ta nowa kombinacja słów kluczowych definiuje element członkowski, który jest dostępny dla wszystkich elementów członkowskich w jego klasie zawierającej, a także typów pochodzących od klasy zawierającej, ale tylko wtedy, gdy znajdują się one również w zawierającym go zestawie.</span><span class="sxs-lookup"><span data-stu-id="7a701-153">This new keyword combination defines a member that is accessible by all members in its containing class as well as by types derived from the containing class, but only if they are also found in the containing assembly.</span></span> <span data-ttu-id="7a701-154">Ponieważ struktury nie mogą być dziedziczone, `Private Protected` można je stosować tylko do elementów członkowskich klasy.</span><span class="sxs-lookup"><span data-stu-id="7a701-154">Because structures cannot be inherited, `Private Protected` can only be applied to the members of a class.</span></span>

<span data-ttu-id="7a701-155">**Wiodący separator szesnastkowy/binarny**</span><span class="sxs-lookup"><span data-stu-id="7a701-155">**Leading hex/binary/octal separator**</span></span>

<span data-ttu-id="7a701-156">Visual Basic 2017 dodano obsługę znaku podkreślenia ( `_` ) jako separatora cyfr.</span><span class="sxs-lookup"><span data-stu-id="7a701-156">Visual Basic 2017 added support for the underscore character (`_`) as a digit separator.</span></span> <span data-ttu-id="7a701-157">Począwszy od Visual Basic 15,5, można użyć znaku podkreślenia jako wiodącego separatora między cyframi prefiksu i szesnastkowym, dwójkowym lub ósemkowym.</span><span class="sxs-lookup"><span data-stu-id="7a701-157">Starting with Visual Basic 15.5, you can use the underscore character as a leading separator between the prefix and hexadecimal, binary, or octal digits.</span></span> <span data-ttu-id="7a701-158">W poniższym przykładzie zastosowano wiodący separator cyfr, aby zdefiniować 3 271 948 384 jako liczbę szesnastkową:</span><span class="sxs-lookup"><span data-stu-id="7a701-158">The following example uses a leading digit separator to define 3,271,948,384 as a hexadecimal number:</span></span>

```vb
Dim number As Integer = &H_C305_F860
```

<span data-ttu-id="7a701-159">Aby użyć znaku podkreślenia jako separatora wiodącego, należy dodać następujący element do pliku projektu Visual Basic ( \* vbproj):</span><span class="sxs-lookup"><span data-stu-id="7a701-159">To use the underscore character as a leading separator, you must add the following element to your Visual Basic project (\*.vbproj) file:</span></span>

```xml
<PropertyGroup>
  <LangVersion>15.5</LangVersion>
</PropertyGroup>
```

## <a name="visual-basic-153"></a><span data-ttu-id="7a701-160">Visual Basic 15,3</span><span class="sxs-lookup"><span data-stu-id="7a701-160">Visual Basic 15.3</span></span>

[<span data-ttu-id="7a701-161">**Wnioskowanie o nazwie krotki**</span><span class="sxs-lookup"><span data-stu-id="7a701-161">**Named tuple inference**</span></span>](../programming-guide/language-features/data-types/tuples.md#inferred-tuple-element-names)

<span data-ttu-id="7a701-162">Podczas przypisywania wartości elementów krotki ze zmiennych, Visual Basic wnioskuje nazwę elementów krotki z odpowiednich nazw zmiennych; nie ma potrzeby jawnej nazwy elementu krotki.</span><span class="sxs-lookup"><span data-stu-id="7a701-162">When you assign the value of tuple elements from variables, Visual Basic infers the name of tuple elements from the corresponding variable names; you do not have to explicitly name a tuple element.</span></span> <span data-ttu-id="7a701-163">Poniższy przykład używa wnioskowania, aby utworzyć krotkę z trzema nazwanymi elementami, `state` , `stateName` i `capital` .</span><span class="sxs-lookup"><span data-stu-id="7a701-163">The following example uses inference to create a tuple with three named elements, `state`, `stateName`, and `capital`.</span></span>

[!code-vb[Inferred tuple names](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

<span data-ttu-id="7a701-164">**Dodatkowe przełączniki kompilatora**</span><span class="sxs-lookup"><span data-stu-id="7a701-164">**Additional compiler switches**</span></span>

<span data-ttu-id="7a701-165">Kompilator wiersza polecenia Visual Basic obsługuje teraz opcje kompilatora [**-opcji refout**](../reference/command-line-compiler/refout-compiler-option.md) i [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) , aby kontrolować dane wyjściowe zestawów referencyjnych.</span><span class="sxs-lookup"><span data-stu-id="7a701-165">The Visual Basic command-line compiler now supports the [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) and [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) compiler options to control the output of reference assemblies.</span></span> <span data-ttu-id="7a701-166">**-opcji refout** definiuje katalog wyjściowy zestawu referencyjnego i **-refonly** określa, że tylko zestaw odwołania ma być wyprowadzany przez kompilację.</span><span class="sxs-lookup"><span data-stu-id="7a701-166">**-refout** defines the output directory of the reference assembly, and **-refonly** specifies that only a reference assembly is to be output by compilation.</span></span>

## <a name="visual-basic-2017"></a><span data-ttu-id="7a701-167">Visual Basic 2017</span><span class="sxs-lookup"><span data-stu-id="7a701-167">Visual Basic 2017</span></span>

[<span data-ttu-id="7a701-168">**Krotki**</span><span class="sxs-lookup"><span data-stu-id="7a701-168">**Tuples**</span></span>](../programming-guide/language-features/data-types/tuples.md)

<span data-ttu-id="7a701-169">Krotki są prostą strukturą danych, najczęściej używaną do zwracania wielu wartości z pojedynczego wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="7a701-169">Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.</span></span> <span data-ttu-id="7a701-170">Zwykle, aby zwrócić wiele wartości z metody, należy wykonać jedną z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="7a701-170">Ordinarily, to return multiple values from a method, you have to do one of the following:</span></span>

- <span data-ttu-id="7a701-171">Zdefiniuj typ niestandardowy (a `Class` lub `Structure` ).</span><span class="sxs-lookup"><span data-stu-id="7a701-171">Define a custom type (a `Class` or a `Structure`).</span></span> <span data-ttu-id="7a701-172">Jest to bardzo ciężki rozwiązanie.</span><span class="sxs-lookup"><span data-stu-id="7a701-172">This is a heavyweight solution.</span></span>

- <span data-ttu-id="7a701-173">Zdefiniuj co najmniej jeden `ByRef` parametr, oprócz zwracania wartości z metody.</span><span class="sxs-lookup"><span data-stu-id="7a701-173">Define one or more `ByRef` parameters, in addition to returning a value from the method.</span></span>

<span data-ttu-id="7a701-174">Obsługa Visual Basic kroteks umożliwia szybkie Definiowanie krotek, opcjonalnie przypisanie nazw semantycznych do wartości i szybkie pobranie wartości.</span><span class="sxs-lookup"><span data-stu-id="7a701-174">Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.</span></span> <span data-ttu-id="7a701-175">Poniższy przykład otacza wywołanie <xref:System.Int32.TryParse%2A> metody i zwraca spójną krotkę.</span><span class="sxs-lookup"><span data-stu-id="7a701-175">The following example wraps a call to the <xref:System.Int32.TryParse%2A> method and returns a tuple.</span></span>

[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

<span data-ttu-id="7a701-176">Następnie można wywołać metodę i obsłużyć zwróconą krotkę z kodem podobnym do poniższego.</span><span class="sxs-lookup"><span data-stu-id="7a701-176">You can then call the method and handle the returned tuple with code like the following.</span></span>

[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)]

<span data-ttu-id="7a701-177">**Literały binarne i separatory cyfr**</span><span class="sxs-lookup"><span data-stu-id="7a701-177">**Binary literals and digit separators**</span></span>

<span data-ttu-id="7a701-178">Można zdefiniować literał binarny przy użyciu prefiksu `&B` lub `&b` .</span><span class="sxs-lookup"><span data-stu-id="7a701-178">You can define a binary literal by using the prefix `&B` or `&b`.</span></span> <span data-ttu-id="7a701-179">Ponadto można użyć znaku podkreślenia, `_` jako separatora cyfr, aby zwiększyć czytelność.</span><span class="sxs-lookup"><span data-stu-id="7a701-179">In addition, you can use the underscore character, `_`, as a digit separator to enhance readability.</span></span> <span data-ttu-id="7a701-180">Poniższy przykład używa obu funkcji do przypisywania `Byte` wartości i wyświetlania jej jako liczby dziesiętnej, szesnastkowej i binarnej.</span><span class="sxs-lookup"><span data-stu-id="7a701-180">The following example uses both features to assign a `Byte` value and to display it as a decimal, hexadecimal, and binary number.</span></span>

[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]

<span data-ttu-id="7a701-181">Aby uzyskać więcej informacji, zobacz sekcję "przypisania literałów" dla typów danych [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments) [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [UInteger —](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULONG](../language-reference/data-types/ulong-data-type.md#literal-assignments)i [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) .</span><span class="sxs-lookup"><span data-stu-id="7a701-181">For more information, see the "Literal assignments" section of the [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), and [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) data types.</span></span>

[<span data-ttu-id="7a701-182">**Obsługa wartości zwracanych odwołań języka C#**</span><span class="sxs-lookup"><span data-stu-id="7a701-182">**Support for C# reference return values**</span></span>](../programming-guide/language-features/procedures/ref-return-values.md)

<span data-ttu-id="7a701-183">Począwszy od języka C# 7,0, C# obsługuje wartości zwracane przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="7a701-183">Starting with C# 7.0, C# supports reference return values.</span></span> <span data-ttu-id="7a701-184">Oznacza to, że gdy metoda wywołująca otrzymuje wartość zwracaną przez odwołanie, może zmienić wartość odwołania.</span><span class="sxs-lookup"><span data-stu-id="7a701-184">That is, when the calling method receives a value returned by reference, it can change the value of the reference.</span></span> <span data-ttu-id="7a701-185">Visual Basic nie pozwala na tworzenie metod za pomocą zwracanych wartości, ale pozwala na używanie i modyfikowanie wartości zwracanych przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="7a701-185">Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.</span></span>

<span data-ttu-id="7a701-186">Na przykład następująca `Sentence` Klasa zapisywana w języku C# zawiera `FindNext` metodę, która umożliwia znalezienie następnego wyrazu w zdaniu rozpoczynającym się od określonego podciągu.</span><span class="sxs-lookup"><span data-stu-id="7a701-186">For example, the following `Sentence` class written in C# includes a `FindNext` method that finds the next word in a sentence that begins with a specified substring.</span></span> <span data-ttu-id="7a701-187">Ciąg jest zwracany jako wartość zwracana przez odwołanie, a `Boolean` zmienna przekazana przez odwołanie do metody wskazuje, czy wyszukiwanie zakończyło się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="7a701-187">The string is returned as a reference return value, and a `Boolean` variable passed by reference to the method indicates whether the search was successful.</span></span> <span data-ttu-id="7a701-188">Oznacza to, że oprócz odczytywania zwracanej wartości, obiekt wywołujący może również go zmodyfikować, a modyfikacja jest odzwierciedlona w `Sentence` klasie.</span><span class="sxs-lookup"><span data-stu-id="7a701-188">This means that in addition to reading the returned value, the caller can also modify it, and that modification is reflected in the `Sentence` class.</span></span>

[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]

<span data-ttu-id="7a701-189">W najprostszej postaci można modyfikować wyraz znaleziony w zdaniu przy użyciu kodu, takiego jak poniższy.</span><span class="sxs-lookup"><span data-stu-id="7a701-189">In its simplest form, you can modify the word found in the sentence by using code like the following.</span></span> <span data-ttu-id="7a701-190">Zwróć uwagę, że nie przypiszesz wartości do metody, ale zamiast wyrażenia zwracanego przez metodę, która jest wartością zwracaną przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="7a701-190">Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]

<span data-ttu-id="7a701-191">Wystąpił problem z tym kodem, chociaż jest to, że jeśli dopasowanie nie zostanie znalezione, metoda zwraca pierwszy wyraz.</span><span class="sxs-lookup"><span data-stu-id="7a701-191">A problem with this code, though, is that if a match is not found, the method returns the first word.</span></span> <span data-ttu-id="7a701-192">Ponieważ przykład nie sprawdza wartości `Boolean` argumentu, aby określić, czy dopasowanie zostanie znalezione, modyfikuje pierwsze słowo, jeśli nie ma żadnego dopasowania.</span><span class="sxs-lookup"><span data-stu-id="7a701-192">Since the example does not examine the value of the `Boolean` argument to determine whether a match is found, it modifies the first word if there is no match.</span></span> <span data-ttu-id="7a701-193">Poniższy przykład rozwiązuje ten problem, zastępując pierwszy wyraz własnym, jeśli nie ma żadnego dopasowania.</span><span class="sxs-lookup"><span data-stu-id="7a701-193">The following example corrects this by replacing the first word with itself if there is no match.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]

<span data-ttu-id="7a701-194">Lepszym rozwiązaniem jest użycie metody pomocnika, do której jest przenoszona wartość zwracana odwołania przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="7a701-194">A better solution is to use a helper method to which the reference return value is passed by reference.</span></span> <span data-ttu-id="7a701-195">Metoda pomocnika może następnie zmodyfikować argument przesłany do niego przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="7a701-195">The helper method can then modify the argument passed to it by reference.</span></span> <span data-ttu-id="7a701-196">W poniższym przykładzie jest to.</span><span class="sxs-lookup"><span data-stu-id="7a701-196">The following example does that.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]

<span data-ttu-id="7a701-197">Aby uzyskać więcej informacji, zobacz [odwołania do zwracanych wartości](../programming-guide/language-features/procedures/ref-return-values.md).</span><span class="sxs-lookup"><span data-stu-id="7a701-197">For more information, see [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md).</span></span>

## <a name="visual-basic-14"></a><span data-ttu-id="7a701-198">Visual Basic 14</span><span class="sxs-lookup"><span data-stu-id="7a701-198">Visual Basic 14</span></span>

[<span data-ttu-id="7a701-199">NameOf</span><span class="sxs-lookup"><span data-stu-id="7a701-199">NameOf</span></span>](../language-reference/operators/nameof.md)

<span data-ttu-id="7a701-200">Można uzyskać niekwalifikowaną nazwę ciągu typu lub składowej, która ma być używana w komunikacie o błędzie bez twardego kodowania ciągu.</span><span class="sxs-lookup"><span data-stu-id="7a701-200">You can get the unqualified string name of a type or member for use in an error message without hard coding a string.</span></span>  <span data-ttu-id="7a701-201">Dzięki temu kod może pozostawać poprawny podczas refaktoryzacji.</span><span class="sxs-lookup"><span data-stu-id="7a701-201">This allows your code to remain correct when refactoring.</span></span>  <span data-ttu-id="7a701-202">Ta funkcja jest również przydatna w przypadku podłączania linków modelu MVC i kontrolera widoku oraz wyzwalania zdarzeń ze zmienionymi właściwościami.</span><span class="sxs-lookup"><span data-stu-id="7a701-202">This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.</span></span>

[<span data-ttu-id="7a701-203">Interpolacja ciągów</span><span class="sxs-lookup"><span data-stu-id="7a701-203">String interpolation</span></span>](../programming-guide/language-features/strings/interpolated-strings.md)

<span data-ttu-id="7a701-204">Do konstruowania ciągów można użyć wyrażeń interpolacji ciągów.</span><span class="sxs-lookup"><span data-stu-id="7a701-204">You can use string interpolation expressions to construct strings.</span></span>  <span data-ttu-id="7a701-205">Wyrażenie interpolowane ciąg wygląda jak ciąg szablonu, który zawiera wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="7a701-205">An interpolated string expression looks like a template string that contains expressions.</span></span>  <span data-ttu-id="7a701-206">Ciąg interpolowany jest łatwiejszy do zrozumienia w odniesieniu do argumentów niż [formatowanie złożone](../../standard/base-types/composite-formatting.md).</span><span class="sxs-lookup"><span data-stu-id="7a701-206">An interpolated string is easier to understand with respect to arguments than [Composite Formatting](../../standard/base-types/composite-formatting.md).</span></span>

[<span data-ttu-id="7a701-207">Dostęp warunkowy do elementu członkowskiego o wartości null i indeksowanie</span><span class="sxs-lookup"><span data-stu-id="7a701-207">Null-conditional member access and indexing</span></span>](../language-reference/operators/null-conditional-operators.md)

<span data-ttu-id="7a701-208">Można testować pod kątem wartości null w bardzo jasny sposób składni przed wykonaniem operacji dostępu do elementu członkowskiego ( `?.` ) lub indeksu ( `?[]` ).</span><span class="sxs-lookup"><span data-stu-id="7a701-208">You can test for null in a very light syntactic way before performing a member access (`?.`) or index (`?[]`) operation.</span></span>  <span data-ttu-id="7a701-209">Te operatory pomagają pisać mniej kodu do obsługi kontroli wartości null, szczególnie w przypadku malejących struktur danych.</span><span class="sxs-lookup"><span data-stu-id="7a701-209">These operators help you write less code to handle null checks, especially for descending into data structures.</span></span>  <span data-ttu-id="7a701-210">Jeśli lewy operand lub odwołanie do obiektu ma wartość null, operacje zwracają wartość null.</span><span class="sxs-lookup"><span data-stu-id="7a701-210">If the left operand or object reference is null, the operations returns null.</span></span>

[<span data-ttu-id="7a701-211">Wielowierszowe literały ciągów</span><span class="sxs-lookup"><span data-stu-id="7a701-211">Multi-line string literals</span></span>](../programming-guide/language-features/strings/string-basics.md)

<span data-ttu-id="7a701-212">Literały ciągu mogą zawierać sekwencje nowego wiersza.</span><span class="sxs-lookup"><span data-stu-id="7a701-212">String literals can contain newline sequences.</span></span>  <span data-ttu-id="7a701-213">Nie potrzebujesz już starego obejścia z używania`<xml><![CDATA[...text with newlines...]]></xml>.Value`</span><span class="sxs-lookup"><span data-stu-id="7a701-213">You no longer need the old work around of using `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span></span>

<span data-ttu-id="7a701-214">**Komentarze**</span><span class="sxs-lookup"><span data-stu-id="7a701-214">**Comments**</span></span>

<span data-ttu-id="7a701-215">Komentarze można umieszczać po niejawnej kontynuacji wierszy, wewnątrz wyrażeń inicjatora i wśród postanowień wyrażenia LINQ.</span><span class="sxs-lookup"><span data-stu-id="7a701-215">You can put comments after implicit line continuations, inside initializer expressions, and among LINQ expression terms.</span></span>

<span data-ttu-id="7a701-216">**Inteligentniejsze w pełni kwalifikowane rozpoznawanie nazw**</span><span class="sxs-lookup"><span data-stu-id="7a701-216">**Smarter fully-qualified name resolution**</span></span>

<span data-ttu-id="7a701-217">Podany kod, taki jak `Threading.Thread.Sleep(1000)` , Visual Basic używany do wyszukiwania przestrzeni nazw "Threading", odkrywał, że był niejednoznaczny między system. Threading i system. Windows. Threading, a następnie zgłasza błąd.</span><span class="sxs-lookup"><span data-stu-id="7a701-217">Given code such as `Threading.Thread.Sleep(1000)`, Visual Basic used to look up the namespace "Threading", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.</span></span>  <span data-ttu-id="7a701-218">Visual Basic teraz traktuje jednocześnie wszystkie możliwe przestrzenie nazw.</span><span class="sxs-lookup"><span data-stu-id="7a701-218">Visual Basic now considers both possible namespaces together.</span></span>  <span data-ttu-id="7a701-219">Jeśli zostanie wyświetlona lista uzupełniania, Edytor programu Visual Studio Wyświetla listę członków z obu typów na liście uzupełniania.</span><span class="sxs-lookup"><span data-stu-id="7a701-219">If you show the completion list, the Visual Studio editor lists members from both types in the completion list.</span></span>

<span data-ttu-id="7a701-220">**Literały daty od początku roku**</span><span class="sxs-lookup"><span data-stu-id="7a701-220">**Year-first date literals**</span></span>

<span data-ttu-id="7a701-221">Możesz mieć literały dat w formacie RRRR-MM-DD `#2015-03-17 16:10 PM#` .</span><span class="sxs-lookup"><span data-stu-id="7a701-221">You can have date literals in yyyy-mm-dd format, `#2015-03-17 16:10 PM#`.</span></span>

<span data-ttu-id="7a701-222">**Właściwości interfejsu tylko do odczytu**</span><span class="sxs-lookup"><span data-stu-id="7a701-222">**Readonly interface properties**</span></span>

<span data-ttu-id="7a701-223">Właściwości interfejsu ReadOnly można zaimplementować przy użyciu właściwości ReadWrite.</span><span class="sxs-lookup"><span data-stu-id="7a701-223">You can implement readonly interface properties using a readwrite property.</span></span> <span data-ttu-id="7a701-224">Interfejs gwarantuje minimalną funkcjonalność i nie zatrzymuje klasy implementującej, umożliwiając ustawienie właściwości.</span><span class="sxs-lookup"><span data-stu-id="7a701-224">The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.</span></span>

[<span data-ttu-id="7a701-225">\<expr>IsNot typeof\<type></span><span class="sxs-lookup"><span data-stu-id="7a701-225">TypeOf \<expr> IsNot \<type></span></span>](../language-reference/operators/typeof-operator.md)

<span data-ttu-id="7a701-226">Aby zwiększyć czytelność kodu, można teraz użyć `TypeOf` programu z `IsNot` .</span><span class="sxs-lookup"><span data-stu-id="7a701-226">For more readability of your code, you can now use `TypeOf` with `IsNot`.</span></span>

[<span data-ttu-id="7a701-227">Ostrzeżenie #Disable \<ID> i #Enable\<ID></span><span class="sxs-lookup"><span data-stu-id="7a701-227">#Disable Warning \<ID> and #Enable Warning \<ID></span></span>](../language-reference/directives/index.md)

<span data-ttu-id="7a701-228">Można wyłączyć i włączyć określone ostrzeżenia dla regionów w pliku źródłowym.</span><span class="sxs-lookup"><span data-stu-id="7a701-228">You can disable and enable specific warnings for regions within a source file.</span></span>

<span data-ttu-id="7a701-229">**Ulepszenia komentarzy w dokumencie XML**</span><span class="sxs-lookup"><span data-stu-id="7a701-229">**XML doc comment improvements**</span></span>

<span data-ttu-id="7a701-230">Podczas pisania komentarzy do dokumentu uzyskasz Inteligentny edytor i kompilację do walidacji nazw parametrów, prawidłowej obsługi `crefs` (typów ogólnych, operatorów itp.), kolorowania i refaktoryzacji.</span><span class="sxs-lookup"><span data-stu-id="7a701-230">When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of `crefs` (generics, operators, etc.), colorizing, and refactoring.</span></span>

[<span data-ttu-id="7a701-231">Częściowe definicje modułów i interfejsów</span><span class="sxs-lookup"><span data-stu-id="7a701-231">Partial module and interface definitions</span></span>](../language-reference/modifiers/partial.md)

<span data-ttu-id="7a701-232">Oprócz klas i struktur można zadeklarować częściowe moduły i interfejsy.</span><span class="sxs-lookup"><span data-stu-id="7a701-232">In addition to classes and structs, you can declare partial modules and interfaces.</span></span>

[<span data-ttu-id="7a701-233">Dyrektywy #Region wewnątrz treści metod</span><span class="sxs-lookup"><span data-stu-id="7a701-233">#Region directives inside method bodies</span></span>](../language-reference/directives/region-directive.md)

<span data-ttu-id="7a701-234">Można umieścić #Region... #End ograniczników regionów w dowolnym miejscu w pliku, wewnątrz funkcji, a nawet w obrębie treści funkcji.</span><span class="sxs-lookup"><span data-stu-id="7a701-234">You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.</span></span>

[<span data-ttu-id="7a701-235">Definicje zastąpień są niejawnie przeciążeń</span><span class="sxs-lookup"><span data-stu-id="7a701-235">Overrides definitions are implicitly overloads</span></span>](../language-reference/modifiers/overrides.md)

<span data-ttu-id="7a701-236">Jeśli dodasz `Overrides` modyfikator do definicji, kompilator niejawnie doda, `Overloads` tak aby można było wpisać mniej kodu w typowych przypadkach.</span><span class="sxs-lookup"><span data-stu-id="7a701-236">If you add the `Overrides` modifier to a definition, the compiler implicitly adds `Overloads` so that you can type less code in common cases.</span></span>

<span data-ttu-id="7a701-237">**CObj dozwolone w argumentach atrybutów**</span><span class="sxs-lookup"><span data-stu-id="7a701-237">**CObj allowed in attributes arguments**</span></span>

<span data-ttu-id="7a701-238">Kompilator używany do wydawania błędu, który CObj (...) nie był stałą, gdy jest używany w konstrukcjach atrybutu.</span><span class="sxs-lookup"><span data-stu-id="7a701-238">The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.</span></span>

<span data-ttu-id="7a701-239">**Deklarowanie i używanie niejednoznacznych metod z różnych interfejsów**</span><span class="sxs-lookup"><span data-stu-id="7a701-239">**Declaring and consuming ambiguous methods from different interfaces**</span></span>

<span data-ttu-id="7a701-240">Wcześniej Poniższy kod zgłosił błędy, które uniemożliwiły zadeklarowanie `IMock` lub wywołanie `GetDetails` (jeśli zostały zadeklarowane w języku C#):</span><span class="sxs-lookup"><span data-stu-id="7a701-240">Previously the following code yielded errors that prevented you from declaring `IMock` or from calling `GetDetails` (if these had been declared in C#):</span></span>

```vb
Interface ICustomer
  Sub GetDetails(x As Integer)
End Interface

Interface ITime
  Sub GetDetails(x As String)
End Interface

Interface IMock : Inherits ICustomer, ITime
  Overloads Sub GetDetails(x As Char)
End Interface

Interface IMock2 : Inherits ICustomer, ITime
End Interface
```

<span data-ttu-id="7a701-241">Teraz kompilator będzie używać normalnych reguł rozpoznawania przeciążenia, aby wybrać najbardziej odpowiednie `GetDetails` do wywołania i można zadeklarować relacje interfejsu w Visual Basic jak te, które przedstawiono w przykładzie.</span><span class="sxs-lookup"><span data-stu-id="7a701-241">Now the compiler will use normal overload resolution rules to choose the most appropriate `GetDetails` to call, and you can declare interface relationships in Visual Basic like those shown in the sample.</span></span>

## <a name="see-also"></a><span data-ttu-id="7a701-242">Zobacz też</span><span class="sxs-lookup"><span data-stu-id="7a701-242">See also</span></span>

- [<span data-ttu-id="7a701-243">Co nowego w programie Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="7a701-243">What's New in Visual Studio 2017</span></span>](/visualstudio/ide/whats-new-visual-studio-2017)
- [<span data-ttu-id="7a701-244">Co nowego w programie Visual Studio 2019</span><span class="sxs-lookup"><span data-stu-id="7a701-244">What's New in Visual Studio 2019</span></span>](/visualstudio/ide/whats-new-visual-studio-2019)
