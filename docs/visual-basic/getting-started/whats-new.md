---
title: Co nowego w języku Visual Basic
ms.date: 10/24/2018
f1_keywords:
- VB.StartPage.WhatsNew
helpviewer_keywords:
- new features, Visual Basic
- what's new [Visual Basic]
- Visual Basic, what's new
ms.assetid: d7e97396-7f42-4873-a81c-4ebcc4b6ca02
ms.openlocfilehash: 7a676981a090d0ac02c1a1af4b0824d914d1e8fc
ms.sourcegitcommit: bce0586f0cccaae6d6cbd625d5a7b824d1d3de4b
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/02/2019
ms.locfileid: "58814019"
---
# <a name="whats-new-for-visual-basic"></a><span data-ttu-id="a4d59-102">Co nowego w języku Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a4d59-102">What's new for Visual Basic</span></span>

<span data-ttu-id="a4d59-103">Ten temat zawiera listę nazw funkcji klucza dla każdej wersji programu Visual Basic z szczegółowe opisy nowych i ulepszonych funkcji w najnowszych wersjach języka.</span><span class="sxs-lookup"><span data-stu-id="a4d59-103">This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the latest versions of the language.</span></span>
  
## <a name="current-version"></a><span data-ttu-id="a4d59-104">Bieżąca wersja</span><span class="sxs-lookup"><span data-stu-id="a4d59-104">Current version</span></span>

<span data-ttu-id="a4d59-105">Visual Basic należy zachować 15,8 / Visual Studio 2017 w wersji 15.8</span><span class="sxs-lookup"><span data-stu-id="a4d59-105">Visual Basic 15.8 / Visual Studio 2017 Version 15.8</span></span>  
<span data-ttu-id="a4d59-106">W przypadku nowych funkcji, zobacz [15.8 Visual Basic](#visual-basic-158)</span><span class="sxs-lookup"><span data-stu-id="a4d59-106">For new features, see [Visual Basic 15.8](#visual-basic-158)</span></span>

## <a name="previous-versions"></a><span data-ttu-id="a4d59-107">Poprzednie wersje</span><span class="sxs-lookup"><span data-stu-id="a4d59-107">Previous versions</span></span>

<span data-ttu-id="a4d59-108">Visual Basic 15.5 / Visual Studio 2017 w wersji 15.5</span><span class="sxs-lookup"><span data-stu-id="a4d59-108">Visual Basic 15.5 / Visual Studio 2017 Version 15.5</span></span>  
<span data-ttu-id="a4d59-109">Aby przejrzeć nowe funcje, zobacz [Visual Basic 15.5](#visual-basic-155)</span><span class="sxs-lookup"><span data-stu-id="a4d59-109">For new features, see [Visual Basic 15.5](#visual-basic-155)</span></span>

<span data-ttu-id="a4d59-110">Visual Basic 15.3 / Visual Studio 2017 w wersji 15.3</span><span class="sxs-lookup"><span data-stu-id="a4d59-110">Visual Basic 15.3 / Visual Studio 2017 Version 15.3</span></span>  
<span data-ttu-id="a4d59-111">Aby przejrzeć nowe funkcje, zobacz [Visual Basic 15.3](#visual-basic-153)</span><span class="sxs-lookup"><span data-stu-id="a4d59-111">For new features, see [Visual Basic 15.3](#visual-basic-153)</span></span>

<span data-ttu-id="a4d59-112">Visual Basic 2017 / Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="a4d59-112">Visual Basic 2017 / Visual Studio 2017</span></span>  
<span data-ttu-id="a4d59-113">Aby przejrzeć nowe funkcje, zobacz [Visual Basic 2017](#visual-basic-2017)</span><span class="sxs-lookup"><span data-stu-id="a4d59-113">For new features, see [Visual Basic 2017](#visual-basic-2017)</span></span>

<span data-ttu-id="a4d59-114">Visual Basic / Visual Studio 2015</span><span class="sxs-lookup"><span data-stu-id="a4d59-114">Visual Basic / Visual Studio 2015</span></span>   
<span data-ttu-id="a4d59-115">Aby przejrzeć nowe funkcje, zobacz [Visual Basic 14](#visual-basic-14)</span><span class="sxs-lookup"><span data-stu-id="a4d59-115">For new features, see [Visual Basic 14](#visual-basic-14)</span></span>

<span data-ttu-id="a4d59-116">Visual Basic / Visual Studio 2013</span><span class="sxs-lookup"><span data-stu-id="a4d59-116">Visual Basic / Visual Studio 2013</span></span>  
<span data-ttu-id="a4d59-117">Wersje zapoznawcze technologii platformy kompilatora .NET ("Roslyn")</span><span class="sxs-lookup"><span data-stu-id="a4d59-117">Technology previews of the .NET Compiler Platform (“Roslyn”)</span></span>

<span data-ttu-id="a4d59-118">Visual Basic / Visual Studio 2012</span><span class="sxs-lookup"><span data-stu-id="a4d59-118">Visual Basic / Visual Studio 2012</span></span>   
<span data-ttu-id="a4d59-119">Słowa kluczowe `Async` i `await`, iteratory, atrybuty informacji obiektów wywołujących</span><span class="sxs-lookup"><span data-stu-id="a4d59-119">`Async` and `await` keywords, iterators, caller info attributes</span></span>

<span data-ttu-id="a4d59-120">Visual Basic, Visual Studio 2010</span><span class="sxs-lookup"><span data-stu-id="a4d59-120">Visual Basic, Visual Studio 2010</span></span>   
<span data-ttu-id="a4d59-121">Właściwości zaimplementowane automatycznie, inicjatory kolekcji, niejawnej kontynuacji wiersza, dynamiczne, ogólna Company/ma przeciwwskazań wariancji, dostęp do globalnej przestrzeni nazw</span><span class="sxs-lookup"><span data-stu-id="a4d59-121">Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access</span></span>

<span data-ttu-id="a4d59-122">Visual Basic / Visual Studio 2008</span><span class="sxs-lookup"><span data-stu-id="a4d59-122">Visual Basic / Visual Studio 2008</span></span>   
<span data-ttu-id="a4d59-123">Language Integrated Query (LINQ), literałów XML, wnioskowanie o typie lokalnym, obiekt inicjatorów, typów anonimowych, metody rozszerzające, lokalnego `var` wnioskowanie, wyrażeń lambda, typu `if` operatora, metod częściowych, typy o wartości zerowalnej</span><span class="sxs-lookup"><span data-stu-id="a4d59-123">Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local `var` type inference, lambda expressions, `if` operator, partial methods, nullable value types</span></span>  

<span data-ttu-id="a4d59-124">Visual Basic / Visual Studio 2005</span><span class="sxs-lookup"><span data-stu-id="a4d59-124">Visual Basic / Visual Studio 2005</span></span>   
<span data-ttu-id="a4d59-125">`My` Typu i pomocnika typów (dostęp do aplikacji, komputer, system plików, użycia sieci)</span><span class="sxs-lookup"><span data-stu-id="a4d59-125">The `My` type and helper types (access to app, computer, files system, network)</span></span>

<span data-ttu-id="a4d59-126">Visual Basic / Visual Studio .NET 2003</span><span class="sxs-lookup"><span data-stu-id="a4d59-126">Visual Basic / Visual Studio .NET 2003</span></span>   
<span data-ttu-id="a4d59-127">Operatory przesunięcia bitowego, deklaracja zmiennej pętli</span><span class="sxs-lookup"><span data-stu-id="a4d59-127">Bit-shift operators, loop variable declaration</span></span>

<span data-ttu-id="a4d59-128">Visual Basic / Visual Studio .NET 2002</span><span class="sxs-lookup"><span data-stu-id="a4d59-128">Visual Basic / Visual Studio .NET 2002</span></span>   
<span data-ttu-id="a4d59-129">Pierwsze wydanie programu Visual Basic .NET</span><span class="sxs-lookup"><span data-stu-id="a4d59-129">The first release of Visual Basic .NET</span></span>

## <a name="visual-basic-158"></a><span data-ttu-id="a4d59-130">Visual Basic 15.8</span><span class="sxs-lookup"><span data-stu-id="a4d59-130">Visual Basic 15.8</span></span>

<span data-ttu-id="a4d59-131">**Zoptymalizowane pod kątem zmiennoprzecinkowych, konwersja liczby całkowitej**</span><span class="sxs-lookup"><span data-stu-id="a4d59-131">**Optimized floating-point to integer conversion**</span></span>

<span data-ttu-id="a4d59-132">W poprzednich wersjach programu Visual Basic, konwersja [Double](../language-reference/data-types/double-data-type.md) i [pojedynczego](../language-reference/data-types/single-data-type.md) wartości liczb całkowitych oferowane stosunkowo niska wydajność.</span><span class="sxs-lookup"><span data-stu-id="a4d59-132">In previous versions of Visual Basic, conversion of [Double](../language-reference/data-types/double-data-type.md) and [Single](../language-reference/data-types/single-data-type.md) values to integers offered relatively poor performance.</span></span> <span data-ttu-id="a4d59-133">Podczas przekazywania wartości zwracanej przez dowolny z następujących metod do jednego z 15.8 Visual Basic znacznie zwiększa wydajność konwersje zmiennoprzecinkowe do liczb całkowitych [funkcje wewnętrzne konwersji liczby całkowitej w Visual Basic](../language-reference/functions/type-conversion-functions.md) () CByte CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng), lub kiedy wartość zwracana przez dowolny z następujących metod jest niejawnie rzutowany na całkowite wpisz kiedy [Option Strict](~/docs/visual-basic/language-reference/statements/option-strict-statement.md) ustawiono `Off`:</span><span class="sxs-lookup"><span data-stu-id="a4d59-133">Visual Basic 15.8 significantly enhances the performance of floating-point conversions to integers when you pass the value returned by any of the following methods to one of the [intrinsic Visual Basic integer conversion functions](../language-reference/functions/type-conversion-functions.md) (CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng), or when the value returned by any of the following methods is implicitly cast to an integral type when [Option Strict](~/docs/visual-basic/language-reference/statements/option-strict-statement.md) is set to `Off`:</span></span>

- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Single)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Single)?displayProperty=nameWithType>
- <xref:System.Math.Ceiling(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Floor(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Round(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Truncate(System.Double)?displayProperty=nameWithType>

<span data-ttu-id="a4d59-134">Tego rodzaju optymalizacji umożliwia kod wymagany do uruchomienia szybciej — maksymalnie dwa razy, jak szybko uzyskać kod, który obsługuje dużą liczbę konwersji na typy liczb całkowitych.</span><span class="sxs-lookup"><span data-stu-id="a4d59-134">This optimization allows code to run faster -- up to twice as fast for code that does a large number of conversions to integer types.</span></span> <span data-ttu-id="a4d59-135">W poniższym przykładzie pokazano niektóre wywołania prosta metoda, które dotyczą tego rodzaju optymalizacji:</span><span class="sxs-lookup"><span data-stu-id="a4d59-135">The following example illustrates some simple method calls that are affected by this optimization:</span></span>

```vb
Dim s As Single = 173.7619
Dim d As Double = s 

Dim i1 As Integer = CInt(Fix(s))               ' Result: 173
Dim b1 As Byte = CByte(Int(d))                 ' Result: 173
Dim s1 AS Short = CShort(Math.Truncate(s))     ' Result: 173
Dim i2 As Integer = CInt(Math.Ceiling(d))      ' Result: 174
Dim i3 As Integer = CInt(Math.Round(s))        ' Result: 174

```

<span data-ttu-id="a4d59-136">Należy zwrócić uwagę na to, czy jest to obcina zamiast wartości zmiennoprzecinkowych Zaokrągla liczbę.</span><span class="sxs-lookup"><span data-stu-id="a4d59-136">Note that this truncates rather than rounds floating-point values.</span></span>

## <a name="visual-basic-155"></a><span data-ttu-id="a4d59-137">Visual Basic 15.5</span><span class="sxs-lookup"><span data-stu-id="a4d59-137">Visual Basic 15.5</span></span>

[<span data-ttu-id="a4d59-138">Argumenty nazwane inne niż końcowe</span><span class="sxs-lookup"><span data-stu-id="a4d59-138">Non-trailing named arguments</span></span>](../programming-guide/language-features/procedures/passing-arguments-by-position-and-by-name.md#mixing-arguments-by-position-and-by-name)

<span data-ttu-id="a4d59-139">W wersji Visual Basic 15.3 i starszych wersjach gdy wywołanie metody uwzględniało argumenty zarówno według pozycji, jak i według nazwy, argumenty pozycyjne musiały poprzedzać argumenty nazwane.</span><span class="sxs-lookup"><span data-stu-id="a4d59-139">In Visual Basic 15.3 and earlier versions, when a method call included arguments both by position and by name, positional arguments had to precede named arguments.</span></span> <span data-ttu-id="a4d59-140">W wersji Visual Basic 15.5 i nowszych argumenty pozycyjne i argumenty nazwane mogą występować w dowolnej kolejności, pod warunkiem że wszystkie argumenty (do ostatniego argumentu pozycyjnego) znajdują się we właściwych pozycjach.</span><span class="sxs-lookup"><span data-stu-id="a4d59-140">Starting with Visual Basic 15.5, positional and named arguments can appear in any order as long as all arguments up to the last positional argument are in the correct position.</span></span> <span data-ttu-id="a4d59-141">Jest to szczególnie przydatne, gdy argumenty nazwane są stosowane w celu poprawy czytelności kodu.
</span><span class="sxs-lookup"><span data-stu-id="a4d59-141">This is particularly useful when named arguments are used to make code more readable.</span></span>

<span data-ttu-id="a4d59-142">Na przykład następujące wywołanie metody ma dwa argumenty pozycyjne, między argumentu nazwanego.</span><span class="sxs-lookup"><span data-stu-id="a4d59-142">For example, the following method call has two positional arguments between a named argument.</span></span> <span data-ttu-id="a4d59-143">Argument nazwany sprawia, że wyczyść wiek reprezentowany przez wartość 19.</span><span class="sxs-lookup"><span data-stu-id="a4d59-143">The named argument makes it clear that the value 19 represents an age.</span></span>

```vb
StudentInfo.Display("Mary", age:=19, #9/21/1998#)
```

[<span data-ttu-id="a4d59-144">`Private Protected` Modyfikator dostępu elementu członkowskiego</span><span class="sxs-lookup"><span data-stu-id="a4d59-144">`Private Protected` member access modifier</span></span>](../language-reference/modifiers/private-protected.md)

<span data-ttu-id="a4d59-145">Ta nowa kombinacja — słowo kluczowe definiuje element członkowski, który jest dostępny, wszystkie elementy członkowskie w swojej klasie zawierający, a także typów pochodnych typu zawierającego klasy, ale tylko wtedy, gdy są one również znajdują się w zawierające zestaw.</span><span class="sxs-lookup"><span data-stu-id="a4d59-145">This new keyword combination defines a member that is accessible by all members in its containing class as well as by types derived from the containing class, but only if they are also found in the containing assembly.</span></span> <span data-ttu-id="a4d59-146">Ponieważ struktury nie może być dziedziczona, `Private Protected` może być stosowany tylko do składowych klasy.</span><span class="sxs-lookup"><span data-stu-id="a4d59-146">Because structures cannot be inherited, `Private Protected` can only be applied to the members of a class.</span></span>

<span data-ttu-id="a4d59-147">**Wiodący znak separatora szesnastkowy/binarny/ósemkowy**</span><span class="sxs-lookup"><span data-stu-id="a4d59-147">**Leading hex/binary/octal separator**</span></span>

<span data-ttu-id="a4d59-148">W wersji +Visual Basic 2017 dodano obsługę znaku podkreślenia (`_`) jako separatora cyfr.</span><span class="sxs-lookup"><span data-stu-id="a4d59-148">Visual Basic 2017 added support for the underscore character (`_`) as a digit separator.</span></span> <span data-ttu-id="a4d59-149">Począwszy od wersji Visual Basic 15.5, można używać znaku podkreślenia jako separatora wiodącego między prefiksem a cyframi szesnastkowymi, binarnymi lub ósemkowymi.</span><span class="sxs-lookup"><span data-stu-id="a4d59-149">Starting with Visual Basic 15.5, you can use the underscore character as a leading separator between the prefix and hexadecimal, binary, or octal digits.</span></span> <span data-ttu-id="a4d59-150">W poniższym przykładzie użyto separatora wiodącego cyfr, aby zdefiniować liczbę 3 271 948 384 w postaci szesnastkowej:</span><span class="sxs-lookup"><span data-stu-id="a4d59-150">The following example uses a leading digit separator to define 3,271,948,384 as a hexadecimal number:</span></span>

```vb
Dim number As Integer = &H_C305_F860
``` 
<span data-ttu-id="a4d59-151">Aby użyć znaku podkreślenia jako separatora wiodącego, należy dodać następujący element do pliku projektu Visual Basic (\*.vbproj):</span><span class="sxs-lookup"><span data-stu-id="a4d59-151">To use the underscore character as a leading separator, you must add the following element to your Visual Basic project (\*.vbproj) file:</span></span>

```xml
<PropertyGroup>
  <LangVersion>15.5</LangVersion>
</PropertyGroup>
```

## <a name="visual-basic-153"></a><span data-ttu-id="a4d59-152">Visual Basic 15.3</span><span class="sxs-lookup"><span data-stu-id="a4d59-152">Visual Basic 15.3</span></span>

[<span data-ttu-id="a4d59-153">**Wnioskowanie o nazwie krotki**</span><span class="sxs-lookup"><span data-stu-id="a4d59-153">**Named tuple inference**</span></span>](../programming-guide/language-features/data-types/tuples.md#inferred-tuple-element-names)

<span data-ttu-id="a4d59-154">Gdy przypiszesz wartość elementów krotki ze zmiennych, Visual Basic wnioskuje nazwy elementów krotki z odpowiedniej nazwy zmiennych; nie trzeba jawnie nazwa elementu krotki.</span><span class="sxs-lookup"><span data-stu-id="a4d59-154">When you assign the value of tuple elements from variables, Visual Basic infers the name of tuple elements from the corresponding variable names; you do not have to explicitly name a tuple element.</span></span> <span data-ttu-id="a4d59-155">W poniższym przykładzie użyto wnioskowania, aby utworzyć krotki o trzy elementy o nazwie, `state`, `stateName`, i `capital`.</span><span class="sxs-lookup"><span data-stu-id="a4d59-155">The following example uses inference to create a tuple with three named elements, `state`, `stateName`, and `capital`.</span></span>

[!code-vb[Inferred tuple names](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

<span data-ttu-id="a4d59-156">**Dodatkowe przełączniki kompilatora**</span><span class="sxs-lookup"><span data-stu-id="a4d59-156">**Additional compiler switches**</span></span>  

<span data-ttu-id="a4d59-157">Visual Basic obsługuje teraz kompilatora wiersza polecenia [ **- opcji refout** ](../reference/command-line-compiler/refout-compiler-option.md) i [ **jest opcja refonly -** ](../reference/command-line-compiler/refonly-compiler-option.md) opcje kompilatora, aby kontrolować dane wyjściowe zestawy referencyjne.</span><span class="sxs-lookup"><span data-stu-id="a4d59-157">The Visual Basic command-line compiler now supports the [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) and [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) compiler options to control the output of reference assemblies.</span></span> <span data-ttu-id="a4d59-158">**-opcji refout** definiuje katalogu wyjściowego zestawu odwołania i **jest opcja refonly -** Określa, że zestaw odwołania na wyjściu przez kompilację.</span><span class="sxs-lookup"><span data-stu-id="a4d59-158">**-refout** defines the output directory of the reference assembly, and **-refonly** specifies that only a reference assembly is to be output by compilation.</span></span>

## <a name="visual-basic-2017"></a><span data-ttu-id="a4d59-159">2017 Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a4d59-159">Visual Basic 2017</span></span>

[<span data-ttu-id="a4d59-160">**Tuples**</span><span class="sxs-lookup"><span data-stu-id="a4d59-160">**Tuples**</span></span>](../programming-guide/language-features/data-types/tuples.md)

<span data-ttu-id="a4d59-161">Kolekcje są uproszczone danych struktury, które najczęściej umożliwia zwracanie wielu wartości z pojedynczym wywołaniu metody.</span><span class="sxs-lookup"><span data-stu-id="a4d59-161">Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.</span></span> <span data-ttu-id="a4d59-162">Zazwyczaj zwracanie wielu wartości z metody, należy wykonać jedną z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="a4d59-162">Ordinarily, to return multiple values from a method, you have to do one of the following:</span></span>

- <span data-ttu-id="a4d59-163">Definiowanie niestandardowego typu ( `Class` lub `Structure`).</span><span class="sxs-lookup"><span data-stu-id="a4d59-163">Define a custom type (a `Class` or a `Structure`).</span></span> <span data-ttu-id="a4d59-164">Jest to rozwiązanie niewielkich.</span><span class="sxs-lookup"><span data-stu-id="a4d59-164">This is a heavyweight solution.</span></span>

- <span data-ttu-id="a4d59-165">Definiują jedną lub więcej `ByRef` parametry oprócz zwracanie wartości z metody.</span><span class="sxs-lookup"><span data-stu-id="a4d59-165">Define one or more `ByRef` parameters, in addition to returning a value from the method.</span></span>
 
<span data-ttu-id="a4d59-166">Obsługa języka Visual Basic dla krotki pozwala szybko zdefiniować krotki, opcjonalnie przypisać nazwy semantycznego do jego wartości i szybko pobrać jego wartości.</span><span class="sxs-lookup"><span data-stu-id="a4d59-166">Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.</span></span> <span data-ttu-id="a4d59-167">Poniższy przykład zawija wywołanie do <xref:System.Int32.TryParse%2A> metodę i zwraca spójną kolekcję.</span><span class="sxs-lookup"><span data-stu-id="a4d59-167">The following example wraps a call to the <xref:System.Int32.TryParse%2A> method and returns a tuple.</span></span>

[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

<span data-ttu-id="a4d59-168">Można następnie wywołać metodę i obsługiwać zwracane spójna kolekcja znajdująca się z kodem, jak pokazano poniżej.</span><span class="sxs-lookup"><span data-stu-id="a4d59-168">You can then call the method and handle the returned tuple with code like the following.</span></span>

[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)] 

<span data-ttu-id="a4d59-169">**Literały binarne oraz separatory cyfr**</span><span class="sxs-lookup"><span data-stu-id="a4d59-169">**Binary literals and digit separators**</span></span>

<span data-ttu-id="a4d59-170">Plik binarny literału można zdefiniować przy użyciu prefiksu `&B` lub `&b`.</span><span class="sxs-lookup"><span data-stu-id="a4d59-170">You can define a binary literal by using the prefix `&B` or `&b`.</span></span> <span data-ttu-id="a4d59-171">Ponadto można użyć znaku podkreślenia `_`, jako separator cyfr w celu zwiększenia czytelności.</span><span class="sxs-lookup"><span data-stu-id="a4d59-171">In addition, you can use the underscore character, `_`, as a digit separator to enhance readability.</span></span> <span data-ttu-id="a4d59-172">W poniższym przykładzie użyto obu funkcji, aby przypisać `Byte` wartość i wyświetlić go jako liczbę dziesiętną, szesnastkowym i binarny.</span><span class="sxs-lookup"><span data-stu-id="a4d59-172">The following example uses both features to assign a `Byte` value and to display it as a decimal, hexadecimal, and binary number.</span></span>

[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]

<span data-ttu-id="a4d59-173">Aby uzyskać więcej informacji, zobacz sekcję "Przypisania literału" [bajtów](../language-reference/data-types/byte-data-type.md#literal-assignments), [całkowitą](../language-reference/data-types/integer-data-type.md#literal-assignments), [długie](../language-reference/data-types/long-data-type.md#literal-assignments), [krótki](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte ](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [Uinteger —](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), i [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) typów danych.</span><span class="sxs-lookup"><span data-stu-id="a4d59-173">For more information, see the "Literal assignments" section of the [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), and [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) data types.</span></span>

[<span data-ttu-id="a4d59-174">**Obsługa języka C# odwołanie zwracane wartości**</span><span class="sxs-lookup"><span data-stu-id="a4d59-174">**Support for C# reference return values**</span></span>](../programming-guide/language-features/procedures/ref-return-values.md)

<span data-ttu-id="a4d59-175">Począwszy od języka C# 7.0, C# obsługuje odwołanie zwracane wartości.</span><span class="sxs-lookup"><span data-stu-id="a4d59-175">Starting with C# 7.0, C# supports reference return values.</span></span> <span data-ttu-id="a4d59-176">Oznacza to, że podczas wywoływania metody otrzymuje wartości zwracane przez odwołanie, można zmienić wartości odwołania.</span><span class="sxs-lookup"><span data-stu-id="a4d59-176">That is, when the calling method receives a value returned by reference, it can change the value of the reference.</span></span> <span data-ttu-id="a4d59-177">Visual Basic nie umożliwia utworzenia metody z odwołaniem do wartości zwracane, ale pozwala korzystać i modyfikować wartości zwracane odwołanie.</span><span class="sxs-lookup"><span data-stu-id="a4d59-177">Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.</span></span>

<span data-ttu-id="a4d59-178">Na przykład następująca `Sentence` klasa napisane w języku C# zawiera `FindNext` metodę, która umożliwia znalezienie następnego wyrazu w zdaniu, zaczynającą się podanym podciągiem.</span><span class="sxs-lookup"><span data-stu-id="a4d59-178">For example, the following `Sentence` class written in C# includes a `FindNext` method that finds the next word in a sentence that begins with a specified substring.</span></span> <span data-ttu-id="a4d59-179">Ten ciąg jest zwracany jako wartość zwracana przez odwołanie, a `Boolean` zmiennej przekazywany przez odwołanie do metody wskazuje, czy wyszukiwanie zakończyło się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="a4d59-179">The string is returned as a reference return value, and a `Boolean` variable passed by reference to the method indicates whether the search was successful.</span></span> <span data-ttu-id="a4d59-180">Oznacza to, że wywołujący można nie tylko do odczytu zwrócona wartość; on również modyfikować go i modyfikacja tego znajduje odzwierciedlenie w `Sentence` klasy.</span><span class="sxs-lookup"><span data-stu-id="a4d59-180">This means that the caller can not only read the returned value; he or she can also modify it, and that modification is reflected in the `Sentence` class.</span></span>

[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]

<span data-ttu-id="a4d59-181">W najprostszej postaci można zmodyfikować wyraz znaleziony w zdaniu przy użyciu kodu, jak pokazano poniżej.</span><span class="sxs-lookup"><span data-stu-id="a4d59-181">In its simplest form, you can modify the word found in the sentence by using code like the following.</span></span> <span data-ttu-id="a4d59-182">Należy pamiętać, że nie przypisujesz wartość do metody, ale raczej do wyrażenia, metoda zwraca odwołanie jest zwracają wartość.</span><span class="sxs-lookup"><span data-stu-id="a4d59-182">Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]

<span data-ttu-id="a4d59-183">Problem z tym kodem jest jednak to, że jeśli nie zostanie znalezione dopasowanie, metoda zwraca pierwszy wyraz.</span><span class="sxs-lookup"><span data-stu-id="a4d59-183">A problem with this code, though, is that if a match is not found, the method returns the first word.</span></span> <span data-ttu-id="a4d59-184">Ponieważ przykładu nie analizuje wartość `Boolean` argumentu, aby ustalić, czy zostanie znalezione dopasowanie, modyfikuje pierwszy wyraz, jeśli nie ma dopasowania.</span><span class="sxs-lookup"><span data-stu-id="a4d59-184">Since the example does not examine the value of the `Boolean` argument to determine whether a match is found, it modifies the first word if there is no match.</span></span> <span data-ttu-id="a4d59-185">Poniższy przykład naprawia to przez zastąpienie pierwszy wyraz z samym sobą, jeśli nie ma dopasowania.</span><span class="sxs-lookup"><span data-stu-id="a4d59-185">The following example corrects this by replacing the first word with itself if there is no match.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]

<span data-ttu-id="a4d59-186">Lepszym rozwiązaniem jest użycie metody pomocnika, do której odwołanie wartość zwracana jest przekazywany przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="a4d59-186">A better solution is to use a helper method to which the reference return value is passed by reference.</span></span> <span data-ttu-id="a4d59-187">Metoda pomocnika, następnie można zmodyfikować argumentu przekazanego do niej przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="a4d59-187">The helper method can then modify the argument passed to it by reference.</span></span> <span data-ttu-id="a4d59-188">Poniższy przykład robi to.</span><span class="sxs-lookup"><span data-stu-id="a4d59-188">The following example does that.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]

<span data-ttu-id="a4d59-189">Aby uzyskać więcej informacji, zobacz [odwołania Return Values](../programming-guide/language-features/procedures/ref-return-values.md).</span><span class="sxs-lookup"><span data-stu-id="a4d59-189">For more information, see [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md).</span></span>

## <a name="visual-basic-14"></a><span data-ttu-id="a4d59-190">Visual Basic, 14</span><span class="sxs-lookup"><span data-stu-id="a4d59-190">Visual Basic 14</span></span>

[<span data-ttu-id="a4d59-191">Nameof</span><span class="sxs-lookup"><span data-stu-id="a4d59-191">Nameof</span></span>](../../csharp/language-reference/keywords/nameof.md)  
 <span data-ttu-id="a4d59-192">Można uzyskać nazwy niekwalifikowanej ciąg typu lub elementu członkowskiego do użytku w komunikacie o błędzie, bez twardych kodowanie ciągu.</span><span class="sxs-lookup"><span data-stu-id="a4d59-192">You can get the unqualified string name of a type or member for use in an error message without hard coding a string.</span></span>  <span data-ttu-id="a4d59-193">Dzięki temu kodzie zachować poprawne podczas refaktoryzacji.</span><span class="sxs-lookup"><span data-stu-id="a4d59-193">This allows your code to remain correct when refactoring.</span></span>  <span data-ttu-id="a4d59-194">Ta funkcja jest również przydatne w przypadku Podłączanie łącza MVC model-view-controller i wyzwalanie zdarzenia zmiany właściwości.</span><span class="sxs-lookup"><span data-stu-id="a4d59-194">This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.</span></span>  
  
[<span data-ttu-id="a4d59-195">Interpolacja ciągów</span><span class="sxs-lookup"><span data-stu-id="a4d59-195">String interpolation</span></span>](../../visual-basic/programming-guide/language-features/strings/interpolated-strings.md)  
 <span data-ttu-id="a4d59-196">Wyrażenie interpolacji ciągu służy do konstruowania ciągów.</span><span class="sxs-lookup"><span data-stu-id="a4d59-196">You can use string interpolation expressions to construct strings.</span></span>  <span data-ttu-id="a4d59-197">Wyrażenie ciągu interpolowanego wygląda jak ciąg szablonu, który zawiera wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="a4d59-197">An interpolated string expression looks like a template string that contains expressions.</span></span>  <span data-ttu-id="a4d59-198">Ciąg interpolowany łatwiej zrozumieć względem argumentów niż [formatowania złożonego](../../standard/base-types/composite-format.md).</span><span class="sxs-lookup"><span data-stu-id="a4d59-198">An interpolated string is easier to understand with respect to arguments than [Composite Formatting](../../standard/base-types/composite-format.md).</span></span>  
  
[<span data-ttu-id="a4d59-199">Dostęp do elementu członkowskiego warunkowe null i indeksowania</span><span class="sxs-lookup"><span data-stu-id="a4d59-199">Null-conditional member access and indexing</span></span>](../language-reference/operators/null-conditional-operators.md)  
<span data-ttu-id="a4d59-200">Możesz sprawdzić o wartości null w sposób bardzo małe, składni przed wykonaniem dostęp do elementu członkowskiego (`?.`) lub indeksu (`?[]`) operacji.</span><span class="sxs-lookup"><span data-stu-id="a4d59-200">You can test for null in a very light syntactic way before performing a member access (`?.`) or index (`?[]`) operation.</span></span>  <span data-ttu-id="a4d59-201">Operatory te pomagają ograniczyć ilość kodu potrzebnego do sprawdzenia wystąpień wartości „null”, zwłaszcza w przypadku wchodzenia głębiej w struktury danych.</span><span class="sxs-lookup"><span data-stu-id="a4d59-201">These operators help you write less code to handle null checks, especially for descending into data structures.</span></span>  <span data-ttu-id="a4d59-202">W przypadku o wartości null po lewej stronie operatora lub obiektu odwołania operacji zwraca wartość null.</span><span class="sxs-lookup"><span data-stu-id="a4d59-202">If the left operand or object reference is null, the operations returns null.</span></span>  
  
[<span data-ttu-id="a4d59-203">Literały ciągu wielowierszowy</span><span class="sxs-lookup"><span data-stu-id="a4d59-203">Multi-line string literals</span></span>](../../visual-basic/programming-guide/language-features/strings/string-basics.md)  
 <span data-ttu-id="a4d59-204">Literały ciągu może zawierać sekwencje nowego wiersza.</span><span class="sxs-lookup"><span data-stu-id="a4d59-204">String literals can contain newline sequences.</span></span>  <span data-ttu-id="a4d59-205">Możesz nie jest już konieczne starego obejść użycia `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span><span class="sxs-lookup"><span data-stu-id="a4d59-205">You no longer need the old work around of using `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span></span>  
  
<span data-ttu-id="a4d59-206">**Komentarze**</span><span class="sxs-lookup"><span data-stu-id="a4d59-206">**Comments**</span></span>  
<span data-ttu-id="a4d59-207">Po kontynuacji wiersza niejawne, wewnątrz wyrażenia inicjatora, a wśród warunki wyrażenia LINQ, można umieścić komentarze.</span><span class="sxs-lookup"><span data-stu-id="a4d59-207">You can put comments after implicit line continuations, inside initializer expressions, and among LINQ expression terms.</span></span>  
  
<span data-ttu-id="a4d59-208">**Inteligentniejsze rozwiązania w pełni kwalifikowana nazwa**</span><span class="sxs-lookup"><span data-stu-id="a4d59-208">**Smarter fully-qualified name resolution**</span></span>  
 <span data-ttu-id="a4d59-209">Podany kod taki jak `Threading.Thread.Sleep(1000)`, Visual Basic, używany do wyszukiwania przestrzeni nazw "Wątkowości" odnajdywanie było niejednoznaczne między System.Threading i System.Windows.Threading, a następnie zgłaszanie błędu.</span><span class="sxs-lookup"><span data-stu-id="a4d59-209">Given code such as `Threading.Thread.Sleep(1000)`, Visual Basic used to look up the namespace "Threading", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.</span></span>  <span data-ttu-id="a4d59-210">Visual Basic traktuje teraz zarówno możliwe przestrzenie nazw ze sobą.</span><span class="sxs-lookup"><span data-stu-id="a4d59-210">Visual Basic now considers both possible namespaces together.</span></span>  <span data-ttu-id="a4d59-211">Jeśli możesz wyświetlić na liście uzupełniania, Edytor programu Visual Studio Wyświetla listę elementów członkowskich z obu typów na liście uzupełniania.</span><span class="sxs-lookup"><span data-stu-id="a4d59-211">If you show the completion list, the Visual Studio editor lists members from both types in the completion list.</span></span>  
  
 <span data-ttu-id="a4d59-212">**Literały daty pierwszego roku**</span><span class="sxs-lookup"><span data-stu-id="a4d59-212">**Year-first date literals**</span></span>  
 <span data-ttu-id="a4d59-213">Masz literały daty w formacie rrrr mm-dd `#2015-03-17 16:10 PM#`.</span><span class="sxs-lookup"><span data-stu-id="a4d59-213">You can have date literals in yyyy-mm-dd format, `#2015-03-17 16:10 PM#`.</span></span>  
  
 <span data-ttu-id="a4d59-214">**Właściwości interfejsu tylko do odczytu**</span><span class="sxs-lookup"><span data-stu-id="a4d59-214">**Readonly interface properties**</span></span>  
 <span data-ttu-id="a4d59-215">Można zaimplementować tylko do odczytu właściwości interfejsu przy użyciu właściwości odczytu i zapisu.</span><span class="sxs-lookup"><span data-stu-id="a4d59-215">You can implement readonly interface properties using a readwrite property.</span></span>  <span data-ttu-id="a4d59-216">Interfejs gwarantuje minimalny zestaw funkcji, a nie zatrzymuje klasa implementująca z zezwalającej na właściwość należy ustawić.</span><span class="sxs-lookup"><span data-stu-id="a4d59-216">The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.</span></span>  
  
 [<span data-ttu-id="a4d59-217">TypeOf \<expr > IsNot \<typ ></span><span class="sxs-lookup"><span data-stu-id="a4d59-217">TypeOf \<expr> IsNot \<type></span></span>](../../visual-basic/language-reference/operators/typeof-operator.md)  
 <span data-ttu-id="a4d59-218">Aby uzyskać więcej czytelność kodu, można teraz używać `TypeOf` z `IsNot`.</span><span class="sxs-lookup"><span data-stu-id="a4d59-218">For more readability of your code, you can now use `TypeOf` with `IsNot`.</span></span>  
  
 [<span data-ttu-id="a4d59-219">Ostrzeżenie #Disable \<ID > i ostrzeżenie #Enable \<identyfikator ></span><span class="sxs-lookup"><span data-stu-id="a4d59-219">#Disable Warning \<ID> and #Enable Warning \<ID></span></span>](../../visual-basic/language-reference/directives/index.md)  
 <span data-ttu-id="a4d59-220">Można wyłączyć i Włącz określone ostrzeżenia dotyczące regionów, w pliku źródłowym.</span><span class="sxs-lookup"><span data-stu-id="a4d59-220">You can disable and enable specific warnings for regions within a source file.</span></span>  
  
 <span data-ttu-id="a4d59-221">**Ulepszenia komentarzy dokumentacji XML**</span><span class="sxs-lookup"><span data-stu-id="a4d59-221">**XML doc comment improvements**</span></span>  
 <span data-ttu-id="a4d59-222">Podczas pisania komentarzy dokumentacji, otrzymujesz Edytor smart i Obsługa sprawdzania poprawności nazwy parametrów, odpowiednich, Obsługa narzędzia build `crefs` (Ogólne, operatory, itp.), kolorowanie i refaktoryzacji.</span><span class="sxs-lookup"><span data-stu-id="a4d59-222">When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of `crefs` (generics, operators, etc.), colorizing, and refactoring.</span></span>  
  
 [<span data-ttu-id="a4d59-223">Definicje częściowe moduł i interfejsu</span><span class="sxs-lookup"><span data-stu-id="a4d59-223">Partial module and interface definitions</span></span>](../../visual-basic/language-reference/modifiers/partial.md)  
 <span data-ttu-id="a4d59-224">Oprócz klasy i struktury można zadeklarować moduły częściowe i interfejsy.</span><span class="sxs-lookup"><span data-stu-id="a4d59-224">In addition to classes and structs, you can declare partial modules and interfaces.</span></span>  
  
 [<span data-ttu-id="a4d59-225">Dyrektywy #Region wewnątrz treści metod</span><span class="sxs-lookup"><span data-stu-id="a4d59-225">#Region directives inside method bodies</span></span>](../../visual-basic/language-reference/directives/region-directive.md)  
 <span data-ttu-id="a4d59-226">Możesz umieścić #Region... ograniczniki #End Region, w dowolnym miejscu pliku wewnątrz funkcji, a nawet, dzieląc go w funkcji jednostki.</span><span class="sxs-lookup"><span data-stu-id="a4d59-226">You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.</span></span>  
  
 [<span data-ttu-id="a4d59-227">Definicje zastąpienia są niejawnie przeciążenia</span><span class="sxs-lookup"><span data-stu-id="a4d59-227">Overrides definitions are implicitly overloads</span></span>](../../visual-basic/language-reference/modifiers/overrides.md)  
 <span data-ttu-id="a4d59-228">Jeśli dodasz `Overrides` modyfikator do definicji, kompilator niejawnie dodaje `Overloads` tak, aby mniejszej ilości kodu można wpisać w typowych przypadkach.</span><span class="sxs-lookup"><span data-stu-id="a4d59-228">If you add the `Overrides` modifier to a definition, the compiler implicitly adds `Overloads` so that you can type less code in common cases.</span></span>  
  
 <span data-ttu-id="a4d59-229">**CObj dozwolone w argumentach atrybutów**</span><span class="sxs-lookup"><span data-stu-id="a4d59-229">**CObj allowed in attributes arguments**</span></span>  
 <span data-ttu-id="a4d59-230">Kompilator używać, aby zapewnić błąd, że CObj(...) nie jest stałą, gdy są używane w konstrukcji atrybutu.</span><span class="sxs-lookup"><span data-stu-id="a4d59-230">The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.</span></span>  
  
 <span data-ttu-id="a4d59-231">**Deklarowanie i używanie niejednoznaczne metody z różnych interfejsów**</span><span class="sxs-lookup"><span data-stu-id="a4d59-231">**Declaring and consuming ambiguous methods from different interfaces**</span></span>  
 <span data-ttu-id="a4d59-232">Wcześniej następujący kod zwróciło błędy, które uniemożliwiały deklarowanie `IMock` lub wywoływania `GetDetails` (jeśli zostały one zgłoszone w języku C#):</span><span class="sxs-lookup"><span data-stu-id="a4d59-232">Previously the following code yielded errors that prevented you from declaring `IMock` or from calling `GetDetails` (if these had been declared in C#):</span></span>  
  
```vb  
Interface ICustomer  
  Sub GetDetails(x As Integer)  
End Interface  
  
Interface ITime  
  Sub GetDetails(x As String)  
End Interface  
  
Interface IMock : Inherits ICustomer, ITime  
  Overloads Sub GetDetails(x As Char)  
End Interface  
  
Interface IMock2 : Inherits ICustomer, ITime  
End Interface  
```  
  
 <span data-ttu-id="a4d59-233">Teraz to kompilator użyje reguł rozwiązywania normalne przeciążenia wybranie najbardziej odpowiedniej `GetDetails` do wywołania, i można zadeklarować interfejsu relacje w języku Visual Basic, podobnie jak pokazano w przykładzie.</span><span class="sxs-lookup"><span data-stu-id="a4d59-233">Now the compiler will use normal overload resolution rules to choose the most appropriate `GetDetails` to call, and you can declare interface relationships in Visual Basic like those shown in the sample.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a4d59-234">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="a4d59-234">See also</span></span>

- [<span data-ttu-id="a4d59-235">Co nowego w programie Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="a4d59-235">What's New in Visual Studio 2017</span></span>](/visualstudio/ide/whats-new-in-visual-studio)
