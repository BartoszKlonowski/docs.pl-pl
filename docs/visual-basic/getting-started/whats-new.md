---
title: Nowości w języku Visual Basic
ms.date: 02/15/2018
ms.prod: .net
ms.technology:
- devlang-visual-basic
ms.topic: article
f1_keywords:
- VB.StartPage.WhatsNew
helpviewer_keywords:
- new features, Visual Basic
- what's new [Visual Basic]
- Visual Basic, what's new
ms.assetid: d7e97396-7f42-4873-a81c-4ebcc4b6ca02
caps.latest.revision: ''
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: c0452a5dde3a266f5d50f69016eac8144bab9ba6
ms.sourcegitcommit: c883637b41ee028786edceece4fa872939d2e64c
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/23/2018
---
# <a name="whats-new-for-visual-basic"></a><span data-ttu-id="32623-102">Nowości w języku Visual Basic</span><span class="sxs-lookup"><span data-stu-id="32623-102">What's new for Visual Basic</span></span>

<span data-ttu-id="32623-103">Ten temat zawiera listę nazw funkcji klucza dla każdej wersji programu Visual Basic z szczegółowe opisy nowych i ulepszonych funkcji w najnowsza wersja języka.</span><span class="sxs-lookup"><span data-stu-id="32623-103">This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the lastest version of the language.</span></span>
  
## <a name="current-version"></a><span data-ttu-id="32623-104">Bieżąca wersja</span><span class="sxs-lookup"><span data-stu-id="32623-104">Current Version</span></span>

<span data-ttu-id="32623-105">Visual Basic 15,5 cala</span><span class="sxs-lookup"><span data-stu-id="32623-105">Visual Basic 15.5</span></span>   
<span data-ttu-id="32623-106">W przypadku nowych funkcji, zobacz [15,5 cala Visual Basic](#visual-basic-155)</span><span class="sxs-lookup"><span data-stu-id="32623-106">For new features, see [Visual Basic 15.5](#visual-basic-155)</span></span>

## <a name="previous-versions"></a><span data-ttu-id="32623-107">Poprzednie wersje</span><span class="sxs-lookup"><span data-stu-id="32623-107">Previous versions</span></span>

<span data-ttu-id="32623-108">Visual Basic 15 ustęp 3</span><span class="sxs-lookup"><span data-stu-id="32623-108">Visual Basic 15.3</span></span>   
<span data-ttu-id="32623-109">W przypadku nowych funkcji, zobacz [15 ustęp 3 Visual Basic](#visual-basic-153)</span><span class="sxs-lookup"><span data-stu-id="32623-109">For new features, see [Visual Basic 15.3](#visual-basic-153)</span></span>

<span data-ttu-id="32623-110">2017 Visual Basic</span><span class="sxs-lookup"><span data-stu-id="32623-110">Visual Basic 2017</span></span>   
<span data-ttu-id="32623-111">W przypadku nowych funkcji, zobacz [2017 Visual Basic](#visual-basic-2017)</span><span class="sxs-lookup"><span data-stu-id="32623-111">For new features, see [Visual Basic 2017](#visual-basic-2017)</span></span>

<span data-ttu-id="32623-112">Visual Basic / Visual Studio .NET 2015</span><span class="sxs-lookup"><span data-stu-id="32623-112">Visual Basic / Visual Studio .NET 2015</span></span>   
<span data-ttu-id="32623-113">W przypadku nowych funkcji, zobacz [14 Visual Basic](#visual-basic-14)</span><span class="sxs-lookup"><span data-stu-id="32623-113">For new features, see [Visual Basic 14](#visual-basic-14)</span></span>

<span data-ttu-id="32623-114">Visual Basic / Visual Studio .NET 2013</span><span class="sxs-lookup"><span data-stu-id="32623-114">Visual Basic / Visual Studio .NET 2013</span></span>  
<span data-ttu-id="32623-115">Podglądy technologii platformy kompilatora .NET ("Roslyn")</span><span class="sxs-lookup"><span data-stu-id="32623-115">Technology previews of the .NET Compiler Platform (“Roslyn”)</span></span>

<span data-ttu-id="32623-116">Visual Basic / Visual Studio .NET 2012</span><span class="sxs-lookup"><span data-stu-id="32623-116">Visual Basic / Visual Studio .NET 2012</span></span>   
<span data-ttu-id="32623-117">`Async` i `await` słów kluczowych, Iteratory, caller — atrybuty informacji</span><span class="sxs-lookup"><span data-stu-id="32623-117">`Async` and `await` keywords, iterators, caller info attributes</span></span>

<span data-ttu-id="32623-118">Visual Basic, Visual Studio .NET 2010</span><span class="sxs-lookup"><span data-stu-id="32623-118">Visual Basic, Visual Studio .NET 2010</span></span>   
<span data-ttu-id="32623-119">Właściwości zaimplementowane automatycznie, inicjatory kolekcji, kontynuacji wiersza niejawne, odchylenie dynamicznych, ogólny co/ma przeciwwskazań, dostępu globalnej przestrzeni nazw</span><span class="sxs-lookup"><span data-stu-id="32623-119">Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access</span></span>

<span data-ttu-id="32623-120">Visual Basic / Visual Studio .NET 2008</span><span class="sxs-lookup"><span data-stu-id="32623-120">Visual Basic / Visual Studio .NET 2008</span></span>   
<span data-ttu-id="32623-121">Język zintegrowane zapytania (LINQ), literałów XML, wnioskowanie o typie lokalnym, obiekt inicjatory, typy anonimowe, metody rozszerzenia, lokalnego `var` wnioskowanie o typie, wyrażenia lambda `if` operatora, metody częściowe, typy o wartości zerowalnej</span><span class="sxs-lookup"><span data-stu-id="32623-121">Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local `var` type inference, lambda expressions, `if` operator, partial methods, nullable value types</span></span>  

<span data-ttu-id="32623-122">Visual Basic / Visual Studio .NET 2005</span><span class="sxs-lookup"><span data-stu-id="32623-122">Visual Basic / Visual Studio .NET 2005</span></span>   
<span data-ttu-id="32623-123">`My` Typu i pomocnika typów (dostęp do aplikacji, komputera, systemu plików, sieci)</span><span class="sxs-lookup"><span data-stu-id="32623-123">The `My` type and helper types (access to app, computer, files system, network)</span></span>

<span data-ttu-id="32623-124">Visual Basic / Visual Studio .NET 2003</span><span class="sxs-lookup"><span data-stu-id="32623-124">Visual Basic / Visual Studio .NET 2003</span></span>   
<span data-ttu-id="32623-125">Operatory przesunięcia bitowego, deklaracja zmiennej pętli</span><span class="sxs-lookup"><span data-stu-id="32623-125">Bit-shift operators, loop variable declaration</span></span>

<span data-ttu-id="32623-126">Visual Basic / Visual Studio .NET 2002</span><span class="sxs-lookup"><span data-stu-id="32623-126">Visual Basic / Visual Studio .NET 2002</span></span>   
<span data-ttu-id="32623-127">Pierwszej wersji programu Visual Basic .NET</span><span class="sxs-lookup"><span data-stu-id="32623-127">The first release of Visual Basic .NET</span></span>

## <a name="visual-basic-155"></a><span data-ttu-id="32623-128">Visual Basic 15,5 cala</span><span class="sxs-lookup"><span data-stu-id="32623-128">Visual Basic 15.5</span></span>

[<span data-ttu-id="32623-129">Non końcowe nazwane argumenty</span><span class="sxs-lookup"><span data-stu-id="32623-129">Non-trailing named arguments</span></span>](../programming-guide/language-features/procedures/passing-arguments-by-position-and-by-name.md#mixing-arguments-by-position-and-by-name)

<span data-ttu-id="32623-130">W Visual Basic 15 ustęp 3 i starszych wersjach gdy wywołanie metody uwzględnione argumentów zarówno według pozycji i według nazwy, argumenty pozycyjne musiał poprzedzać nazwane argumenty.</span><span class="sxs-lookup"><span data-stu-id="32623-130">In Visual Basic 15.3 and earlier versions, when a method call included arguments both by position and by name, positional arguments had to precede named arguments.</span></span> <span data-ttu-id="32623-131">Argumenty nazwane i pozycyjnych począwszy od 15,5 cala Visual Basic, może wystąpić w dowolnej kolejności, tak długo, jak wszystkie argumenty do ostatni argument pozycyjny są w poprawnej pozycji.</span><span class="sxs-lookup"><span data-stu-id="32623-131">Starting with Visual Basic 15.5, positional and named arguments can appear in any order as long as all arguments up to the last positional argument are in the correct position.</span></span> <span data-ttu-id="32623-132">Jest to szczególnie przydatne, gdy nazwane argumenty są używane, aby zwiększyć czytelność kodu.</span><span class="sxs-lookup"><span data-stu-id="32623-132">This is particularly useful when named arguments are used to make code more readable.</span></span>

<span data-ttu-id="32623-133">Na przykład następujące wywołanie metody ma dwa argumenty pozycyjne między nazwany argument.</span><span class="sxs-lookup"><span data-stu-id="32623-133">For example, the following method call has two positional arguments between a named argument.</span></span> <span data-ttu-id="32623-134">Nazwany argument ułatwia wyczyść reprezentowany przez wartość 19 wieku.</span><span class="sxs-lookup"><span data-stu-id="32623-134">The named argument makes it clear that the value 19 represents an age.</span></span>

```vb
StudentInfo.Display("Mary", age:=19, #9/21/1998#)
```

<span data-ttu-id="32623-135">**Wiodący znak separatora hex/binary/ósemkowe**</span><span class="sxs-lookup"><span data-stu-id="32623-135">**Leading hex/binary/octal separator**</span></span>

<span data-ttu-id="32623-136">Visual Basic 2017 dodano obsługę znaku podkreślenia (`_`) jako separator cyfr.</span><span class="sxs-lookup"><span data-stu-id="32623-136">Visual Basic 2017 added support for the underscore character (`_`) as a digit separator.</span></span> <span data-ttu-id="32623-137">Począwszy od 15,5 cala Visual Basic, można użyć znaku podkreślenia jako separator wiodące między prefiks i cyfr szesnastkowych, binarne lub ósemkowo.</span><span class="sxs-lookup"><span data-stu-id="32623-137">Starting with Visual Basic 15.5, you can use the underscore character as a leading separator between the prefix and hexadecimal, binary, or octal digits.</span></span> <span data-ttu-id="32623-138">W poniższym przykładzie użyto wiodące separator cyfr, aby zdefiniować 3,271,948,384 jako liczbę szesnastkową:</span><span class="sxs-lookup"><span data-stu-id="32623-138">The following example uses a leading digit separator to define 3,271,948,384 as a hexadecimal number:</span></span>

```vb
Dim number As Integer = &H_C305_F860
``` 
<span data-ttu-id="32623-139">Aby użyć znaku podkreślenia jako separator początkowych, należy dodać następujący element do projektu Visual Basic (\*.vbproj) plików:</span><span class="sxs-lookup"><span data-stu-id="32623-139">To use the underscore character as a leading separator, you must add the following element to your Visual Basic project (\*.vbproj) file:</span></span>

```xml
<PropertyGroup>
  <LangVersion>15.5</LangVersion>
</PropertyGroup>
```

## <a name="visual-basic-153"></a><span data-ttu-id="32623-140">Visual Basic 15 ustęp 3</span><span class="sxs-lookup"><span data-stu-id="32623-140">Visual Basic 15.3</span></span>

[<span data-ttu-id="32623-141">**Wnioskowanie spójnej kolekcji o nazwie**</span><span class="sxs-lookup"><span data-stu-id="32623-141">**Named tuple inference**</span></span>](../programming-guide/language-features/data-types/tuples.md#inferred-tuple-element-names)

<span data-ttu-id="32623-142">Jeśli wartość krotki elementy z zmienne, Visual Basic wnioskuje nazwy elementów krotki z odpowiedniej nazwy zmiennych; nie trzeba jawnie nazwa element spójnej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="32623-142">When you assign the value of tuple elements from variables, Visual Basic infers the name of tuple elements from the corresponding variable names; you do not have to explicitly name a tuple element.</span></span> <span data-ttu-id="32623-143">W poniższym przykładzie użyto wnioskowania do utworzenia spójnych kolekcji z trzy elementy o nazwie, `state`, `stateName`, i `capital`.</span><span class="sxs-lookup"><span data-stu-id="32623-143">The following example uses inference to create a tuple with three named elements, `state`, `stateName`, and `capital`.</span></span>

[!code-vb[Inferred tuple names](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

<span data-ttu-id="32623-144">**Dodatkowe przełączniki kompilatora**</span><span class="sxs-lookup"><span data-stu-id="32623-144">**Additional compiler switches**</span></span>  

<span data-ttu-id="32623-145">Obsługuje teraz wiersza polecenia kompilatora Visual Basic [ **- refout** ](../reference/command-line-compiler/refout-compiler-option.md) i [ **- refonly** ](../reference/command-line-compiler/refonly-compiler-option.md) opcje kontroli dane wyjściowe kompilatora zestawy odwołań.</span><span class="sxs-lookup"><span data-stu-id="32623-145">The Visual Basic command-line compiler now supports the [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) and [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) compiler options to control the output of reference assemblies.</span></span> <span data-ttu-id="32623-146">**-refout** definiuje katalogu wyjściowego zestawu odwołania i **- refonly** Określa, że zestaw odwołania ma być danymi wyjściowymi kompilacji.</span><span class="sxs-lookup"><span data-stu-id="32623-146">**-refout** defines the output directory of the reference assembly, and **-refonly** specifies that only a reference assembly is to be output by compilation.</span></span>

## <a name="visual-basic-2017"></a><span data-ttu-id="32623-147">2017 Visual Basic</span><span class="sxs-lookup"><span data-stu-id="32623-147">Visual Basic 2017</span></span>

[<span data-ttu-id="32623-148">**Krotki**</span><span class="sxs-lookup"><span data-stu-id="32623-148">**Tuples**</span></span>](../programming-guide/language-features/data-types/tuples.md)

<span data-ttu-id="32623-149">Spójne kolekcje są lekkie danych struktury, która najczęściej służy do zwracania wiele wartości z wywołania pojedynczej metody.</span><span class="sxs-lookup"><span data-stu-id="32623-149">Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.</span></span> <span data-ttu-id="32623-150">Zwykle zwracać wiele wartości z metody, należy wykonać jedną z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="32623-150">Ordinarily, to return multiple values from a method, you have to do one of the following:</span></span>

- <span data-ttu-id="32623-151">Definiowanie niestandardowego typu ( `Class` lub `Structure`).</span><span class="sxs-lookup"><span data-stu-id="32623-151">Define a custom type (a `Class` or a `Structure`).</span></span> <span data-ttu-id="32623-152">Jest to rozwiązanie ogromnych.</span><span class="sxs-lookup"><span data-stu-id="32623-152">This is a heavyweight solution.</span></span>

- <span data-ttu-id="32623-153">Zdefiniuj co najmniej jeden `ByRef` parametrów, oprócz zwracanie wartości z metody.</span><span class="sxs-lookup"><span data-stu-id="32623-153">Define one or more `ByRef` parameters, in addition to returning a value from the method.</span></span>
 
<span data-ttu-id="32623-154">Obsługa języka Visual Basic krotek pozwala szybko zdefiniować krotka, opcjonalnie przypisać semantycznego nazwy do jego wartości i szybko pobrać jego wartości.</span><span class="sxs-lookup"><span data-stu-id="32623-154">Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.</span></span> <span data-ttu-id="32623-155">Poniższy przykład opakowuje wywołanie <xref:System.Int32.TryParse%2A> metodę i zwraca spójną kolekcję.</span><span class="sxs-lookup"><span data-stu-id="32623-155">The following example wraps a call to the <xref:System.Int32.TryParse%2A> method and returns a tuple.</span></span>

[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

<span data-ttu-id="32623-156">Można wywołać metody i obsługi zwrócony krotki z kodu podobne do następujących.</span><span class="sxs-lookup"><span data-stu-id="32623-156">You can then call the method and handle the returned tuple with code like the following.</span></span>

[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)] 

<span data-ttu-id="32623-157">**Literały binarne i separatory cyfr**</span><span class="sxs-lookup"><span data-stu-id="32623-157">**Binary literals and digit separators**</span></span>

<span data-ttu-id="32623-158">Dane binarne literału można zdefiniować przy użyciu prefiksu `&B` lub `&b`.</span><span class="sxs-lookup"><span data-stu-id="32623-158">You can define a binary literal by using the prefix `&B` or `&b`.</span></span> <span data-ttu-id="32623-159">Ponadto można użyć znaku podkreślenia `_`, jako separator cyfr w celu zwiększenia czytelności.</span><span class="sxs-lookup"><span data-stu-id="32623-159">In addition, you can use the underscore character, `_`, as a digit separator to enhance readability.</span></span> <span data-ttu-id="32623-160">W poniższym przykładzie użyto obie funkcje można przypisać `Byte` wartość i wyświetl ją jako liczbę dziesiętną szesnastkowe i binarnego.</span><span class="sxs-lookup"><span data-stu-id="32623-160">The following example uses both features to assign a `Byte` value and to display it as a decimal, hexadecimal, and binary number.</span></span>

[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]

<span data-ttu-id="32623-161">Aby uzyskać więcej informacji, zobacz sekcję "Przypisania literału" [bajtów](../language-reference/data-types/byte-data-type.md#literal-assignments), [całkowitą](../language-reference/data-types/integer-data-type.md#literal-assignments), [długi](../language-reference/data-types/long-data-type.md#literal-assignments), [krótki](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte ](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [Uinteger —](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), i [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) typów danych.</span><span class="sxs-lookup"><span data-stu-id="32623-161">For more information, see the "Literal assignments" section of the [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), and [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) data types.</span></span>

<span data-ttu-id="32623-162">**Obsługa języka C# odwołanie zwracanych wartości**</span><span class="sxs-lookup"><span data-stu-id="32623-162">**Support for C# reference return values**</span></span>

<span data-ttu-id="32623-163">Począwszy od C# 7, C# obsługuje odwołania może zwracać wartości.</span><span class="sxs-lookup"><span data-stu-id="32623-163">Starting with C# 7, C# supports reference return values.</span></span> <span data-ttu-id="32623-164">Oznacza to gdy wywołanie metody odbiera wartość zwracana przez odwołanie, można zmienić wartości odwołania.</span><span class="sxs-lookup"><span data-stu-id="32623-164">That is, when the calling method receives a value returned by reference, it can change the value of the reference.</span></span> <span data-ttu-id="32623-165">Visual Basic nie zezwala na utworzenia metod z odwołaniem zwracają wartości, ale pozwala ona do wykorzystania i zmodyfikować zwracanych wartości odwołania.</span><span class="sxs-lookup"><span data-stu-id="32623-165">Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.</span></span>

<span data-ttu-id="32623-166">Na przykład następująca `Sentence` klasa napisane w języku C# zawiera `FindNext` metodę, która znajduje następny wyraz w zdaniu zaczyna się od wskazany podciąg.</span><span class="sxs-lookup"><span data-stu-id="32623-166">For example, the following `Sentence` class written in C# includes a `FindNext` method that finds the next word in a sentence that begins with a specified substring.</span></span> <span data-ttu-id="32623-167">Jako wartość zwracana przez odwołanie i zostanie zwrócony ciąg `Boolean` zmiennej przekazywana przez odwołanie do metody wskazuje, czy wyszukiwanie zakończyła się powodzeniem.</span><span class="sxs-lookup"><span data-stu-id="32623-167">The string is returned as a reference return value, and a `Boolean` variable passed by reference to the method indicates whether the search was successful.</span></span> <span data-ttu-id="32623-168">Oznacza to, że obiekt wywołujący nie może tylko odczytać zwrócona wartość; on również ją zmodyfikować, a tej zmiany jest widoczny w `Sentence` klasy.</span><span class="sxs-lookup"><span data-stu-id="32623-168">This means that the caller can not only read the returned value; he or she can also modify it, and that modification is reflected in the `Sentence` class.</span></span>

[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]

<span data-ttu-id="32623-169">W najprostszej postaci można zmodyfikować wyraz znaleziony w zdaniu przy użyciu kodu podobne do następujących.</span><span class="sxs-lookup"><span data-stu-id="32623-169">In its simplest form, you can modify the word found in the sentence by using code like the following.</span></span> <span data-ttu-id="32623-170">Należy pamiętać, że nie przypisujesz wartość do metody, ale raczej wyrażenie zwraca metody, których to odwołanie, wartość zwracana.</span><span class="sxs-lookup"><span data-stu-id="32623-170">Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]

<span data-ttu-id="32623-171">Problem z tym kodem jest, że jeśli nie, metoda zwraca pierwsze słowo.</span><span class="sxs-lookup"><span data-stu-id="32623-171">A problem with this code, though, is that if a match is not found, the method returns the first word.</span></span> <span data-ttu-id="32623-172">Ponieważ przykładzie nie bada wartość `Boolean` argumentu, aby określić, czy dopasowanie zostanie znaleziony, modyfikuje pierwsze słowo, jeśli nie zostanie odnaleziony odpowiednik.</span><span class="sxs-lookup"><span data-stu-id="32623-172">Since the example does not examine the value of the `Boolean` argument to determine whether a match is found, it modifies the first word if there is no match.</span></span> <span data-ttu-id="32623-173">Poniższy przykład poprawia to zastępując pierwsze słowo z samym sobą, jeśli nie Brak dopasowania.</span><span class="sxs-lookup"><span data-stu-id="32623-173">The following example corrects this by replacing the first word with itself if there is no match.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]

<span data-ttu-id="32623-174">Lepszym rozwiązaniem jest przy użyciu metody pomocnika, do której odwołanie wartość zwracana jest przekazywana przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="32623-174">A better solution is to use a helper method to which the reference return value is passed by reference.</span></span> <span data-ttu-id="32623-175">Metoda pomocnika można następnie zmodyfikować argumentu przekazanego do niej przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="32623-175">The helper method can then modify the argument passed to it by reference.</span></span> <span data-ttu-id="32623-176">Poniższy przykład robi to.</span><span class="sxs-lookup"><span data-stu-id="32623-176">The following example does that.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]

<span data-ttu-id="32623-177">Aby uzyskać więcej informacji, zobacz [odwołania zwracać wartości](../programming-guide/language-features/procedures/ref-return-values.md).</span><span class="sxs-lookup"><span data-stu-id="32623-177">For more information, see [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md).</span></span>

## <a name="visual-basic-14"></a><span data-ttu-id="32623-178">Visual Basic 14</span><span class="sxs-lookup"><span data-stu-id="32623-178">Visual Basic 14</span></span>

[<span data-ttu-id="32623-179">Nameof</span><span class="sxs-lookup"><span data-stu-id="32623-179">Nameof</span></span>](../../csharp/language-reference/keywords/nameof.md)  
 <span data-ttu-id="32623-180">Niekwalifikowane ciąg nazwę typu lub elementu członkowskiego do użycia w komunikacie o błędzie można uzyskać, bez twardych kodowanie ciągu.</span><span class="sxs-lookup"><span data-stu-id="32623-180">You can get the unqualified string name of a type or member for use in an error message without hard coding a string.</span></span>  <span data-ttu-id="32623-181">Dzięki temu swój kod, aby pozostać poprawne podczas refaktoryzacji.</span><span class="sxs-lookup"><span data-stu-id="32623-181">This allows your code to remain correct when refactoring.</span></span>  <span data-ttu-id="32623-182">Ta funkcja jest również przydatne w przypadku podłączenia łącza MVC model-view-controller i wyzwalania zdarzenia zmiany właściwości.</span><span class="sxs-lookup"><span data-stu-id="32623-182">This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.</span></span>  
  
[<span data-ttu-id="32623-183">Interpolacja ciągów</span><span class="sxs-lookup"><span data-stu-id="32623-183">String Interpolation</span></span>](../../csharp/language-reference/keywords/interpolated-strings.md)  
 <span data-ttu-id="32623-184">Wyrażenia parametrów interpolacji służy do tworzenia ciągów.</span><span class="sxs-lookup"><span data-stu-id="32623-184">You can use string interpolation expressions to construct strings.</span></span>  <span data-ttu-id="32623-185">Wyrażenie ciągu interpolowanym wygląda jak ciąg szablonu, który zawiera wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="32623-185">An interpolated string expression looks like a template string that contains expressions.</span></span>  <span data-ttu-id="32623-186">Ciągu interpolowanym łatwiej zrozumieć względem argumentów niż [złożone formatowanie](../../standard/base-types/composite-format.md).</span><span class="sxs-lookup"><span data-stu-id="32623-186">An interpolated string is easier to understand with respect to arguments than [Composite Formatting](../../standard/base-types/composite-format.md).</span></span>  
  
[<span data-ttu-id="32623-187">Dostęp do elementu członkowskiego warunkowe null i indeksowania</span><span class="sxs-lookup"><span data-stu-id="32623-187">Null-conditional Member Access and Indexing</span></span>](../../csharp/language-reference/operators/null-conditional-operators.md)  
<span data-ttu-id="32623-188">Można sprawdzić wartość null w sposób składni bardzo małe przed wykonaniem dostępu elementu członkowskiego (`?.`) lub indeks (`?[]`) operacji.</span><span class="sxs-lookup"><span data-stu-id="32623-188">You can test for null in a very light syntactic way before performing a member access (`?.`) or index (`?[]`) operation.</span></span>  <span data-ttu-id="32623-189">Tych operatorów pomóc zapisu sprawdza mniej kod obsługujący wartości null, szczególnie w przypadku malejącej do struktur danych.</span><span class="sxs-lookup"><span data-stu-id="32623-189">These operators help you write less code to handle null checks, especially for descending into data structures.</span></span>  <span data-ttu-id="32623-190">Jeśli Lewy argument operacji lub obiektu odwołanie ma wartość null, operacje zwraca wartość null.</span><span class="sxs-lookup"><span data-stu-id="32623-190">If the left operand or object reference is null, the operations returns null.</span></span>  
  
[<span data-ttu-id="32623-191">Literały ciągu wiele wierszy</span><span class="sxs-lookup"><span data-stu-id="32623-191">Multi-line String Literals</span></span>](../../visual-basic/programming-guide/language-features/strings/string-basics.md)  
 <span data-ttu-id="32623-192">Literały ciągu może zawierać sekwencje znaków nowego wiersza.</span><span class="sxs-lookup"><span data-stu-id="32623-192">String literals can contain newline sequences.</span></span>  <span data-ttu-id="32623-193">Możesz już konieczne stary obejść użycia `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span><span class="sxs-lookup"><span data-stu-id="32623-193">You no longer need the old work around of using `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span></span>  
  
<span data-ttu-id="32623-194">Komentarze</span><span class="sxs-lookup"><span data-stu-id="32623-194">Comments</span></span>  
<span data-ttu-id="32623-195">Możesz umieścić komentarze po kontynuacje niejawne wiersza, wewnątrz wyrażenia inicjatora, jak i między LINQ wyrażeń.</span><span class="sxs-lookup"><span data-stu-id="32623-195">You can put comments after implicit line continuations, inside initializer expressions, and amongst LINQ expression terms.</span></span>  
  
 <span data-ttu-id="32623-196">Inteligentny rozdzielczość w pełni kwalifikowaną nazwę</span><span class="sxs-lookup"><span data-stu-id="32623-196">Smarter Fully-qualified Name Resolution</span></span>  
 <span data-ttu-id="32623-197">Podany kod, takich jak `Threading.Thread.Sleep(1000)`, Visual Basic używaną do odszukania przestrzeni nazw "Wątkowość" odnajdywanie jest niejednoznaczny między System.Threading i System.Windows.Threading, a następnie składają raporty wystąpił błąd.</span><span class="sxs-lookup"><span data-stu-id="32623-197">Given code such as `Threading.Thread.Sleep(1000)`, Visual Basic used to look up the namespace "Threading", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.</span></span>  <span data-ttu-id="32623-198">Visual Basic uwzględnia teraz obu tych możliwości przestrzeni nazw razem.</span><span class="sxs-lookup"><span data-stu-id="32623-198">Visual Basic now considers both possible namespaces together.</span></span>  <span data-ttu-id="32623-199">Jeśli występuje na liście uzupełniania, edytorze programu Visual Studio zawiera listę elementów członkowskich z obu typów na liście uzupełniania.</span><span class="sxs-lookup"><span data-stu-id="32623-199">If you show the completion list, the Visual Studio editor lists members from both types in the completion list.</span></span>  
  
 <span data-ttu-id="32623-200">Literały daty pierwszej roku</span><span class="sxs-lookup"><span data-stu-id="32623-200">Year-first Date Literals</span></span>  
 <span data-ttu-id="32623-201">Masz literały daty w formacie rrrr mm-dd `#2015-03-17 16:10 PM#`.</span><span class="sxs-lookup"><span data-stu-id="32623-201">You can have date literals in yyyy-mm-dd format, `#2015-03-17 16:10 PM#`.</span></span>  
  
 <span data-ttu-id="32623-202">Właściwości tylko do odczytu — interfejs</span><span class="sxs-lookup"><span data-stu-id="32623-202">Readonly Interface Properties</span></span>  
 <span data-ttu-id="32623-203">Można wdrożyć tylko do odczytu właściwości interfejsu za pomocą właściwości odczytu i zapisu.</span><span class="sxs-lookup"><span data-stu-id="32623-203">You can implement readonly interface properties using a readwrite property.</span></span>  <span data-ttu-id="32623-204">Interfejs gwarantuje minimalny zestaw funkcji, a nie zatrzymuje klasa implementująca z stosowanie ustawionej właściwości.</span><span class="sxs-lookup"><span data-stu-id="32623-204">The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.</span></span>  
  
 [<span data-ttu-id="32623-205">TypeOf \<expr > IsNot \<typu ></span><span class="sxs-lookup"><span data-stu-id="32623-205">TypeOf \<expr> IsNot \<type></span></span>](../../visual-basic/language-reference/operators/typeof-operator.md)  
 <span data-ttu-id="32623-206">Aby uzyskać więcej czytelność kodu, można teraz używać `TypeOf` z `IsNot`.</span><span class="sxs-lookup"><span data-stu-id="32623-206">For more readability of your code, you can now use `TypeOf` with `IsNot`.</span></span>  
  
 [<span data-ttu-id="32623-207">Ostrzeżenie #Disable \<ID > i ostrzeżenie #Enable \<ID ></span><span class="sxs-lookup"><span data-stu-id="32623-207">#Disable Warning \<ID> and #Enable Warning \<ID></span></span>](../../visual-basic/language-reference/directives/directives.md)  
 <span data-ttu-id="32623-208">Można wyłączyć i Włącz określone ostrzeżenia dla regionów, w pliku źródłowym.</span><span class="sxs-lookup"><span data-stu-id="32623-208">You can disable and enable specific warnings for regions within a source file.</span></span>  
  
 <span data-ttu-id="32623-209">Ulepszenia komentarza dokumentu XML</span><span class="sxs-lookup"><span data-stu-id="32623-209">XML Doc-comment Improvements</span></span>  
 <span data-ttu-id="32623-210">Podczas zapisywania komentarze w dokumencie, Pobierz inteligentne edytora i Obsługa sprawdzania poprawności nazwy parametrów, odpowiednich Obsługa kompilacji `crefs` (Ogólne, operatory, itp.), kolorowanie i refaktoryzacji.</span><span class="sxs-lookup"><span data-stu-id="32623-210">When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of `crefs` (generics, operators, etc.), colorizing, and refactoring.</span></span>  
  
 [<span data-ttu-id="32623-211">Moduł częściowe i definicje interfejsu</span><span class="sxs-lookup"><span data-stu-id="32623-211">Partial Module and Interface Definitions</span></span>](../../visual-basic/language-reference/modifiers/partial.md)  
 <span data-ttu-id="32623-212">Oprócz klas i struktur mogą zadeklarować częściowe moduły i interfejsów.</span><span class="sxs-lookup"><span data-stu-id="32623-212">In addition to classes and structs, you can declare partial modules and interfaces.</span></span>  
  
 [<span data-ttu-id="32623-213">#Region dyrektywy wewnątrz treści — metoda</span><span class="sxs-lookup"><span data-stu-id="32623-213">#Region Directives inside Method Bodies</span></span>](../../visual-basic/language-reference/directives/region-directive.md)  
 <span data-ttu-id="32623-214">Możesz też zaznaczyć #Region... ograniczniki #End Region w dowolnym miejscu w funkcjach, a nawet, dzieląc go w pliku funkcji jednostki.</span><span class="sxs-lookup"><span data-stu-id="32623-214">You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.</span></span>  
  
 [<span data-ttu-id="32623-215">Definicje zastąpienia są niejawnie Overloads</span><span class="sxs-lookup"><span data-stu-id="32623-215">Overrides Definitions are Implicitly Overloads</span></span>](../../visual-basic/language-reference/modifiers/overrides.md)  
 <span data-ttu-id="32623-216">Jeśli dodasz `Overrides` modyfikator do definicji, kompilator niejawnie dodaje `Overloads` przypadków, w którym można wpisać wspólną mniejsza ilość kodu.</span><span class="sxs-lookup"><span data-stu-id="32623-216">If you add the `Overrides` modifier to a definition, the compiler implicitly adds `Overloads` so that you can type less code in common cases.</span></span>  
  
 <span data-ttu-id="32623-217">CObj w argumentach atrybutów dozwolone</span><span class="sxs-lookup"><span data-stu-id="32623-217">CObj Allowed in Attributes Arguments</span></span>  
 <span data-ttu-id="32623-218">Kompilator używać, aby zapewnić błąd, że CObj(...) nie jest stałą, gdy są używane w konstrukcji atrybutu.</span><span class="sxs-lookup"><span data-stu-id="32623-218">The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.</span></span>  
  
 <span data-ttu-id="32623-219">Deklarowanie i korzystanie z metody niejednoznaczne z różnych interfejsów</span><span class="sxs-lookup"><span data-stu-id="32623-219">Declaring and Consuming Ambiguous Methods from Different Interfaces</span></span>  
 <span data-ttu-id="32623-220">Wcześniej następujący kod zwróciło błędy, które uniemożliwiały deklarowanie `IMock` lub z wywołaniem `GetDetails` (jeśli je zadeklarowano w języku C#):</span><span class="sxs-lookup"><span data-stu-id="32623-220">Previously the following code yielded errors that prevented you from declaring `IMock` or from calling `GetDetails` (if these had been declared in C#):</span></span>  
  
```vb  
Interface ICustomer  
  Sub GetDetails(x As Integer)  
End Interface  
  
Interface ITime  
  Sub GetDetails(x As String)  
End Interface  
  
Interface IMock : Inherits ICustomer, ITime  
  Overloads Sub GetDetails(x As Char)  
End Interface  
  
Interface IMock2 : Inherits ICustomer, ITime  
End Interface  
```  
  
 <span data-ttu-id="32623-221">Teraz kompilator użyje reguł rozwiązywania normalne przeciążenia wybranie najbardziej odpowiedniej `GetDetails` do wywołania, i można zadeklarować interfejsu relacje w języku Visual Basic, jak pokazano w przykładzie.</span><span class="sxs-lookup"><span data-stu-id="32623-221">Now the compiler will use normal overload resolution rules to choose the most appropriate `GetDetails` to call, and you can declare interface relationships in Visual Basic like those shown in the sample.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="32623-222">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="32623-222">See also</span></span>  
 [<span data-ttu-id="32623-223">Co to jest nowa w programie Visual Studio 2017 r.</span><span class="sxs-lookup"><span data-stu-id="32623-223">What's New in Visual Studio 2017</span></span>](/visualstudio/ide/whats-new-in-visual-studio)
