---
title: Interfejsy
ms.date: 07/20/2015
helpviewer_keywords:
- Visual Basic code, interfaces
- interfaces [Visual Basic], Visual Basic
- interfaces
- interfaces [Visual Basic]
ms.assetid: 61b06674-12c9-430b-be68-cc67ecee1f5b
ms.openlocfilehash: 619aa6695db756e56a836fd76693cc8a3976f8e2
ms.sourcegitcommit: 17ee6605e01ef32506f8fdc686954244ba6911de
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 11/22/2019
ms.locfileid: "74345053"
---
# <a name="interfaces-visual-basic"></a><span data-ttu-id="f8a8a-102">Interfejsy (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="f8a8a-102">Interfaces (Visual Basic)</span></span>
<span data-ttu-id="f8a8a-103">*Interfejsy* definiują właściwości, metody i zdarzenia, które mogą implementować klasy.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-103">*Interfaces* define the properties, methods, and events that classes can implement.</span></span> <span data-ttu-id="f8a8a-104">Interfejsy umożliwiają definiowanie funkcji jako małych grup ściśle powiązanych właściwości, metod i zdarzeń; zmniejsza to problemy ze zgodnością, ponieważ można opracowywać ulepszone implementacje dla interfejsów bez narażania istniejącego kodu.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-104">Interfaces allow you to define features as small groups of closely related properties, methods, and events; this reduces compatibility problems because you can develop enhanced implementations for your interfaces without jeopardizing existing code.</span></span> <span data-ttu-id="f8a8a-105">W dowolnym momencie możesz dodać nowe funkcje, opracowując dodatkowe interfejsy i implementacje.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-105">You can add new features at any time by developing additional interfaces and implementations.</span></span>  
  
 <span data-ttu-id="f8a8a-106">Istnieje kilka innych powodów, dla których warto chcieć używać interfejsów zamiast dziedziczenia klasy:</span><span class="sxs-lookup"><span data-stu-id="f8a8a-106">There are several other reasons why you might want to use interfaces instead of class inheritance:</span></span>  
  
- <span data-ttu-id="f8a8a-107">Interfejsy są lepiej dopasowane do sytuacji, w których aplikacje wymagają wielu niepowiązanych typów obiektów, aby zapewnić pewne funkcje.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-107">Interfaces are better suited to situations in which your applications require many possibly unrelated object types to provide certain functionality.</span></span>  
  
- <span data-ttu-id="f8a8a-108">Interfejsy są bardziej elastyczne niż klasy bazowe, ponieważ istnieje możliwość zdefiniowania jednej implementacji, która może zaimplementować wiele interfejsów.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-108">Interfaces are more flexible than base classes because you can define a single implementation that can implement multiple interfaces.</span></span>  
  
- <span data-ttu-id="f8a8a-109">Interfejsy są lepsze w sytuacjach, w których nie trzeba dziedziczyć implementacji z klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-109">Interfaces are better in situations in which you do not have to inherit implementation from a base class.</span></span>  
  
- <span data-ttu-id="f8a8a-110">Interfejsy są przydatne, gdy nie można użyć dziedziczenia klas.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-110">Interfaces are useful when you cannot use class inheritance.</span></span> <span data-ttu-id="f8a8a-111">Na przykład struktury nie mogą dziedziczyć z klas, ale mogą implementować interfejsy.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-111">For example, structures cannot inherit from classes, but they can implement interfaces.</span></span>  
  
## <a name="declaring-interfaces"></a><span data-ttu-id="f8a8a-112">Deklarowanie interfejsów</span><span class="sxs-lookup"><span data-stu-id="f8a8a-112">Declaring Interfaces</span></span>  
 <span data-ttu-id="f8a8a-113">Definicje interfejsu są ujęte w instrukcji `Interface` i `End Interface`.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-113">Interface definitions are enclosed within the `Interface` and `End Interface` statements.</span></span> <span data-ttu-id="f8a8a-114">Postępując zgodnie z instrukcją `Interface`, można dodać opcjonalną instrukcję `Inherits`, która zawiera jeden lub więcej dziedziczonych interfejsów.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-114">Following the `Interface` statement, you can add an optional `Inherits` statement that lists one or more inherited interfaces.</span></span> <span data-ttu-id="f8a8a-115">Instrukcje `Inherits` muszą poprzedzać wszystkie inne instrukcje w deklaracji poza komentarzem.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-115">The `Inherits` statements must precede all other statements in the declaration except comments.</span></span> <span data-ttu-id="f8a8a-116">Pozostałe instrukcje w definicji interfejsu powinny mieć `Event`, `Sub`, `Function`, `Property`, `Interface`, `Class`, `Structure`i `Enum` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-116">The remaining statements in the interface definition should be `Event`, `Sub`, `Function`, `Property`, `Interface`, `Class`, `Structure`, and `Enum` statements.</span></span> <span data-ttu-id="f8a8a-117">Interfejsy nie mogą zawierać żadnych kodów implementacji ani instrukcji skojarzonych z kodem implementacji, takich jak `End Sub` lub `End Property`.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-117">Interfaces cannot contain any implementation code or statements associated with implementation code, such as `End Sub` or `End Property`.</span></span>  
  
 <span data-ttu-id="f8a8a-118">W przestrzeni nazw instrukcje interfejsu są domyślnie `Friend`, ale mogą być również jawnie zadeklarowane jako `Public` lub `Friend`.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-118">In a namespace, interface statements are `Friend` by default, but they can also be explicitly declared as `Public` or `Friend`.</span></span> <span data-ttu-id="f8a8a-119">Interfejsy zdefiniowane w ramach klas, modułów, interfejsów i struktur są domyślnie `Public`, ale mogą być również jawnie zadeklarowane jako `Public`, `Friend`, `Protected`lub `Private`.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-119">Interfaces defined within classes, modules, interfaces, and structures are `Public` by default, but they can also be explicitly declared as `Public`, `Friend`, `Protected`, or `Private`.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="f8a8a-120">Słowo kluczowe `Shadows` można zastosować do wszystkich elementów członkowskich interfejsu.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-120">The `Shadows` keyword can be applied to all interface members.</span></span> <span data-ttu-id="f8a8a-121">Słowo kluczowe `Overloads` można zastosować do instrukcji `Sub`, `Function`i `Property` zadeklarowanych w definicji interfejsu.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-121">The `Overloads` keyword can be applied to `Sub`, `Function`, and `Property` statements declared in an interface definition.</span></span> <span data-ttu-id="f8a8a-122">Ponadto instrukcje `Property` mogą mieć Modyfikatory `Default`, `ReadOnly`lub `WriteOnly`.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-122">In addition, `Property` statements can have the `Default`, `ReadOnly`, or `WriteOnly` modifiers.</span></span> <span data-ttu-id="f8a8a-123">Żaden z innych modyfikatorów —`Public`, `Private`, `Friend`, `Protected`, `Shared`, `Overrides`, `MustOverride`lub `Overridable`— są dozwolone.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-123">None of the other modifiers—`Public`, `Private`, `Friend`, `Protected`, `Shared`, `Overrides`, `MustOverride`, or `Overridable`—are allowed.</span></span> <span data-ttu-id="f8a8a-124">Aby uzyskać więcej informacji, zobacz [konteksty deklaracji i domyślne poziomy dostępu](../../../../visual-basic/language-reference/statements/declaration-contexts-and-default-access-levels.md).</span><span class="sxs-lookup"><span data-stu-id="f8a8a-124">For more information, see [Declaration Contexts and Default Access Levels](../../../../visual-basic/language-reference/statements/declaration-contexts-and-default-access-levels.md).</span></span>  
  
 <span data-ttu-id="f8a8a-125">Na przykład poniższy kod definiuje interfejs z jedną funkcją, jedną właściwością i jednym zdarzeniem.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-125">For example, the following code defines an interface with one function, one property, and one event.</span></span>  
  
 [!code-vb[VbVbalrOOP#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/OOP.vb#17)]  
  
## <a name="implementing-interfaces"></a><span data-ttu-id="f8a8a-126">Implementowanie interfejsów</span><span class="sxs-lookup"><span data-stu-id="f8a8a-126">Implementing Interfaces</span></span>  
 <span data-ttu-id="f8a8a-127">`Implements` słowa zastrzeżonego Visual Basic są używane na dwa sposoby.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-127">The Visual Basic reserved word `Implements` is used in two ways.</span></span> <span data-ttu-id="f8a8a-128">Instrukcja `Implements` oznacza, że Klasa lub struktura implementuje interfejs.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-128">The `Implements` statement signifies that a class or structure implements an interface.</span></span> <span data-ttu-id="f8a8a-129">Słowo kluczowe `Implements` oznacza, że składowa klasy lub składowej struktury implementuje określonego elementu członkowskiego interfejsu.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-129">The `Implements` keyword signifies that a class member or structure member implements a specific interface member.</span></span>  
  
### <a name="implements-statement"></a><span data-ttu-id="f8a8a-130">Implements — Instrukcja</span><span class="sxs-lookup"><span data-stu-id="f8a8a-130">Implements Statement</span></span>  
 <span data-ttu-id="f8a8a-131">Jeśli klasa lub struktura implementuje jeden lub więcej interfejsów, musi zawierać instrukcję `Implements` bezpośrednio po instrukcji `Class` lub `Structure`.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-131">If a class or structure implements one or more interfaces, it must include the `Implements` statement immediately after the `Class` or `Structure` statement.</span></span> <span data-ttu-id="f8a8a-132">Instrukcja `Implements` wymaga rozdzielonej przecinkami listy interfejsów, które mają być implementowane przez klasę.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-132">The `Implements` statement requires a comma-separated list of interfaces to be implemented by a class.</span></span> <span data-ttu-id="f8a8a-133">Klasa lub struktura muszą implementować wszystkie elementy członkowskie interfejsu za pomocą słowa kluczowego `Implements`.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-133">The class or structure must implement all interface members using the `Implements` keyword.</span></span>  
  
### <a name="implements-keyword"></a><span data-ttu-id="f8a8a-134">Implements — słowo kluczowe</span><span class="sxs-lookup"><span data-stu-id="f8a8a-134">Implements Keyword</span></span>  
 <span data-ttu-id="f8a8a-135">Słowo kluczowe `Implements` wymaga zaimplementowania listy składowych interfejsu rozdzielanych przecinkami.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-135">The `Implements` keyword requires a comma-separated list of interface members to be implemented.</span></span> <span data-ttu-id="f8a8a-136">Ogólnie tylko jeden element członkowski interfejsu jest określony, ale można określić wielu członków.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-136">Generally, only a single interface member is specified, but you can specify multiple members.</span></span> <span data-ttu-id="f8a8a-137">Specyfikacja elementu członkowskiego interfejsu składa się z nazwy interfejsu, która musi być określona w instrukcji Implements w klasie; okres; i nazwa funkcji składowej, właściwości lub zdarzenia, które mają zostać zaimplementowane.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-137">The specification of an interface member consists of the interface name, which must be specified in an implements statement within the class; a period; and the name of the member function, property, or event to be implemented.</span></span> <span data-ttu-id="f8a8a-138">Nazwa elementu członkowskiego implementującego element członkowski interfejsu może korzystać z dowolnego identyfikatora prawnego i nie jest ograniczona do Konwencji `InterfaceName_MethodName` używanej we wcześniejszych wersjach Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-138">The name of a member that implements an interface member can use any legal identifier, and it is not limited to the `InterfaceName_MethodName` convention used in earlier versions of Visual Basic.</span></span>  
  
 <span data-ttu-id="f8a8a-139">Na przykład poniższy kod ilustruje sposób deklarowania podprocedury o nazwie `Sub1` implementującej metodę interfejsu:</span><span class="sxs-lookup"><span data-stu-id="f8a8a-139">For example, the following code shows how to declare a subroutine named `Sub1` that implements a method of an interface:</span></span>  
  
 [!code-vb[VbVbalrOOP#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/OOP.vb#69)]  
  
 <span data-ttu-id="f8a8a-140">Typy parametrów i zwracane typy składowej implementującej muszą być zgodne z właściwością interfejsu lub deklaracją elementu członkowskiego w interfejsie.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-140">The parameter types and return types of the implementing member must match the interface property or member declaration in the interface.</span></span> <span data-ttu-id="f8a8a-141">Najbardziej typowym sposobem implementacji elementu interfejsu jest element członkowski, który ma taką samą nazwę jak interfejs, jak pokazano w poprzednim przykładzie.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-141">The most common way to implement an element of an interface is with a member that has the same name as the interface, as shown in the previous example.</span></span>  
  
 <span data-ttu-id="f8a8a-142">Aby zadeklarować implementację metody interfejsu, można użyć dowolnych atrybutów, które są prawne dla deklaracji metody wystąpienia, w tym `Overloads`, `Overrides`, `Overridable`, `Public`, `Private`, `Protected`, `Friend`, `Protected Friend`, `MustOverride`, `Default`i `Static`.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-142">To declare the implementation of an interface method, you can use any attributes that are legal on instance method declarations, including `Overloads`, `Overrides`, `Overridable`, `Public`, `Private`, `Protected`, `Friend`, `Protected Friend`, `MustOverride`, `Default`, and `Static`.</span></span> <span data-ttu-id="f8a8a-143">Atrybut `Shared` nie jest dozwolony, ponieważ definiuje klasę, a nie metodę wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-143">The `Shared` attribute is not legal since it defines a class rather than an instance method.</span></span>  
  
 <span data-ttu-id="f8a8a-144">Za pomocą `Implements`można również napisać pojedynczą metodę, która implementuje wiele metod zdefiniowanych w interfejsie, tak jak w poniższym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="f8a8a-144">Using `Implements`, you can also write a single method that implements multiple methods defined in an interface, as in the following example:</span></span>  
  
 [!code-vb[VbVbalrOOP#70](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/OOP.vb#70)]  
  
 <span data-ttu-id="f8a8a-145">Do zaimplementowania elementu członkowskiego interfejsu można użyć prywatnego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-145">You can use a private member to implement an interface member.</span></span> <span data-ttu-id="f8a8a-146">Gdy prywatny element członkowski implementuje element członkowski interfejsu, ten element członkowski jest dostępny w interfejsie, mimo że nie jest dostępny bezpośrednio dla zmiennych obiektów klasy.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-146">When a private member implements a member of an interface, that member becomes available by way of the interface even though it is not available directly on object variables for the class.</span></span>  
  
### <a name="interface-implementation-examples"></a><span data-ttu-id="f8a8a-147">Przykłady implementacji interfejsu</span><span class="sxs-lookup"><span data-stu-id="f8a8a-147">Interface Implementation Examples</span></span>  
 <span data-ttu-id="f8a8a-148">Klasy implementujące interfejs muszą implementować wszystkie jego właściwości, metody i zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-148">Classes that implement an interface must implement all its properties, methods, and events.</span></span>  
  
 <span data-ttu-id="f8a8a-149">W poniższym przykładzie zdefiniowano dwa interfejsy.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-149">The following example defines two interfaces.</span></span> <span data-ttu-id="f8a8a-150">Drugi interfejs, `Interface2`, dziedziczy `Interface1` i definiuje dodatkową właściwość i metodę.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-150">The second interface, `Interface2`, inherits `Interface1` and defines an additional property and method.</span></span>  
  
 [!code-vb[VbVbalrOOP#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/OOP.vb#39)]  
  
 <span data-ttu-id="f8a8a-151">Następny przykład implementuje `Interface1`, interfejs zdefiniowany w poprzednim przykładzie:</span><span class="sxs-lookup"><span data-stu-id="f8a8a-151">The next example implements `Interface1`, the interface defined in the previous example:</span></span>  
  
 [!code-vb[VbVbalrOOP#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/OOP.vb#40)]  
  
 <span data-ttu-id="f8a8a-152">Ostatni przykład implementuje `Interface2`, w tym metodę dziedziczoną z `Interface1`:</span><span class="sxs-lookup"><span data-stu-id="f8a8a-152">The final example implements `Interface2`, including a method inherited from `Interface1`:</span></span>  
  
 [!code-vb[VbVbalrOOP#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/OOP.vb#41)]  
  
 <span data-ttu-id="f8a8a-153">Można zaimplementować właściwość ReadOnly z właściwością ReadWrite (oznacza to, że nie trzeba deklarować jej jako tylko do odczytu w klasie implementującej).</span><span class="sxs-lookup"><span data-stu-id="f8a8a-153">You can implement a readonly property with a readwrite property (that is, you do not have to declare it readonly in the implementing class).</span></span>  <span data-ttu-id="f8a8a-154">Implementacja interfejsu niesie obietnice zwiększenia do wdrożenia co najmniej elementów członkowskich, które deklaruje interfejs, ale można zaoferować więcej funkcji, takich jak umożliwienie zapisu właściwości.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-154">Implementing an interface promises to implement at least the members that the interface declares, but you can offer more functionality, such as allowing your property to be writable.</span></span>  
  
## <a name="related-topics"></a><span data-ttu-id="f8a8a-155">Tematy pokrewne</span><span class="sxs-lookup"><span data-stu-id="f8a8a-155">Related Topics</span></span>  
  
|<span data-ttu-id="f8a8a-156">Tytuł</span><span class="sxs-lookup"><span data-stu-id="f8a8a-156">Title</span></span>|<span data-ttu-id="f8a8a-157">Opis</span><span class="sxs-lookup"><span data-stu-id="f8a8a-157">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="f8a8a-158">Przewodnik: tworzenie i wdrażanie interfejsów</span><span class="sxs-lookup"><span data-stu-id="f8a8a-158">Walkthrough: Creating and Implementing Interfaces</span></span>](../../../../visual-basic/programming-guide/language-features/interfaces/walkthrough-creating-and-implementing-interfaces.md)|<span data-ttu-id="f8a8a-159">Zawiera szczegółową procedurę, która przeprowadzi Cię przez proces definiowania i implementowania własnego interfejsu.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-159">Provides a detailed procedure that takes you through the process of defining and implementing your own interface.</span></span>|  
|[<span data-ttu-id="f8a8a-160">Wariancje w interfejsach ogólnych</span><span class="sxs-lookup"><span data-stu-id="f8a8a-160">Variance in Generic Interfaces</span></span>](../../concepts/covariance-contravariance/variance-in-generic-interfaces.md)|<span data-ttu-id="f8a8a-161">Omawia kowariancję i kontrawariancja w interfejsach ogólnych i zawiera listę podstawowych interfejsów w .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="f8a8a-161">Discusses covariance and contravariance in generic interfaces and provides a list of variant generic interfaces in the .NET Framework.</span></span>|
