### <a name="horizontal-scrolling-and-virtualization"></a>Przewijanie w poziomie i wirtualizacji

|   |   |
|---|---|
|Szczegóły|Ta zmiana dotyczy <xref:System.Windows.Controls.ItemsControl?displayProperty=name> wykonuje własną wirtualizacji w kierunku prostopadłym do głównego kierunek przewijania (główny przykładem jest <xref:System.Windows.Controls.DataGrid?displayProperty=name> EnableColumnVirtualization =&quot;True&quot;).  Wynik pewnych operacji przewijania poziome został zmieniony w celu uzyskania wyników, które są bardziej intuicyjne i bardziej odpowiednikiem wyniki można porównywać pod względem pionowego operacji.<p/>Operacje obejmują &quot;przewijania w tym miejscu&quot; i &quot;prawą krawędź&quot;, aby użyć nazwy z menu uzyskać, klikając prawym przyciskiem myszy poziomy pasek przewijania.  Oba te obliczenia przesunięcia kandydata i wywołania <xref:System.Windows.Controls.Primitives.IScrollInfo.SetHorizontalOffset(System.Double)>.<p/>Po przewijanie do nowego przesunięcie pojęcia &quot;tutaj&quot; lub &quot;prawej krawędzi&quot; mógł ulec zmianie, ponieważ nowo cofnąć zwirtualizowanych zawartość została zmieniona wartość <xref:System.Windows.Controls.Primitives.IScrollInfo.ExtentWidth?displayProperty=name>.<p/>Przed .NET Framework 4.6.2 operacji przewijania po prostu używa przesunięcie kandydujących, mimo że nie może być &quot;tutaj&quot; lub &quot;prawej krawędzi&quot; więcej.  Powoduje to efektów, jak &quot;odbijania&quot; przewijania uchwytu, najlepiej pokazano przykład. Załóżmy, że <xref:System.Windows.Controls.DataGrid?displayProperty=name> ma ExtentWidth = 1000 i szerokości = 200.  Przewiń do &quot;prawą krawędź&quot; candidate używa przesunięcie 1000 – 200 = 800.  Podczas przewijania, do które, nowe kolumny są de-zwirtualizowany; Załóżmy, że są one bardzo szeroki, tak aby <xref:System.Windows.Controls.Primitives.IScrollInfo.ExtentWidth?displayProperty=name> zmiany do 2000.  Przewijania kończy HorizontalOffset = 800 i stronie przycisku suwaka &quot;odrzuceń&quot; do niemal środka pasek przewijania - dokładnie 800/2000 = 40%.<p/>Zmiana jest ponownie obliczyć nowego przesunięcie kandydujących, gdy taka sytuacja występuje i spróbuj ponownie. (Jest to, jak pionowe przewijanie już działa.) <p/>Zmiana daje bardziej przewidywalne i intuicyjne środowisko użytkownika końcowego, ale również mogą wpłynąć na dowolną aplikację, która jest zależna od dokładną wartość <xref:System.Windows.Controls.Primitives.IScrollInfo.HorizontalOffset?displayProperty=name> po przewiń poziomą, czy wywoływane przez użytkownika końcowego lub jawnym wywołaniem <xref:System.Windows.Controls.Primitives.IScrollInfo.SetHorizontalOffset(System.Double)>.|
|Sugestia|Aplikacji, która używa wartości prognozowanej na <xref:System.Windows.Controls.Primitives.IScrollInfo.HorizontalOffset?displayProperty=name> należy zmienić można pobrać wartość rzeczywista (i wartość <xref:System.Windows.Controls.Primitives.IScrollInfo.ExtentWidth?displayProperty=name>) po przewijania poziomego, które mogą ulec zmianie <xref:System.Windows.Controls.Primitives.IScrollInfo.ExtentWidth?displayProperty=name> z powodu dezaktywowanie wirtualizacji.|
|Zakres|Pomocnicza|
|Wersja|4.6.2|
|Typ|środowisko uruchomieniowe|
|Dotyczy interfejsów API|<ul><li><xref:System.Windows.Controls.Primitives.IScrollInfo?displayProperty=nameWithType></li></ul>|

