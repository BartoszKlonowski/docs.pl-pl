---
ms.openlocfilehash: ddae1bfdd1a6f67bce111e0f97dd501c82022f36
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/15/2020
ms.locfileid: "72887817"
---
### <a name="new-64-bit-jit-compiler-in-the-net-framework-46"></a>Nowy 64-bitowy kompilator JIT w .NET Framework 4.6

|   |   |
|---|---|
|Szczegóły|Począwszy od .NET Framework 4.6, nowy kompilator JIT 64-bitowy jest używany do kompilacji just-in-time. W niektórych przypadkach zgłaszany jest nieoczekiwany wyjątek lub obserwuje się inne zachowanie niż w przypadku, gdy aplikacja jest uruchamiana przy użyciu kompilatora 32-bitowego lub starszego kompilatora JIT 64-bitowego. Ta zmiana nie wpływa na 32-bitowy kompilator JIT. Znane różnice są następujące:<ul><li>Pod pewnymi warunkami operacja rozpakowywania może zgłosić <xref:System.NullReferenceException> w wersji kompilacji z optymalizacji włączone.</li><li>W niektórych przypadkach wykonanie kodu produkcyjnego w <xref:System.StackOverflowException>treści dużej metody może spowodować rzut .</li><li>Pod pewnymi warunkami struktury przekazywane do metody są traktowane jako typy odwołań, a nie jako typy wartości w kompilacjach release. Jednym z przejawów tego problemu jest to, że poszczególne elementy w kolekcji pojawiają się w nieoczekiwanej kolejności.</li><li>W pewnych warunkach <xref:System.UInt16> porównanie wartości z ich zestawem bitów jest niepoprawne, jeśli optymalizacja jest włączona.</li><li>W pewnych warunkach, szczególnie podczas inicjowania <xref:System.Reflection.Emit.OpCodes.Initblk?displayProperty=nameWithType> wartości tablicy, inicjowanie pamięci przez instrukcję IL może zainicjować pamięć z niepoprawną wartością. Może to spowodować nieobsługiwał wyjątek lub niepoprawne dane wyjściowe.</li><li>W pewnych rzadkich warunkach test bitowy <xref:System.Boolean> warunkowy może zwrócić niepoprawną wartość lub zgłosić wyjątek, jeśli włączone są optymalizacje kompilatora.</li><li>Pod <code>if</code> pewnymi warunkami, jeśli instrukcja jest używana do <code>try</code> testowania warunku <code>try</code> przed wprowadzeniem bloku i <code>catch</code> w <code>finally</code> wyjściu z bloku, a ten sam warunek <code>if</code> jest <code>catch</code> oceniany w lub bloku, nowy kompilator JIT 64-bitowy usuwa warunek z lub <code>finally</code> bloku, gdy optymalizuje kod. W rezultacie kod wewnątrz <code>if</code> instrukcji <code>catch</code> w <code>finally</code> lub bloku jest wykonywany bezwarunkowo.</li></ul>|
|Sugestia|**Łagodzenie znanych problemów** <br/> Jeśli napotkasz problemy wymienione powyżej, możesz je rozwiązać, wykonując dowolną z następujących czynności:<ul><li>Uaktualnienie do programu .NET Framework 4.6.2. Nowy kompilator 64-bitowy dołączony do programu .NET Framework 4.6.2 rozwiązuje każdy z tych znanych problemów.</li><li>Upewnij się, że twoja wersja systemu Windows jest aktualna, uruchamiając usługę Windows Update. Aktualizacje usługi do .NET Framework 4.6 i 4.6.1 <xref:System.NullReferenceException> rozwiązać każdy z tych problemów, z wyjątkiem w operacji rozpakowywania.</li><li>Skompiluj ze starszym 64-bitowym kompilatorem JIT. Zobacz **łagodzenia innych problemów** sekcji, aby uzyskać więcej informacji na temat sposobu wykonania tej sprawy.</li></ul>**Łagodzenie innych problemów** <br/> Jeśli wystąpi jakakolwiek inna różnica w zachowaniu między kodem skompilowanym ze starszym kompilatorem 64-bitowym a nowym 64-bitowym kompilatorem JIT lub między wersjami debugowania i wersji aplikacji, które są skompilowane z nowym 64-bitowym kompilatorem JIT, możesz wykonać następujące czynności: , aby skompilować aplikację ze starszym 64-bitowym kompilatorem JIT:<ul><li>Na podstawie dla aplikacji można dodać [<](~/docs/framework/configure-apps/file-schema/runtime/uselegacyjit-element.md) element do pliku konfiguracji aplikacji. Następujące wyłącza kompilacji z nowym kompilatorem JIT 64-bit i zamiast tego używa starszego kompilatora JIT 64-bit.</li></ul><pre><code class="lang-xml">&lt;?xml version =&quot;1.0&quot;?&gt;&#13;&#10;&lt;configuration&gt;&#13;&#10;&lt;runtime&gt;&#13;&#10;&lt;useLegacyJit enabled=&quot;1&quot; /&gt;&#13;&#10;&lt;/runtime&gt;&#13;&#10;&lt;/configuration&gt;&#13;&#10;</code></pre><ul><li>Na podstawie dla użytkownika można dodać <code>REG_DWORD</code> wartość <code>useLegacyJit</code> o <code>HKEY_CURRENT_USER\SOFTWARE\Microsoft\.NETFramework</code> nazwie do klucza rejestru. Wartość 1 umożliwia starszy kompilator JIT 64-bitowy; wartość 0 wyłącza go i włącza nowy kompilator JIT 64-bitowy.</li><li>Na podstawie na komputerze można dodać <code>REG_DWORD</code> wartość <code>useLegacyJit</code> o <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework</code> nazwie do klucza rejestru. Wartość <code>1</code> włącza starszy kompilator JIT 64-bitowy; wartość wyłącza <code>0</code> go i włącza nowy kompilator JIT 64-bitowy.</li></ul>Możesz również poinformować nas o problemie, zgłaszając błąd w [usłudze Microsoft Connect](https://connect.microsoft.com/VisualStudio).|
|Zakres|Brzeg|
|Wersja|4.6|
|Typ|Przekierowanie|
